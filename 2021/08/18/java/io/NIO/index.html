<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="NIO"><meta name="keywords" content=""><meta name="author" content="Fuyusakaiori"><meta name="copyright" content="Fuyusakaiori"><title>NIO | 天鹅绒房间</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"37DAS9P43B","apiKey":"c2a5f8cdb503b255bb4384b147d4ab84","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#NIO"><span class="toc-number">1.</span> <span class="toc-text">NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">核心类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.1.</span> <span class="toc-text">新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer"><span class="toc-number">1.2.2.</span> <span class="toc-text">Buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ByteBuffer"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">ByteBuffer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel"><span class="toc-number">1.2.3.</span> <span class="toc-text">Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FileChannel"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">FileChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SocketChannel"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">SocketChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ServerSocketChannel"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">ServerSocketChannel</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Selector"><span class="toc-number">1.2.4.</span> <span class="toc-text">Selector</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4"><span class="toc-number">1.3.</span> <span class="toc-text">实例: 多人聊天室</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i1.xpic.jp/file/xpicjp/2022/01/21/2070676bca90a832cba0ff3e76a701b1.png"></div><div class="author-info__name text-center">Fuyusakaiori</div><div class="author-info__description text-center">啥也不会的大三狗</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/fuyusakaiori">いらしゃい</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">115</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">12</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">34</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/随机图库/1643042375499.2rf317jrwiw0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">天鹅绒房间</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/home">主页 | Home</a><a class="site-page" href="/archives">归档 | Archives</a><a class="site-page" href="/categories">分类 | Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">NIO</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-18</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/IO/">IO</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">9.2k</span><span class="post-meta__separator">|</span><span>Reading time: 34 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><p>:::primary</p>
<p>前提：熟练掌握传统 <code>I/O</code> 核心思想及其核心类，便于和新 <code>I/O</code> 进行相应的对比学习</p>
<p>:::</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p><strong>什么是 NIO？</strong></p>
</blockquote>
<ul>
<li>名称：<ul>
<li><code>NIO</code> 在 <code>JDK 1.4</code> 之后提供，所以官方定义为 <code>New I/O</code>，用于区别 <code>JDK 1.1</code> 提供的传统 <code>I/O</code></li>
<li><code>NIO</code> 具有 ++非阻塞++ 的特性，所以也通常被称为 <code>No-Blocking I/O</code>，用于区别传统的 <code>Blocking I/O</code></li>
</ul>
</li>
<li>细节：[推出 NIO 之后，传统 I/O 的底层重新采用 NIO 实现了一次，从而提升传统 I/O 的速度]{.blue}</li>
</ul>
<blockquote>
<p><strong>什么是阻塞式 I/O？什么又是非阻塞式 I/O</strong>（之前 I/O 概述中已经提到过再次重复一遍）</p>
</blockquote>
<ul>
<li>阻塞与非阻塞：[读写方法是否为阻塞式调用]{.red}<ul>
<li>阻塞式：服务器的线程调用 <code>传统 I/O</code>，此线程就必须一直等待客户端发送消息，[线程在此期间什么都不能做]{.red}</li>
<li>非阻塞式：服务器的线程调用 <code>新 I/O</code>，此线程只需要在客户端发送消息的时候才去接收，[线程在此期间可以完成其他任务]{.red}</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>为什么需要提供非阻塞式的 I/O？</strong></p>
</blockquote>
<ul>
<li><p>核心：[减少线程对于服务器资源的占用以及服务器上下文切换占用的时间]{.red}</p>
<p>  !!线程、线程池以及上下文切换的概念及其特性参考操作系统相关知识!!{.bulr}</p>
</li>
<li><p>服务器初期设计（<code>BIO</code>）：</p>
<ul>
<li><p>背景：服务器显然需要处理大量客户端发来的请求，每个线程因为采用传统 <code>I/O</code>，所以仅能够处理一个客户端请求</p>
</li>
<li><p>核心：</p>
<ul>
<li><p>[多线程处理用户请求]{.red}</p>
</li>
<li><p>每个客户端发来请求时，服务器都 [创建相应的线程]{.red} 负责处理客户端的请求，处理结束后 [线程销毁]{.red}</p>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/18/85bed0bbdb4705d0e11ebf6ebe860b23.png" alt="85bed0bbdb4705d0e11ebf6ebe860b23.png" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>[大量线程的创建和销毁需要占用非常多的服务器资源]{.green}</li>
<li>[大量线程的存在会导致服务器频繁的执行上下文切换，浪费线程的执行时间]{.green}</li>
</ul>
</li>
</ul>
</li>
<li><p>服务器改进设计（<code>伪异步 I/O</code>）：</p>
<ul>
<li><p>背景：没有推出 <code>新 I/O</code> 的情况下，显然想要避免大量线程的创建和销毁就只能采用 [线程池技术]{.blue}</p>
</li>
<li><p>核心：</p>
<ul>
<li><p>[线程池技术]{.red}</p>
</li>
<li><p>服务器创建线程池，线程的管理全部交给线程池负责，服务器 [“可以完成其他的任务”]{.blue}，这就是所谓的伪异步</p>
</li>
<li><p>服务器 “可以完成其他任务”只是给人的一种错觉，因为只要建立的是 [TCP]{.red} 连接，那么服务器只能处于阻塞状态，等待客户端发来请求</p>
<p>  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/18/5ab06e96145063ffd4c734a80e1b4551.png" alt="5ab06e96145063ffd4c734a80e1b4551.png"></p>
</li>
</ul>
</li>
<li><p>优点：[避免服务器创建和销毁大量的线程造成的资源浪费]{.red}</p>
</li>
<li><p>缺点：</p>
<ul>
<li>[大量的线程依然会导致频繁的执行上下文切换]{.green}</li>
<li>[线程池的线程数量是固定的就会导致在大量请求同时发出时，必然存在客户端长时间等待的情况]{.green}</li>
</ul>
</li>
</ul>
</li>
<li><p>服务器现有设计（<code>NIO</code>）：</p>
<ul>
<li><p>背景：无论如何，大量的线程都会造成服务器资源消耗，所以考虑能不能 [每个线程处理多个客户端请求]{.blue}，从而减少线程的数量</p>
</li>
<li><p>核心：</p>
<ul>
<li><p>[Channel 类使得线程可以采用非阻塞式的读写方法，而不需要一直等待客户端请求]{.red}</p>
<blockquote>
<p><strong>那么线程如何才能在做其他事情的时候，知道有客户端发送请求了呢？</strong></p>
</blockquote>
</li>
<li><p>[Selector 类可以监视多个客户端是否发送消息]{.red}</p>
</li>
<li><p>服务器只需要创建少量的线程，线程监视每个客户端</p>
<ol>
<li>如果没有任何客户端发送请求，线程可以根据服务器的需要完成其他的事件</li>
<li>如果某个客户端突然发送请求，线程立刻就回去处理该客户端发送的请求</li>
<li>如果线程监视的多个客户端同时发送请求，线程需要按照一定的顺序依次处理</li>
</ol>
</li>
</ul>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/18/1509fb72aeea89d73f037b7c9cada762.png" alt="1509fb72aeea89d73f037b7c9cada762.png" style="zoom:80%;" /></li>
<li><p>优点：[减少服务器需要的线程数量，避免资源的大量占用和上下文切换占用的时间]{.red}</p>
</li>
<li><p>缺点：[单个线程可能来不及同时处理多个客户端请求，依然存在客户端等待的情况]{.green}</p>
</li>
</ul>
</li>
</ul>
<h2 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2><h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><ul>
<li><p>核心：[传统 I/O 是 <strong>面向流</strong> 设计的，新 I/O 是面向 <strong>缓冲区</strong> 设计的]{.red}</p>
</li>
<li><p><code>Channel</code>：</p>
<ul>
<li>名称：通常直译为通道</li>
<li>新特性：<ul>
<li>[Channel 取代传统 I/O 中的 InputStream 和 OutputStream，实现双向读写]{.blue}</li>
<li>[Channel 具有非阻塞的特性，不过需要手动设置，默认为阻塞]{.blue}</li>
</ul>
</li>
<li>细节：<ul>
<li>[Channel 必须借助缓冲区 Buffer 才可以将数据交付给进程]{.blue}</li>
<li>[Channel 之间可以直接交换数据]{.blue}</li>
</ul>
</li>
</ul>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/22/5689b4d52a045ff5ae72f35155029a89.png" alt="5689b4d52a045ff5ae72f35155029a89.png" style="zoom:80%;" /></li>
<li><p><code>Buffer</code>：</p>
<ul>
<li>名称：缓冲区</li>
<li>新特性：[可以存储大量的数据，便于一次性读写完成，实现双向读写]{.blue}</li>
</ul>
</li>
<li><p><code>Selector</code></p>
<ul>
<li>名称：选择器</li>
<li>新特性：<ul>
<li>[采用轮询的方式监视多个 Channel 上的事件，如果发生事件就会通知服务器进行处理，如果没有发生事件就阻塞服务器]{.blue}</li>
<li>[实现 I/O 多路复用模型中的 Reactor 模型]{.blue}</li>
</ul>
</li>
</ul>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/22/bb0faea705a6c70db4c16fe1b510a1ba.png" alt="bb0faea705a6c70db4c16fe1b510a1ba.png" style="zoom:80%;" /></li>
</ul>
<h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><blockquote>
<p><strong>缓冲区：基础知识</strong></p>
</blockquote>
<ul>
<li><p>定义：每个<code>Channel</code> 都需要先将 [数据写入缓冲区或者从缓冲区中读入数据]{.blue}，然后客户端或者服务器从缓冲区中获取数据</p>
</li>
<li><p>特点：① 抽象类 ② [底层采用数组实现]{.red} ③ [既可以读取也可以写入]{.red}</p>
</li>
<li><p>子类</p>
<ul>
<li><p>[核心子类]{.red}：<code>ByteBuffer</code></p>
</li>
<li><p>其余子类：<code>IntBuffer、LongBuffer、CharBuffer、FloatBuffer、DoubleBuffer</code></p>
<p>  注：[ByteBuffer 用于传输二进制的数据，也就意味着可以传输任何类型的文件，用途相比于其他子类更加广泛]{.blue}</p>
</li>
</ul>
</li>
<li><p>内部结构</p>
<ul>
<li><p>写模式：每次向缓冲区中写入数据，<code>position</code> 指针都会相应的向前移动</p>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/18/b8e02b3c24bb877d3e9d5a8f2039228b.png" alt="b8e02b3c24bb877d3e9d5a8f2039228b.png" style="zoom:80%;" /></li>
<li><p>翻转：</p>
<ul>
<li><p>缓冲区读取数据是从起始指针开始读取的，而写模式下的 <code>position</code> 指针并没有指向写入的数据</p>
</li>
<li><p>[处于写模式下的缓冲区是无法直接读取到写入的数据，需要经过翻转操作后才可以读取数据]{.red}</p>
</li>
<li><p><code>position</code> 指针重新指向缓冲区开头，<code>limit</code> 指针指向写入数据的末尾</p>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/18/b81a2df08a90aca872acf6bff4326eca.png" alt="b81a2df08a90aca872acf6bff4326eca.png" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>读模式：</p>
<ul>
<li><p>每次从缓冲区中读出数据，<code>position</code> 指针都会向前移动</p>
</li>
<li><p>读取数据存在两种情况：</p>
<ol>
<li><p>缓冲区中的数据已经被读取完毕：调用 [清空]{.red} 的方法重新返回写模式</p>
</li>
<li><p>缓冲区中的数据没有被全部读取：调用 [压缩]{.red} 的方法重新返回写模式</p>
 <img src="https://i1.xpic.jp/file/xpicjp/2021/08/18/95c63f409ed4df541187e6340ae63989.png" alt="95c63f409ed4df541187e6340ae63989.png" style="zoom:80%;" /></li>
</ol>
</li>
</ul>
</li>
<li><p>清空：<code>position</code> 指针重新移动到缓冲区开头，<code>limit</code> 指针重新移动到缓冲区结尾</p>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/18/6e570f500925a0f79dcc168c90cec5a7.png" alt="6e570f500925a0f79dcc168c90cec5a7.png" style="zoom:80%;" /></li>
<li><p>压缩：[将没有被读取的数据移动到缓冲区开头]{.red}，<code>position</code> 指针移动到没有被读取的数据后面，<code>limit</code> 指针重新移动到缓冲区结尾</p>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/18/af734a77fd91f2110f46b4f77e9ab622.png" alt="af734a77fd91f2110f46b4f77e9ab622.png" style="zoom:80%;" />

<p>  注：[无论是清空还是压缩方法，缓冲区中的数据都没有被实际清除，仅仅只是将指针重新移动到开始的位置而已]{.red}</p>
</li>
</ul>
</li>
<li><p>构造方法：[缓冲区抽象类创建对象采用单例模式，也就是说构造方法是私有的]{.red}</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Buffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap) &#123;       <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">if</span> (cap &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Negative capacity: &quot;</span> + cap);</span><br><span class="line">    <span class="keyword">this</span>.capacity = cap;</span><br><span class="line">    limit(lim);</span><br><span class="line">    position(pos);</span><br><span class="line">    <span class="keyword">if</span> (mark &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mark &gt; pos)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;mark &gt; position: (&quot;</span></span><br><span class="line">                                               + mark + <span class="string">&quot; &gt; &quot;</span> + pos + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.mark = mark;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方法</p>
<ul>
<li><p><code>put() &amp; get()</code>：[Buffer 抽象类没有提供读取和写入方法具体实现 -&gt; 交付给子类自行实现读取和写入的方法]{.red}</p>
</li>
<li><p><code>compact()</code>：[Buffer 抽象类也没有提供压缩方法的具体实现]</p>
</li>
<li><p><code>flip()</code>：[缓冲区从写模式切换到读模式]{.red}</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*不允许子类重写的方法*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// limit 指针移动到 position 指针处</span></span><br><span class="line">    limit = position;</span><br><span class="line">    <span class="comment">// position 指针重新移动到缓冲区开始的位置</span></span><br><span class="line">    position = <span class="number">0</span>;		</span><br><span class="line">    mark = -<span class="number">1</span>;			</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;				</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>clear()</code>：[清空缓冲区并且从读模式切换到写模式]{.red}</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>rewind()</code>：[重新将 <code>position</code> 指针移动到缓冲区起始位置]{.red}</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>hasremaning()</code>：[缓冲区中是否还存在数据]{.red}</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasRemaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> position &lt; limit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h4><blockquote>
<p><strong>字节缓冲区：基础知识</strong></p>
</blockquote>
<ul>
<li>特点：仅能够存放字节类型的数据</li>
<li>子类：<ul>
<li><code>MappedByteBuffer</code></li>
<li><code>DirectByteBuffer</code>：[采用物理机中的真实内存作为缓冲区，读写效率高，创建效率低，容易出现内存泄露问题]{.red}</li>
<li><code>HeadByteBuffer</code>：[采用虚拟机中的堆内存作为缓冲区，读写效率较低，创建效率较高]{.red}</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>字节缓冲区：方法</strong></p>
</blockquote>
<ul>
<li><p>创建缓冲区对象</p>
<ul>
<li><p>实例：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建缓冲区对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createBuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 缓冲区使用堆内存: 缓冲区中的数据会受到虚拟机的垃圾回收机制的影响, 读写效率相对较低</span></span><br><span class="line">    ByteBuffer heapBuffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 缓冲区采用直接内存(系统内存): </span></span><br><span class="line">    <span class="comment">// 缓冲区中的数据不会收到垃圾回收机制的影响, 读写效率高, 创建对象效率较低</span></span><br><span class="line">    <span class="comment">// 缓冲区中的数据如果没有合理释放,容易导致内存溢出或者泄露</span></span><br><span class="line">    ByteBuffer directBuffer = ByteBuffer.allocateDirect(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方法：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*堆内存缓冲区*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 返回的是 HeapByteBuffer 对象，也就是 ByteBuffer 的子类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(capacity, capacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*直接内存缓冲区*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回的是 DirectByteBuffer 对象，也就是 ByteBuffer 的子类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>读取和写入缓冲区：</p>
<ul>
<li><p>字符串转换为字节方式：[缓冲区只能够存放字节类型的数据，所以需要将发送的数据转换为字节类型]{.blue}</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串转换为字节类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stringToBytes</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 缓冲区</span></span><br><span class="line">    ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">50</span>);</span><br><span class="line">    <span class="comment">// 1.直接利用字符串类提供的方法</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="string">&quot;Hello,World!&quot;</span>.getBytes();</span><br><span class="line">    <span class="comment">// 手动将字节数组放入缓冲区中</span></span><br><span class="line">    buffer1.put(bytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.利用 NIO 提供的字符串转换方式：方法返回值就是缓冲区，不需要手动添加数据</span></span><br><span class="line">    ByteBuffer buffer2 = StandardCharsets.UTF_16.encode(<span class="string">&quot;Hello,World&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 利用缓冲区自身提供的方法实现字符串转换</span></span><br><span class="line">    ByteBuffer buffer3 = ByteBuffer.wrap(<span class="string">&quot;Hello,World!&quot;</span>.getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>读取和写入方式</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取和写入缓冲区的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readOrWriteBuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="comment">// 仅写入单个字符</span></span><br><span class="line">    buffer.put((<span class="keyword">byte</span>)<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    <span class="comment">// 指定字符写入的位置</span></span><br><span class="line">    buffer.put(<span class="number">1</span>, (<span class="keyword">byte</span>)<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    <span class="comment">// 写入字符数组</span></span><br><span class="line">    buffer.put(<span class="string">&quot;Hello,World&quot;</span>.getBytes());</span><br><span class="line">    <span class="comment">// 写入其他的缓冲区</span></span><br><span class="line">    buffer.put(StandardCharsets.UTF_16.encode(<span class="string">&quot;你好~&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲区记得翻转</span></span><br><span class="line">    buffer.flip();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;当前位置: &quot;</span> + buffer.position());</span><br><span class="line">    <span class="comment">// 读取单个字节：每次读取, position 指针是会向前移动的</span></span><br><span class="line">    System.out.println((<span class="keyword">char</span>) buffer.get());</span><br><span class="line">    System.out.println(<span class="string">&quot;当前位置: &quot;</span> + buffer.position());</span><br><span class="line">    <span class="comment">// 读取指定位置的字节: 每次读取, position 指针都是不会移动的</span></span><br><span class="line">    <span class="comment">// 指定的位置：当前 position 指针 + 给出的 index</span></span><br><span class="line">    System.out.println((<span class="keyword">char</span>) buffer.get(<span class="number">2</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;当前位置: &quot;</span> + buffer.position());</span><br><span class="line">    <span class="comment">// 读取字节数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 每次读取一个字节数组的大小，将字节存放在字节数组中，并且 position指针 也是会向前移动的</span></span><br><span class="line">    <span class="comment">// 返回值是 ByteBuffer：并不是新创建一个缓冲区，而是返回当前缓冲区在读取一个字节数组之后的状态</span></span><br><span class="line">    ByteBuffer byteBuffer = buffer.get(bytes);</span><br><span class="line">    System.out.println(<span class="string">&quot;当前位置: &quot;</span> + buffer.position());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>读写文件：[需要提前用到 Channel ]{.blue}</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用 NIO 核心类读取文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFileByNIO</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 利用文件流获取到相应的通道</span></span><br><span class="line">    FileChannel channel = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;file.txt&quot;</span>)).getChannel();</span><br><span class="line">    <span class="comment">// 为缓冲区分配大小</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 从通道中读取数据 -&gt; 将通道中读取的数据写入缓冲区 -&gt; 服务器/客户端从缓冲区中接收数据</span></span><br><span class="line">    <span class="comment">// 读取次数</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环读取通道中的数据: 这里缓冲区大小仅有 5 字节, 而文本含有 12 字节, 显然需要读 3 次</span></span><br><span class="line">    <span class="keyword">while</span> (channel.read(buffer) != -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将缓冲区中的数据读取出来: 先进行翻转后读取</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="comment">// 循环读出缓冲区中的数据</span></span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 只能一个字节一个字节地读取</span></span><br><span class="line">            System.out.print((<span class="keyword">char</span>) buffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n读取次数: &quot;</span> + ++count);</span><br><span class="line">        <span class="comment">// 需要再次向缓冲区中写入数据：先将缓冲区清空后写入</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭通道</span></span><br><span class="line">    channel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​    </p>
<blockquote>
<p><strong>字节缓冲区：分散读取 + 集中写入</strong></p>
</blockquote>
<ul>
<li><p>分散读取（ScatteringRead）：[从通道中的读取的数据同时向多个缓冲区写入数据 -&gt; 最后从多个缓冲区中读取数据]{.red}</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分散读取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scatteringRead</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FileChannel fileChannel = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;file.txt&quot;</span>)).getChannel();</span><br><span class="line">    <span class="comment">// 多个缓冲区</span></span><br><span class="line">    ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">    ByteBuffer buffer2 = ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    ByteBuffer buffer3 = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 通道中的数据同时写入到多个缓冲区中</span></span><br><span class="line">    fileChannel.read(<span class="keyword">new</span> ByteBuffer[]&#123;buffer1, buffer2, buffer3&#125;);</span><br><span class="line">    <span class="comment">// 从多个缓冲区中分别读取数据：分散读取</span></span><br><span class="line">    buffer1.flip();</span><br><span class="line">    <span class="keyword">while</span> (buffer1.hasRemaining())</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print((<span class="keyword">char</span>) buffer1.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>集中写入（GatheringWrites）：[向缓冲区中写入数据 -&gt; 同时从多个缓冲区中读取数据并且写入通道中]{.red}</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gatheringWrites</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FileChannel fileChannel = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;newfile.txt&quot;</span>)).getChannel();</span><br><span class="line">    <span class="comment">// 多个缓冲区</span></span><br><span class="line">    ByteBuffer buffer1 = StandardCharsets.UTF_8.encode(<span class="string">&quot;Hello,World\n&quot;</span>);</span><br><span class="line">    ByteBuffer buffer2 = Charset.defaultCharset().encode(<span class="string">&quot;你好~\n&quot;</span>);</span><br><span class="line">    ByteBuffer buffer3 = ByteBuffer.wrap(<span class="string">&quot;I/O 模型是个啥啊\n&quot;</span>.getBytes());</span><br><span class="line">    <span class="comment">// 同时从多个缓冲区中读取数据后写入通道中</span></span><br><span class="line">    fileChannel.write(<span class="keyword">new</span> ByteBuffer[]&#123;buffer1, buffer2, buffer3&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><strong>字节缓冲区：黏包半包分析</strong></p>
</blockquote>
<ul>
<li><p>问题：</p>
<ul>
<li><p>客户端向服务器发送多条消息，每条消息采用换行符分割开来</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送的消息: </span></span><br><span class="line"><span class="string">&quot;Hello,World!\n&quot;</span> </span><br><span class="line"><span class="string">&quot;Persona5\n&quot;</span> </span><br><span class="line"><span class="string">&quot;Tohou\n&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>通道能够写入的数据是 [有限]{.red} 的，缓冲区可能一次无法将所有的数据全部写入通道中</p>
<p>  导致缓冲区中遗留下来的数据和下次写入缓冲区中的数据进行重新组合，接收方接收到混乱的数据</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 黏包半包现象</span></span><br><span class="line"><span class="comment">// 半包现象：仅有部分数据被接收到</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="comment">// 黏包想象：多个数据被连接起来形成一条数据</span></span><br><span class="line"><span class="string">&quot;,World!\nPersona5\nTohou&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>简单的解决方案</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单解决黏包半包现象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(ByteBuffer buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 缓冲区切换成读模式</span></span><br><span class="line">    buffer.flip();</span><br><span class="line">    <span class="comment">// 存放完整消息的缓冲区</span></span><br><span class="line">    ByteBuffer destination;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.limit(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果读取到换行符就把前面所有字节读取出来</span></span><br><span class="line">        <span class="keyword">if</span> (buffer.get(i) == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[i + <span class="number">1</span> - buffer.position()];</span><br><span class="line">            buffer.get(bytes);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>)b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后如果缓冲区中仍然存在不完整的消息：那么将剩余数据压缩到缓冲区头部</span></span><br><span class="line">    buffer.compact();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><ul>
<li>特点：① 抽象类 ② 可读可写 ③ 通道中的数据必须经过缓冲区后才可以输出 ④ 通道提供的方法默认为阻塞式调用，可以选择设置为非阻塞式调用</li>
<li>子类<ul>
<li>文件通道：<code>FileChannel</code><ul>
<li><code>FileChannel</code> 仅提供阻塞式方法，并且不能够使用 <code>Selector</code> 优化传输过程</li>
<li><code>FileChannel</code> 可以创建单向的通道对象，也可以创建双向的通道对象</li>
</ul>
</li>
<li>网络通道：<ul>
<li><p>UDP 连接：<code>DatagramChannel</code></p>
</li>
<li><p>TCP 连接：<code>ServerSocketChannel、SocketChannel</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h4><blockquote>
<p><strong>文件通道：基础知识</strong></p>
</blockquote>
<ul>
<li>定义：文件之间交互数据的通道</li>
<li>特点：<ul>
<li>可以利用流对象和随机流对象创建文件通道：流对象创建的通道是单向的，随机流对象创建的通道可以双向可以单向</li>
<li>可以利用静态方法创建对象（单例模式）</li>
<li>[文件通道仅能够采用阻塞式方法进行数据的传输]{.red}</li>
<li>[文件通道之间可以不借助缓冲区直接交互数据、其余通道子类必须借助缓冲区交互数据]{.red}</li>
<li>[写入文件通道的数据并不会立刻被操作系统写入文件，而是会先写入内存的缓冲区，等待缓冲区充满之后才会全部写入]{.red}</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>文件通道：方法</strong></p>
</blockquote>
<ul>
<li><p>创建文件通道</p>
<ul>
<li><p>利用文件流获取通道：<code>FileInputStream</code> 获取通道；<code>FileOutputStream</code> 获取通道</p>
<ul>
<li><p>[通道本身具有双向性，但是通过文件流获取的通道依然只能够单向传输]{.red}</p>
</li>
<li><p>[单向通道不可以调用反向的方法，否则会抛出异常]{.red}（<code>NonWritableChannelException、NonReadableChannelException</code>）</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取文件通道</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getFileChannel</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FileChannel fileInputChannel = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;file.txt&quot;</span>)).getChannel();</span><br><span class="line">    FileChannel fileOutputChannel = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;file.txt&quot;</span>)).getChannel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>利用随机文件流获取通道：[指定随机文件流为可读可写时，获取的通道才具有双向性]{.red}</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取文件通道</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getFileChannel</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FileChannel fileChannel = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">&quot;file.txt&quot;</span>), <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line">    <span class="comment">// 既可以读取也可以写入</span></span><br><span class="line">    filechannel.read(...);</span><br><span class="line">    filechannel.write(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>利用工具类创建获取通道</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建双向的文件通道</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getDoubleChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 指定当前的通道类型：只能够指定一个</span></span><br><span class="line">    FileChannel fileChannel1 = FileChannel.open(Paths.get(<span class="string">&quot;file.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">    <span class="comment">// 指定当前通道的类型：可以指定多个，也就意味着通道可以实现双向性</span></span><br><span class="line">    Set&lt;OpenOption&gt; openOptions = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Collections.addAll(openOptions, StandardOpenOption.WRITE, StandardOpenOption.READ);</span><br><span class="line">    FileChannel fileChannel2 = FileChannel.open(Paths.get(<span class="string">&quot;file.txt&quot;</span>), openOptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>文件通道读写方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通道的读写方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">channelReadAndWrite</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用双向的文件通道</span></span><br><span class="line">    Set&lt;OpenOption&gt; openOptions = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Collections.addAll(openOptions, StandardOpenOption.WRITE, StandardOpenOption.READ);</span><br><span class="line">    FileChannel fileChannel = FileChannel.open(Paths.get(<span class="string">&quot;file.txt&quot;</span>), openOptions);</span><br><span class="line">    ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">12</span>);</span><br><span class="line">    ByteBuffer buffer2 = ByteBuffer.allocate(<span class="number">12</span>);</span><br><span class="line">    ByteBuffer buffer3 = ByteBuffer.allocate(<span class="number">12</span>);</span><br><span class="line">    <span class="comment">// 写入单个缓冲区</span></span><br><span class="line">    fileChannel.read(buffer1);</span><br><span class="line">    <span class="comment">// 写入多个缓冲区</span></span><br><span class="line">    fileChannel.read(<span class="keyword">new</span> ByteBuffer[]&#123;buffer1, buffer2, buffer3&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取单个缓冲区</span></span><br><span class="line">    fileChannel.write(buffer1);</span><br><span class="line">    <span class="comment">// 读取多个缓冲区</span></span><br><span class="line">    fileChannel.write(<span class="keyword">new</span> ByteBuffer[]&#123;buffer1, buffer2, buffer3&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>文件通道相互传递数据：[通道借助缓冲区可以交互数据，也可以通道之间直接交互数据，效率更高 -&gt; 用于实现文件拷贝]{.red}</p>
<ul>
<li><p>通道借助缓冲区交互数据</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通道间通信</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">channelTransfer</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ByteBuffer byteBuffer = StandardCharsets.UTF_8.encode(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">    FileChannel fic = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;file.txt&quot;</span>)).getChannel();</span><br><span class="line">    FileChannel foc = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;newfile.txt&quot;</span>)).getChannel();</span><br><span class="line">    <span class="comment">// 借助缓冲区交互数据</span></span><br><span class="line">    fic.read(byteBuffer);</span><br><span class="line">    byteBuffer.flip();</span><br><span class="line">    foc.write(byteBuffer);</span><br><span class="line">    byteBuffer.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通道之间直接交互数据</p>
<ul>
<li>[每次通道仅能够交互 2G 的数据，超出传输限制后就不能够一次传输完成]{.red}</li>
<li>实际测试每次传输最大为 2079MB 的大小</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通道间通信</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">channelTransfer</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ByteBuffer byteBuffer = StandardCharsets.UTF_8.encode(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">    FileChannel fic = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;file.txt&quot;</span>)).getChannel();</span><br><span class="line">    FileChannel foc = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;newfile.txt&quot;</span>)).getChannel();</span><br><span class="line">    <span class="comment">// 直接交互大量数据: 文件通道超过 2G 后就没有办法一次性交互完成了</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> length = fic.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; length;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// transferTo 会返回写入的字节数量</span></span><br><span class="line">        i = fic.transferTo(i , length - i, foc);</span><br><span class="line">        System.out.println(i + <span class="string">&quot;\t&quot;</span> + ++count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>文件通道：工具类</strong></p>
</blockquote>
<ul>
<li><p>前提：<code>JDK 1.7</code> 之后提供了新的文件工具类 <code>Path &amp; Files</code></p>
</li>
<li><p>Path &amp; Paths</p>
<ul>
<li><p>定义：Path 采用文件路径的表示文件的 [接口]{.red}；Paths 类是用来构建 Path 对象的工具类</p>
</li>
<li><p>归属：<code>package java.nio.file;</code></p>
<p>  注：为什么提到这个呢？因为 <code>package javafx.scene.shape;</code> 包中同样提供了 Path 类</p>
</li>
<li><p>方法：</p>
<ul>
<li><p>Path：提供的方法和 File 文件类相近，不再加以赘述</p>
</li>
<li><p>Paths：创建实现了 Path 接口的对象</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 Path 文件对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createPath</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Path path = Paths.get(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>Files</p>
<ul>
<li><p>定义：用于控制 Path 文件路径表示的文件</p>
</li>
<li><p>归属：<code>package java.nio.file;</code></p>
</li>
<li><p>新增目录</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Files 工具类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filesToAdd</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Path path = Paths.get(<span class="string">&quot;first/second/file.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 检验路径表示的文件是否存在</span></span><br><span class="line">    Files.exists(path);</span><br><span class="line">    <span class="comment">// 创建单级目录: 如果创建的是多级目录的话就会报错</span></span><br><span class="line">    Files.createDirectory(path);</span><br><span class="line">    <span class="comment">// 创建多级目录</span></span><br><span class="line">    Files.createDirectories(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>删除文件/目录</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filesToDel</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Path path = Paths.get(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line">    Path directory = Paths.get(<span class="string">&quot;src/main/java/network/&quot;</span>);</span><br><span class="line">    <span class="comment">// 删除文件: 如果文件不存在会报错</span></span><br><span class="line">    Files.delete(path);</span><br><span class="line">    <span class="comment">// 删除目录：如果目录不为空会报错</span></span><br><span class="line">    Files.delete(directory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>拷贝/移动文件</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filesToUpdate</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Path source = Paths.get(<span class="string">&quot;newfile.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 移动的位置的文件可以是不存在的，会自动帮你生成</span></span><br><span class="line">    Path destination = Paths.get(<span class="string">&quot;src/main/java/mynio/newfile.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 将文件复制到新的位置: 如果文件已经存在默认报错，可以设置选项强制覆盖已经存在的文件</span></span><br><span class="line">    Files.copy(source, destination, StandardCopyOption.REPLACE_EXISTING);</span><br><span class="line">    <span class="comment">// 将文件移动到新的位置: 保证文件移动的原子性</span></span><br><span class="line">    Files.move(source, destination, StandardCopyOption.ATOMIC_MOVE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>遍历目录：<code>JDK 1.7</code> 以前遍历文件目录是需要采用递归手动实现的</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 采用 walktree 方法实现的目录遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filesToList</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Path directory = Paths.get(<span class="string">&quot;D:\\动画\\魔法禁书目录&quot;</span>);</span><br><span class="line">    <span class="comment">// 计算文件数量: 使用原子整型类</span></span><br><span class="line">    <span class="comment">// 因为匿名内部类中所有变量都默认是 final, 所以不可以使用普通变量</span></span><br><span class="line">    AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    Files.walkFileTree(directory, <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line">        <span class="comment">// SimpleFileVisitor 的构造方法是受保护的，所以我们不可以直接构造其对象</span></span><br><span class="line">        <span class="comment">// 这里采用匿名内部类的方式，实际上是创建了继承 SimpleFileVisitor 的类</span></span><br><span class="line">        <span class="comment">// 理所应当地可以创建其子类的对象</span></span><br><span class="line">        <span class="comment">// 第一个重写方法：访问目录前需要完成的事情</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--&gt;&quot;</span>+dir);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二个重写的方法：访问到文件时需要完成的事情</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">            count.getAndIncrement();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.visitFile(file, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第三个需要重写的方法：退出目录时完成的事情</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&lt;--&quot;</span>+dir);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.postVisitDirectory(dir, exc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 输出文件数量</span></span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用 walk 实现方法实现目录遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filesToList</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Path directory = Paths.get(<span class="string">&quot;D:\\动画\\魔法禁书目录&quot;</span>);</span><br><span class="line">    AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">// 指定遍历的深度: 即可以向下遍历多少层级的目录</span></span><br><span class="line">    Files.walk(directory, <span class="number">4</span>).forEach(path -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (Files.isDirectory(path))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;目录: &quot;</span> + path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Files.isRegularFile(path))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件: &quot;</span> + path);</span><br><span class="line">            count.getAndIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h4><ul>
<li><p>定义：客户端使用的通道端口</p>
</li>
<li><p>特点：</p>
<ul>
<li>仅能够利用静态方法创建对象（构造方法是受到保护的）</li>
<li>默认提供阻塞式的方法，可以设置为非阻塞式方法：[设置读写方法为非阻塞]{.red}</li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li><p>创建客户端端口对象：[客户端可以在创建端口对象的同时指定连接的服务器端口号]{.red}</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建对象时指定端口号并且连接该端口号：不需要手动连接服务器端口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SocketChannel sc = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">4396</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;客户端:启动成功&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动连接服务器端口号</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> viod <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SocketChannel sc = SocketChannel.open();</span><br><span class="line">    <span class="comment">// 客户端连接服务器: 调用 connect 方法连接不是 bind</span></span><br><span class="line">    sc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">4396</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注册监听器（涉及到 Selector 类）</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>客户端实例</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SocketChannel sc = SocketChannel.open();</span><br><span class="line">    <span class="comment">// 客户端连接服务器: 调用 connect 方法连接不是 bind</span></span><br><span class="line">    sc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">4396</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;客户端:启动成功&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调试技巧</p>
<ul>
<li><p>可以不用代码编写输入流或者写入固定的数据用以测试</p>
</li>
<li><p>可以在客户端最后一行代码旁打上 [断点]{.red}</p>
</li>
<li><p>启动服务器端后以调试（Debug）的方式启动客户端</p>
</li>
<li><p>在客户端的调试界面右击端口对象后，点击 <code>Evaluate Expression</code> 后直接编写代码调试</p>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/20/19c7119a8d00be28477bff5632bc05e4.png" alt="19c7119a8d00be28477bff5632bc05e4.png" style="zoom:80%;" /></li>
<li><p>编写代码调试，这样测试的代码就不用遗留下来</p>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/20/4cb5269b20102ec2c36264e49ea32e44.png" alt="4cb5269b20102ec2c36264e49ea32e44.png" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
<h4 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h4><ul>
<li><p>定义：服务器端使用的端口</p>
</li>
<li><p>特点：</p>
<ul>
<li>仅能够利用静态方法创建对象（构造方法是受到保护的）</li>
<li>默认提供阻塞式的方法，可以设置为非阻塞式方法：[设置接收请求的方法为非阻塞]{.red}</li>
</ul>
</li>
<li><p>方法：</p>
<ul>
<li><p>创建服务器端口对象</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NIO 提供的端口对象不能够在创建的时候传入端口号：需要手动调用方法绑定</span></span><br><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();</span><br></pre></td></tr></table></figure></li>
<li><p>绑定端口号</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IO 提供的端口对象实际上内部就是调用了 bind 方法：只不过现在需要手动调用了</span></span><br><span class="line">ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">4396</span>));</span><br></pre></td></tr></table></figure></li>
<li><p>注册监听器（涉及到 Selector 类）</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Selector 类中详细解释：设置当前通道关心哪些事件，只要事件被监听到，服务器就不再阻塞</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>服务器实例</p>
<ul>
<li><p>传统 IO 实现的 BIO 通信模型需要使用多线程来满足多个客户端同时发出的请求</p>
</li>
<li><p>新 IO 实现的 NIO 通信模型只需要使用单线程就可以完全满足多个客户端同时发出请求</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 构造器时受到保护的: 通过静态方法创建对象</span></span><br><span class="line">    ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">    <span class="comment">// 绑定端口号</span></span><br><span class="line">    ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">4396</span>));</span><br><span class="line">    <span class="comment">// 改进: 手动设置为非阻塞 -&gt; accept 方法会非阻塞式调用</span></span><br><span class="line">    ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 创建缓冲区</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">36</span>);</span><br><span class="line">    <span class="comment">// 记录当前在线的客户端</span></span><br><span class="line">    List&lt;SocketChannel&gt; clients = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 服务器长时间运行</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        SocketChannel sc = ssc.accept();</span><br><span class="line">        <span class="keyword">if</span> (sc != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 只要服务器接收到客户端相应的请求就将其添加到集合汇总</span></span><br><span class="line">            clients.add(sc);</span><br><span class="line">            System.out.println(sc);</span><br><span class="line">            <span class="comment">// 改进：从客户端通道读取数据时也设置为非阻塞 -&gt; 读写方法变为非阻塞方法</span></span><br><span class="line">            sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读取客户端发送的消息</span></span><br><span class="line">        <span class="keyword">for</span> (SocketChannel client : clients)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 只有在读取到字节后才可以输出: read 方法没有读取到字节返回 0, 抛出异常返回 -1</span></span><br><span class="line">            <span class="keyword">if</span> (client.read(buffer) &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 输出缓冲区中的内容</span></span><br><span class="line">                readBuffer(buffer);</span><br><span class="line">                System.out.print(<span class="string">&quot;\t&quot;</span> + client + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>问题：思考一下，现在的服务器代码是否存在问题？如果存在问题，那么应该怎样解决？</p>
</li>
</ul>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><blockquote>
<p><strong>Selector：基础知识</strong></p>
</blockquote>
<ul>
<li><p>前情提要：</p>
<ul>
<li><p>问题：测试过之前的服务器代码就能够发现问题，服务器即使在没有客户端连接的情况下都在运行，非常占用服务器资源</p>
<p>  !!经过自己电脑测试之后发现，每开一个客户端进程，CPU 的资源利用率就会上涨将近 15%!!</p>
</li>
<li><p>目的：</p>
<p>  我们显然不希望在没有客户端请求到来的时候服务器也在不停地运行</p>
<p>  [我们需要的是服务器仅在客户端发来请求的时候才开始处理，其余时候阻塞就行]{.blue}</p>
</li>
<li><p>解决：[Selector 类]{.red}</p>
</li>
</ul>
</li>
<li><p>名称：直译为选择器</p>
</li>
<li><p>定义：Selector 监视 [事件]{.red} 的发生：只要事件发生就通知相应的通道来处理该事件，否则就阻塞服务器</p>
</li>
<li><p>核心：[<strong>将轮询的非阻塞机制优化成复用式的阻塞机制</strong>]{.red}</p>
<p>  注：Selector 并不是将阻塞变成非阻塞，而是对非阻塞机制进行优化，优化的结果就是阻塞机制</p>
</li>
<li><p>事件：[主要分为四种事件]{.red}</p>
<ul>
<li><code>SelectionKey.OP_ACCEPT</code>：服务器接收客户端连接请求时该事件发生</li>
<li><code>SelectionKey.OP_READ</code>：客户端发送数据时该事件发生</li>
<li><code>SelectionKey.OP_WRITE</code>：服务器端发送数据时该事件发生</li>
<li><code>SelectionKey.OP_CONNECT</code>：客户端向服务器发送连接请求时该事件发生</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>[Selector 可以被多个通道共同使用]{.red}</li>
<li>[Selector 可以监视同一个通道关注的多个事件]{.red}</li>
</ul>
</li>
<li><p>创建并注册 Selector</p>
<ul>
<li>创建：Selector 构造方法依然是受到保护的，仅能够通过静态方法创建实例对象</li>
<li>注册：<ul>
<li>概述：[ServerSocketChannel 对象]{.blue} 调用 <code>register</code> 方法</li>
<li>第一个参数：传入通道想要注册的监视器（注：是通道向监视器注册）</li>
<li>第二个参数：传入通道关注的事件（[注：通道可以同时关注多个事件]{.red}）</li>
<li>第三个参数：传入通道独占的缓冲区，主要在服务器发生 [写事件]{.red} 时会使用到</li>
<li>返回值：Selector 会为通道分配相应的管理员，用来管理该通道关注的所有事件</li>
</ul>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 服务器端口</span></span><br><span class="line">    ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">    ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">4396</span>));</span><br><span class="line">    ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 创建监视器（选择器）</span></span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    <span class="comment">// 服务器端注册监视器: 指定当前通道关注的事件</span></span><br><span class="line">    <span class="comment">// 返回值为监视器分配的管理员: 用于管理该通道关注的所有事件</span></span><br><span class="line">    SelectionKey key = ssc.register(selector, SelectionKey.OP_ACCEPT, <span class="keyword">null</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>阻塞服务器：Selector 调用 <code>select</code> 方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 只要没有事件发生，监视器就会阻塞服务器; 只要事件产生，就让服务器开始处理事件</span></span><br><span class="line">        selector.select();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>获取并且遍历事件集合</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取当前发生的事件集合: 因为可能多个客户端同时触发事件，所以是集合</span></span><br><span class="line">        Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">        <span class="comment">// 采用迭代器遍历集合: 后续涉及到移除事件</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">        <span class="comment">// 管理员判断当前是哪种事件发生了</span></span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 遍历事件集合处理事件</span></span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 获取当前的事件</span></span><br><span class="line">                SelectionKey sk = iterator.next();</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>处理事件</p>
<ul>
<li>处理接收事件</li>
<li>处理读事件</li>
<li>处理写事件</li>
</ul>
</li>
<li><p>移除事件</p>
</li>
</ul>
<blockquote>
<p><strong>Selector：相关问题</strong></p>
</blockquote>
<ul>
<li>处理客户端断开连接问题</li>
<li>处理消息边界问题</li>
<li>处理容量超出问题</li>
</ul>
<h2 id="实例-多人聊天室"><a href="#实例-多人聊天室" class="headerlink" title="实例: 多人聊天室"></a>实例: 多人聊天室</h2><blockquote>
<p><strong>服务器端</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.v5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多人聊天室: 采用 NIO + Selector 实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 服务器端口号: 默认使用的端口号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">7777</span>;</span><br><span class="line">    <span class="comment">// 缓冲区固定分配的空间大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">// 退出消息标识符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXIT = <span class="string">&quot;退出&quot;</span>;</span><br><span class="line">    <span class="comment">// 调用者可以根据需要使用其他的端口号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="comment">// 服务器端</span></span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel server;</span><br><span class="line">    <span class="comment">// 监听器</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatServer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_PORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatServer</span><span class="params">(<span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取客户端相关信息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getClientName</span><span class="params">(SocketChannel client)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;客户端[&quot;</span> + client.socket().getPort() + <span class="string">&quot;]:&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理连接事件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">acceptHandler</span><span class="params">(SelectionKey selectionKey)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 通知相应的通道来处理事件: 服务器端开始处理</span></span><br><span class="line">        ServerSocketChannel server = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">        <span class="comment">// 获取客户端连接</span></span><br><span class="line">        SocketChannel client = server.accept();</span><br><span class="line">        <span class="comment">// 打印提示信息</span></span><br><span class="line">        System.out.println(getClientName(client) + <span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">        <span class="comment">// 客户端同样设置为非阻塞</span></span><br><span class="line">        client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 客户端向选择器注册: 每个客户端都有属于自己的专属缓冲区</span></span><br><span class="line">        client.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(BUFFER_SIZE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转发消息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">forward</span><span class="params">(Set&lt;SelectionKey&gt; selectionKeys, SocketChannel client, ByteBuffer buffer)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 开始处理事件: 获取所有注册在监听器上的通道</span></span><br><span class="line">        Set&lt;SelectionKey&gt; keys = selector.keys();</span><br><span class="line">        <span class="comment">// 开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (SelectionKey receiver : keys)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 因为获取的是所有的事件而不是发生的所有事件, 所以这里面包含服务器端要处理的事件</span></span><br><span class="line">            <span class="comment">// 我们只需要向客户端转发消息, 所有只需要处理对应通道为客户端的事件, 而不需要服务器端的</span></span><br><span class="line">            <span class="keyword">if</span> (receiver.channel() <span class="keyword">instanceof</span> SocketChannel)</span><br><span class="line">            &#123;</span><br><span class="line">                SocketChannel channel = (SocketChannel) receiver.channel();</span><br><span class="line">                <span class="keyword">if</span> (channel != client)</span><br><span class="line">                &#123;</span><br><span class="line">                    buffer.rewind();</span><br><span class="line">                    channel.write(buffer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断客户端是否退出</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isExit</span><span class="params">(ByteBuffer buffer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(StandardCharsets.UTF_8.decode(buffer)).contains(EXIT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理读事件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readHandler</span><span class="params">(SelectionKey selectionKey)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 缓冲区</span></span><br><span class="line">        ByteBuffer buffer = (ByteBuffer) selectionKey.attachment();</span><br><span class="line">        <span class="comment">// 从发送消息的客户端中读取数据</span></span><br><span class="line">        SocketChannel client = (SocketChannel) selectionKey.channel();</span><br><span class="line">        buffer.put(getClientName(client).getBytes());</span><br><span class="line">        client.read(buffer);</span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="keyword">if</span> (isExit(buffer))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(getClientName(client) + <span class="string">&quot;断开连接&quot;</span>);</span><br><span class="line">            client.write(StandardCharsets.UTF_8.encode(EXIT));</span><br><span class="line">            <span class="comment">// 取消监听该事件</span></span><br><span class="line">            selectionKey.cancel();</span><br><span class="line">            <span class="comment">// 关闭客户端</span></span><br><span class="line">            client.close();</span><br><span class="line">            <span class="comment">// 结束执行该方法</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写模式切换成读模式</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="comment">// 打印提示信息: decode 方法会将 position 指针移动, 所以使用这个方法之后想要再次读取, 就要使用 clear 或者 rewind 方法</span></span><br><span class="line">        System.out.println(StandardCharsets.UTF_8.decode(buffer));</span><br><span class="line">        <span class="comment">// 转发消息</span></span><br><span class="line">        forward(selector.keys(), client, buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理发生的事件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">selectionKeyHandler</span><span class="params">(Set&lt;SelectionKey&gt; selectionKeys)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 采用迭代器遍历事件集合更好: 因为有可能部分事件发生了但没有处理</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 遍历集合事件</span></span><br><span class="line">            SelectionKey selectionKey = iterator.next();</span><br><span class="line">            <span class="comment">// 根据事件类型分别处理</span></span><br><span class="line">            <span class="keyword">if</span> (selectionKey.isAcceptable())</span><br><span class="line">            &#123;</span><br><span class="line">               acceptHandler(selectionKey);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable())</span><br><span class="line">            &#123;</span><br><span class="line">                readHandler(selectionKey);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isWritable())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// TODO 服务器端向客户端发送消息, 一次没有发送完成才会触发写事件</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 事件处理完成后移除</span></span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable close)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (close != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            close.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            server = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">// 服务器端设置为非阻塞</span></span><br><span class="line">            server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 绑定端口号</span></span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            <span class="comment">// 创建选择器</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">// 服务器端注册: 仅需要关注客户端连接的事件</span></span><br><span class="line">            server.register(selector, SelectionKey.OP_ACCEPT, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 打印提示信息</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;服务器[%d]:%s\n&quot;</span>, port, <span class="string">&quot;启动成功&quot;</span>);</span><br><span class="line">            <span class="comment">// 服务器开始等待客户端连接并且处理事件</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 阻塞服务器: 防止服务器空转</span></span><br><span class="line">                selector.select();</span><br><span class="line">                <span class="comment">// 获取此时所有发生的事件并处理</span></span><br><span class="line">                selectionKeyHandler(selector.selectedKeys());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ChatServer().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>客户端</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.v5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectableChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_LOCALHOST = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">7777</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXIT = <span class="string">&quot;退出&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> String localhost;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel client;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClient</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_PORT, DEFAULT_LOCALHOST);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClient</span><span class="params">(<span class="keyword">int</span> port, String localhost)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.localhost = localhost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取客户端相关信息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getClientName</span><span class="params">(SocketChannel client)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        InetSocketAddress address = (InetSocketAddress) client.getLocalAddress();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;客户端[&quot;</span> + address.getPort() + <span class="string">&quot;]:&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理连接事件</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectHandler</span><span class="params">(SelectionKey selectionKey)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 获取处理事件的通道</span></span><br><span class="line">        SocketChannel channel = (SocketChannel) selectionKey.channel();</span><br><span class="line">        <span class="comment">// 连接正在建立时返回 true</span></span><br><span class="line">        <span class="keyword">if</span> (channel.isConnectionPending())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 手动确认连接建立完成</span></span><br><span class="line">            channel.finishConnect();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理读取事件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readHandler</span><span class="params">(SelectionKey selectionKey)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 获取事件对应的通道</span></span><br><span class="line">        SocketChannel client = (SocketChannel) selectionKey.channel();</span><br><span class="line">        <span class="comment">// 获取事件对应的附件(缓冲区)</span></span><br><span class="line">        ByteBuffer buffer = (ByteBuffer) selectionKey.attachment();</span><br><span class="line">        client.read(buffer);</span><br><span class="line">        <span class="comment">// 写模式切换成读模式</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        String msg = String.valueOf(StandardCharsets.UTF_8.decode(buffer));</span><br><span class="line">        <span class="keyword">if</span> (EXIT.equals(msg))</span><br><span class="line">        &#123;</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印提示信息</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// 读模式切换成写模式</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理事件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">selectionKeysHandler</span><span class="params">(Set&lt;SelectionKey&gt; selectionKeys)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历事件集合</span></span><br><span class="line">        <span class="keyword">for</span> (SelectionKey selectionKey : selectionKeys)</span><br><span class="line">        &#123;</span><br><span class="line">             readHandler(selectionKey);</span><br><span class="line">        &#125;</span><br><span class="line">        selectionKeys.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 创建客户端</span></span><br><span class="line">            client = SocketChannel.open();</span><br><span class="line">            <span class="comment">// 客户端绑定端口号</span></span><br><span class="line">            client.connect(<span class="keyword">new</span> InetSocketAddress(localhost, port));</span><br><span class="line">            <span class="comment">// 客户端设置为非阻塞</span></span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 开启输入线程</span></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ChatClientInputThread(client)).start();</span><br><span class="line">            <span class="comment">// 打印提示信息</span></span><br><span class="line">            System.out.println(getClientName(client) + <span class="string">&quot;启动成功&quot;</span>);</span><br><span class="line">            <span class="comment">// 监听器</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">// 注册监听事件</span></span><br><span class="line">            client.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ,</span><br><span class="line">                    ByteBuffer.allocate(BUFFER_SIZE));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 阻塞客户端</span></span><br><span class="line">                selector.select();</span><br><span class="line">                <span class="comment">// 获取发生的事件集合</span></span><br><span class="line">                selectionKeysHandler(selector.selectedKeys());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ChatClient().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.v5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClientInputThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXIT = <span class="string">&quot;退出&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BufferedReader READER = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">            <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                    System.in));</span><br><span class="line">    <span class="keyword">private</span> SocketChannel client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClientInputThread</span><span class="params">(SocketChannel client)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">while</span> ((msg = READER.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ByteBuffer buffer = StandardCharsets.UTF_8.encode(msg);</span><br><span class="line">                client.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Fuyusakaiori</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/08/18/java/io/NIO/">http://example.com/2021/08/18/java/io/NIO/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/08/19/java/io/%E6%A6%82%E8%BF%B0/"><i class="fa fa-chevron-left">  </i><span>概述</span></a></div><div class="next-post pull-right"><a href="/2021/08/16/java/generic/%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6/"><span>泛型编程</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/随机图库/1643042375499.2rf317jrwiw0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2022 By Fuyusakaiori</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">wind glass bluebird</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>