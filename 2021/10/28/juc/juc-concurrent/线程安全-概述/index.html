<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="线程安全-概述"><meta name="keywords" content=""><meta name="author" content="Fuyusakaiori"><meta name="copyright" content="Fuyusakaiori"><title>线程安全-概述 | 天鹅绒房间</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"37DAS9P43B","apiKey":"c2a5f8cdb503b255bb4384b147d4ab84","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">什么是线程安全问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.</span> <span class="toc-text">共享变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.</span> <span class="toc-text">线程安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9"><span class="toc-number">1.3.1.</span> <span class="toc-text">基本内容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">原子性问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">可见性问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">有序性问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%AD%89%E7%BA%A7"><span class="toc-number">1.3.2.</span> <span class="toc-text">线程安全等级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">不可变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">绝对线程安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">相对线程安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%85%BC%E5%AE%B9"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">线程兼容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AF%B9%E7%AB%8B"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">线程对立</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i1.xpic.jp/file/xpicjp/2022/01/21/2070676bca90a832cba0ff3e76a701b1.png"></div><div class="author-info__name text-center">Fuyusakaiori</div><div class="author-info__description text-center">啥也不会的大三狗</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/fuyusakaiori">いらしゃい</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">108</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">32</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/随机图库/1642739303853.5y6qd48prwk0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">天鹅绒房间</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/Home">主页 | Home</a><a class="site-page" href="/archives">归档 | Archives</a><a class="site-page" href="/categories">分类 | Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">线程安全-概述</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-10-28</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java 并发编程</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">多线程基础</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">3.1k</span><span class="post-meta__separator">|</span><span>Reading time: 9 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="什么是线程安全问题？"><a href="#什么是线程安全问题？" class="headerlink" title="什么是线程安全问题？"></a>什么是线程安全问题？</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>:::primary</p>
<p>① 详细讲述线程安全之前先来简单感受下什么是线程安全问题</p>
<p>② 感受下出现线程安全问题的大致需要什么样的条件，因为我发现在没有样例的情况怎么写都是不好写的</p>
<p>:::</p>
<ul>
<li><p>线程不安全示例：</p>
<ul>
<li><p>[类提供对成员变量进行读写的方法，而多个线程同时调用类提供的该方法对成员变量递增 1000 次]{.aqua}</p>
</li>
<li><p>[最后得到结果会是我们预想的 2000 吗？还是会得到一个非常奇怪的结果？ ]{.aqua}</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronized</span></span>&#123;</span><br><span class="line">	<span class="comment">// 多线程使用的变量    </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">	<span class="comment">// 多线程控制变量的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为了节省代码的篇幅, 仅列出对成员变量和相应的方法，多线程的代码请自己编写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果你已经编写好多线程的代码，并且经过测试应该会发现结果可能每次都不一样</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/线程不安全的示例.rnomm14qxww.png" alt="线程不安全的示例" style="zoom:80%;" />

<p>  +++danger 为什么会出现如此奇怪的结果？</p>
<p>  ① 每个线程对成员变量进行相加的过程中并不是简单地执行加法，而是执行了三种操作</p>
<p>  ② 每个线程首先会获取成员变量的值、成员变量加一、最后将结果更新给成员变量</p>
<p>  ③ 如果某个线程在执行完成员变量加一之后，因为线程上下文切换而导致无法执行时，此时的结果依然是原来的值</p>
<p>  ④ 其余线程获取到的成员变量的值就是原来的值，执行完后续两个操作之后，成员变量真正完成了加一的操作</p>
<p>  ⑤ 但是刚才没有执行完的线程并不知道这件事情，它继续将自己的运算得到的结果更新给成员变量</p>
<p>  ⑥ 这就导致最后明明执行两次加法，但是成员变量却只增加了一次</p>
<p>  +++</p>
</li>
</ul>
</li>
<li><p>线程不安全的条件</p>
<ul>
<li>[存在可共享的变量]{.red}</li>
<li>[存在多线程并行或者并发地对共享变量进行读写]{.red}</li>
</ul>
</li>
<li><p>前言：</p>
<ul>
<li>只有确定共享变量之后，才能够分析是否会有线程安全问题，最终才能够确定同步方案<ol>
<li>首先就需要了解如何确定共享变量，哪些变量才是共享变量</li>
<li>其次就需要分析线程安全问题是如何产生的</li>
<li>最后才会思考如何采用合适的同步方案解决线程安全问题</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h2><ul>
<li><p>前提：</p>
<ul>
<li>[变量是否共享都是以线程为单位的，而不是对象或者方法之类的]{.orange}</li>
<li>[共享变量是产生线程安全问题的必要条件]{.orange}<ul>
<li>[线程安全问题的产生必然基于对共享变量的操作]{.pink}</li>
<li>[但是共享变量的存在不一定会导致线程安全问题的出现]{.pink}</li>
</ul>
</li>
</ul>
</li>
<li><p>共享变量定义：[多线程可以同时访问的变量称为共享变量]{.grey}</p>
</li>
<li><p>共享变量位置：[Java 虚拟机中的栈空间的变量都是线程私有的，堆空间中的对象都是线程共享的]{.red}</p>
</li>
<li><p>共享变量实例：</p>
<ul>
<li><p>成员变量（实例变量 + 类变量）：</p>
<ul>
<li><p>前提：[无论成员变量是基本数据类型还是引用类型都是 <strong>可能</strong> 共享的]{.orange}</p>
<ul>
<li>对象的成员变量都是分配在堆空间中的，而堆空间是所有线程都共享的区域</li>
</ul>
</li>
<li><p>[如果成员变量在能够直接或者间接地被其他对象使用，那么这些成员变量都是可共享的变量]{.red}</p>
<ul>
<li><p>逸出的方式有非常多种，并不是每种逸出方式都可能造成线程安全的</p>
</li>
<li><p>只能够代表这些变量可以被其他线程所访问到，也就是可共享</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedVariable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// ① 访问权限是公共的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">// ② 访问权限私有的基本数据类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="comment">// 其余线程可以通过方法获取私有成员变量的副本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ③ 访问权限私有的引用数据类型</span></span><br><span class="line">    <span class="keyword">private</span> StringBuilder sb;</span><br><span class="line">    <span class="comment">// 其余线程可以通过方法获取到私有成员变量的引用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">getStringBuilder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ④ 直接对成员变量的使用也是逸出, 不是只有返回成员变量才叫逸出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStringBuilder</span><span class="params">(StringBuilder sb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sb = sb;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 总结:</span></span><br><span class="line">    <span class="comment">// ① ④ 两种方式都涉及到对成员变量的修改, 是很容易产生产生线程安全的</span></span><br><span class="line">    <span class="comment">// ② ③ 两种方式涉及到的知识成员变量的修改, 但是后者会产生线程安全问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>局部变量：</p>
<ul>
<li><p>前提：</p>
<ol>
<li>[基本数据类型的局部变量是 <strong>不可能</strong> 被共享的]{.orange}<ul>
<li>基本数据类型的局部变量是分配在栈空间中的</li>
<li>每个线程访问该局部变量的时候都复制一份到自己的栈空间中</li>
<li>每个线程的栈空间都是私有的，不存在共享变量的可能</li>
</ul>
</li>
<li>[引用类型的局部变量存在是 <strong>可能</strong> 共享的]{.aqua}<ul>
<li>每个线程访问局部变量的时候复制对象的引用到自己栈空间中</li>
<li>每个线程的使用的引用指向的都是堆空间中相同的对象，所以存在共享的可能</li>
</ul>
</li>
</ol>
</li>
<li><p>[如果 <strong>引用类型</strong> 的局部变量能够直接或间接地被其他对象使用，那么这些局部变量都是可共享的变量]{.red}</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ① 方法的持续调用, 导致局部变量被其他线程所引用</span></span><br><span class="line"><span class="comment">// 个人感觉这种情况比较特殊, 但是既然存在那也写上来吧</span></span><br><span class="line"><span class="comment">// 注：基本数据类型即使这么做也是没有用的, 因为 Java 是值传递, 每个线程都会拿到副本</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 此时的局部变量就已经逸出到其他线程中了, 可以被其他线程所使用</span></span><br><span class="line">        add(list, i + <span class="number">2</span>);</span><br><span class="line">        remove(list, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一个线程可以给链表增加元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        list.add(number);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 另一个线程可以给链表移除元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        list.remove(index);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ② 返回值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getStringBuilder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 是否存在线程安全取决于调用者</span></span><br><span class="line">    <span class="comment">// 返回的对象如果只有一个线程使用, 那就有没有问题</span></span><br><span class="line">    <span class="comment">// 返回的对象如果有多个线程使用，那就有线程安全问题</span></span><br><span class="line">    <span class="comment">// 但是无论怎样, 这个对象都是可以被共享的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>总结：</p>
<ol>
<li>[只要变量不暴露给其他对象使用，那么无论变量是什么类型，它都是不可共享的]{.blue}</li>
<li>[引用类型的变量通常都是可以共享的，基本数据类型的变量是成员变量是才可以共享]{.blue}</li>
<li>[堆中的对象基本可以共享，取决于线程是否开放他，栈中的变量不可能共享]{.blue}</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>:::primary</p>
<p>① 这里会简述代码中常见的线程安全问题，至于这些线程安全问题究竟是如何造成的，稍后再讲</p>
<p>② 这样排版的主要原因是因为，没有对内存模型的认知，是根本不可能深入理解可见性这个概念的</p>
<p>③ 所以造成原子性、可见性、有序性问题的原因都会在 Java 内存模型中讲述</p>
<p>:::</p>
<h3 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h3><ul>
<li><p>示例：先来看看什么样的是线程安全问题</p>
<ul>
<li>测试代码</li>
<li>测试结果</li>
</ul>
</li>
<li><p>线程安全定义：</p>
<ul>
<li>严谨的定义：<ol>
<li>多个线程并发或者并行访问共享变量的时候</li>
<li>无论运行时采用何种调度方式安排线程的执行，并且不需要任何额外的同步代码</li>
<li>多线程访问共享变量的结果都能够表现出正确的行为，那么就认为是线程安全的</li>
</ol>
</li>
<li>通俗的定义：[多线程按照任意顺序对共享资源进行访问都能够得到正确的结果，就认为是线程安全]{.red}</li>
</ul>
</li>
<li><p>线程安全问题：多线程访问共享变量的结果或者说正确性得不到保证时，就认为出现了线程安全问题</p>
<ul>
<li><p>多线程访问共享变量的方式会直接决定是否会产生线程安全问题</p>
</li>
<li><p>访问方式：读与写</p>
<ul>
<li><p>[多线程 <strong>同时读取共享变量</strong> 不会造成线程安全问题]{.red}</p>
<ul>
<li>解释：同时读取共享变量的行为显然是无论如何打乱，执行的结果一定是符合预期的</li>
</ul>
</li>
<li><p>[多线程 <strong>同时读写或者同时写入</strong> 共享变量都是会造成线程安全问题的]{.red}</p>
<ul>
<li><p>解释：同时的读写或者同时写入的行为被打乱，那么执行的结果是非常有可能不同的</p>
</li>
<li><p>举例：如果某个线程正在对共享变量做递增操作，修改完成之后还没来得及更新变量</p>
<p>  ​              另外一个线程也获取到共享变量并对其进行递增操作，修改完成之后进行更新</p>
<p>  ​              这样就会导致明明变量递增了两次，但是最终只增加了一</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>临界区：[线程访问共享变量的代码块称为临界区]{.red}</p>
</li>
<li><p>竞态条件：[多线程访问共享变量的结果取决于特定的顺序的时候，就认为发生了竞态条件]{.red}</p>
</li>
</ul>
<h4 id="原子性问题"><a href="#原子性问题" class="headerlink" title="原子性问题"></a>原子性问题</h4><ul>
<li><p>定义：</p>
</li>
<li><p>测试代码</p>
</li>
</ul>
<h4 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h4><ul>
<li>定义：</li>
</ul>
<h4 id="有序性问题"><a href="#有序性问题" class="headerlink" title="有序性问题"></a>有序性问题</h4><p>:::primary</p>
<p>:::</p>
<h3 id="线程安全等级"><a href="#线程安全等级" class="headerlink" title="线程安全等级"></a>线程安全等级</h3><h4 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h4><ul>
<li><p>定义：[不可变的对象或者变量都是不会存在任何线程安全性问题的]{.red}</p>
</li>
<li><p>不可变的变量的线程安全：确保变量的线程安全</p>
</li>
<li><p>不可变对象的线程安全</p>
<ul>
<li><p>[不可变对象只能够代表对象的引用是不可以改变的，但是对象内部的成员变量依旧可以访问并且改变]{.red}</p>
</li>
<li><p>也就是说只能够保证引用的线程安全，对象内部的线程安全是没有保证的，需要对象自行保证</p>
<p>  :::danger</p>
<p>  ① 最简单的方式就是将对象内部的所有变量都声明为不可变</p>
<p>  ② 类声明为不可变只能够代表该类无法被继承，而不是代表线程安全的</p>
<p>  :::</p>
</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/不可变性.752xyg222q00.png" alt="不可变性" style="zoom:80%;" /></li>
<li><p>细节：</p>
<ul>
<li>JDK 5 之后才能够保证不可变对象没有线程安全问题</li>
<li>[不可变对象需要在没有发生 <strong>this 引用逃逸</strong> 的情况下被正确的构建出来才是线程安全的]{.pink}</li>
</ul>
</li>
</ul>
<h4 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h4><ul>
<li>定义：[严格满足线程安全的定义也就是绝对线程安全]{.pink}</li>
<li>细节：绝对线程安全几乎很难做到，Java 提供的大多数线程安全类并不是绝对线程安全的</li>
</ul>
<h4 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h4><ul>
<li>定义：<ul>
<li>线程单次调用对象中的某个方法时是线程安全的，不需要提供任何同步措施</li>
<li>但是线程组合调用多个线程的方法时需要采用一定的同步措施</li>
</ul>
</li>
<li>细节：相对线程安全就是通常意义上指的线程安全，Java 提供的大多数线程安全类都是相对线程安全的</li>
</ul>
<h4 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h4><ul>
<li>定义：线程调用的对象不具备任何确保线程安全的措施，需要在调用端提供完善的同步措施</li>
</ul>
<h4 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h4><ul>
<li>定义：[无论线程调用的对象是否采取了同步措施，都没有办法让线程并行或者并发调用该对象]{.red}</li>
<li>例子：<code>suspend()</code> 和 <code>resume()</code> 是线程对立的方法<ul>
<li>两个线程分别调用 <code>suspend()</code> 和 <code>resume()</code> 方法是不现实的</li>
<li>前者用于挂起线程，后者用于恢复线程，这两个方法同时执行显然是不合理的 </li>
</ul>
</li>
<li>细节：Java 天生就支持多线程，所以会产生线程对立的方法都被废弃掉了（此前应该提过几个已经被废弃的方法）</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Fuyusakaiori</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/10/28/juc/juc-concurrent/线程安全-概述/">http://example.com/2021/10/28/juc/juc-concurrent/线程安全-概述/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/11/01/java/jcf/Collection-ArrayList/"><i class="fa fa-chevron-left">  </i><span>Collection-ArrayList</span></a></div><div class="next-post pull-right"><a href="/2021/10/28/juc/juc-concurrent/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-synchronized-%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/"><span>线程同步-synchronized-优化策略</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/随机图库/1642739303853.5y6qd48prwk0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2022 By Fuyusakaiori</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">wind glass bluebird</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>