<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="线程同步-synchronized-基础"><meta name="keywords" content=""><meta name="author" content="Fuyusakaiori"><meta name="copyright" content="Fuyusakaiori"><title>线程同步-synchronized-基础 | 天鹅绒房间</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"37DAS9P43B","apiKey":"c2a5f8cdb503b255bb4384b147d4ab84","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Synchronized-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">Synchronized-基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized"><span class="toc-number">1.2.1.</span> <span class="toc-text">synchronized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait"><span class="toc-number">1.2.2.</span> <span class="toc-text">wait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#notify-notifyAll"><span class="toc-number">1.2.3.</span> <span class="toc-text">notify &#x2F; notifyAll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92"><span class="toc-number">1.2.4.</span> <span class="toc-text">虚假唤醒</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E9%94%81%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.</span> <span class="toc-text">八锁问题</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i1.xpic.jp/file/xpicjp/2022/01/21/2070676bca90a832cba0ff3e76a701b1.png"></div><div class="author-info__name text-center">Fuyusakaiori</div><div class="author-info__description text-center">啥也不会的大三狗</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/fuyusakaiori">いらしゃい</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">108</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">32</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/随机图库/1642739303853.5y6qd48prwk0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">天鹅绒房间</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/Home">主页 | Home</a><a class="site-page" href="/archives">归档 | Archives</a><a class="site-page" href="/categories">分类 | Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">线程同步-synchronized-基础</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-10-28</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java 并发编程</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">多线程基础</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">4.9k</span><span class="post-meta__separator">|</span><span>Reading time: 17 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="Synchronized-基础"><a href="#Synchronized-基础" class="headerlink" title="Synchronized-基础"></a>Synchronized-基础</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>:::primary</p>
<p>基本概念是对 synchronized 的所有内容的总结，如果发现存在难以理解的地方可以先查看后面的笔记</p>
<p>:::</p>
<p>[基本内容]{.label .info}</p>
<ul>
<li><p>synchronized 定义：[采用的 <strong>悲观锁</strong> 的思想，是一种独占锁或者说排他锁]{.red}</p>
</li>
<li><p>synchronized 作用：[给共享变量添加排他锁从而确保 <strong>每次仅有一个线程</strong> 可以访问该共享变量，确保线程安全]{.red}</p>
</li>
<li><p>synchronized 过程分析：</p>
<ul>
<li><p>[存在线程成功获取共享变量的锁之后，其余线程就会 <strong>发生上下文切换进入阻塞队列等待</strong>]{.red}</p>
<ul>
<li>[持有锁的线程被 <strong>分配的时间片可能不足</strong> 以支撑执行完临界区中所有代码]{.pink}</li>
<li>[此时线程会发生上下文切换 <strong>但是依然持有锁</strong>，其余线程依然处于阻塞队列中无法获取锁]{.pink}</li>
<li>[持有锁的线程需要等待处理器再次分配给自己时间片，从而执行完临界区中所有代码，才能够释放锁]{.pink}</li>
</ul>
</li>
<li><p>[持有锁的线程释放锁之后，阻塞队列中的线程 <strong>再次发生上下文切换开始竞争锁的所有权</strong>]{.red}</p>
</li>
<li><p>竞争成功的线程可以获取到共享变量的锁，其余线程再次进入阻塞队列等待</p>
</li>
</ul>
</li>
<li><p>wait 作用：[持有锁的线程执行所需的条件没有得到的满足时，主动释放锁进入等待队列等待，让其余线程执行]{.red}</p>
</li>
<li><p>notify / notifyAll 作用：[等待队列中的线程执行所需的条件得到满足，从而被唤醒去竞争锁的使用权]{.red}</p>
</li>
</ul>
<p>[底层原理]{.label .danger}</p>
<ul>
<li>实现原理：<ul>
<li>[synchronized + wait + notify 机制就是基于操作系统提出的 <strong>管程</strong> 这个概念实现的]{.red}</li>
<li>[synchronized + wait + notify 都是抽象数据结构管程的组成部分]{.red}</li>
</ul>
</li>
<li>编译器实现：<ul>
<li>[编译器在编译生成字节码的时候会将 synchronized 转换成 monitorenter、monitorexit 两条字节码指令]{.red}</li>
<li>[这两条字节码指令确保共享变量是线程独占的，并且在修改之后对其他线程是可见的]{.red}</li>
<li>[这两条字节码指令的底层实现是由 HotSpot 虚拟机中的 ObjectMonitor 对象实现的]{.red}<ul>
<li>[这个对象负责管理锁、锁的拥有者、等待队列、阻塞队列等信息]{.pink}</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>:::info</p>
<p>这里只是简单讲述 synchronized 关键字的底层实现，详细内容查看<a target="_blank" rel="noopener" href="http://47.101.45.234/juc/juc-concurrent/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-synchronized-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">Synchronized 底层原理</a></p>
<p>:::</p>
<p>[性能分析]{.label .success}</p>
<ul>
<li><p>核心：[synchronized 锁]{.red}</p>
</li>
<li><p>[<strong>每次没能成功获取锁的线程需要执行上下文切换进入阻塞队列，而上下文切换会陷入内核态造成很大的开销</strong>]{.red}</p>
</li>
<li><p>[没有竞争的情况下线程依然需要获取锁，也就是会修改监视器对象的信息，这种开销显然是没有必要的]{.red}</p>
<ul>
<li>[没有竞争的情况下产生的获取监视器对象的开销已经在 JDK 6 之后被相应的优化措施解决了]{.pink}</li>
</ul>
</li>
</ul>
<p>[优化措施]{.label .primary}</p>
<ul>
<li>前提：所有的优化措施都是基于没有线程竞争的情况，从而减少没有竞争的情况下同步的开销</li>
<li>[轻量级锁 + 偏向锁（批量重偏向、批量撤销）]{.pink}</li>
<li>[自旋锁 + 锁消除 + 锁粗化]{.pink}</li>
</ul>
<p>[其余细节]{.label .warning}</p>
<ul>
<li><p>[synchronized 锁完美解决了所有并发问题：原子性问题、可见性问题、有序性问题]{.red}</p>
<ul>
<li>不过 synchronized 只是采用内存屏障禁止同步代码块外的代码和同步代码块内的代码进行指令重排</li>
<li>而同步代码内部的代码依然是可以随意进行指令重排的，因为在单线程下指令重排的结果依然是正确的</li>
</ul>
</li>
<li><p>[synchronized 锁是非公平锁，并且不可以被中断，不可以设置超时等待]{.red}</p>
</li>
<li><p>[synchronized 锁可以对共享变量添加，也可以对方法添加]{.red}</p>
<ul>
<li>[synchronized 锁给实例方法添加的本质是给对象实例 this 添加锁]{.pink}</li>
<li>[synchronized 锁给静态方法添加的本质是给 Class 对象添加锁]{.pink}</li>
</ul>
</li>
<li><p>[synchronized 只能给引用类型的变量上锁，基本数据类型是不可以上锁的，并且锁住的引用类型不能为空]{.red}</p>
</li>
<li><p>[不同线程中 synchronized 锁住对象必须相同，才能够确保共享变量是线程独占的]{.red}</p>
</li>
</ul>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><ul>
<li><p>synchronized</p>
<ol>
<li><p>使用方式：给共享变量添加排他锁：<code>synchronized(object)</code></p>
<ul>
<li><p>演示代码</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object object;</span><br><span class="line"><span class="comment">// 给共享变量上锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 其余代码</span></span><br><span class="line">    <span class="keyword">synchronized</span>(object)&#123;</span><br><span class="line">        <span class="comment">// 临界区: 对共享变量进行操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其余代码</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></li>
<li><p>细节：</p>
<ul>
<li><p>[给共享变量上锁可以避免给不需要同步的代码块上锁，从而提高加锁的效率]{.pink}</p>
</li>
<li><p>[只有引用类型的共享变量可以上锁，基本数据类型可以借助引用类型变量保护自身]{.red}</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于上锁的变量</span></span><br><span class="line"><span class="keyword">private</span> Object lock;</span><br><span class="line"><span class="comment">// 共享变量: 不可以直接上锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 其余代码</span></span><br><span class="line">    <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">        <span class="comment">// 保护基本数据类型的变量</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其余代码</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>使用方式：给方法添加排他锁</p>
<ul>
<li><p>演示代码（两种添加方式）</p>
<ul>
<li><p>[给虚方法（实例方法）上锁的实质是对类对象上锁]{.red}</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronized</span></span>&#123;</span><br><span class="line">    <span class="comment">// 给实例方法上锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等价于锁住类相应的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>[给静态方法上锁的实质是对类的 Class 对象上锁]{.red}</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronized</span></span>&#123;</span><br><span class="line">    <span class="comment">// 给静态方法上锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等价于锁住类对应的 Class对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(ThreadSynchronized.class)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>细节：[给整个方法上锁会导致锁住不需要同步的代码块从而降低线程的效率]{.pink}</p>
</li>
</ul>
</li>
<li><p>解决线程安全问题：原子性问题</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程同步方案: synchronized 关键字</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronized</span></span>&#123;</span><br><span class="line">    <span class="comment">// 共享变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本数据类型无法上锁, 所以可以给方法上锁或者直接给 this 上锁</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        ThreadSynchronized obj = <span class="keyword">new</span> ThreadSynchronized();</span><br><span class="line">		<span class="comment">// 执行递增操作的线程</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">                obj.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">		<span class="comment">// 执行递减操作的线程</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">                obj.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">		<span class="comment">// 启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 无论这个测试代码执行多少次, 最后得到结果一定是固定且正确的</span></span><br><span class="line">        log.debug(<span class="string">&quot;count = &#123;&#125;&quot;</span>, obj.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><ul>
<li><p>作用：[调用该方法的线程会 <strong>主动放弃共享变量</strong> 的锁，进入等待队列等待被唤醒]{.red}</p>
</li>
<li><p>应用场景：线程发现自己正在执行的任务缺少相应的资源，无法继续正常执行下去，所以会先挂起自己等待条件满足</p>
</li>
<li><p>特点：</p>
<ul>
<li>[线程会从 RUNNABLE 状态变为 WAIT 或者 TIMED_WAITING 状态]{.red}</li>
<li>[线程调用 wait 方法之后会主动释放锁，以便其他线程能够获取]{.red}</li>
<li>[wait 方法被调用之前必须先对共享变量上锁，否则会抛出 IllegalMonitorStateException]{.pink}</li>
<li>[Object 类中提供了该方法，所以引用类型的共享变量都具有 wait 方法]{.blue}</li>
<li>[notify \ notify、interrupt 方法可以打断线程的等待过程，并且抛出 InterruptedException 异常]{.pink}</li>
</ul>
</li>
<li><p>使用方式：</p>
<ol>
<li><p><code>wait()</code>：[线程会无限期等待其余线程唤醒自己]{.aqua}</p>
</li>
<li><p><code>wait(long timeout)</code> ：[线程会在有限的时间内等待其余线程唤醒自己，超过时间之后就不会继续等待]{.aqua}</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object object;</span><br><span class="line"><span class="comment">// 给共享变量上锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      	<span class="comment">// 其余代码</span></span><br><span class="line">    	<span class="keyword">synchronized</span>(object)&#123;</span><br><span class="line">        	<span class="comment">// 线程发现正在执行的任务缺少相应资源, 挂起自己</span></span><br><span class="line">        	<span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 线程会持续等待直到有人唤醒自己</span></span><br><span class="line">         		object.wait()   </span><br><span class="line">        	&#125;<span class="keyword">catch</span> (Exception e)&#123;&#125;</span><br><span class="line">    	&#125;  </span><br><span class="line">   	&#125;).start();</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="notify-notifyAll"><a href="#notify-notifyAll" class="headerlink" title="notify / notifyAll"></a>notify / notifyAll</h3><ul>
<li><p>作用：[正在运行的线程唤醒等待队列中等待的线程]{.red}</p>
</li>
<li><p>应用场景：正在运行的线程提供了等待队列中的线程需要的资源，所以将这些等待线程唤醒</p>
</li>
<li><p>特点：</p>
<ul>
<li>[线程调用 notify / notifyAll 方法 <strong>不会主动释放锁</strong>]{.red}<ul>
<li>[这也就意味着线程只能够在即将释放锁的时候调用 notify / notifyAll 方法]{.pink}</li>
<li>[否则在没有释放锁的情况下唤醒等待线程，被唤醒的线程也只能陷入阻塞]{.pink}</li>
</ul>
</li>
<li>[没有任何方法可以指定唤醒某个线程]{.red}<ul>
<li>Java 采用的是内核级线程 + 抢占式调度的算法，所有线程的调度都由 OS 管理</li>
<li>C# 等采用协程的语言才是可以控制线程的</li>
</ul>
</li>
<li>[被唤醒的线程是从此前释放锁的位置开始执行而不是从头开始]{.pink}</li>
<li>[Object 类中提供了该方法，所以引用类型的共享变量都具有 notify / notifyAll 方法]{.blue}</li>
</ul>
</li>
<li><p>使用方式：</p>
<ol>
<li><p><code>notify</code>：[线程调用 notify 方法将会 <strong>随机唤醒</strong> 一个线程]{.aqua}</p>
</li>
<li><p><code>notifyAll</code>：[线程调用 notifyAll 将会 <strong>唤醒所有</strong> 等待线程]{.aqua}</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object object;</span><br><span class="line"><span class="comment">// 给共享变量上锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      	<span class="comment">// 其余代码</span></span><br><span class="line">    	<span class="keyword">synchronized</span>(object)&#123;</span><br><span class="line">        	<span class="comment">// 线程发现正在执行的任务缺少相应资源, 挂起自己</span></span><br><span class="line">        	<span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 线程会持续等待直到有人唤醒自己</span></span><br><span class="line">         		object.wait()   </span><br><span class="line">        	&#125;<span class="keyword">catch</span> (Exception e)&#123;&#125;</span><br><span class="line">    	&#125;  </span><br><span class="line">   	&#125;).start();</span><br><span class="line">    </span><br><span class="line">    Time.Unit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 主线程获取锁之后唤醒等待队列中的线程</span></span><br><span class="line">    <span class="keyword">synchronized</span> (LOCK)&#123;</span><br><span class="line">        <span class="comment">// 唤醒所有线程</span></span><br><span class="line">        LOCK.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h3><ul>
<li><p>问题描述：[线程没有其他任何线程 <strong>唤醒或者被中断或者超时</strong>，该线程从 WAIT 状态变为 RUNNABLE 状态]{.blue}</p>
<ul>
<li>这里的唤醒应该指的是其余线程想要唤醒的不是这个线程，所以说该线程没有被唤醒</li>
</ul>
</li>
<li><p>问题演示：</p>
<ol>
<li>Thread-1、Thread-2 需要 flag、status 变量为 true 时才可正常执行任务</li>
<li>两个线程在获取到对象锁之后分别检查变量是否满足，不满足的情况下就会进入等待队列中等待</li>
<li>主线程在子线程释放锁之后获取对象锁，并且在即将离开之前唤醒所有线程</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 虚假唤醒问题</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.fake&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadFakeNotify</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// 第一个线程正常执行需要满足的条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 第二个线程正常执行需要满足的条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> status= <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">// 为了节省篇幅将去除异常的代码块</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK)&#123;</span><br><span class="line">                <span class="comment">// 先检查运行所需的条件是否满足</span></span><br><span class="line">                <span class="keyword">if</span> (!flag)&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;线程未能够获得执行所需的条件, 进入等待队列...&quot;</span>);</span><br><span class="line">                    LOCK.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 唤醒之后检查是否满足条件</span></span><br><span class="line">                <span class="keyword">if</span> (flag)</span><br><span class="line">                    log.debug(<span class="string">&quot;执行任务...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK)&#123;</span><br><span class="line">                <span class="comment">// 先检查运行所需的条件是否满足</span></span><br><span class="line">                <span class="keyword">if</span> (!status)&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;线程未能够获得执行所需的条件, 进入等待队列...&quot;</span>);</span><br><span class="line">                    LOCK.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (status)</span><br><span class="line">                    log.debug(<span class="string">&quot;执行任务...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK)&#123;</span><br><span class="line">                <span class="comment">// 由于资源限制仅满足一个条件</span></span><br><span class="line">                status = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒所有线程</span></span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>核心原因：[每个锁对象仅存在唯一的条件变量，也就是只有一个等待队列]{.red}</p>
<ol>
<li>[所有持有该锁对象的线程在调用 wait 方法之后都会进入相同的等待队列]{.pink}</li>
<li>[其余线程调用 notifyAll 方法会唤醒所有线程，无论线程需要的条件是否满足]{.pink}</li>
<li>[被唤醒的线程不会检查条件变量是否满足，而是直接从此前等待的位置继续执行]{.pink}</li>
<li>[从而导致线程在条件没有满足的情况下，什么都无法完成就结束了]{.pink}</li>
</ol>
</li>
<li><p>正确使用方式：[采用循环判断的方式而不是条件判断]{.aqua}</p>
<ul>
<li>每次线程被唤醒都会检查自己的条件是否满足<ul>
<li>如果条件不满足就会继续调用 wait 方法进行等待</li>
<li>如果条件满足就执行正常任务</li>
</ul>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (LOCK)&#123;</span><br><span class="line">        <span class="comment">// 先检查运行所需的条件是否满足</span></span><br><span class="line">        <span class="keyword">while</span> (!flag)&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;线程未能够获得执行所需的条件, 进入等待队列...&quot;</span>);</span><br><span class="line">            LOCK.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 唤醒之后检查是否满足条件</span></span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            log.debug(<span class="string">&quot;执行任务...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>:::primary</p>
<p>① 在 if 块中使用 wait 方法是非常危险的，因为一旦线程被唤醒并得到锁，就不会再判断if条件而是执行if语句块外的代码</p>
<p>② 在 while 块中则是会在唤醒之后继续判断条件是否成立，这样就避免被虚假唤醒的危险</p>
<p>:::</p>
<h2 id="八锁问题"><a href="#八锁问题" class="headerlink" title="八锁问题"></a>八锁问题</h2><p>:::info</p>
<p>如果你认为自己对 Synchronized 关键的使用掌握的很好的话，其实这八个问题都很简单，没有必要看</p>
<p>:::</p>
<ul>
<li><p>前言：[线程八锁问题其实非常简单，考察的是你是否能够清楚分辨锁住的到底是那个对象和线程执行的先后顺序]{.aqua}</p>
</li>
<li><p>问题</p>
<p>  +++warning 观察下列情况，分析两个线程锁住的对象是否相同，线程之间是否会因为锁而互斥</p>
<p>  两个线程锁住都是 this 引用，而 this 指向的是相同的对象，既然锁住的对象相同那么必然就会产生互斥</p>
<p>  +++</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronizedTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法一...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法二...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ThreadSynchronizedTest test = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method1, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method2, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  +++warning 在第一题的基础上让其中一个线程睡眠固定时间，试分析会出现的情况</p>
<p>  ① sleep 方法不会释放线程持有的锁</p>
<p>  ② 其中一个线程需要等待另一个线程固定时间+运行时间才可以获取锁]</p>
<p>  +++</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronizedTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 省略捕获异常的代码...</span></span><br><span class="line">        TimeUnit.sleep(<span class="number">1</span>)</span><br><span class="line">        log.debug(<span class="string">&quot;方法一...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法二...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ThreadSynchronizedTest test = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method1, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method2, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  +++warning 观察下列情况，试分析线程的执行的先后顺序</p>
<p>  ① 线程-1和线程-2之间的执行顺序取决于谁先抢到锁，先抢到的先执行</p>
<p>  ② 线程-3执行的方法没有上锁，执行的时机依靠虚拟机的调度</p>
<p>  ③ 线程1和线程-3：线程-3会先于线程-1执行结束，无论线程-1是否抢到锁，因为线程-1需要睡眠1秒，而线程的调度时间是纳 秒级别的，线程-1执行结束前线程-3早就被调度执行</p>
<p>  ④ 线程-2和线程-3：如果线程-2没有先抢到锁，那么就会晚于线程-3执行，因为线程-1需要睡眠1秒；如果线程-2先抢到锁，那么线程-2和线程-3的执行顺序就是随机的</p>
<p>  ⑤ 结果：3 1 2，3 2 1，2 3 1</p>
<p>  +++</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程八锁问题: 明确到底锁住的是哪个对象</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronizedTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 省略捕获异常的代码...</span></span><br><span class="line">        TimeUnit.sleep(<span class="number">1</span>)</span><br><span class="line">        log.debug(<span class="string">&quot;方法一...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法二...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 没有上锁的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ThreadSynchronizedTest test = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method1, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method2, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method3, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  +++warning 观察下面的代码，试分析两个线程锁住的是否为同一个对象，是否产生互斥</p>
<p>  ① 两者锁住的不是相同的对象，虽然 synchronized 锁住的都是 this 引用，但是两个 this 指向的却是不同的对象</p>
<p>  ② 锁住既然不是相同的对象，那么也就不会产生互斥，两个线程可以并发或者并行输出</p>
<p>  +++</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronizedTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法一...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法二...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       	<span class="comment">// 两个不同的对象</span></span><br><span class="line">        ThreadSynchronizedTest test1 = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        ThreadSynchronizedTest test2 = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(test1::method1, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(test2::method2, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  +++warning 观察下面的代码，试分析两个线程锁住的是否为同一个对象，是否产生互斥</p>
<p>  前者锁住的是静态方法，锁住的是类对应的 Class 对象；后者锁住的是实例方法，锁住的是类对应的实例对象</p>
<p>  +++</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronizedTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法一...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法二...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       	<span class="comment">// 两个不同的对象</span></span><br><span class="line">        ThreadSynchronizedTest test = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        <span class="comment">// 对象调用静态方法是可以的, 只不过不推荐</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;test.method1();&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method2, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  +++warning 观察下面的代码，试分析两个线程锁住的是否为同一个对象，是否产生互斥</p>
<p>  两者锁住都是类对应的 Class 对象</p>
<p>  +++</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronizedTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法一...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法二...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 两个不同的对象</span></span><br><span class="line">        ThreadSynchronizedTest test = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        <span class="comment">// 对象调用静态方法是可以的, 只不过不推荐</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;test.method1();&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;test.method2();&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  +++warning 观察下面的代码，试分析两个线程锁住的是否为同一个对象，是否产生互斥</p>
<p>  前者锁住的依然是 Class 对象，后者锁住的依然是实例对象，只不过实例是 test2 而不是 test 1</p>
<p>  +++</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronizedTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法一...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法二...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 两个不同的对象</span></span><br><span class="line">        ThreadSynchronizedTest test1 = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        ThreadSynchronizedTest test2 = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        <span class="comment">// 对象调用静态方法是可以的, 只不过不推荐</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;test1.method1();&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;test2.method2();&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  +++warning 观察下面的代码，试分析两个线程锁住的是否为同一个对象，是否产生互斥</p>
<p>  虚拟机会为每个类都维护唯一的 Class 对象，两者锁住的都是相同的 Class 对象，尽管实例对象是不同</p>
<p>  +++</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronizedTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法一...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法二...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 两个不同的对象</span></span><br><span class="line">        ThreadSynchronizedTest test1 = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        ThreadSynchronizedTest test2 = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        <span class="comment">// 对象调用静态方法是可以的, 只不过不推荐</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;test1.method1();&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;test2.method2();&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>总结：帮助初学者熟悉 synchronized 机制使用的题目，个人觉得意义不是很大</p>
</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Fuyusakaiori</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/10/28/juc/juc-concurrent/线程同步-synchronized-基础/">http://example.com/2021/10/28/juc/juc-concurrent/线程同步-synchronized-基础/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/10/28/juc/juc-concurrent/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-synchronized-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"><i class="fa fa-chevron-left">  </i><span>线程同步-synchronized-底层原理</span></a></div><div class="next-post pull-right"><a href="/2021/10/28/juc/juc-concurrent/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-volatile/"><span>线程同步-volatile</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/随机图库/1642739303853.5y6qd48prwk0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2022 By Fuyusakaiori</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">wind glass bluebird</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>