<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="Synchronized-底层原理       :::primary ① Synchronized 等价于操作系统中的管程，所以首先理解操作系统中的管程是非常重要的 ② Java 中提供的所有锁机制几乎都是基于管程的概念实现的 ③ 想要知道 Synchronized 是如何实现管程的，需要了解以下的知识 参考笔记： 堆空间 - 对象创建 进程同步-信号量 :">
<meta property="og:type" content="article">
<meta property="og:title" content="线程同步-synchronized-底层原理">
<meta property="og:url" content="http://example.com/2021/10/28/juc/juc-concurrent/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-synchronized-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="天鹅绒房间">
<meta property="og:description" content="Synchronized-底层原理       :::primary ① Synchronized 等价于操作系统中的管程，所以首先理解操作系统中的管程是非常重要的 ② Java 中提供的所有锁机制几乎都是基于管程的概念实现的 ③ 想要知道 Synchronized 是如何实现管程的，需要了解以下的知识 参考笔记： 堆空间 - 对象创建 进程同步-信号量 :">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/管程.3kwq144bgzc0.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/获取管程的使用权（1）.19slk7btdups.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/获取管程的使用权（2）.1d7ofw1x2cyo.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/获取管程的使用权（3）.7ffj485ern40.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/更新-Mark-Word.5902q4pwfec0.png">
<meta property="article:published_time" content="2021-10-28T12:47:45.774Z">
<meta property="article:modified_time" content="2021-10-29T06:27:36.035Z">
<meta property="article:author" content="Fuyusakaiori">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/管程.3kwq144bgzc0.png"><title>线程同步-synchronized-底层原理 | 天鹅绒房间</title><link ref="canonical" href="http://example.com/2021/10/28/juc/juc-concurrent/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-synchronized-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">天鹅绒房间</div><div class="header-banner-info__subtitle">Velvet Room</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">线程同步-synchronized-底层原理</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-29</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body">
        <h1 id="Synchronized-底层原理"   >
          <a href="#Synchronized-底层原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#Synchronized-底层原理" class="headerlink" title="Synchronized-底层原理"></a>Synchronized-底层原理</h1>
      <p>:::primary</p>
<p>① Synchronized 等价于操作系统中的管程，所以首先理解操作系统中的管程是非常重要的</p>
<p>② Java 中提供的所有锁机制几乎都是基于管程的概念实现的</p>
<p>③ 想要知道 Synchronized 是如何实现管程的，需要了解以下的知识</p>
<p>参考笔记：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://47.101.45.234/jvm/runtime/heapspace/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/" >堆空间 - 对象创建</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><a href="">进程同步-信号量</a></p>
<p>:::</p>

        <h2 id="什么是管程？"   >
          <a href="#什么是管程？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是管程？" class="headerlink" title="什么是管程？"></a>什么是管程？</h2>
      <p>:::primary</p>
<p>先来了解下管程的基本机制和基本概念，不涉及具体的过程细节，具体细节放在之后再讲述</p>
<p>参考书籍：《现代操作系统》</p>
<p>参考博客：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38998213/article/details/87899231" >管程的理解</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<ul>
<li><p>名称：Monitor</p>
<ul>
<li>被翻译成管程或者监视器（<del>Java 中还有个概念叫监听器，不过这玩意不重要</del>）</li>
</ul>
</li>
<li><p>定义：[管理共享变量和共享变量的函数实现的一种用于实现同步的高级 <strong>抽象数据结构</strong> ]{.red}</p>
<ul>
<li>[管程中主要包含线程需要使用的共享变量，以及操作共享变量的函数]{.pink}</li>
<li>[抽象数据结构就意味着它不是具体的实现，所以不同语言可以实现自己的管程，是编译器层面的同步方式]{.pink}</li>
</ul>
</li>
<li><p>组成：[共享变量 + 函数 + 信号量 + 条件变量]{.red}</p>
<ul>
<li>[管程作为高级抽象数据结构，其底层通常采用信号量实现同步]{.pink}</li>
<li>[编译器通常确保操作系统能够识别到管程，进而使用信号量进行同步]{.pink}</li>
</ul>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这样的抽象数据结构就称为管程*/</span></span><br><span class="line">monitor monitor_name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*共享变量*/</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">/*信号量: 实现互斥使用的(由编译器负责,程序员不用管)*/</span></span><br><span class="line">    Semaphor semaphor;</span><br><span class="line">    <span class="comment">/*条件变量: 实现线程阻塞和唤醒使用的*/</span></span><br><span class="line">    Condition condition;</span><br><span class="line">    <span class="comment">/*共享变量的函数实现*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="comment">/*初始化代码*/</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>机制：</p>
<ul>
<li>互斥：[管程机制本质采用<strong>信号量等同步机制</strong>确保线程在管程中的互斥，即管程中仅存在唯一活跃的线程]{.red}<ul>
<li>[信号量是由编译器在生成编译文件的时候自动添加而不是由程序员添加，也就是管程是由编译器实现的]{.pink}</li>
<li>[所以管程可以认为是 <strong>软件层面</strong> 实现的同步方式，而此前的信号量通常都是 <strong>硬件层面</strong> 实现的]{.pink}</li>
</ul>
</li>
<li>条件变量：[管程机制允许活跃线程条件不足主动放弃管程的使用权，等待条件满足后重新获取管程的使用权]{.red}<ul>
<li>为何引入条件变量？<ul>
<li>条件不足可能是因为线程需要的某种资源没有获取到，诸如 IO 读取的数据、缓冲区数据不足等等</li>
<li>线程无法得到资源就无法向下执行，就会无限期持有锁，导致其余线程永远获取不到锁</li>
</ul>
</li>
<li>如何使用条件变量？<ul>
<li>核心：线程放弃使用管程时就会自行调用 wait、其余线程唤醒这些等待线程时就会使用 signal</li>
<li>wait 方法会从条件变量中减少一个信号，同时将线程添加到等待队列中</li>
<li>signal 方法会向条件变量发送一个信号，唤醒等待队列中的线程</li>
</ul>
</li>
<li>本质：[条件变量类似于二元信号量 + 指针]{.red}<ul>
<li>[每个条件变量仅能够存储一个信号]{.pink}<ul>
<li>多次调用 signal 方法而不调用 wait 方法会导致信号无法存储而丢失，导致唤醒失去意义</li>
<li>也就是说 wait 方法必须在 signal 方法前使用，毕竟没有等待的线程再怎么唤醒也是没有意义的</li>
</ul>
</li>
<li>[每个条件变量还指向一个等待队列，用于记录当前正在等待的线程]{.pink}</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>[Pascal、C 语言都是不支持管程这种高级同步原语的，Java、C++ 是支持的]{.red}<ul>
<li>Java 管程不同于 OS 定义的经典管程<ul>
<li>[OS 管程默认可以定义包含多个不同的条件变量（定义）]{.pink}</li>
<li>[Java 管程默认仅包含一个条件变量，Java ReentrantLock 管程可以创建多个条件变量（实现）]{.pink}</li>
</ul>
</li>
</ul>
</li>
<li>[进程或者线程不可以直接访问管程中包含的共享变量，只能够借助管程中的函数访问]{.red}</li>
</ul>
</li>
</ul>

        <h2 id="为什么要使用管程？"   >
          <a href="#为什么要使用管程？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么要使用管程？" class="headerlink" title="为什么要使用管程？"></a>为什么要使用管程？</h2>
      <p>:::primary</p>
<p>参考书籍：《操作系统概念》</p>
<p>:::</p>
<ul>
<li><p>核心：[采用信号量实现同步可能存在许多难以避免的问题]{.red}</p>
</li>
<li><p>示例：（采用 C 语言描述）</p>
<ul>
<li><p>[同时执行两次减少信号量的操作显然会导致死锁的发生，这完全可能由程序员自己造成]{.aqua}</p>
  <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">wait(mutex);</span><br><span class="line">	<span class="comment">// 临界区</span></span><br><span class="line">wait(mutex);</span><br></pre></td></tr></table></div></figure></li>
<li><p>[先执行增加信号量的操作，后执行减少信号量的操作，会导致临界区中多于一个活跃线程]{.aqua}</p>
  <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">signal(mutex);</span><br><span class="line">	<span class="comment">// 临界区</span></span><br><span class="line">wait(mutex);</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>
<ul>
<li>总结：<ul>
<li>程序员需要自己确定 wait、signal 操作放置在何处，容易不小心放错位置</li>
<li>管程通常借由编译器保证这些 PV 操作到底添加在何处，比程序员自己添加要安全得多</li>
<li>[<del>Java 采用管程的另一个原因是因为管程比较方便实现（为啥？）</del>]{.grey}</li>
</ul>
</li>
</ul>
<p>​    </p>

        <h2 id="管程如何实现？"   >
          <a href="#管程如何实现？" class="heading-link"><i class="fas fa-link"></i></a><a href="#管程如何实现？" class="headerlink" title="管程如何实现？"></a>管程如何实现？</h2>
      <p>:::info</p>
<p>① 上述内容先简单讲述了 OS 中定义的管程概念，因为管程是一种抽象的概念，所以没有在刚才的内容讲述更加具体的内容</p>
<p>② 接下来就会讲述 Java 如何实现管程这一概念，但是需要优先了解对象是如何组成的</p>
<p>参考笔记：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://47.101.45.234/jvm/runtime/heapspace/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/" >对象是如何组成的？</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<ul>
<li><p>前提：</p>
<ul>
<li>对象头的组成<ul>
<li>Mark Word：包含哈希码、年龄计数器、锁记录等相关信息</li>
<li>类型指针（指向 Klass 对象）</li>
<li>数组长度（只有数组才有的部分）</li>
</ul>
</li>
<li>[阻塞队列：等待当前线程释放锁的线程会进入阻塞队列]{.red}</li>
<li>[等待队列：调用 wait 方法后等待被唤醒的线程进入等待队列]{.red}</li>
</ul>
</li>
<li><p>图解 synchronized 原理</p>
<ul>
<li><p>整体过程</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/管程.3kwq144bgzc0.png" alt="管程" style="zoom:80%;" /></li>
<li><p>线程获取锁：</p>
<ol>
<li>线程判断管程当前是否存在使用者</li>
</ol>
<ul>
<li><p>如果管程当前不存在使用者，那么还要考虑阻塞队列中是否存在等待线程</p>
<ul>
<li><p>[如果不存在等待线程，那么当前线程就可以直接获取管程的使用权]{.pink}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/获取管程的使用权（1）.19slk7btdups.png" alt="获取管程的使用权（1）" style="zoom:80%;" /></li>
<li><p>[如果存在等待线程，线程就需要和阻塞队列中的线程竞争获取对象锁]{.pink}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/获取管程的使用权（2）.1d7ofw1x2cyo.png" alt="获取管程的使用权（2）" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>[如果管程当前存在使用者，那么线程就需要进入阻塞队列等待]{.pink}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/获取管程的使用权（3）.7ffj485ern40.png" alt="获取管程的使用权（3）" style="zoom:80%;" /></li>
</ul>
<ol start="2">
<li><p>[<strong>对象头</strong> 的 Mark Word 的锁记录会从未上锁改为重量级锁状态，同时重量级锁指针指向当前的管程]{.pink}</p>
</li>
<li><p>[<strong>管程</strong> 在线程获取到使用权之后将内部的 Owner 属性设置为当前线程]{.pink}</p>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 虚拟机内部的管程源码</span></span><br><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">//记录个数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL; <span class="comment">// 持有锁的当前线程	</span></span><br><span class="line">    _WaitSet      = NULL; <span class="comment">// 调用 wait 方法后等待被唤醒的线程进入等待队列</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ; <span class="comment">// 等待当前线程释放锁的线程会进入阻塞队列</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

 <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/更新-Mark-Word.5902q4pwfec0.png" alt="更新-Mark-Word" style="zoom:80%;" /></li>
</ol>
</li>
<li><p>线程退出管程（锁）的过程</p>
<ol>
<li>[对象头的 Mark Word 又从重量级锁的状态变为未上锁状态，重量级指针指向空（null）]{.pink}</li>
<li>[管程会将内部的 Owner 属性重新置为空（null），即现在没有线程使用管程]{.pink}</li>
</ol>
</li>
<li><p>线程进入和退出等待队列</p>
<ul>
<li>[线程自行调用 wait 方法放弃管程的使用权，从而进入等待队列中等待被唤醒]{.pink}</li>
<li>[其余线程才可以调用 notify / notifyAll 方法唤醒等待队列中的线程，让等待的线程退出等待队列]{.pink}</li>
</ul>
</li>
</ul>
</li>
<li><p>字节码解释 synchronized 原理</p>
<ul>
<li><p>synchronized 锁对象</p>
<ul>
<li>[编译器会在进入临界区和退出临界区之前添加两条字节码指令：monitorenter、monitorexit]{.aqua}<ul>
<li>这两条指令就实现了管程中始终只存在唯一的活跃线程，实现了线程的互斥</li>
</ul>
</li>
<li>[monitorenter 指令会尝试获取对象锁，如果获取成功就会进入临界区，获取失败就会进入等待队列]{.aqua}</li>
<li>[monitorexit 指令会确保对象锁能够正常被释放，确保其他线程能够获取对象锁]{.aqua}</li>
<li>[额外的 monitorexit：确保临界区中发生异常后依然能够正确释放对象锁]{.pink}</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">   descriptor: ([Ljava/lang/String;)V</span><br><span class="line">   flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field LOCK:Ljava/lang/Object;</span></span><br><span class="line">        <span class="number">3</span>: dup</span><br><span class="line">        <span class="number">4</span>: astore_1</span><br><span class="line">        <span class="number">5</span>: monitorenter	 <span class="comment">// 编译器在字节码文件中插入 monitor 原语确保实现同步						</span></span><br><span class="line">        <span class="number">6</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// 临界区：操作共享变量</span></span><br><span class="line">        <span class="number">9</span>: iconst_1</span><br><span class="line">       <span class="number">10</span>: iadd</span><br><span class="line">       <span class="number">11</span>: putstatic     #<span class="number">3</span>                  </span><br><span class="line">       <span class="number">14</span>: aload_1                           <span class="comment">// 临界区</span></span><br><span class="line">       <span class="number">15</span>: monitorexit     <span class="comment">// 编译器在字节码问题进中插入 monitor 原语确保退出同步块</span></span><br><span class="line">       <span class="number">16</span>: goto          <span class="number">24</span></span><br><span class="line">       <span class="number">19</span>: astore_2</span><br><span class="line">       <span class="number">20</span>: aload_1</span><br><span class="line">       <span class="number">21</span>: monitorexit     <span class="comment">// 编译器确保代码抛出异常时依然能够释放锁的使用权, 从而确保不会死锁</span></span><br><span class="line">       <span class="number">22</span>: aload_2</span><br><span class="line">       <span class="number">23</span>: athrow</span><br><span class="line">       <span class="number">24</span>: <span class="keyword">return</span></span><br><span class="line">		</span><br></pre></td></tr></table></div></figure></li>
<li><p>synchronized 锁方法</p>
<ul>
<li>[方法锁不再添加字节码来确保线程间的互斥而是通过设置访问权限让虚拟机意识到需要进行同步]{.aqua}</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>;</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   <span class="comment">// 锁方法就不会再字节码文件中添加字节码指令来确保同步而是设置访问权限</span></span><br><span class="line">   <span class="comment">// 设置 ACC_SYNCHRONIZED 同步的权限</span></span><br><span class="line">   flags: (<span class="number">0x0029</span>) ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field count:I</span></span><br><span class="line">        <span class="number">3</span>: iconst_1</span><br><span class="line">        <span class="number">4</span>: iadd</span><br><span class="line">        <span class="number">5</span>: putstatic     #<span class="number">2</span>                  <span class="comment">// Field count:I</span></span><br><span class="line">        <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">       line <span class="number">13</span>: <span class="number">8</span></span><br><span class="line">		</span><br></pre></td></tr></table></div></figure>

</li>
</ul>
</li>
</ul>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://example.com">Fuyusakaiori</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://example.com/2021/10/28/juc/juc-concurrent/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-synchronized-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">http://example.com/2021/10/28/juc/juc-concurrent/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-synchronized-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-ND</a> 许可协议。转载请注明出处！</span></div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2021/10/28/juc/juc-concurrent/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-synchronized-%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">线程同步-synchronized-优化策略</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2021/10/28/juc/juc-concurrent/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-synchronized-%E5%9F%BA%E7%A1%80/"><span class="paginator-prev__text">线程同步-synchronized-基础</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Synchronized-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">
          Synchronized-底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%A1%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">
          什么是管程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%AE%A1%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">
          为什么要使用管程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">
          管程如何实现？</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/随机图库/1641882498931.3kditdl6ds40.webp" alt="avatar"></div><p class="sidebar-ov-author__text">什么都不会的废物</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/fuyusakaiori" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://weibo.com/Sakiless/home?topnav=1&amp;wvr=6" target="_blank" rel="noopener" data-popover="微博" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weibo"></i></span></a><a class="sidebar-ov-social-item" href="670232228" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">106</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">32</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-nd.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020~2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>小忍的甜甜圈</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1.0.1/dist/canvas-nest.min.js" color="0,0,0" opacity="0.6" count="99" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>