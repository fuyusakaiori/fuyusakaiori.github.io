<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="方法区"><meta name="keywords" content=""><meta name="author" content="Fuyusakaiori"><meta name="copyright" content="Fuyusakaiori"><title>方法区 | 天鹅绒房间</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"37DAS9P43B","apiKey":"c2a5f8cdb503b255bb4384b147d4ab84","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">1.</span> <span class="toc-text">方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E4%BF%A1%E6%81%AF"><span class="toc-number">1.1.1.</span> <span class="toc-text">存储信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text">方法区大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="toc-number">1.1.3.</span> <span class="toc-text">方法区溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.1.4.</span> <span class="toc-text">垃圾回收</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.2.</span> <span class="toc-text">运行时常量池</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i1.xpic.jp/file/xpicjp/2022/01/21/2070676bca90a832cba0ff3e76a701b1.png"></div><div class="author-info__name text-center">Fuyusakaiori</div><div class="author-info__description text-center">啥也不会的大三狗</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/fuyusakaiori">いらしゃい</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">111</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">33</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/随机图库/1643042375499.2rf317jrwiw0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">天鹅绒房间</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/Home">主页 | Home</a><a class="site-page" href="/archives">归档 | Archives</a><a class="site-page" href="/categories">分类 | Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">方法区</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-09-21</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/">Java 虚拟机</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/">运行时数据区</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/%E6%96%B9%E6%B3%95%E5%8C%BA/">方法区</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">3.7k</span><span class="post-meta__separator">|</span><span>Reading time: 11 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>定义：虚拟机中独立于堆空间的较大存储空间</p>
</li>
<li><p>作用：[存放所有和 <strong>类相关的信息</strong> ]{.red}</p>
</li>
<li><p>实现方式：</p>
<ul>
<li>永久代（PermSpace）：[方法区使用的虚拟机的内存]{.red}</li>
<li>元空间（MetaSpace）：[方法区直接使用操作系统提供的物理内存]{.red}</li>
</ul>
<p>  +++danger 为什么要采用元空间实现方法区而不是永久代呢？</p>
<p>  ① 官方文档中的解释非常模糊：因为被收购的 JRockit 采用的元空间实现方法区，所以整合 HotSpot 和 JRockit 虚拟机时也采用元空间实现</p>
<p>  ② 实际的原因应该是这样的：</p>
<p>  永久代使用的是虚拟机内存，操作系统分配给虚拟机内存是非常有限的，只要方法区加载过多的类，就非常容易造成 OutOfMemoryError 异常</p>
<p>  元空间直接使用操作系统的内存，只要加载的类的数量不超过操作系统的内存大小就行，显然没有那么容易出现 OutOfMemoryError 异常</p>
<p>  +++</p>
</li>
<li><p>历史：</p>
<ul>
<li><p>[JDK 6：方法区采用永久代实现，静态变量和字符串常量池都存放在方法区中]{.blue}</p>
</li>
<li><p>[JDK 7：方法区依旧采用永久代实现，静态变量和字符串常量池移动到堆空间中]{.blue}</p>
</li>
<li><p>[JDK 8：方法区改用元空间实现，静态变量和字符串常量池依旧存放在堆空间中]{.blue}</p>
<p>  :::info</p>
<p>  注：从 JDK 7 开始就打算逐渐采用元空间替代永久代了</p>
<p>  :::</p>
</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>方法区和堆区都不需要连续的内存空间，都可以采用固定容量或者动态扩展</li>
<li>[方法区是线程共享区域]{.red}</li>
<li>[方法区 <strong>存在垃圾回收机制</strong>，也存在 OutOfMemoryError 异常]{.red}</li>
<li>[方法区有两种具体的实现方式：永久代和元空间]{.red}</li>
</ul>
</li>
</ul>
<h3 id="存储信息"><a href="#存储信息" class="headerlink" title="存储信息"></a>存储信息</h3><blockquote>
<p><strong>方法区中存储的类型信息是从哪里获得的?</strong></p>
</blockquote>
<ul>
<li>过程：<ul>
<li>前端编译器将源代码编译成字节码文件</li>
<li>虚拟机利用 IO 流读取字节码文件</li>
<li>虚拟机利用 [字节码文件和运行时信息]{.blue} 构建 Klass 对象存储类型信息</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>方法区中的存储的是什么?</strong></p>
</blockquote>
<p>:::warning</p>
<p>如果不了解 <a href="">OOP-Klass</a> 模型的读者，请先了解后再继续阅读</p>
<p>:::</p>
<ul>
<li><p>核心：[Klass 对象]{.red}</p>
<ul>
<li><p>每个 Klass 对象包含了 [类相关的字节码信息和运行时的信息]{.blue}</p>
</li>
<li><p>字节码文件存储的信息仅是方法区中信息的一部分</p>
<p>  其余信息必须等到类被加载到虚拟机中之后才能够得到（诸如类加载器信息，虚方法表）</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>每个 Klass 对象又包含什么信息呢?</strong></p>
</blockquote>
<ul>
<li>图示</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/JDK-6-方法区.669ebsb2dx00.png" alt="JDK-6-方法区" style="zoom:80%;" />

<ul>
<li><p>类相关信息</p>
<ul>
<li><p>类型信息：</p>
<ul>
<li>类的全限定名：包名 + 类名（java.lang.Object）</li>
<li>类的修饰符：访问权限、是否静态（static）、是否可变（final）</li>
<li>继承的父类：父类的名称也必须使用全限定名</li>
<li>实现的所有接口：接口的名称也必须是全限定名</li>
</ul>
</li>
<li><p>字段信息：字段的名称 + 字段的类型 + 字段的修饰符</p>
</li>
<li><p>静态变量：静态变量的名称 + 静态变量的类型 + 静态变量的访问权限</p>
<ul>
<li><p>[静态变量在没有对象的情况下依旧可以访问]{.green}</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodComponent</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String string = <span class="string">&quot;初始值&quot;</span>;</span><br><span class="line">    <span class="comment">// 测试静态变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 即使对象为 null 依旧是可以访问静态变量的</span></span><br><span class="line">        MethodComponent methodComponent = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(methodComponent.string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>[如果静态变量是引用类型的话，引用存放在方法区中，对象存放在堆区中]{.blue}</p>
</li>
</ul>
</li>
<li><p>方法信息：方法签名 + 方法返回值 + 方法访问权限 + 方法参数 + 局部变量表 + 操作数栈大小 + 异常信息表</p>
</li>
<li><p>[方法表]{.red}</p>
<ul>
<li>[虚方法表：存放该类自身的和继承的所有虚方法以实现方法分派]{.blue}</li>
<li>[接口方法表：存放该类实现的所有接口提供的方法以实现方法分派]{.blue}</li>
<li>[生成时间：方法表在类加载阶段被初始化（连接阶段）]{.blue}</li>
</ul>
</li>
<li><p>[类加载器]{.red}</p>
<ul>
<li>定义：记录当前类是被哪个类加载器加载进入虚拟机的</li>
<li>生成时间：[类加载器的相关信息也是在类加载阶段被初始化的（加载阶段）]{.blue}</li>
</ul>
</li>
<li><p>[Class 对象的引用]{.red}</p>
<ul>
<li><p>定义：保留对 Class 对象的引用确保反射能够找到 Class 对象</p>
<p>  [对象中保存是的类元数据（Klass 对象）的指针，只有类元数据中记录 Class 对象的引用，反射才能够找到 Class对象]{.blue}</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0">运行时常量池</a>：字面量（字符串常量池、其余常量）、符号引用 </p>
<ul>
<li>[每个 Klass 对象都拥有一个运行时常量池，也就意味每个类都拥有独立的运行时常量池]{.red}</li>
<li>[非字符串类型的常量的值会在编译期间就写入字节码文件中，所以认为常量在编译期间就被赋值]{.red}</li>
</ul>
</li>
<li><p>即时编译生成的代码缓存</p>
</li>
</ul>
<blockquote>
<p><strong>上述提到的信息真的都存放在方法区中吗?</strong></p>
</blockquote>
<ul>
<li><p>JDK 6 版本之前方法区确实按照这些信息进行存放</p>
</li>
<li><p>JDK 7 版本将 [静态变量、字符串常量池全部移动到堆空间中]{.red}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/JDK-7-方法区.4iqixiimvnc0.png" alt="JDK-7-方法区" style="zoom:80%;" /></li>
<li><p>JDK 8 版本没有变动静态变量、字符串常量池的位置，[只是改用元空间实现]{.red}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/JDK-8-方法区.5ajphdnv5uo0.png" alt="JDK-8-方法区" style="zoom:80%;" /></li>
</ul>
<p>+++danger 为什么要将字符串常量池移动到堆区中呢？</p>
<p>+++</p>
<h3 id="方法区大小"><a href="#方法区大小" class="headerlink" title="方法区大小"></a>方法区大小</h3><ul>
<li>采用永久代实现的方法区<ul>
<li>方法区初始大小：20.75 MB</li>
<li>方法区最大容量：32位虚拟机最大容量为 64MB，64位虚拟机最大容量为 82MB</li>
<li>设置方法区大小的命令：<ul>
<li>[XX:PermSize=size 更改方法区的初始大小值]{.blue}</li>
<li>[XX:MaxPermSize=size 更改方法区的最大容量]{.blue}</li>
</ul>
</li>
<li>细节：<ul>
<li>[方法区的设置的最大容量不可以超过虚拟机的最大内存]{.red}</li>
<li>方法区存放的类信息的大小超过了方法区的最大容量，就会抛出 OutOfMemoryError 异常</li>
</ul>
</li>
</ul>
</li>
<li>采用元空间实现的方法区<ul>
<li>元空间初始大小：21 MB（[取决于不同的操作系统]{.red}）</li>
<li>元空间最大容量：[默认没有上限值，取决于操作系统提供的物理内存大小]{.red}</li>
<li>设置方法区大小的命令<ul>
<li>[XX:MetaspaceSize=size 更改方法区的初始大小值]{.blue}</li>
<li>[XX:MaxMetaspaceSize=size 更改方法区的最大容量]{.blue}</li>
</ul>
</li>
<li>细节：[每次方法区触发垃圾回收机制时，都会根据释放的空间大小来动态地改变方法区的大小]{.red}<ul>
<li>[如果垃圾回收释放的空间较少，那么方法区的容量将会提升]{.blue}</li>
<li>[如果垃圾回收释放的空间较多，那么方法区的容量就会相应减少]{.blue}</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h3><ul>
<li><p>原因：内存泄露或者内存溢出</p>
</li>
<li><p>内存泄露：[不再使用的类或者被废弃的常量没有得到回收]{.red}</p>
</li>
<li><p>内存溢出</p>
<ul>
<li><p>情况：① 加载大量的类（Jar 包）② 服务器（Tomcat）部署工程过多 ③ 反射/动态代理生成太多的类</p>
</li>
<li><p>测试：</p>
<ul>
<li><p>[加载的类的数量过多造成的溢出]{.red}</p>
<ul>
<li><p>自定义类加载器加载大量类</p>
<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 虚拟机参数：</span></span><br><span class="line"><span class="comment">// JDK 7：-XX:PermSize=10m -XX:MaxPermSize=10m</span></span><br><span class="line"><span class="comment">// JDK 8：-XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m</span></span><br><span class="line"><span class="comment">// 关闭指针压缩：-XX:-UseCompressedClassPointers</span></span><br><span class="line"><span class="comment">// 该类继承类加载器：所以该类自身就是个类加载器了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodArea</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 加载大量类使得方法区溢出</span></span><br><span class="line">        MethodArea methodArea = <span class="keyword">new</span> MethodArea();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ClassWriter classWriter = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 获取 Object 的字节码文件</span></span><br><span class="line">            classWriter.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="keyword">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 将 Object 的字节码文件转换成字节数组保存</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = classWriter.toByteArray();</span><br><span class="line">            <span class="comment">// 将字节数组转换成 Class 对象, 方法区中会生成对应的 Klass 对象</span></span><br><span class="line">            methodArea.defineClass(<span class="string">&quot;Class&quot;</span>+i, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">            <span class="comment">// Klass 对象数量过多导致方法区溢出, Class 对象是存放在堆区中的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<p>JDK 8 版本：如果不关闭指针压缩，抛出的异常就是 Compressed class space，指针压缩都没有办法省出空间了</p>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/元空间溢出.srnryv3fg1c.png" alt="元空间溢出" style="zoom:80%;" />

<p>JDK 7 版本：① 需要更换运行环境 ② 不需要手动关闭压缩指针 ③ 记得更换虚拟机命令 ④ ClassWriter 类需要重新导入（所属包不一样）</p>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/永久代溢出.jrbirrpd1dc.png" alt="永久代溢出" style="zoom:80%;" /></li>
<li><p>反射/动态代理加载的类过多</p>
<p>测试代码：可以了解下代理模式（动态代理 + 静态代理）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodArea</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 测试生成的代理类数量</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 动态代理</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">            enhancer.setCallback(</span><br><span class="line">                    (MethodInterceptor) (o, method, objects, methodProxy)</span><br><span class="line">                                                -&gt; methodProxy.invokeSuper(o, objects));</span><br><span class="line">            enhancer.create();</span><br><span class="line">            System.out.println(++count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/动态生成溢出.2y4bjza6lj00.png" alt="动态生成溢出" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
</li>
<li><p>[运行时常量池造成的溢出]{.blue}</p>
<p>:::warning</p>
<p>运行时常量池造成的溢出仅会在 JDK 6 之前的版本出现</p>
<p>:::</p>
</li>
</ul>
</li>
</ul>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><blockquote>
<p><strong>方法区进行垃圾回收的前提</strong></p>
</blockquote>
<ul>
<li>前提：[虚拟机规范中没有明确规定方法区必须实现垃圾回收机制]{.green}<ul>
<li>大多数的垃圾回收器都支持对方法区进行垃圾回收</li>
<li>部分垃圾回收器（[如 ZGC 垃圾回收器]{.red}）不支持方法区的垃圾回收</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>为什么最好支持对方法区进行垃圾回收呢?</strong></p>
</blockquote>
<ul>
<li>核心：[避免对方法区造成过大的内存压力从而导致的内存泄露或者内存溢出]{.red}<ul>
<li>许多采用反射和动态代理的框架，以及频繁自定义类加载器框架中会使得大量类被加载进入虚拟机<ul>
<li>采用反射和动态代理的框架：Spring、Mybatis</li>
<li>频繁自定义类加载器的框架：Tomcat、OSGi</li>
</ul>
</li>
<li>大量的类被加载进入虚拟机而无法被卸载的话就容易造成 OutOfMemoryError 异常</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>方法区垃圾回收的对象以及条件</strong></p>
</blockquote>
<ul>
<li>回收对象：[常量池中废弃的各种类型的常量和不再使用的类]{.red}</li>
<li>回收条件<ul>
<li>常量回收条件：[常量不再被任何地方引用]{.red}</li>
<li>类回收条件：<ul>
<li>[该类所有的实例及其派生子类的实例全部都被回收完成]{.red}</li>
<li>[加载该类的类加载器已经被回收（非常难以达成）]{.red}</li>
<li>[该类对应的 Class 对象已经被回收，无法再使用反射获取类信息]{.red}</li>
</ul>
</li>
<li>细节：<ul>
<li>[没有被引用的常量可以立刻被回收]{.red}</li>
<li>[满足回收条件的类仅仅只是允许被回收，具体是否回收取决于虚拟机自身]{.red}</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><blockquote>
<p><strong>什么是运行时常量池?</strong></p>
</blockquote>
<ul>
<li>定义：存放编译期生成的各种字面量和符号引用的池子<ul>
<li>字节码文件将所有常量存放在 [常量池]{.red} 中</li>
<li>字节码文件被加载进入虚拟机后，虚拟机将常量池单独提取出来成为运行时常量池</li>
</ul>
</li>
<li>特点：[具有动态性：可以在进程运行期间将常量添加进入运行时常量池（String.intern()）]{.red}</li>
</ul>
<blockquote>
<p><strong>运行时常量池存放哪些常量呢?</strong></p>
</blockquote>
<ul>
<li><p>字面量</p>
<ul>
<li><p>基本数据类型声明的变量</p>
</li>
<li><p>[采用非创建对象的方式声明的字符串]{.red}</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本数据类型常量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> first = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> second = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> third = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">short</span> fourth = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 字符串字面量: 字符串本身就是常量</span></span><br><span class="line"><span class="keyword">private</span> String str = <span class="string">&quot;初始值&quot;</span>;</span><br><span class="line"><span class="comment">// 采用对象的创建方式, 字符串就不是字面量了</span></span><br><span class="line"><span class="keyword">private</span> String strObj = <span class="keyword">new</span> String(<span class="string">&quot;另一个初始值&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>符号引用 &amp; 直接引用</p>
<ul>
<li><p>符号引用：</p>
<ul>
<li><p>定义：[表示类型信息和名称的 <strong>字符串</strong>]{.red}</p>
</li>
<li><p>表示内容：</p>
<ul>
<li>类和接口的全限定名称</li>
<li>字段的名称和类型</li>
<li>方法的名称和类型</li>
</ul>
</li>
<li><p>实例测试</p>
<p>  测试代码</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SymbolReferrence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        methodB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  字节码（methodA 方法）</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> aload_0</span><br><span class="line"><span class="comment">// #2 是符号引用所在的索引，在常量池中找到对应的符号引用</span></span><br><span class="line"><span class="number">1</span> invokevirtual #<span class="number">2</span> </span><br><span class="line"><span class="number">4</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>  常量池（省略了每条索引之后的注释）</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 根据字节码指令提供的索引，在常量池中找到对应的符号引用</span></span><br><span class="line">#<span class="number">2</span> = Methodref          #<span class="number">3.</span>#<span class="number">21</span></span><br><span class="line"><span class="comment">// 2. 该符号引用告诉我们去找另外两个索引 #3 #21</span></span><br><span class="line">#<span class="number">3</span> = Class              #<span class="number">22</span></span><br><span class="line">#<span class="number">21</span> = NameAndType       #<span class="number">13</span>:#<span class="number">6</span></span><br><span class="line"><span class="comment">// 3. 上面两个符号索引告诉我们接着找其他的索引</span></span><br><span class="line"><span class="comment">// 4. #22 被解析出来了，对应的就是方法所在的类的名字</span></span><br><span class="line">#<span class="number">22</span> = Utf8               chapter09/SymbolReferrence</span><br><span class="line"><span class="comment">// 5 #13 #6 也被相应的解析出来了，方法的返回值和名称    </span></span><br><span class="line">#<span class="number">6</span> = Utf8               ()V</span><br><span class="line">#<span class="number">13</span> = Utf8               methodB</span><br></pre></td></tr></table></figure>

<p>  完整流程</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/符号引用.4di2d7wlqb60.png" alt="符号引用" style="zoom:80%;" />

<p>  <strong>总结：符号引用就是用来表示类、方法、字段、接口的相关信息的字符串</strong></p>
</li>
<li><p>细节</p>
<ul>
<li>虚拟机是无法直接利用符号引用找到类或者方法在内存中的具体的位置，必须解析成直接引用</li>
<li>[符号引用可以在两个阶段被解析：类加载的解析阶段，方法执行时的动态链接阶段]{.red}</li>
</ul>
</li>
</ul>
</li>
<li><p>直接引用：</p>
<ul>
<li>定义：[类、方法、字段、接口在虚拟机内存中的实际地址]{.red}</li>
<li>细节：<ul>
<li>符号引用解析成的直接引用会直接替换原有的符号引用，存在方法区中</li>
<li>虚拟机能够直接使用的地址，用于访问类、方法、字段、接口的相关信息</li>
</ul>
</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/解析过程.4qqc3n55wjg0.png" alt="解析过程" style="zoom:80%;" /></li>
</ul>
<p>  :::primary</p>
<p>  参考：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/30300585/answer/51335493">JVM里的符号引用如何存储？</a></p>
<p>  :::</p>
</li>
</ul>
<blockquote>
<p><strong>为什么需要运行时常量池呢?</strong></p>
</blockquote>
<ul>
<li>核心：[避免字节码膨胀：减小字节码文件的大小]{.red}</li>
<li>原因：<ul>
<li>如果每个类在被编译的时候都把自己继承的类和实现的接口的详细信息都写入字节码</li>
<li>那么显然就会导致 [字节码的容量非常大]{.red}，因为继承的类和实现的接口也有自己相应的继承实现关系</li>
<li>为了避免这个问题字节码膨胀，显然将用符号引用来代替表示继承的类和实现的接口是非常合适的，不需要记录详细信息</li>
<li>那么既然使用了符号引用，显然需要一块空间来存储符号引用，所以采用运行时常量池来存储符号引用</li>
</ul>
</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Fuyusakaiori</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/09/21/jvm/runtime/methodarea/方法区/">http://example.com/2021/09/21/jvm/runtime/methodarea/方法区/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/09/21/jvm/runtime/methodarea/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/"><i class="fa fa-chevron-left">  </i><span>字符串常量池</span></a></div><div class="next-post pull-right"><a href="/2021/09/20/jvm/runtime/heapspace/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/"><span>堆空间-直接内存</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/随机图库/1643042375499.2rf317jrwiw0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2022 By Fuyusakaiori</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">wind glass bluebird</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>