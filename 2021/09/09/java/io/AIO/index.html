<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="AIO"><meta name="keywords" content=""><meta name="author" content="Fuyusakaiori"><meta name="copyright" content="Fuyusakaiori"><title>AIO | 天鹅绒房间</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"37DAS9P43B","apiKey":"c2a5f8cdb503b255bb4384b147d4ab84","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#AIO"><span class="toc-number">1.</span> <span class="toc-text">AIO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">核心类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%EF%BC%9A%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4"><span class="toc-number">1.3.</span> <span class="toc-text">实战：多人聊天室</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i1.xpic.jp/file/xpicjp/2022/01/21/2070676bca90a832cba0ff3e76a701b1.png"></div><div class="author-info__name text-center">Fuyusakaiori</div><div class="author-info__description text-center">啥也不会的大三狗</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/fuyusakaiori">いらしゃい</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">115</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">17</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">35</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/随机图库/1643042375499.2rf317jrwiw0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">天鹅绒房间</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/home">主页 | Home</a><a class="site-page" href="/archives">归档 | Archives</a><a class="site-page" href="/categories">分类 | Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">AIO</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-09-09</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/IO/">IO</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">4.4k</span><span class="post-meta__separator">|</span><span>Reading time: 17 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p><strong>什么是 AIO？</strong></p>
</blockquote>
<ul>
<li><p>历史：JDK 1.7 推出真正的 [异步非阻塞式的调用（AIO）]{.red}</p>
</li>
<li><p>名称：</p>
<ul>
<li><p>AIO 全称为 Asynchronous IO </p>
</li>
<li><p>AIO 实际上并不是官方定义的名称，而是根据新增加的核心类命名的，通常也可以称为 NIO2</p>
<blockquote>
<p>AIO 所有的核心类仍然是属于 java.nio 包下的，本质上是对 NIO 架构的完善</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>什么是异步非阻塞式调用？</strong></p>
</blockquote>
<p>:::info</p>
<p>此前的 IO 概述中已经提到过了，这里再简单的描述下</p>
<p>:::</p>
<ul>
<li><p>异步非阻塞式调用</p>
<ul>
<li><p>定义：</p>
<ul>
<li><p>进程向操作系统注册，[编写回调函数后将 IO 操作完全交付给操作系统实现]{.blue}，进程继续执行自己其他的任务</p>
<blockquote>
<p>回调函数：名字听起来很高端，实际就是进程告诉操作系统在 IO 事件发生后该如何处理，毕竟进程自己不再管了</p>
</blockquote>
</li>
<li><p>操作系统在 IO 事件发生后，选择 [线程池中的某个线程执行进程提供的回调函数]{.blue} 处理发生的 IO 事件</p>
</li>
<li><p>回调函数处理 IO 事件完成后，向进程发出信号通知 IO 事件已经完成，[进程不需要再使用任何系统调用来完成 IO 事件]{.blue}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/AIO.i95xm33f7co.png" alt="AIO" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>区别：</p>
<ul>
<li>不同于同步非阻塞式中的 [Selector 采用轮询机制处理事件]{.red}，异步非阻塞式采用 [订阅-通知]{.red} 模式</li>
<li>[无论是 NIO 的哪个版本最终都需要进程自己调用方法处理事件，AIO 则是将编写好的方法完全交给操作系统去执行，自己则不再关心]{.blue}</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>为什么要使用 AIO？</strong></p>
</blockquote>
<ul>
<li><p>异步非阻塞式 IO 是多路复用式 IO 的一种 [替代方案]{.blue}</p>
<p>  +++ 两种方案并没有本质上的优劣之分，实际开发就是 NIO + AIO 两者的结合</p>
<ul>
<li><p>[NIO 是 Java 自己实现的方法，所以在不同的操作系统都是没有区别的]{.red}</p>
</li>
<li><p>[AIO 是涉及到操作系统的实现，所以在不同的操作系统下效率可能是不同的]{.red}</p>
<blockquote>
<p>Windows 平台采用 IOCP 技术真正实现异步操作，Linux 平台仅能够利用 epoll 模拟异步操作</p>
</blockquote>
</li>
</ul>
<p>  +++</p>
</li>
</ul>
<h2 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2><blockquote>
<p><strong>AIO 的核心类有哪些？</strong></p>
</blockquote>
<ul>
<li>[AsynchronousSocketChannel]{.red}</li>
<li>[AsynchronousServerSocketChannel]{.red}</li>
<li>AsynchronousFileChannel：文件操作并不常用，所以不会编写案例</li>
<li>[AsynchronousChannelGroup]{.blue}</li>
<li>[CompletionHandler&lt;V,A&gt;]{.red}</li>
<li>Future&lt;V.&gt;：[Future 类并不是 NIO 包下的类，而是 JUC 包中提供的类]{.green}</li>
</ul>
<blockquote>
<p><strong>AIO 核心类如何使用？</strong></p>
</blockquote>
<ul>
<li>概述中提到了 AIO 本质是对 NIO 的完善，所以新增的核心类在使用方法上和 NIO 没有太大的区别</li>
<li>主要区别在于新增的 CompletionHandler 类，该类是用于编写回调函数处理 IO 事件的，其余类没有太大区别</li>
</ul>
<blockquote>
<p><strong>AsynchronousServerSocketChannel：创建服务器端</strong></p>
</blockquote>
<ul>
<li><p>[创建线程池（推荐使用）]{.red}</p>
<ul>
<li><p>问题：IO 事件发生时，进程在执行其他的任务，显然主线程是肯定不可能执行回调函数了，那么操作系统应该如何执行回调函数呢？</p>
</li>
<li><p>解决方式：[操作系统调用线程池中存在的线程去执行回调函数]{.red}</p>
<blockquote>
<p>操作系统调用 AsynchronousChannelGroup 中的线程池，线程在 IO 事件发生时执行回调函数</p>
</blockquote>
</li>
<li><p>创建方式：</p>
<ul>
<li>利用工具类 Excutors 创建线程池：[newFixedThreadPool、newCachedThreadPool、newScheduledThreadPool、newSingleThreadExecutor]{.blue}</li>
<li>利用类 ThreadPoolExecutor 创建自定义线程池：[阿里开发手册推荐使用的方式]{.red}</li>
</ul>
</li>
</ul>
</li>
<li><p>创建服务器端：[bind]{.blue} 方法绑定端口号</p>
</li>
<li><p>服务器端接收客户端请求：调用 [accept]{.blue} 方法接收请求 </p>
</li>
<li><p>使用循环和阻塞函数：</p>
<ul>
<li><p>问题一：[accept]{.blue} 方法是异步非阻塞式的，也就意味着服务器端在执行完这个方法之后，会立刻执行之后的代码，如果没有，那么服务器就会直接结束，这显然是不合理的，因为客户端都还没有连接上，服务器就结束了，那么应该怎么解决？</p>
</li>
<li><p>解决方式：[while(true)]{.blue} 循环显然可以避免这个问题</p>
</li>
<li><p>问题二：[while(true)]{.blue} 循环会导致服务器不停的空转，也就是此前轮询模型的问题，这也是我们不想看到的，那么应该怎么解决？</p>
</li>
<li><p>解决方式：此前的 [多路复用模型]{.red} 的解决方式就是使用 [select]{.blue} 阻塞方法来避免这个问题，那么我们也可以采用阻塞方法来解决</p>
<blockquote>
<p>此前学习过程中使用的方法是 System.in.read，虽然确实能够达到效果，但是感觉不是最终的解决方案</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务器端主方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建自定义线程池</span></span><br><span class="line">        ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>,<span class="comment">// 核心线程数量</span></span><br><span class="line">            <span class="number">3</span>,<span class="comment">// 最大线程数量</span></span><br><span class="line">            <span class="number">5</span>,<span class="comment">// 空闲线程的存活时间</span></span><br><span class="line">            TimeUnit.SECONDS,<span class="comment">// 存活时间单位</span></span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(),<span class="comment">// 阻塞队列：超过最大线程时还能够容纳的客户端</span></span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()<span class="comment">// 拒绝策略：超过阻塞队列容量后的处理方式</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 创建 AsynchronousChannelGroup</span></span><br><span class="line">        AsynchronousChannelGroup acg = AsynchronousChannelGroup.withThreadPool(threadPool);</span><br><span class="line">        <span class="comment">// 创建服务器端实例（assc 是我定义的成员变量）：如果没有传入 AsynchronousChannelGroup，则会使用默认的</span></span><br><span class="line">        assc = AsynchronousServerSocketChannel.open(acg);</span><br><span class="line">        <span class="comment">// 服务器端绑定端口号</span></span><br><span class="line">        assc.bind(<span class="keyword">new</span> InetSocketAddress(DEFAULT_PORT));</span><br><span class="line">        System.out.printf(<span class="string">&quot;服务器[%d]:%s\n&quot;</span>, DEFAULT_PORT, <span class="string">&quot;启动成功&quot;</span>);</span><br><span class="line">        <span class="comment">// accept 方法参数介绍</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 第一个参数是 Attachment：(1) 可以传入任意的类型 (2) 用于辅助回调函数处理 IO 事件的</span></span><br><span class="line">            <span class="comment">// 诸如缓冲区等辅助信息都是可以传入的</span></span><br><span class="line">            <span class="comment">// 第二个参数是 CompletionHandler（回调函数）：用于处理 IO 事件的类</span></span><br><span class="line">            <span class="comment">// 这里有两种写法：(1) 直接使用匿名内部类的写法（不推荐）(2) 编写实现 CompletionHandler 接口的内部类</span></span><br><span class="line">            <span class="comment">// 不推荐第一种写法的原因是会导致代码看起来非常乱，虽然简洁，读者可以自己试试编写一下</span></span><br><span class="line">            assc.accept(<span class="keyword">null</span>, <span class="keyword">new</span> AcceptHandler());</span><br><span class="line">            assc.accept(<span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;()&#123;</span><br><span class="line">                <span class="comment">// 回调函数</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 阻塞服务器：防止服务器空转</span></span><br><span class="line">            System.in.read();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>CompletionHandler&lt;V,A&gt;：编写回调函数处理 IO 事件</strong></p>
</blockquote>
<ul>
<li><p>前提：服务器创建完成后，显然需要向操作系统交代 IO 事件如何处理，即回调函数的编写</p>
</li>
<li><p>[处理客户端连接请求的回调函数]{.red}</p>
<ul>
<li><p>实现 [CompletionHandler]{.blue} 接口，传入两个类型</p>
<blockquote>
<p>第一个类型只能够是 AsynchronousSocketChannel、第二个类型根据自己的 Attachment而定，不过通常都是 Object</p>
</blockquote>
</li>
<li><p>重写 [completed]{.blue} 和 [failed]{.blue} 方法</p>
<blockquote>
<p>completed 方法在正确接收到客户端请求后触发，failed 方法在客户端异常断开后触发</p>
</blockquote>
</li>
</ul>
</li>
<li><p>[处理读取客户端发送的数据和向客户端写入数据的回调函数]{.red}</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部类: 用于处理客户端发出的连接请求</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptHandler</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">AsynchronousSocketChannel</span>, <span class="title">Object</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 第一个参数是客户端，第二个参数是附件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel asc, Object attachment)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 注：对客户端进行操作前需要确保客户端是仍然是正常连接的</span></span><br><span class="line">        <span class="keyword">if</span> (asc != <span class="keyword">null</span> &amp;&amp; asc.isOpen())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 打印客户端信息：getRemoteAddress 可以得到客户端的进程号</span></span><br><span class="line">            <span class="comment">// 注：getRemoteAddress 是会抛出异常的，这里我省略掉了，节省篇幅</span></span><br><span class="line">            System.out.println(<span class="string">&quot;客户端&quot;</span> + asc.getRemoteAddress() + <span class="string">&quot;:连接成功&quot;</span>);</span><br><span class="line">            <span class="comment">// 对客户端执行操作</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            Map&lt;String, Object&gt; info = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="comment">// 回调函数不仅要处理写还要处理，所以提供辅助信息用以判断</span></span><br><span class="line">            info.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="comment">// 读取数据需要从缓冲区中读取，所以也应该作为辅助信息传入</span></span><br><span class="line">            info.put(<span class="string">&quot;buffer&quot;</span>, buffer);</span><br><span class="line">            <span class="comment">// 读取客户端的发送的数据： read 方法也是异步非阻塞式的方法，所以也需要相应的回调函数进行处理</span></span><br><span class="line">            asc.read(buffer, info, <span class="keyword">new</span> ReadAndWriteHandler(asc));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务器必须再次向操作系统注册，才能够继续连接客户端，否则服务器端就不会继续连接客户端了</span></span><br><span class="line">        <span class="keyword">if</span> (assc.isOpen())</span><br><span class="line">        &#123;</span><br><span class="line">            assc.accept(<span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出现异常执行的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部类: 用于处理读取客户端的数据的请求和向客户端写入数据的请求</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadAndWriteHandler</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>, <span class="title">Object</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 记录当前处理的客户端</span></span><br><span class="line">    <span class="keyword">private</span> AsynchronousSocketChannel asc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadAndWriteHandler</span><span class="params">(AsynchronousSocketChannel asc)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.asc = asc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个参数是每次读取或者写入的字节数量，第二个参数依然是附件信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, Object attachment)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 强制转换获取辅助信息</span></span><br><span class="line">        Map&lt;String, Object&gt; info = (Map&lt;String, Object&gt;) attachment;</span><br><span class="line">        <span class="comment">// 获取缓冲区</span></span><br><span class="line">        ByteBuffer buffer = (ByteBuffer) info.get(<span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取当前处理的是读取还是写入</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;read&quot;</span>.equals(info.get(<span class="string">&quot;type&quot;</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 读取客户端发送的数据并且显示在服务器端</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            String msg = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">            <span class="comment">// 依然省略捕获异常的过程</span></span><br><span class="line">            System.out.println(asc.getRemoteAddress() + <span class="string">&quot;:\t&quot;</span> + msg + <span class="string">&quot;\t字节数量[&quot;</span> + result +<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            <span class="comment">// 清空缓冲区</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="comment">// 更新辅助信息</span></span><br><span class="line">            info.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="comment">// 向客户端发送信息，原封不动的发送回去，当然你也可以发送其他内容，修改缓冲区就行</span></span><br><span class="line">            <span class="comment">// 向客户端发送信息后，服务器端显然需要继续读取客户端发送的信息，所以不可以将回调函数置为 null，那样后续就接收不到信息了</span></span><br><span class="line">            asc.write(buffer, info, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;write&quot;</span>.equals(info.get(<span class="string">&quot;type&quot;</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            asc.read(buffer, info, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>AsynchronousSocketChannel：创建客户端</strong></p>
</blockquote>
<ul>
<li>前提：客户端的创建比较简单，所以采用未来时 Future 来处理</li>
<li>创建线程池（推荐）：客户端依然有对应的 AsynchronousChannelGroup 来处理回调函数，只不过我这里就不再演示了</li>
<li>创建客户端：[connect]{.blue} 连接服务器端</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建客户端</span></span><br><span class="line">        asc = AsynchronousSocketChannel.open();</span><br><span class="line">        <span class="comment">// 向服务器端发出连接请求</span></span><br><span class="line">        asc.connect(<span class="keyword">new</span> InetSocketAddress(DEFAULT_LOCALHOST, DEFAULT_PORT));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException | InterruptedException | ExecutionException e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Future：利用未来时处理 IO 事件</strong></p>
</blockquote>
<ul>
<li>异步非阻塞式的方法都具有 Future 类型的返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建客户端</span></span><br><span class="line">        asc = AsynchronousSocketChannel.open();</span><br><span class="line">        <span class="comment">// 获取返回值</span></span><br><span class="line">        Future&lt;Void&gt; connect = asc.connect(<span class="keyword">new</span> InetSocketAddress(DEFAULT_LOCALHOST, DEFAULT_PORT));</span><br><span class="line">        <span class="comment">// 客户端将会等待连接建立完成: 如果连接没有建立完成，就会阻塞，如果建立完成，将继续执行</span></span><br><span class="line">        connect.get();</span><br><span class="line">        <span class="comment">// 从控制台中读取信息</span></span><br><span class="line">        String msg;</span><br><span class="line">        <span class="keyword">while</span> ((msg = reader.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 向服务端发送信息</span></span><br><span class="line">            ByteBuffer buffer = StandardCharsets.UTF_8.encode(msg);</span><br><span class="line">            Future&lt;Integer&gt; write = asc.write(buffer);</span><br><span class="line">            <span class="comment">// 数据发送完毕后才会继续执行</span></span><br><span class="line">            write.get();</span><br><span class="line">            <span class="comment">// 读取服务器端返回的消息</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            Future&lt;Integer&gt; read = asc.read(buffer);</span><br><span class="line">            <span class="comment">// 接收数据完成后才会继续执行</span></span><br><span class="line">            read.get();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException | InterruptedException | ExecutionException e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实战：多人聊天室"><a href="#实战：多人聊天室" class="headerlink" title="实战：多人聊天室"></a>实战：多人聊天室</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.v4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousChannelGroup;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多人聊天室服务器端: 采用异步非阻塞式 IO 实现</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 服务器端口号: 默认使用的端口号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">8888</span>;</span><br><span class="line">    <span class="comment">// 缓冲区固定分配的空间大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">// 退出消息标识符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXIT = <span class="string">&quot;退出&quot;</span>;</span><br><span class="line">    <span class="comment">// 调用者可以根据需要使用其他的端口号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="comment">// 保存客户端的集合: 因为采用的是订阅-通知的模式, 所以没有方法可以直接获取到所有的客户端</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;AsynchronousSocketChannel&gt; clients;</span><br><span class="line">    <span class="comment">// 服务器端通道: 调用者可以根据需要传入自定义的通道</span></span><br><span class="line">    <span class="keyword">private</span> AsynchronousServerSocketChannel server;</span><br><span class="line">    <span class="comment">// 线程池</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService threadPool;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousChannelGroup acg;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理客户端连接请求的回调函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">AsynchronousSocketChannel</span>, <span class="title">Object</span>&gt;</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel client, Object attachment)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 服务器端继续接收其他的客户端连接请求</span></span><br><span class="line">            <span class="keyword">if</span> (server.isOpen())</span><br><span class="line">            &#123;</span><br><span class="line">                server.accept(attachment, <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 提示客户端连接成功</span></span><br><span class="line">            System.out.println(getClientName(client) + <span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">            <span class="comment">// 客户端加入集合中</span></span><br><span class="line">            addClient(client);</span><br><span class="line">            <span class="comment">// 服务器端主要功能: 接收客户端发送的消息并且转发给其他客户端</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE);</span><br><span class="line">            buffer.put(getClientName(client).getBytes());</span><br><span class="line">            <span class="comment">// 客户端通道实际只有读事件才需要使用回调函数, 写事件是不需要的</span></span><br><span class="line">            client.read(buffer, buffer, <span class="keyword">new</span> ReadHandler(client));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 异常处理</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理客户端读写请求的回调函数: 泛型中传入的是整型, 所以为了知道客户端的信息, 我们需要将其作为辅助信息传入</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>, <span class="title">Object</span>&gt;</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> AsynchronousSocketChannel client;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReadHandler</span><span class="params">(AsynchronousSocketChannel client)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.client = client;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, Object attachment)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            ByteBuffer buffer = (ByteBuffer) attachment;</span><br><span class="line">            <span class="comment">// 从写模式切换成读模式</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">// 判断客户端是否想要退出</span></span><br><span class="line">            <span class="keyword">if</span> (isExit(buffer))</span><br><span class="line">            &#123;</span><br><span class="line">                removeClient(client);</span><br><span class="line">                <span class="comment">// 关闭该客户端, 不需要再继续读取该客户端的信息, 所以没必要传递回调函数</span></span><br><span class="line">                client.write(StandardCharsets.UTF_8.encode(EXIT));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 服务器端显示客户端发送的消息</span></span><br><span class="line">            String msg = String.valueOf(StandardCharsets.UTF_8.decode(buffer));</span><br><span class="line">            System.out.println(msg + <span class="string">&quot;(&quot;</span> + result + <span class="string">&quot;字节)&quot;</span>);</span><br><span class="line">            <span class="comment">// 转发消息</span></span><br><span class="line">            forward(client, msg);</span><br><span class="line">            <span class="comment">// 读模式切换成写模式</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="comment">// 更新辅助信息</span></span><br><span class="line">            buffer.put(getClientName(client).getBytes());</span><br><span class="line">            <span class="comment">// 服务器端继续读取当前客户端发送的其他消息</span></span><br><span class="line">            client.read(buffer, buffer, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 异常处理</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatServer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_PORT, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatServer</span><span class="params">(<span class="keyword">int</span> port, AsynchronousServerSocketChannel server)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.server = server;</span><br><span class="line">        clients = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认使用的服务器端通道</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AsynchronousServerSocketChannel <span class="title">getAsynchronousServerSocketChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 默认使用的线程池</span></span><br><span class="line">        threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">8</span>,</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">        );</span><br><span class="line">        acg = AsynchronousChannelGroup.withThreadPool(threadPool);</span><br><span class="line">        <span class="keyword">return</span> AsynchronousServerSocketChannel.open(acg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转发消息: 最为关键的修改</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">forward</span><span class="params">(AsynchronousSocketChannel client, String msg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (AsynchronousSocketChannel other : clients)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (client != other)</span><br><span class="line">                <span class="comment">// 每个客户端都应该拥有属于自己的缓冲区, 否则在多线程环境下共用一个, 真的不好检测会出现什么问题</span></span><br><span class="line">                <span class="comment">// (其实主要问题还是他妈的 IDEA 调试异步函数进不去, 就离谱)</span></span><br><span class="line">                other.write(StandardCharsets.UTF_8.encode(msg));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断客户端是否想要退出</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isExit</span><span class="params">(ByteBuffer buffer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> EXIT.equals(<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端加入服务器端</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addClient</span><span class="params">(AsynchronousSocketChannel client)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        clients.add(client);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端退出服务器端</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeClient</span><span class="params">(AsynchronousSocketChannel client)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        close(client);</span><br><span class="line">        clients.remove(client);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取客户端标识符</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getClientName</span><span class="params">(AsynchronousSocketChannel client)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            InetSocketAddress address = (InetSocketAddress) client.getRemoteAddress();</span><br><span class="line">            port = address.getPort();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;客户端[&quot;</span> + port + <span class="string">&quot;]:&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭各种通道或者流</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable closeable)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (closeable != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                closeable.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器端主方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 服务器端初始化</span></span><br><span class="line">            <span class="keyword">if</span> (server == <span class="keyword">null</span>)</span><br><span class="line">                server = getAsynchronousServerSocketChannel();</span><br><span class="line">            <span class="comment">// 绑定端口号</span></span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            <span class="comment">// 提示服务器启动成功</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;服务器[%d]:%s\n&quot;</span>, port, <span class="string">&quot;启动成功&quot;</span>);</span><br><span class="line">            <span class="comment">// 接收客户端的连接请求:</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                server.accept(<span class="keyword">null</span>, <span class="keyword">new</span> AcceptHandler());</span><br><span class="line">                <span class="comment">// 阻塞服务器</span></span><br><span class="line">                System.in.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            close(server);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 启动服务器</span></span><br><span class="line">        <span class="keyword">new</span> ChatServer().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.v4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousChannelGroup;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多人聊天室: 客户端</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_LOCALHOST = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">8888</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXIT = <span class="string">&quot;退出&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousSocketChannel client;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousChannelGroup acg;</span><br><span class="line">    <span class="keyword">private</span> ExecutorService threadPool;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClient</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_PORT, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClient</span><span class="params">(<span class="keyword">int</span> port, AsynchronousSocketChannel client)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AsynchronousSocketChannel <span class="title">getAsynchronousSocketChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 默认使用的线程池</span></span><br><span class="line">        threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">15</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">        );</span><br><span class="line">        acg = AsynchronousChannelGroup.withThreadPool(threadPool);</span><br><span class="line">        <span class="keyword">return</span> AsynchronousSocketChannel.open(acg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取客户端标识符</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getClientName</span><span class="params">(AsynchronousSocketChannel client)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            InetSocketAddress address = (InetSocketAddress) client.getRemoteAddress();</span><br><span class="line">            port = address.getPort();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;客户端[&quot;</span> + port + <span class="string">&quot;]:&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable closeable)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (closeable != <span class="keyword">null</span>)</span><br><span class="line">                closeable.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (client == <span class="keyword">null</span>)</span><br><span class="line">                client = getAsynchronousSocketChannel();</span><br><span class="line">            Future&lt;Void&gt; connect = client.connect(<span class="keyword">new</span> InetSocketAddress(DEFAULT_LOCALHOST, port));</span><br><span class="line">            <span class="comment">// 阻塞客户端</span></span><br><span class="line">            connect.get();</span><br><span class="line">            System.out.println(getClientName(client) + <span class="string">&quot;启动成功&quot;</span>);</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE);</span><br><span class="line">            <span class="comment">// 控制台输入必然阻塞: 只能够新开线程处理</span></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ChatClientInputThread(client)).start();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Future&lt;Integer&gt; read = client.read(buffer);</span><br><span class="line">                <span class="keyword">int</span> res = read.get();</span><br><span class="line">                <span class="keyword">if</span> (res &lt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    close(client);</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    System.out.println(StandardCharsets.UTF_8.decode(buffer));</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException | InterruptedException | ExecutionException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ChatClient().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.v4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClientInputThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXIT = <span class="string">&quot;退出&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BufferedReader READER = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">        <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">            System.in));</span><br><span class="line">    <span class="keyword">private</span> AsynchronousSocketChannel client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClientInputThread</span><span class="params">(AsynchronousSocketChannel client)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">while</span> ((msg = READER.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Future&lt;Integer&gt; write = client.write(StandardCharsets.UTF_8.encode(msg));</span><br><span class="line">                write.get();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException | InterruptedException | ExecutionException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Fuyusakaiori</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/09/09/java/io/AIO/">http://example.com/2021/09/09/java/io/AIO/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/09/09/network/%E6%A6%82%E8%BF%B0/"><i class="fa fa-chevron-left">  </i><span>概述</span></a></div><div class="next-post pull-right"><a href="/2021/09/07/java/interface/Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><span>Lambda 表达式</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/随机图库/1643042375499.2rf317jrwiw0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2022 By Fuyusakaiori</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">wind glass bluebird</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>