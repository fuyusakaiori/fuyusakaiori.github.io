<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="InnoDB 体系架构"><meta name="keywords" content="InnoDB,MySQL"><meta name="author" content="Fuyusakaiori"><meta name="copyright" content="Fuyusakaiori"><title>InnoDB 体系架构 | 天鹅绒房间</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"37DAS9P43B","apiKey":"c2a5f8cdb503b255bb4384b147d4ab84","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#InnoDB-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">InnoDB 体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B1%A0"><span class="toc-number">1.2.2.</span> <span class="toc-text">缓冲池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E7%BC%93%E5%86%B2"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">插入缓冲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E6%AC%A1%E5%86%99%E7%BC%93%E5%86%B2"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">两次写缓冲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">自适应哈希</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.2.3.</span> <span class="toc-text">日志缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E5%86%85%E5%AD%98%E6%B1%A0"><span class="toc-number">1.2.4.</span> <span class="toc-text">额外内存池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">后台线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">主线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">主循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">后台循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%B7%E6%96%B0%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">刷新循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%82%E5%81%9C%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">暂停循环</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i1.xpic.jp/file/xpicjp/2022/01/21/2070676bca90a832cba0ff3e76a701b1.png"></div><div class="author-info__name text-center">Fuyusakaiori</div><div class="author-info__description text-center">啥也不会的大三狗</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/fuyusakaiori">いらしゃい</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">112</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">34</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/随机图库/1643042375499.2rf317jrwiw0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">天鹅绒房间</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/Home">主页 | Home</a><a class="site-page" href="/archives">归档 | Archives</a><a class="site-page" href="/categories">分类 | Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">InnoDB 体系架构</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-01-19</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/MySQL/">MySQL</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/MySQL/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/">基础架构</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">4.4k</span><span class="post-meta__separator">|</span><span>Reading time: 13 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="InnoDB-体系结构"><a href="#InnoDB-体系结构" class="headerlink" title="InnoDB 体系结构"></a>InnoDB 体系结构</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>本篇文章主要介绍 InnoDB 存储引擎的整体架构，<strong>着重讲述后台线程是如何工作的，内存池中的缓冲池的特性和存储的内容、以及日志缓冲池仅简单介绍</strong>，这些内容会在之后的日志和索引篇章详细讲解.此外，本篇文章基本完全参考《MySQL 技术内幕：InnoDB 存储引擎》，略去了细枝末节的内容，感兴趣的读者可以去详细阅读这本书</p>
</blockquote>
<p>① MySQL 查询或者更新数据的整体逻辑</p>
<ul>
<li>首先 MySQL 进程会检查内存中是否存在需要查询或者更新的数据<ul>
<li>如果内存中存在对应需要查询或者更新的数据，那么就会将内存中对应的数据更新<ul>
<li>内存中被修改的数据此时就会被称为脏页，与之相对没有被修改的页面就是干净的页面</li>
<li>这里也就是说修改的内容并不会立刻写入磁盘中，而是暂时保存在内存中，至于什么时候写入磁盘就是后台线程的任务了</li>
</ul>
</li>
<li>如果内存中没有对应的数据，那么就会触发缺页中断，操作系统就会开始处理中断</li>
</ul>
</li>
<li>然后 MySQL 就会有对应的后台线程去负责从磁盘中将数据所在的整个数据页全部加载进入内存中<ul>
<li>如果内存中还有空闲的空间，那么直接将数据页全部加载进入内存就可以了</li>
<li>如果内存中没有空闲的空间，那么就会采用 LRU（最近最少使用算法）去替换内存中的数据页</li>
</ul>
</li>
</ul>
<p>如此设计的理由和操作系统的设计是类似的，现代计算体系结构肯定要求数据必须在内存中才能够使用，但是数据库中存储的数据通常是非常多的，不可能全部都加载到内存中，所以采用这种按需调用的方式，而读取数据的最小单位为页而不是行，则是避免频繁的磁盘读写造成的性能下降，因为如果每次读写磁盘仅读写一行，那么十行数据就必须读写十次，这个效率是非常低的</p>
<p><a style="color:grey;">注：概述的执行逻辑没有考虑日志、缓冲区的等内容，只是想说明数据一定是先被加载内存中修改再择机写入磁盘中的</a></p>
<p>② InnoDB 存储引擎架构图</p>
<p><a style="color:grey;">整个架构图是根据书中的内容总结得到的，做了细微的扩展和调整。后台线程中增加 purge thread、page cleaner thread 两个线程，这两个线程是辅助 master 线程完成工作的，并不是很重要。日志缓冲区中增加了 undo log buffer，在书中并没有明确指出存在这个缓冲区，但是个人认为应该存在对应缓冲区，binlog 个人认为应该是存放在业务层对应的内存中的，而不是引擎层</a></p>
<img src="https://i1.xpic.jp/file/xpicjp/2022/01/21/eb62cfbe112209d7183142d5da8ba139.png" alt="InnoDB 存储引擎架构图" style="zoom:67%;" />

<h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>内存池的主要功能</strong></p>
<ul>
<li>维护和管理线程需要使用的数据结构等信息</li>
<li>缓存从磁盘中加载的数据页、索引页等相关数据信息，从而避免频繁地磁盘读取</li>
<li>设计插入缓存、二次写缓冲、日志缓冲等缓冲结构，从而提升向磁盘写入数据的效率以及确保数据库宕机之后的恢复效率</li>
</ul>
<p><strong>内存池的主要组成</strong></p>
<ul>
<li>内存池主要有三部分组成：缓冲池、日志缓冲池、额外内存池三部分组成</li>
<li>缓冲池内部存储的信息主要是：数据页、索引页、插入缓冲、两次写缓冲、自适应哈希、锁等相关信息</li>
<li>日志缓冲内部存储的信息主要是：redo log、undo log（我自己的想法）</li>
</ul>
<p><strong>内存池的大小</strong></p>
<ul>
<li>参数 <code>innodb_buffer_pool_size</code> 控制缓冲池的大小</li>
<li>参数 <code>innodb_log_buffer_size</code> 控制日志缓冲池的大小</li>
<li><del>参数 <code>innodb_additional_mem_pool_size</code> 控制额外内存池的大小</del>（MySQL 5.7 版本之后被移除）</li>
</ul>
<img src="https://i1.xpic.jp/file/xpicjp/2022/01/21/e80aa06bbcc196b392a4a388a7bb4b0c.png" alt="两个参数的默认大小" style="zoom:67%;" />

<h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p>缓冲池存储内容：缓冲池缓存的主要内容就是从磁盘中加载进来的数据页和索引页，其余优化策略所占据的内存相对较小</p>
<ul>
<li>后台线程的主要工作内存就是缓冲池：每次都从内存中查询或者更新内存中的数据，之后择机将数据写入磁盘中</li>
<li>读取数据的最小单位是页：每次查询对应的一行或者多行数据的时候，都是将这些行所在数据页全部加载进来</li>
</ul>
<p><a style="color:grey;">注：数据页和索引页将会在之后表结构中详细讲述，现在知道这两个东西分别用于存储数据和索引就行了</a></p>
<p>查看缓冲池使用情况：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看引擎的使用情况</span></span><br><span class="line"><span class="keyword">show</span> engine innodb status \G;</span><br></pre></td></tr></table></figure>

<img src="https://i1.xpic.jp/file/xpicjp/2022/01/21/d093fcc8f61db66dcc4e327684bc89ea.png" alt="缓冲池使用情况" style="zoom:67%;" />

<h4 id="插入缓冲"><a href="#插入缓冲" class="headerlink" title="插入缓冲"></a>插入缓冲</h4><h4 id="两次写缓冲"><a href="#两次写缓冲" class="headerlink" title="两次写缓冲"></a>两次写缓冲</h4><blockquote>
<p>参考博客：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/geaozhang/p/7241744.html">两次写缓冲</a></p>
</blockquote>
<p>1、<strong>为什么需要两次写缓冲？</strong></p>
<p>MySQL 中默认每张数据页都是 16KB 的大小，文件系统每张数据页大小通常是 4KB，而磁盘 I/O 的速率显然是不足以将数据库中的数据页瞬间写入到文件系统中。如果在磁盘 I/O 传输的过程中数据库或者文件系统出现故障而宕机，磁盘中就存在未写完的残缺数据页。</p>
<p><strong>这种残缺的数据页没有办法继续使用，也没有办法使用重做日志进行恢复（重做日志记录的是物理页的修改，在物理页已经损坏的情况下，重做日志无法使用）</strong></p>
<p><strong>这种情况就称为部分写失效（partial page write），所以二次写缓冲就是用于解决部分写失效问题的，用于保障数据库的可靠性的技术</strong></p>
<img src="https://i1.xpic.jp/file/xpicjp/2022/01/21/094348cb0d7ec1511c4ff9a23170cb93.png" alt="部分写失效" style="zoom:67%;" />



<hr>
<p>2、<strong>两次写缓冲是如何完成的？</strong></p>
<p>先来分析问题的核心，本质在于 ① 数据页出现新旧内容交替的情况，导致重做日志无法对其生效 ② 脏页的数据也丢失了</p>
<p>既然这样，在重做日志无法生效的情况下，那么只有考虑将脏页的数据提前备份，只要发生宕机就直接从备份数据中恢复就好</p>
<ul>
<li><strong>先调用 <code>memcpy</code> 函数将脏页拷贝到两次写缓冲中（double write buffer）</strong></li>
<li><strong>然后将两次写缓冲中的内容先拷贝到共享表空间中（ibdata1）</strong></li>
<li><strong>最后将两次写缓冲中的内容离散地同步写入到磁盘中去</strong></li>
</ul>
<p>再来看看两次写缓冲是否解决了部分写失效的问题：</p>
<ul>
<li>如果在将脏页拷贝到两次写缓冲中去的时数据库宕机，那么磁盘页没有被损坏，那么就可以应用重做日志恢复数据重写落盘</li>
<li>如果在将缓冲区的数据写入共享表空间中时数据库宕机(?)</li>
<li>如果在写入磁盘的时候数据库宕机，那么只需要检验出数据页确实发生损坏，那么就可以从共享表空间中取出脏页副本恢复即可</li>
</ul>
<img src="https://i1.xpic.jp/file/xpicjp/2022/01/21/79231e24da91a7054062b1824e496ea1.png" alt="二次写缓冲" style="zoom:67%;" />

<hr>
<p>3、<strong>两次写缓冲是否带来了问题？</strong></p>
<h4 id="自适应哈希"><a href="#自适应哈希" class="headerlink" title="自适应哈希"></a>自适应哈希</h4><h3 id="日志缓冲区"><a href="#日志缓冲区" class="headerlink" title="日志缓冲区"></a>日志缓冲区</h3><p>日志缓冲区主要存储内容：重做日志和回滚日志记录的内容</p>
<ul>
<li>后台线程每次根据 SQL 语句记录日志的时候，都会先将日志记录在日志缓冲区中，择机将日志缓冲区的内容写入磁盘中</li>
<li>日志缓冲区的值不需要设置太大：后台线程会定期将日志缓冲区中的内容写入磁盘中，所以不用担心溢出</li>
</ul>
<h3 id="额外内存池"><a href="#额外内存池" class="headerlink" title="额外内存池"></a>额外内存池</h3><p><em>不是很明白这个是干什么的</em></p>
<h2 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><strong>后台线程主要功能</strong></p>
<ul>
<li>后台线程主要负责更新内存池中的缓存数据，保证内存池中的数据基本是最新的</li>
<li>后台线程还要负责将内存池中的数据定期刷回到磁盘中去，并且确保在写入过程发生宕机时，能够从宕机的异常状态恢复到正常运行状态</li>
</ul>
<p><strong>后台线程种类</strong></p>
<p>① 后台线程主要分为 4 类：</p>
<ul>
<li>主线程：负责协调所有功能的线程</li>
<li>锁线程：负责和上锁和释放锁（全局锁、表锁、行锁）的相关线程（不准确）</li>
<li>错误监控线程：负责异常处理的线程（不准确）</li>
<li>I/O 线程：插入缓冲线程、日志线程、读写磁盘的线程</li>
</ul>
<p>② 后台线程的数量</p>
<ul>
<li>InnoDB 默认版本中后台线程的数量配置为 7 个，InnoDB Plugin 版本（MySQL 5.1）后台线程数量为 13 个<ul>
<li>7 个线程：4 个 I/O 线程（插入缓冲、日志、读磁盘、写磁盘线程）、主线程、错误监控线程、锁线程</li>
<li>13 个线程：读磁盘线程和写磁盘线程从 1 个变为 4 个，其余线程的数量没有变化</li>
</ul>
</li>
<li>Linux 系统的后台线程数量是不可以改变的，Windows 系统下可以通过相应的变量控制后台线程数量<ul>
<li>InnoDB 默认版本中采用 <code>innodb_file_io_threads</code> 进行控制</li>
<li>InnoDB Plugin 版本中采用 <code>innodb_read_io_threads</code> 和 <code>innodb_write_io_threads</code> 两个变量控制</li>
</ul>
</li>
</ul>
<img src="https://i1.xpic.jp/file/xpicjp/2022/01/20/9c765d4512cd18f6ea49319d613bc671.png" alt="I/O 线程" style="zoom:67%;" />



<h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><blockquote>
<p>主线程主要分为四个循环过程：主循环、后台循环、刷新循环。负责最主要功能的就是主循环，其余循环的功能基本都是主循环的子集。其主要内容就是就是 ① 将内存中的日志刷新到磁盘中去 ② 将内存中脏页更新到磁盘中去 ③ 将从磁盘中读取的数据和插入缓冲中的数据合并 ④ 删除不再使用的回滚日志</p>
</blockquote>
<img src="https://i1.xpic.jp/file/xpicjp/2022/01/21/0b6f1291b03dd7cbd2fd9ddc63cd8b69.png" alt="主循环主要的工作" style="zoom:67%;" />

<h4 id="主循环"><a href="#主循环" class="headerlink" title="主循环"></a>主循环</h4><p>① 主循环负责的功能种类</p>
<ul>
<li>每秒都需要执行的操作：通常称为系统繁忙的时候</li>
<li>每间隔 10秒 执行的操作：通常称为系统空闲的时候</li>
</ul>
<p><a style="color:grey;">注：这里的时间频率只是大致上的，每秒执行的操作以及线程休眠都会造成一定的延时</a></p>
<hr>
<p>② 主循环每秒执行的操作</p>
<p>1、<strong>刷新日志：无论事务是否提交，每秒都会将日志缓冲区中记录的日志全部刷新到磁盘中</strong></p>
<p>不过，日志缓冲区记录的日志落盘除了主线程每秒刷新之外，还有其他情况也是会刷新到磁盘的</p>
<ul>
<li>binlog：采用 <code>sync_binlog</code> 参数控制落盘时机<ul>
<li><strong>不强制要求落盘时机，由系统自行判断落盘时机</strong></li>
<li><strong>每提交一个事务就立刻将日志刷新到磁盘中</strong></li>
<li><strong>每提交 N 个事务后才将日志刷新到磁盘中</strong></li>
</ul>
</li>
<li>redo log：<ul>
<li>采用 <code>innodb_flush_log_at_trx_commit</code> 参数控制落盘时机<ul>
<li>延迟写：<strong>事务提交时，准备将缓冲区中的日志写入磁盘，但是需要等待主线程的每秒刷新</strong></li>
<li>实时写、实时刷：<strong>事务提交时，不等主线程刷新，而是直接采用同步阻塞的方式将日志刷新到磁盘</strong></li>
<li>实时写、延迟刷：<strong>事务提交时，不等待主线程刷新，采用异步的方式将日志刷新到磁盘</strong></li>
<li>注：实时写实时刷可以保证日志写入磁盘中而不会丢失，而实时写延迟刷则无法保证，但是前者效率低后者效率高</li>
</ul>
</li>
<li>重做日志缓冲区写入的内容超过一半后，会强制将部分重做日志写入磁盘，并相应推进检查点</li>
</ul>
</li>
</ul>
<p>刷新日志的细节分析以及留存的疑问</p>
<ul>
<li>不必等待事务提交再将全部的日志刷新到磁盘中，所以事务提交过程比较快</li>
<li>每秒都将日志缓冲区中的内容刷新到磁盘，I/O 性能不会很差吗？（我的疑问 ①）</li>
<li>既然每秒中都刷新日志到磁盘中，那么两阶段提交还有什么意义呢？（我的疑问 ②）</li>
</ul>
<p><a style="color:grey;">注：这里提到的各种类型日志及其刷盘时机会在之后的日志部分详细讲述，包括两种日志如何配合都会在之后讲述</a></p>
<p>2、<strong>合并插入缓冲：将插入缓冲区中存放的修改记录和从磁盘中加载进入的数据页进行合并</strong></p>
<ul>
<li>合并插入缓冲的条件<ul>
<li>如果当前一秒内发生的 I/O 次数小于 5 次，那么就会考虑执行合并插入缓冲的操作</li>
<li>如果当前一秒内发生 I/O 的频率非常高，那么就不会执行合并插入缓冲的操作</li>
</ul>
</li>
</ul>
<p>3、<strong>刷脏页：将缓冲区中存放的脏页（已经被修改的数据页）写入磁盘中</strong></p>
<ul>
<li><p>向磁盘写入脏页的条件：根据实际的 <code>buf_get_modified_ratio_pct</code> 比例确定</p>
<ul>
<li>如果缓冲池中的脏页所占内存比例超过阈值，那么就会将 100 个脏页全部写入磁盘中</li>
<li>如果缓冲池脏页所占的比例没有超过阈值，那么就不会刷新任何脏页</li>
</ul>
<p><a style="color:grey;">注：每秒刷新的脏页数量是固定，不会根据情况变动</a></p>
</li>
<li><p>阈值的设置：可以通过 <code>innodb_max_dirty_pages_pct</code> 这个参数进行设置</p>
<ul>
<li>刷脏页的阈值默认值为 90%，在引擎之后的版本将这个值修改为 75%</li>
<li>默认值修改的原因在于如果内存特别大的情况下，就容易导致长时间脏页没有落盘，从而导致宕机之后需要更多时间恢复树</li>
</ul>
</li>
<li><p>其余向磁盘写入脏页的条件</p>
<ul>
<li><strong>重做日志记录内容超过一半的时候，也会将脏页刷新到磁盘中</strong></li>
<li><strong>线程空闲的时候，也会将脏页刷新到磁盘中</strong></li>
<li><strong>数据库正常退出的时候，会强制将所有脏页刷新到磁盘中</strong></li>
</ul>
</li>
</ul>
<p><strong>如果当前线程没有任何活动或者操作行为，就切换到后台循环</strong></p>
<hr>
<p>③ 主循环每 10 秒执行的操作</p>
<p>1、<strong>刷脏页：将缓冲区中存放的脏页（已经被修改的数据页）写入磁盘中</strong></p>
<ul>
<li>刷新脏页的条件：<ul>
<li>如果过去的 10 秒内执行的 I/O 操作少于 200 次，那么就会将 100 个脏页全部写入磁盘中</li>
<li>如果过去的 10 秒内执行 I/O 的频率过高，那么存储引擎会认为当前没有空闲将脏页写入磁盘</li>
</ul>
</li>
</ul>
<p>2、<strong>合并插入缓冲 + 刷新日志到磁盘 + 删除不再使用 undo 页</strong></p>
<ul>
<li>执行条件：<ul>
<li>无论过去时间内 I/O 的频率如何，这里都是会执行合并插入缓冲和刷新日志的操作</li>
<li>无论事务是否提交，都会将日志缓冲区中的内容刷新到磁盘中</li>
<li>没有其他更早的事务使用当前事务的回滚日志时，就会删除回滚日志对应的 undo 页</li>
</ul>
</li>
</ul>
<p><a style="color:grey;">注：undo log 的详细内容将在日志中讲述，这里只需要知道它是事务原子性的底层原理</a></p>
<p>3、<strong>继续刷脏页：将 100 个或者 10 个脏页全部写入磁盘中</strong></p>
<ul>
<li>继续刷新脏页的条件<ul>
<li>如果脏页在缓冲池中的内存占比已经超过 70%，那么就会考虑刷新 100个 脏页进入磁盘中</li>
<li>如果脏页在缓冲池中的内存占比没有超过 70%，那么仅会刷新 10 个脏页进入磁盘</li>
</ul>
</li>
</ul>
<p><a style="color:grey">注：不同于每秒操作，每隔 10 秒则必然会将部分脏页写入磁盘中</a></p>
<hr>
<p>④ 主循环的伪代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">master_thread</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">goto</span> main_loop;</span><br><span class="line">	<span class="comment">// 主循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="comment">// 线程存在休眠，所以每秒并不是精确的</span></span><br><span class="line">        thread.sleep(<span class="number">1</span>); </span><br><span class="line">        <span class="comment">// 将日志刷新到磁盘中</span></span><br><span class="line">        <span class="keyword">do</span> <span class="built_in">log</span> buffer flush to disk; </span><br><span class="line">        <span class="keyword">if</span>(last_one_seconds &lt; <span class="number">5</span>) </span><br><span class="line">            <span class="comment">// 执行插入缓冲合并</span></span><br><span class="line">            <span class="keyword">do</span> merge at most <span class="number">5</span> insert buffer; </span><br><span class="line">        <span class="keyword">if</span>(buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct) </span><br><span class="line">            <span class="comment">// 将 100 个脏页刷新到磁盘</span></span><br><span class="line">            <span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty pages; </span><br><span class="line">        <span class="keyword">if</span>(no user activity)</span><br><span class="line">            <span class="comment">// 如果没有用户活动就切换到后台线程</span></span><br><span class="line">            <span class="keyword">goto</span> background loop; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(last_ten_seconds &lt; <span class="number">200</span>)</span><br><span class="line">        <span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty pages;</span><br><span class="line">    <span class="keyword">do</span> merge at most <span class="number">5</span> insert buffer;</span><br><span class="line">    <span class="keyword">do</span> <span class="built_in">log</span> buffer flush to disk;</span><br><span class="line">    <span class="comment">// 删除不再使用的 undo 页</span></span><br><span class="line">    <span class="keyword">do</span> full purge; </span><br><span class="line">    <span class="keyword">if</span>(buf_get_modified_ratio_pct &gt; <span class="number">70</span>%)</span><br><span class="line">        <span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty pages;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">do</span> buffer pool flush <span class="number">10</span> dirty pages;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="后台循环"><a href="#后台循环" class="headerlink" title="后台循环"></a>后台循环</h4><ul>
<li>删除不再使用 undo 页面</li>
<li>合并插入缓冲（20个）</li>
<li>如果线程当前需要执行新的操作或者活动，那么就会跳回到主循环中去执行</li>
<li>如果当前线程依旧没有任何需要执行的操作，那么就会跳转到刷新循环中执行</li>
</ul>
<h4 id="刷新循环"><a href="#刷新循环" class="headerlink" title="刷新循环"></a>刷新循环</h4><ul>
<li>不停地刷新脏页到磁盘中去（100个），直到没有脏页可以刷新的时候，就跳转到暂停循环中</li>
</ul>
<h4 id="暂停循环"><a href="#暂停循环" class="headerlink" title="暂停循环"></a>暂停循环</h4><ul>
<li>如果线程进入暂停循环了，那么存储引擎就会将该线程挂起，不在执行任何操作</li>
<li>如果线程需要执行新的操作，那么再由存储引擎将其唤醒，进入主循环中继续执行</li>
</ul>
<p>注：如果 MySQL 启用了 InnoDB 引擎，但是没有任何表在定义的时候使用 InnoDB 引擎，那么主线程就始终处于暂停循环</p>
<blockquote>
<p>参考资料：</p>
<p>《MySQL 技术内幕：InnoDB 存储引擎》</p>
</blockquote>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Fuyusakaiori</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2022/01/19/database/mysql/structure/InnoDB 体系架构/">http://example.com/2022/01/19/database/mysql/structure/InnoDB 体系架构/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/InnoDB/">InnoDB</a><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/01/19/database/mysql/structure/InnoDB%20%E8%A1%A8%E7%BB%93%E6%9E%84/"><i class="fa fa-chevron-left">  </i><span>InnoDB 表结构</span></a></div><div class="next-post pull-right"><a href="/2022/01/13/database/mysql/structure/MySQL%20%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"><span>MySQL 基础架构</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/随机图库/1643042375499.2rf317jrwiw0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2022 By Fuyusakaiori</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">wind glass bluebird</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>