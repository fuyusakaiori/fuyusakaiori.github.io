<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="啥也不会的大三狗">
<meta property="og:type" content="website">
<meta property="og:title" content="天鹅绒房间">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="天鹅绒房间">
<meta property="og:description" content="啥也不会的大三狗">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Fuyusakaiori">
<meta name="twitter:card" content="summary"><title>天鹅绒房间</title><link ref="canonical" href="http://example.com/page/5/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">天鹅绒房间</div><div class="header-banner-info__subtitle">Velvet Room</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/19/juc/juc-basic/%E5%B0%BE%E5%A3%B0/">线程-尾声</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-19</span></span></div></header><div class="post-body"><div class="post-excerpt"></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/19/juc/juc-basic/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">线程-基础知识</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-21</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="基础知识"   >
          <a href="#基础知识" class="heading-link"><i class="fas fa-link"></i></a><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1>
      
        <h2 id="OS-线程基础知识"   >
          <a href="#OS-线程基础知识" class="heading-link"><i class="fas fa-link"></i></a><a href="#OS-线程基础知识" class="headerlink" title="OS 线程基础知识"></a>OS 线程基础知识</h2>
      <p>:::info</p>
<p>① 所有语言层面的线程知识都是基于操作系统，所以本篇笔记会优先[简单讲述]{.red}操作系统中线程</p>
<p>② 了解操作系统中的线程之后才会开始介绍 Java 线程、C# 协程中的相关知识</p>
<p>注：最好对操作系统中的线程基础知识有所了解</p>
<p>:::</p>

        <h3 id="什么是线程？"   >
          <a href="#什么是线程？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h3>
      <ul>
<li>线程定义：<ul>
<li>OS 定义：<ul>
<li>线程是拥有 [<strong>独立</strong>的程序计数器、寄存器、栈空间]{.red} </li>
<li>并且共享进程提供的 [代码段、数据段]{.red} 等资源的 [处理器基本单元]{.red}</li>
</ul>
</li>
<li>通俗定义：[线程是由一系列指令组成的不具有存储空间的串行控制流，负责将每条指令交付给处理器执行]{.red}</li>
</ul>
</li>
<li>线程模型：寄存器 + 程序计数器 + 占空间</li>
<li>线程状态<ul>
<li>新生态：线程刚被操作系统创建还没有启动的时候的状态</li>
<li>就绪态：线程已经获取到所有启动所需要的资源的时候的状态</li>
<li>运行态：线程获取到处理器的使用权的时候的状态</li>
<li>等待态（阻塞态）：[线程等待 IO 操作返回数据时的状态]{.red}</li>
<li>终止态：线程执行完所以任务之后的状态</li>
</ul>
</li>
<li>线程上下文切换：</li>
<li>并行与并发：</li>
</ul>

        <h3 id="为什么使用线程？"   >
          <a href="#为什么使用线程？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么使用线程？" class="headerlink" title="为什么使用线程？"></a>为什么使用线程？</h3>
      <ul>
<li><p>[核心：多个线程能够提高进程的工作效率]{.red}</p>
<ul>
<li>多线程从两方面提升效率<ul>
<li>[提升进程对于用户的 <strong>响应时间</strong>：多线程的诞生就是为了改善响应时间]{.red}</li>
<li>[提升进程对于计算任务的 <strong>执行速度</strong>：多核处理器出现之后才能够提高进程的执行速度]{.red}</li>
</ul>
</li>
<li>提升工作效率的两个前提：<ol>
<li>[线程执行的任务主要是 IO 密集型而不是 CPU 密集型]{.red}<ul>
<li>解释 CPU 密集型：<ul>
<li>[如果线程执行的是 CPU 密集型任务，那么处理器就会长时间处于满负荷运载的状态]{.aqua}</li>
<li>[如果存在多线程并发的情况，那么处理器就必须花费时间执行上下文切换，浪费执行计算的时间]{.aqua}</li>
</ul>
</li>
<li>解释 IO 密集型：<ul>
<li>[如果线程执行的 IO 密集型任务，那么线程因为 IO 过程而阻塞时，处理器也会相应的空闲下来]{.orange}</li>
<li>[避免处理器长时间处于空闲，就可切换上下文让其他等待的线程执行，让处理器可以重新工作]{.orange}</li>
</ul>
</li>
<li>总结：多线程对于 IO 密集型任务可以很好地 [改善进程的响应时间]{.red}，当前线程阻塞了可以换其他线程</li>
</ul>
</li>
<li>[计算机最好是多核处理器而不是单核处理器]{.red}<ul>
<li>[单核处理器下的多线程只能实现并发，只能够提高进程的响应时间，而无法提高进程的运算速度]{.aqua}<ul>
<li>每个计算核只能够运行一个线程，那么需要执行其他的线程就必须上下文切换</li>
<li>线程无论执行的是 CPU 还是 IO 密集型都无法从实质上提升进程的执行速度的，毕竟只有并发</li>
</ul>
</li>
<li>[多核处理器下的多线程可以同时实现并行和并发，既可以提高响应时间也可以提供运算速度]{.orange}<ul>
<li>多个线程之间可以完全相互不干扰的并行执行，处理器不需要对并行的线程执行上下文切换</li>
<li>不过依然会对单个处理器上并发的线程执行上下文切换，避免处理器的长时间等待</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>总结：[不能够非常笼统地说多线程就是能够提高进程的工作效率，具体情况需要具体分析，使用不当反而造成性能下降]{.red}<ol>
<li>[单核处理器下的多线程是为了改善进程的响应时间，而无法提高进程的执行速度，毕竟始终只有一个线程在运行]{.purple}</li>
<li>[多核处理器的出现是为了更好地支持多线程，只要多个线程能够并行执行，显然就可以提高执行速度，在并行的基础上实现并发，又可以改善响应时间]{.purple}</li>
</ol>
</li>
</ul>
</li>
<li><p>[多个线程可以共享同一个进程提供的所有资源，多个进程之间则是独立的不可共享的]{.pink}</p>
<ul>
<li>优点：多线程通信和协作时可以随意使用相同资源，避免重复创建相同的资源</li>
<li>缺点：多线程使用共享资源时需要确保线程安全</li>
</ul>
</li>
<li><p>[线程的创建和销毁的成本相对于进程非常低，减轻操作系统的负担]{.pink}</p>
<ul>
<li>细节：即使线程的创建和开销成本很低，但是创建或者销毁大量的线程也是非常消耗资源的</li>
</ul>
</li>
<li><p>Amdahl（阿姆达尔定律）</p>
</li>
</ul>

        <h3 id="线程如何实现？"   >
          <a href="#线程如何实现？" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程如何实现？" class="headerlink" title="线程如何实现？"></a>线程如何实现？</h3>
      
        <h4 id="线程实现"   >
          <a href="#线程实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h4>
      <ul>
<li>前言：<ul>
<li>OS 层面的线程：几乎绝大多数操作系统都是支持多线程的</li>
<li>语言层面的线程：每种语言实现线程的方式各不相同<ul>
<li>内核级线程代表（线程）：Java、C\C++</li>
<li>用户级线程代表（协程/纤程）：C#、Python、Golang</li>
</ul>
</li>
</ul>
</li>
<li>现状：<ul>
<li>线程的创建和销毁对于日益增加的并发量来说依然是笔不小的开销，即使有线程池、多路复用等方法的改善</li>
<li>如今大多数新兴语言，诸如 Python、Golang 都是采用的协程而不是传统的线程，从而支持更高的并发量</li>
</ul>
</li>
</ul>

        <h5 id="内核级线程"   >
          <a href="#内核级线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h5>
      <ul>
<li>定义：</li>
<li>特点：</li>
<li>图示：</li>
</ul>

        <h5 id="用户级线程"   >
          <a href="#用户级线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h5>
      <ul>
<li>定义：</li>
<li>特点：</li>
<li>图示</li>
</ul>

        <h5 id="混合级线程"   >
          <a href="#混合级线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#混合级线程" class="headerlink" title="混合级线程"></a>混合级线程</h5>
      <ul>
<li>定义：</li>
<li>特点：</li>
<li>图示：</li>
</ul>

        <h4 id="线程调度"   >
          <a href="#线程调度" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4>
      <p>:::primary</p>
<p>每种算法的详细内容也放在操作系统的笔记中，这里要是每种算法都详细讲述实在是太多了</p>
<p>:::</p>
<ul>
<li>前言：<ul>
<li>[内核级线程调度和进程调度基本类似]{.red}</li>
<li>[用户级线程的调度算法完全取决于程序员编写的逻辑]{.red}</li>
</ul>
</li>
<li>两类调度方式<ul>
<li>协同式调度：先来先服务算法</li>
<li>抢占式调度：时间片轮转法</li>
<li>最短作业优先、优先权调度、多级队列调度既可以是协同式的，也可以是抢占式的</li>
</ul>
</li>
</ul>

        <h4 id="线程通信？线程同步？"   >
          <a href="#线程通信？线程同步？" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程通信？线程同步？" class="headerlink" title="线程通信？线程同步？"></a>线程通信？线程同步？</h4>
      <p>:::primary</p>
<p>① 之所以将标题取为疑问的方式，是因为网络上关于这一块内容存在非常多滥竽充数和胡乱的解释</p>
<p>② 首先明确通信和同步是两种完全不同的行为，但是却又有一定的联系，接下来将会提到</p>
<p>③ 通信和同步的具体方式将会放在之后来讲，这里受限于篇幅不在此展开</p>
<p>:::</p>
<ul>
<li><p>前言：</p>
<ul>
<li>[只有进程间存在通信的概念，线程间通信只是一种伪术语]{.red}<ul>
<li>[多个进程之间是相互隔离的，没有办法直接交互或者共享数据，所以才需要通信]{.pink}</li>
<li>[多个线程之间本身就是共享同一个进程的所有资源，相互之间可以直接交互数据，没有所谓通信的概念]{.pink}</li>
<li>[多个线程之间天生共享进程的资源，可以认为多线程默认通信方式就是共享内存]{.pink}</li>
</ul>
</li>
<li>[只要进程或者线程采用共享内存的方式通信，就会存在线程安全问题，就需要采用同步手段解决]{.red}</li>
<li>[进程之间通常才会考虑通信方式，线程之间通常只考虑同步方式]{.red}</li>
</ul>
</li>
<li><p>进程间通信：① 管道 ② 消息队列 ③ 共享内存 ④ 套接字 ⑤ 信号 ⑥ 信号量（常见的六种）</p>
<ul>
<li>[本地进程通信：共享内存、信号、管道]{.red}</li>
<li>[分布式进程通信：消息队列、套接字、RPC、Stream]{.aqua}</li>
<li>细节：<ul>
<li>管道：可以细分为匿名管道和命名管道两种类型</li>
<li>信号量：本质是同步手段而不是进程间的通信手段</li>
</ul>
</li>
</ul>
</li>
<li><p>线程间同步：</p>
<ul>
<li>前提：[线程间通信是基于共享内存的方式进行通信的，所以不再考虑通信的方式]{.red}<ol>
<li>Java 提供的 <code>sleep()、wait()、join()</code>等方法严格意义上不能够算作线程通信</li>
<li>毕竟线程之间没有办法交互数据，也没有办法互相通知对方完成什么事情，只能够是一种协作方式吧</li>
</ol>
</li>
<li>竞争条件：[多线程并发访问共享资源的结果和访问的顺序有关的情况称为竞争条件]{.red}</li>
<li>临界区：[线程使用共享资源的代码块]{.red}</li>
<li>方式：<ul>
<li>[硬件方式：屏蔽中断、TSL、Swap、CAS、LL/SC]{.red}<ul>
<li>TSL（Test And Set）：x86 指令集中的命令是 XCHG</li>
<li>CAS（Compare And Swap）</li>
<li>LL/SC：Load-Linked/Store-Conditional</li>
</ul>
</li>
<li>[软件方式：锁变量、严格轮换法、Peterson、信号量（包括互斥量）]{.red}</li>
<li>[编译器层面：管程]{.red}</li>
</ul>
</li>
<li>细节：上述同步方案都是基于操作系统或者编译器层面的，语言层面自行实现的锁不在此列出</li>
</ul>
</li>
</ul>

        <h3 id="线程应用"   >
          <a href="#线程应用" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程应用" class="headerlink" title="线程应用"></a>线程应用</h3>
      <ul>
<li><p>应用场景：</p>
<ul>
<li>[Web 开发中]{.orange}大多数情况都是不会用到多线程技术的，这些工作已经由各种各种的中间件（Tomcat、Netty）为你完成</li>
<li>[中间件开发中]{.aqua}，诸如服务器开发才会使用到多线程的知识，而且是非常重要的</li>
</ul>
</li>
<li><p>服务器开发</p>
</li>
</ul>

        <h3 id="番外"   >
          <a href="#番外" class="heading-link"><i class="fas fa-link"></i></a><a href="#番外" class="headerlink" title="番外"></a>番外</h3>
      
        <h4 id="线程与进程"   >
          <a href="#线程与进程" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h4>
      
        <h4 id="线程与协程"   >
          <a href="#线程与协程" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程与协程" class="headerlink" title="线程与协程"></a>线程与协程</h4>
      <p>:::primary</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/172471249" >什么是协程？</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44575037/article/details/105513014" >协程的概念，为什么要用协程，以及协程的使用</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/zheng199172/article/details/88800275" >什么是协程？</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<ul>
<li>[银弹：协程 + 异步 IO]{.rainbow}</li>
</ul>

        <h5 id="什么是协程？"   >
          <a href="#什么是协程？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是协程？" class="headerlink" title="什么是协程？"></a>什么是协程？</h5>
      
        <h5 id="为什么要使用协程？"   >
          <a href="#为什么要使用协程？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么要使用协程？" class="headerlink" title="为什么要使用协程？"></a>为什么要使用协程？</h5>
      
        <h5 id="协程比线程好在哪里？"   >
          <a href="#协程比线程好在哪里？" class="heading-link"><i class="fas fa-link"></i></a><a href="#协程比线程好在哪里？" class="headerlink" title="协程比线程好在哪里？"></a>协程比线程好在哪里？</h5>
      
        <h2 id="Java-线程基础知识"   >
          <a href="#Java-线程基础知识" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java-线程基础知识" class="headerlink" title="Java 线程基础知识"></a>Java 线程基础知识</h2>
      
        <h3 id="线程实现-1"   >
          <a href="#线程实现-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程实现-1" class="headerlink" title="线程实现"></a>线程实现</h3>
      
        <h4 id="创建线程"   >
          <a href="#创建线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4>
      <p>:::info</p>
<p>① 需要具有 Lambda 表达式和匿名内部类的相关知识</p>
<p>② 采用匿名内部类或者 Lambda 表达式实现的线程在使用外界变量时，那个变量必须是不可变类型的</p>
<p>:::</p>

        <h5 id="extends-Thread"   >
          <a href="#extends-Thread" class="heading-link"><i class="fas fa-link"></i></a><a href="#extends-Thread" class="headerlink" title="extends Thread"></a>extends Thread</h5>
      <ul>
<li>实现过程<ul>
<li>[继承 Thread 类]{.red} <ul>
<li>[extends 关键字实现继承]{.pink}</li>
<li>[匿名内部类实现继承]{.pink}</li>
</ul>
</li>
<li>重写 run 方法<ul>
<li>线程启动后会自动调用 run 方法中的逻辑</li>
<li>线程执行完成 run 方法之后就会自行结束</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前提: 线程是不可以被多次启动的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 采用匿名内部类的方式继承 Thread 类</span></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">&quot;Thread-0&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;Hello, Thread!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//============================</span></span><br><span class="line"><span class="comment">//2 采用 extends 关键字的方式继承 Thread</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Hello, Thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>优点：</p>
<ul>
<li>[可以给线程类任意添加成员变量]{.red}</li>
<li>[可以直接使用 this 关键字获取当前正在执行的线程]{.red}</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>[线程继承 Thread 类之后无法继承其他类]{.green}</li>
<li>[线程和任务存在耦合，同一个类派生的线程对象都只能够执行相同的任务，没有办法执行不同的任务]{.green}</li>
</ul>
</li>
<li><p>线程安全相关：</p>
<ul>
<li><p>核心：[如果构造函数没有引入外界的成员变量，那么继承实现的线程就是线程安全的]{.red}</p>
</li>
<li><p>解释：</p>
<ol>
<li>[传入多个线程对象的构造函数的中的变量可能是相同的，所以构造函数引入外界成员变量有线程安全问题]{.blue}</li>
<li>[没有传入外界变量时，每个线程对象都拥有独立的成员变量，彼此之间不会共享变量，没有共享就不会造成线程安全性问题]{.blue}</li>
</ol>
</li>
<li><p>图示：</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/创建.2vk5pno19c80.png" alt="创建" style="zoom:80%;" /></li>
</ul>
</li>
</ul>

        <h5 id="implements-Runnable"   >
          <a href="#implements-Runnable" class="heading-link"><i class="fas fa-link"></i></a><a href="#implements-Runnable" class="headerlink" title="implements Runnable"></a>implements Runnable</h5>
      <ul>
<li><p>前提：[Runnable 实现方式并不是创建线程类，而是创建线程执行的任务类]{.red}</p>
<ul>
<li>任务类中主要编写线程需要执行的逻辑</li>
<li>线程类主要负责线程自身的资源调度等行为</li>
<li>线程类采用组合的方式使用我们编写的任务类</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员变量</span></span><br><span class="line"><span class="keyword">private</span> Runnable target;</span><br><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果线程对象的构造方法中没有传入任务类, 那么就会执行线程默认的 run 方法</span></span><br><span class="line"><span class="comment">// 如果线程对象的构造方法中传入了任务类, 那么显然执行的就是 target 对象的 run 方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>实现过程</p>
<ul>
<li>[实现 Runnable 接口]{.red}<ul>
<li>implements 关键字实现</li>
<li>Lambda 表达式 / 匿名内部类实现</li>
</ul>
</li>
<li>重写 run 方法</li>
<li>创建 Thread 对象，并将 Runnable 实例传入构造方法中</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前提: 线程是不可以被多次启动的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    // <span class="number">1</span>、采用 Lambda 表达式实现的</span></span></span><br><span class="line"><span class="params"><span class="function">    new Thread(()</span>-&gt;</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Hello, Lambda Thread!&quot;</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;Thread-0&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、线程这里执行的就是任务对象中的 run 方法</span></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnalbe());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=================================</span></span><br><span class="line"><span class="comment">// 2、采用 implements 关键字实现的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Hello, Thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>优点：</p>
<ul>
<li>[任务类可以继续继承或者实现其他类或者接口]{.red}</li>
<li>[线程和任务解耦，每个线程对象可以执行相同的任务也可以执行不同的任务]{.red}</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><p>[无法直接为每个线程添加成员变量]{.green}</p>
</li>
<li><p>[任务类只能够调用 Thread.current 方法来判断当前运行的线程，而无法调用 this 来判断运行的线程]{.green}</p>
<blockquote>
<p>Runnable 只是 Thread 执行的任务而不是线程，显然不能够依靠 this 关键字知道当前正在运行的线程</p>
</blockquote>
</li>
</ul>
</li>
<li><p>线程安全：</p>
<ul>
<li><p>核心：</p>
<ul>
<li>[执行相同任务的线程会共享任务中的变量，从而容易导致线程安全问题]{.red}</li>
<li>[执行不同任务的线程如果在构造函数中引入外界成员变量，也会导致线程安全问题]{.red}</li>
</ul>
</li>
<li><p>图示</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/创建线程-2.1p6cz6fa6ji8.png" alt="创建线程-2" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
<p>:::warning</p>
<p>① 线程安全的相关话题将会在之后的多线程提到</p>
<p>② 总结来说就是继承实现的线程不容易出现线程安全问题，接口实现的线程容易造成线程安全</p>
<p>:::</p>

        <h5 id="implements-Callable-lt-T-gt"   >
          <a href="#implements-Callable-lt-T-gt" class="heading-link"><i class="fas fa-link"></i></a><a href="#implements-Callable-lt-T-gt" class="headerlink" title="implements Callable&lt; T &gt;"></a>implements Callable&lt; T &gt;</h5>
      <ul>
<li><p>前提：Callable 实现方式也不是创建线程类，而是创建线程执行的任务类</p>
</li>
<li><p>实现过程</p>
<ul>
<li>[实现 Callable 接口，确定返回值类型]{.red}<ul>
<li>implements 实现</li>
<li>Lambda 表达式 / 匿名内部类实现 </li>
</ul>
</li>
<li>[重写 call 方法，提供返回值]{.red}</li>
<li>[创建 FutureTask 对象，并将 Callable 实例传入对象的构造函数中，确定返回值类型]{.red}<ul>
<li>FutureTask 对象让调用线程阻塞等待线程执行结束，并且获取返回值</li>
</ul>
</li>
<li>[创建 Thread 对象，并将 FutureTask 实例传入构造函数中]{.red}</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前提: 线程是不可以被多次启动的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1、Lambda 表达式实现: </span></span><br><span class="line">    FutureTask&lt;Boolean&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(()-&gt;&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">new</span> Thread(task, <span class="string">&quot;Thread-3&quot;</span>).start();</span><br><span class="line">    <span class="comment">// 阻塞等待结果</span></span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, task.get());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.2、创建 Callable 实例</span></span><br><span class="line">    MyRunnable runnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    <span class="comment">// 2.3、创建 FutureTask 对象</span></span><br><span class="line">    FutureTask&lt;Boolean&gt; task = <span class="keyword">new</span> FutureTask(runnable);</span><br><span class="line">    <span class="comment">// 2.4、创建线程</span></span><br><span class="line">    <span class="keyword">new</span> Thread(task);</span><br><span class="line">    <span class="comment">// 2.5、接收返回结果</span></span><br><span class="line">    task.get();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=====================</span></span><br><span class="line"><span class="comment">// 2、implements 实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>细节：[Callable 接口和 Runnable 接口本质是一种实现方式]{.blue}</p>
<ul>
<li><p>Thread 实际上是没有能够接受 FutureTask 或者 Callable 类型的构造方法</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>之所以 FutureTask 能够作为参数传递，那只能够是因为它实现了 Runnable 接口</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>所以这两种方式其实本质是相同的</p>
</li>
</ul>
</li>
</ul>

        <h4 id="启动线程"   >
          <a href="#启动线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h4>
      <ul>
<li><p><code>start()</code> 方法</p>
<ul>
<li><p>作用：[线程对象调用 start 方法后就会让虚拟机向操作系统发出请求，创建新的线程]{.pink}</p>
</li>
<li><p>细节：</p>
<ul>
<li>[线程对象不可以重复调用 start 方法，否则会抛出异常]{.red}</li>
<li>[线程对象只有调用 start 方法才会创建线程，只有这个方法才会调用 start0 方法启动线程]{.red}</li>
</ul>
</li>
<li><p>源码：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地方法, 虚拟机会向操作系统申请创建新的线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">// 标记线程是否成功启动</span></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//====================</span></span><br><span class="line">        <span class="comment">// 调用本地方法 start0() 启动线程</span></span><br><span class="line">        start0();</span><br><span class="line">        <span class="comment">// 线程成功启动之后会将标志置为 true</span></span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//====================</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果线程已经启动了, 却再次调用 start 方法会抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p><code>run()</code> 方法</p>
<ul>
<li><p>作用：[线程启动之后默认调用的方法，执行方法内的代码]{.pink}</p>
</li>
<li><p>细节：[调用者可以执行该方法中的代码，但是无法启动线程]{.red}</p>
</li>
<li><p>源码：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 内部根本没有调用 start0 方法，所以也就不会真正意义上的创建新的线程</span></span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>核心区别：[start 能够启动线程而 run 方法是显然不可以的]{.red}</p>
</li>
</ul>

        <h3 id="线程类型"   >
          <a href="#线程类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程类型" class="headerlink" title="线程类型"></a>线程类型</h3>
      <p>:::info</p>
<p>① 线程类型仅分为两种类型：用户线程和守护线程</p>
<p>② 进程类型可以根据特点而分为多种类型：CPU 密集型、IO 密集型、独立进程、协作进程、僵尸进程、孤儿进程</p>
<p>③ 两者的分类是完全不同的，不要搞混淆了</p>
<p>:::</p>
<ul>
<li><p>用户线程：</p>
<ul>
<li>定义：默认创建的所有线程都是用户线程</li>
<li>特点：[虚拟机会等待所有用户线程都结束之后才会停止运行]{.red}</li>
</ul>
</li>
<li><p>守护线程</p>
<ul>
<li>定义：为用户线程提供服务的被称为守护线程</li>
<li>特点：[虚拟机不会等待所有守护线程结束才停止，只要所有用户线程结束虚拟机就停止]{.red}</li>
</ul>
</li>
<li><p>测试</p>
<ul>
<li>测试用户线程：</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.daemon&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDaemon</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Thread user = <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">				<span class="comment">// 空循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        user.start();</span><br><span class="line">		<span class="comment">// 测试结果：主线程都结束了，但是虚拟机依然没有停止</span></span><br><span class="line">        log.debug(<span class="string">&quot;主线程结束...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>测试守护线程</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.daemon&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDaemon</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Thread daemon = <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        daemon.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        daemon.start();</span><br><span class="line">		<span class="comment">// 测试结果：虚拟机在主线程停止之后立刻就停止了</span></span><br><span class="line">        log.debug(<span class="string">&quot;主线程结束...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

</li>
</ul>

        <h3 id="线程状态"   >
          <a href="#线程状态" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3>
      <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/Java-线程状态.2fk56yodgvgg.png" alt="Java-线程状态" style="zoom:80%;" />

<ul>
<li><p>前提：</p>
<ul>
<li>[OS 给线程定义了五种基本状态]{.red}</li>
<li>[Java 在 OS 的基础上重新给线程定义了六种基本状态]{.red}</li>
</ul>
</li>
<li><p>基本状态：</p>
<ul>
<li>NEW（初始态）：[线程对象没有调用 start 方法启动时的状态]{.green}</li>
<li>RUNNABLE（运行态）：[包含线程准备运行、线程正在运行、线程被 IO 阻塞三种状态]{.blue}<ul>
<li>虚拟机无法区分线程是处于运行态还是处于就绪态，所以将这两种都划分为 Runnable</li>
<li>虚拟机也不知道被 IO 阻塞的线程是否可以运行，所以也认为是 Runnable</li>
</ul>
</li>
<li>TIMED_WAITING（有限等待态）：[线程因为方法调用而陷入的有限期等待，一定时间后会由虚拟机唤醒]{.orange}</li>
<li>WAITING（无限等待态）：[线程因为方法调用而陷入的无限期等待]{.pink}</li>
<li>BLOCKED（阻塞态）：[线程因为无法获取到锁而陷入的阻塞状态]{.aqua}</li>
<li>TERMINATED（终止态）：[线程执行完成 run 方法之后的状态]{.gray}</li>
</ul>
</li>
<li><p>状态转换</p>
<ul>
<li>[NEW =&gt; RUNNABLE：仅有 start 方法可以实现]{.red}</li>
<li>[RUNNABLE =&gt; WAITING：wait、join、park]{.red}<ul>
<li>WAITING =&gt; RUNNABLE：notify / notifyAll，等待的线程结束、unpark</li>
</ul>
</li>
<li>[RUNNABLE =&gt; TIMED_WAITING：wait、join、park、sleep]{.red}<ul>
<li>TIMED_WAITING =&gt; RUNNABLE：限定时间结束之后，虚拟机主动唤醒线程</li>
</ul>
</li>
<li>[RUNNABLE =&gt; BLOCKED：线程竞争锁失败]{.red}<ul>
<li>BLOCKED =&gt; RUNNABLE：线程竞争锁成功并且开始运行</li>
<li>常见锁：synchronized、ReentrantLock、ReentrantReadWriteLock</li>
</ul>
</li>
<li>[RUNNABLE =&gt; TERMINATED：线程执行结束]{.red}</li>
</ul>
</li>
<li><p>测试线程状态</p>
<ul>
<li>代码</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试线程的六种状态</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.ThreadState&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadState</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// NEW 状态: 没有调用 start 方法</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;log.debug(<span class="string">&quot;初始态...&quot;</span>);&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RUNNABLE 状态: 调用 start 方法后线程开始运行的状态</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TERMINATED 状态: 线程先于主线程结束, 就能够看到结束态</span></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;log.debug(<span class="string">&quot;&quot;</span>); &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TIMED_WAITING 状态: 线程陷入休眠, 一段时间后想来\</span></span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// WAITING 状态: 等待其余线程结束的时候可以看到等待状态</span></span><br><span class="line">        Thread t5 = <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ThreadState.class)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t4.join();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BLOCKED 状态: 获取陷入等待状态的线程持有的锁, 就能够看到阻塞态</span></span><br><span class="line">        Thread t6 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ThreadState.class)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动所有线程</span></span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">        t5.start();</span><br><span class="line">        t6.start();</span><br><span class="line">        <span class="comment">// 主线程休眠</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印状态</span></span><br><span class="line">        log.debug(<span class="string">&quot;t1 state: &#123;&#125;&quot;</span>, t1.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t2 state: &#123;&#125;&quot;</span>, t2.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t3 state: &#123;&#125;&quot;</span>, t3.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t4 state: &#123;&#125;&quot;</span>, t4.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t5 state: &#123;&#125;&quot;</span>, t5.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t6 state: &#123;&#125;&quot;</span>, t6.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>结果</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/测试线程状态.1g41tslp9cu8.png" alt="测试线程状态" style="zoom:80%;" /></li>
</ul>

        <h3 id="线程优先级"   >
          <a href="#线程优先级" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3>
      
        <h3 id="线程调度-1"   >
          <a href="#线程调度-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程调度-1" class="headerlink" title="线程调度"></a>线程调度</h3>
      <ul>
<li>核心：<ul>
<li>[Java 线程采用的是内核级线程实现的，内核级线程通常都是采用抢占式调用]{.red}</li>
<li>[抢占式调用的执行时间由 OS 控制而不受程序员的控制，所以 Java 线程几乎不可控]{.red}</li>
</ul>
</li>
<li>细节：[线程的优先级和 Yield 方法几乎都只能向 OS 建议优先调度某些线程，而没有办法强行控制]{.red}</li>
</ul>

        <h3 id="线程协作"   >
          <a href="#线程协作" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h3>
      <p>:::primary</p>
<p>线程协作的常用方法也会在之后的笔记中讲述</p>
<p>:::</p>

        <h3 id="线程同步"   >
          <a href="#线程同步" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3>
      <p>:::primary</p>
<p>线程同步的相关内容在多线程基础中讲述，需要理解线程安全之后才能够理解为什么需要线程同步</p>
<p>:::</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/28/os/process/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/">进程同步</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-28</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h3 id="进程同步"   >
          <a href="#进程同步" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3>
      <p><a style="color:red;">前提：基于单核处理器的前提讨论进程的同步</a></p>

        <h4 id="同步概述"   >
          <a href="#同步概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#同步概述" class="headerlink" title="同步概述"></a>同步概述</h4>
      <ul>
<li><p>引入：</p>
<ul>
<li><p>问题：</p>
<ul>
<li><p>进程协作时需要相互通信；进程通信方式通常有两种：==消息传递 + 共享内存==</p>
</li>
<li><p>共享内存方式涉及多个进程对公共区域的操作</p>
<p>  -&gt; 多个进程可能 ==同时== 对公共区域进行操作，造成公共区域的 ==数据不一致性== （==并行==）</p>
<p>  ​     解释：进程 A 正在对公共区域进行写操作，进程 B 同时对公共区域进行读操作，那么读出来的数据和存储的数据很可能不一致</p>
<p>  -&gt; 某个进程正在对公共区域进行操作，另一个进程 ==抢占== 当前进程的处理器使用权，造成公共区域的 ==数据不一致性== （==并发==）</p>
<p>  ​     解释：进程 A 执行计算后得到相应的数据打算向公共区域中写入，进程 B 直接抢占处理器的使用权，导致进程 A 无法写入，那么读出来的</p>
<p>  ​               数据也会和将要存储的数据不一致</p>
<p>  <a style="color:red;">进程的并行和并发都有可能造成公共区域的不一致性</a></p>
</li>
</ul>
</li>
<li><p>方式：==同步== -&gt; 利用机制确保各个协作进程之间按照规定的顺序执行 / 利用机制确保各个协作进程不会 ==并发== 操作公共资源</p>
<p>  <a style="color:red;">1. 同步的核心就是对公共区域上锁</a></p>
<p>  解释：某个进程正在操作公共区域时，其余的进程只能够按照顺序依次等待执行，相当于对当前的公共区域上锁了</p>
<p>  <a style="color:red;">2. 进程同步并不代表调度算法是非抢占式的</a></p>
<p>  解释：每个进程并不仅仅只是对公共区域操作，某个进程对公共区域操作结束后，仍然可能继续操作其他的数据</p>
<p>  ​          非抢占式就可以允许当前进程继续执行，抢占式就会允许其他进程开始对公共区域操作，因为已经有进程在等待操作公共区域了</p>
</li>
<li><p>细节：<a style="color:red;">单核处理器通常在修改变量时禁止中断打断当前进程的执行；多核处理器通常是采用同步方式解决</a></p>
<p>  注：多核处理器需要对每个计算核都禁止中断，是非常低效的行为</p>
</li>
</ul>
</li>
<li><p>概念：</p>
<ul>
<li><p>==竞争条件==：多个进程并发访问和操作同一数据并且执行结果 ==和特定访问顺序有关== 的情况</p>
  <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 利用生产者消费者问题进行解释</span></span><br><span class="line"><span class="comment">2. 笔记中此前使用循环队列解决生产者消费者问题，导致缓冲区容量始终少 1</span></span><br><span class="line"><span class="comment">3. 在这里加以改进使用公共变量 counter 来记录缓冲区数据项的数量</span></span><br><span class="line"><span class="comment">4. 正是因为使用公共变量 counter 就会导致竞争条件的出现</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>

  <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 counter 默认值为 5 </span></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">while</span> (counter == BUFFER_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果公共变量等于缓冲区大小证明缓冲区已满 -&gt; 生产者进入空循环中等待 -&gt; 直到缓冲区不满为止</span></span><br><span class="line">    &#125;</span><br><span class="line">    buffer[in] = next_produced; </span><br><span class="line">    in = (in + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    1. 生产者生产完数据项之后 -&gt; 修改自己寄存器中数据项数量的值</span></span><br><span class="line"><span class="comment">    2. 此时消费者想要对缓冲区进行读取 -&gt; 处理器切换至消费者 -&gt; 此时生产者还没来得及对公共变量做出修改</span></span><br><span class="line"><span class="comment">    3. 生产者寄存器中的值显然是 6，但是公共变量仍然是 5</span></span><br><span class="line"><span class="comment">    ---------------------------------------------------------&gt; 消费者进程执行结束</span></span><br><span class="line"><span class="comment">    生产者继续执行 -&gt; 将寄存器的值赋给公共变量 -&gt; 此时公共变量显然为 6 ！</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    counter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

  <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">while</span> (counter == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果公共变量等于0证明缓冲区中没有数据项 -&gt; 消费者进入空循环等待 -&gt; 直到缓冲区中存在数据项为止</span></span><br><span class="line">    &#125;</span><br><span class="line">    next_consumed = buffer[out]; </span><br><span class="line">    out = (out + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 消费者消费完数据项后 -&gt; 修改自己寄存器中的数据项的值</span></span><br><span class="line"><span class="comment">    2. 生产者进程想要继续执行 -&gt; 处理器切换至生产者 -&gt; 此时消费者也没有来得及对公共变量做出修改</span></span><br><span class="line"><span class="comment">    3. 消费者寄存器的值显然是 4 ！但是公共变量仍然为 5</span></span><br><span class="line"><span class="comment">    ---------------------------------------------------------&gt; 生产者进程执行结束</span></span><br><span class="line"><span class="comment">    消费者进程继续执行 -&gt; 将寄存器中的值赋给公共变量 -&gt; 此时公共变量显然为 4 (6 -&gt; 4)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    counter--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">总结：由于生产者进程 -&gt; 消费者进程 -&gt; 生产者进程 -&gt; 消费者进程 这种执行顺序导致了公共变量的不一致</span></span><br><span class="line"><span class="comment">	 如果不允许进程对公共区域进行并发操作，那么顺序显然就是 生产者进程 -&gt; 消费者进程，不会造成公共变量的不一致</span></span><br><span class="line"><span class="comment">	 这种类似的情况都称之为竞争条件，执行的结果和特定的顺序有关</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure></li>
<li><p>代码区域</p>
<ul>
<li><p>进入区：判断进程是否可以进入临界区的代码段 + 对临界资源上锁的代码段（如果进程可以进入）</p>
<p>  <a style="color:red;">进程被允许进入临界区后需要对临界资源上锁；不被允许进入临界区的进程应该位于进入区等待</a></p>
</li>
<li><p>==临界区==：对共享区域进行访问的 ==代码段==</p>
<p>  <a style="color:red;">临界区中只允许存在一个进程</a></p>
<p>  <em>注：同步可以说是解决进程通信的问题，也可以说就是解决临界区的实现问题，怎么才能够确保临界区中只存在一个进程</em></p>
</li>
<li><p>退出区：释放临界资源的锁的代码段</p>
<p>  <a style="color:red;">进程结束对临界资源的使用后需要对释放临界资源的锁</a></p>
</li>
<li><p>剩余区：进程需要执行的剩余代码段</p>
</li>
</ul>
<p>  <img src="https://i1.xpic.jp/file/xpicjp/2021/05/24/46b5aefd6a79c95d28b25e767c1d14c4.png" alt="46b5aefd6a79c95d28b25e767c1d14c4.png"></p>
</li>
<li><p>同步条件：</p>
<ul>
<li><p>互斥(mutual exclusion)：临界区中存在进程正在执行，==不允许== 其余进程进入临界区执行</p>
</li>
<li><p>进步(progress)：想进入临界区的进程可以 ==参与选择进入== ，不想要进入临界区的进程不允许进入</p>
</li>
<li><p>有限等待(bounded waiting)：想进入临界区的进程不能 ==无限地等待== 下去</p>
<p>  解释：因为可能存在多个进程同时在进入区中等待，需要避免某个进程始终在等待进入临界区</p>
</li>
</ul>
<p>  <a style="color:red;">每个同步方式都应该满足这三个条件 -&gt; 同步方式的进入区和退出区必须满足这三个条件</a></p>
<p>  解释：因为进入区和退出区才是控制进程进入临界区的关键，临界区只是对公共区域操作的代码而已</p>
</li>
</ul>
</li>
</ul>

        <h4 id="同步方式"   >
          <a href="#同步方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h4>
      
        <h5 id="软件同步"   >
          <a href="#软件同步" class="heading-link"><i class="fas fa-link"></i></a><a href="#软件同步" class="headerlink" title="软件同步"></a>软件同步</h5>
      
        <h6 id="Peterson"   >
          <a href="#Peterson" class="heading-link"><i class="fas fa-link"></i></a><a href="#Peterson" class="headerlink" title="Peterson"></a>Peterson</h6>
      <ul>
<li><p>内容：</p>
<ul>
<li><p><code>boolean[] flag</code>：想要进入临界区的进程都将其在数组中的对应位置置为 <code>true</code></p>
<p>  注：想要进入临界区的进程将标志位置为 <code>true</code> 并不代表一定能够进入，必须要另外一个进程 “谦让” 自己才可以进入</p>
</li>
<li><p><code>int turn</code>：表示当前进程优先让另一个进程执行</p>
<p>  解释：这个参数最好不要理解成轮到哪个进程进入临界区的意思，否则可能算法理解会有问题</p>
</li>
</ul>
</li>
<li><p>适用情况：<a style="color:red;">仅适用于两个进程的同步方式</a></p>
</li>
<li><p>代码：</p>
  <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. pid 表示执行该代码段的进程的进程标识符，opid 表示另一个进程的进程标识符</span></span><br><span class="line"><span class="comment">2. opid = 1 -pid；这也就是为什么 Peterson 方式只适用于两个进程，要是再多来一个进程就会把它当成第一个进程 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">synchronize</span><span class="params">(<span class="keyword">int</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. 代表进程标识符为 pid 的进程想要进入临界区</span></span><br><span class="line">		flag[pid] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 2. 当前进程希望让另一个进程优先进入临界区 (或者理解为询问另一个进程是否想要进入临界区)</span></span><br><span class="line">        turn = opid; </span><br><span class="line">        <span class="comment">// 3. 此时由于当前进程希望另一个进程优先进入临界区，那么剩下的显然就看另一个进程自己是否想要进入了</span></span><br><span class="line">        <span class="comment">// -&gt; 如果另一个进程想要进入，那么显然当前进程就必须进入循环进行空等待 (如果另一个进程想要进入，那么证明另一个进程显然是先来的)</span></span><br><span class="line">        <span class="comment">// -&gt; 如果另一个进程不想进入，那么显然当前进程可以直接进入临界区</span></span><br><span class="line">        <span class="keyword">while</span>(flag[opid] &amp;&amp; turn == opid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 空等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 临界区 */</span></span><br><span class="line">        flag[pid] = <span class="literal">false</span>; <span class="comment">// 退出区</span></span><br><span class="line">        <span class="comment">/* 剩余区 */</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

</li>
</ul>

        <h5 id="硬件同步"   >
          <a href="#硬件同步" class="heading-link"><i class="fas fa-link"></i></a><a href="#硬件同步" class="headerlink" title="硬件同步"></a>硬件同步</h5>
      <p><a style="color:red;">注：这里用 C 语言代替汇编指令集表示，仅仅只是一种抽象，落实到不同的指令集上是不同的</a></p>

        <h6 id="TestAndSet"   >
          <a href="#TestAndSet" class="heading-link"><i class="fas fa-link"></i></a><a href="#TestAndSet" class="headerlink" title="TestAndSet"></a>TestAndSet</h6>
      <ul>
<li><p>内容：<code>bool *lock</code>：每个进程都可以操作的全局变量；初始化为 <code>false</code></p>
</li>
<li><p>适用情况：<a style="color:red;">适用于多个进程的同步方式</a></p>
</li>
<li><p>缺陷：<a style="color:red;">没有满足有限等待的条件？</a></p>
</li>
<li><p>代码：</p>
  <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 进入函数后先将当前锁的值记住</span></span><br><span class="line"><span class="comment">2. 无论当前锁的值为什么，都修改为 true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">testAndSet</span><span class="params">(<span class="keyword">bool</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">bool</span> temp = *lock;</span><br><span class="line">   *lock = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 返回锁之前的值；锁的值为 false 就代表临界资源没有上锁，锁的值为 true 就代表邻接资源上锁</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">synchronize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;	<span class="comment">// 1. 只要当前的锁为 false，就证明没有进程在临界区中，当前进程就可以进入临界区</span></span><br><span class="line">        <span class="comment">// 2. 其余进程想要进入临界区时，拿到锁的值为 true，所以函数返回的值也为 true，无法进入临界区中</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">testAndSet</span>(&amp;lock))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 空等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 临界区 */</span></span><br><span class="line">        lock = <span class="literal">false</span>; <span class="comment">// 退出区；3. 当前进程退出临界区后，修改锁的值，其余进程就可以进入了</span></span><br><span class="line">        <span class="comment">/* 剩余区 */</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h6 id="Swap"   >
          <a href="#Swap" class="heading-link"><i class="fas fa-link"></i></a><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h6>
      <ul>
<li><p>内容：</p>
<ul>
<li><code>bool *key</code>：用于和 <code>lock</code> 进行交换，判断当前临界区中是否存在进程 <a style="color:red;">局部变量</a></li>
<li>``bool *lock<code>：每个进程都可以操作的 &lt;a style=&quot;color:red;&quot;&gt;全局变量&lt;/a&gt;；初始化为 </code>false`</li>
</ul>
</li>
<li><p>适用情况：<a style="color:red;">适用于多个进程的同步方式</a></p>
</li>
<li><p>缺陷：<a style="color:red;">(1) 没有满足有限等待的条件？</a> (2) 实现非常的复杂</p>
</li>
<li><p>代码</p>
  <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span> <span class="params">(<span class="keyword">bool</span> *a, <span class="keyword">bool</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    boolean temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">synchronize</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. 默认临界区中是存在进程的所以才会初始化为 true</span></span><br><span class="line">        key = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 2. 锁的值和 key 的值交换：</span></span><br><span class="line">            <span class="comment">// -&gt; 如果锁的值为 false，那么交换后 key 显然也是 false，那么就证明临界区中不存在进程</span></span><br><span class="line">            <span class="comment">// -&gt; 如果锁的值为 true，那么交换后 key 仍然会为 true，那么会当前进程会继续交换</span></span><br><span class="line">            <span class="built_in">Swap</span>(&amp;lock, &amp;key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 临界区 */</span></span><br><span class="line">        lock = <span class="literal">false</span>; <span class="comment">// 退出区</span></span><br><span class="line">        <span class="comment">/* 剩余区 */</span></span><br><span class="line">    &#125;             </span><br><span class="line">&#125;     </span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h6 id="中断屏蔽"   >
          <a href="#中断屏蔽" class="heading-link"><i class="fas fa-link"></i></a><a href="#中断屏蔽" class="headerlink" title="中断屏蔽"></a>中断屏蔽</h6>
      
        <h5 id="互斥锁"   >
          <a href="#互斥锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h5>
      <ul>
<li>内容</li>
<li>优点 &amp; 缺点：<ul>
<li>优点：相比于硬件同步实现非常简单</li>
<li>缺点：<a style="color:red;">忙等待</a></li>
</ul>
</li>
<li>代码：</li>
</ul>

        <h5 id="信号量"   >
          <a href="#信号量" class="heading-link"><i class="fas fa-link"></i></a><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5>
      <ul>
<li><p>定义：信号量是只能够通过 <code>wait()</code> + <code>signal()</code> 操作的 ==整型== 公共变量</p>
<p>  <a style="color:red;">1. 信号量初始值为 1</a></p>
<p>  <a style="color:red;">2. wait 函数用于实现进入区；signal 函数用于实现退出区</a></p>
  <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(S &lt;= <span class="number">0</span>) <span class="comment">// 你可能会在这里产生疑问，信号量的值怎么为负的呢？明显只要有一个进程在临界区，S 就只能够为 0 呀？之后会解释</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 空等待</span></span><br><span class="line">    &#125;</span><br><span class="line">    S--; <span class="comment">// 因为进程进入临界区了，所以信号量需要减少</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

  <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S++;<span class="comment">// 代表当前进程退出临界区，所以信号量需要增加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>分类：</p>
<ul>
<li><p>二进制信号量：信号量的值 ==只能== 够为 1 和 0</p>
<p>  <a style="color:red;">二进制信号量类似于互斥锁同步方式</a></p>
</li>
<li><p>计数信号量：信号量的值等于公共资源的数量（信号量的值可以为 ==大于等于 0 的整数== ）</p>
<p>  <a style="color:red;">信号量减少到 0 的时候证明当前公共资源的数量被分配完了，没有多的可以让其余进程操作了</a></p>
</li>
</ul>
</li>
<li><p>实现：</p>
<ul>
<li><p>普通实现</p>
<p>  <a style="color:red;">普通实现和互斥锁是一样的；并且同样拥有忙等待的问题</a></p>
  <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">synchronize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        wait(mutex); <span class="comment">// 进入区</span></span><br><span class="line">        <span class="comment">/* 临界区 */</span></span><br><span class="line">        signal(mutex); <span class="comment">// 退出区</span></span><br><span class="line">        <span class="comment">/* 剩余区 */</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>改进实现</p>
<p>  <a style="color:red;">改进实现后忙等待的概率变小了</a></p>
  <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mutex;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">list</span>;</span></span><br><span class="line">&#125;<span class="function">semaphore</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(semaphore *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	S-&gt;value--;</span><br><span class="line">	<span class="keyword">if</span> (S-&gt;value &lt; <span class="number">0</span>) </span><br><span class="line">    &#123; </span><br><span class="line">		add <span class="keyword">this</span> process to S-&gt;List;</span><br><span class="line">        block(); <span class="comment">// 让当前进程进入阻塞态</span></span><br><span class="line">	&#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">(semaphore *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S-&gt;value++;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;value &lt;= <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        remove a process P from S-&gt;List;</span><br><span class="line">        wakeup(P); <span class="comment">// 让当前进程进入就绪态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>

        <h4 id="经典同步问题"   >
          <a href="#经典同步问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h4>
      
        <h5 id="生产者-消费者问题"   >
          <a href="#生产者-消费者问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h5>
      
        <h5 id="读者-写者问题"   >
          <a href="#读者-写者问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h5>
      
        <h5 id="哲学家就餐问题"   >
          <a href="#哲学家就餐问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h5>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/28/os/process/%E8%BF%9B%E7%A8%8B%E6%AD%BB%E9%94%81/">进程死锁</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-28</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h3 id="进程死锁"   >
          <a href="#进程死锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程死锁" class="headerlink" title="进程死锁"></a>进程死锁</h3>
      
        <h4 id="死锁概述"   >
          <a href="#死锁概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#死锁概述" class="headerlink" title="死锁概述"></a>死锁概述</h4>
      <ul>
<li><p>定义：同组中的 ==每个进程== 正在等待某个 ==只能够由同组其他进程== 执行的事件发生，称 ==操作系统== 处于死锁状态</p>
<p>  <a style="color:red;">死锁指的是操作系统的状态而不是某个进程的状态</a></p>
</li>
<li><p>==必要条件==</p>
<ul>
<li><p>条件内容：</p>
<ul>
<li>互斥(mutual exclusion)：==至少存在一个== 资源实例 ==不能共享==</li>
<li>持有并等待(hold and wait)：拥有进程的资源申请新的资源时 ==必须等待该资源的释放==</li>
<li>不可抢占(no preemption)：被其他进程使用的资源不可以被抢占使用</li>
<li>循环等待(circular wait)： 存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源</li>
</ul>
<p>  <img src="https://i1.xpic.jp/file/xpicjp/2021/05/26/4d0ac0dd7ecf5358a72c5cae66cb6a61.png" alt="4d0ac0dd7ecf5358a72c5cae66cb6a61.png"></p>
</li>
<li><p>细节：<a style="color:red;">四个条件是死锁发生的必要条件而不是充分条件</a></p>
<p>  解释：死锁发生时必定满足上述四个条件；四个条件同时存在时不能保证死锁一定发生，可能还需要更多的条件</p>
<p>  <a style="color:red;">注：不满足四个条件中的其中之一就不可能发生死锁</a></p>
</li>
</ul>
</li>
<li><p>资源：</p>
<ul>
<li><p>资源分类：</p>
</li>
<li><p>资源实例</p>
</li>
<li><p>资源分配图</p>
<ul>
<li>边：分配边 + 申请边</li>
<li>点：进程节点 + 资源节点</li>
<li>资源实例：每个资源中的原点</li>
</ul>
<p>  <a style="color:red;">单实例资源图中存在环一定会导致死锁发生；多实例资源图中存在环不一定导致死锁发生</a></p>
<p>  <img src="https://i1.xpic.jp/file/xpicjp/2021/05/26/9fb25f2b47b8d709f57518079094e271.png" alt="9fb25f2b47b8d709f57518079094e271.png"></p>
</li>
</ul>
</li>
</ul>

        <h4 id="死锁处理"   >
          <a href="#死锁处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#死锁处理" class="headerlink" title="死锁处理"></a>死锁处理</h4>
      
        <h5 id="死锁预防-amp-避免"   >
          <a href="#死锁预防-amp-避免" class="heading-link"><i class="fas fa-link"></i></a><a href="#死锁预防-amp-避免" class="headerlink" title="死锁预防 &amp; 避免"></a>死锁预防 &amp; 避免</h5>
      <ul>
<li>定义：制定相应的 ==协议或者规则== 阻止死锁的发生</li>
</ul>

        <h6 id="死锁预防"   >
          <a href="#死锁预防" class="heading-link"><i class="fas fa-link"></i></a><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h6>
      <ul>
<li><p>核心：<a style="color:red;">直接确保四个必要条件至少一个不发生</a></p>
</li>
<li><p>方式：</p>
<ul>
<li><p>阻止互斥：<a style="color:red;">允许资源被进程共享</a></p>
<p>  注：通过阻止互斥发生来预防死锁是不现实的 -&gt; <a style="color:red;">大多数的资源都是不共享的</a></p>
</li>
<li><p>阻止持有并等待：</p>
<ul>
<li><p>两种方式：</p>
<ol>
<li><p><a style="color:red;">每个进程在进入处理器执行前申请并获得所有需要的资源</a></p>
<p> 解释：不允许在执行过程中再申请资源，即使释放资源再申请也不行</p>
</li>
<li><p><a style="color:red;">每个进程在执行过程中申请资源必须先释放拥有的资源</a></p>
<p> 解释：并不需要在执行前就获取所有资源，只不过再次申请资源前需要先释放拥有的资源</p>
</li>
</ol>
</li>
<li><p>缺陷：</p>
<ol>
<li><p>进程 ==长时间占用== 某种资源但是暂时并没有使用</p>
</li>
<li><p>进程申请的资源被其余进程占用导致进程处于 ==饥饿状态==</p>
<p> 注：饥饿和死锁是有区别的</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>阻止不可抢占：某个进程在申请资源后没有得到满足就必须 ==释放拥有的资源== 提供给其他进程使用</p>
<p>  解释：因为当前进程没有获得必需的资源那么就无法运行，那么进程当前拥有的资源也是没有意义的，就应该允许其余进程抢占（释放）</p>
<p>  <a style="color:red;">注：阻止不可抢占容易导致释放资源的进程丢失之前的任务进度（处理器和寄存器可以），进程间反复的相互抢占资源会导致进程的执行被无限推迟</a></p>
</li>
<li><p>阻止循环等待：每个资源递增编号，每个进程只能按照编号的顺序 ==递增申请== 每项资源</p>
<p>  解释：P<del>1</del> 拥有资源 R<del>1</del> 后才可以申请 R<del>2</del>，获得 R<del>2</del> 之后才可以申请 R<del>3</del>；P<del>2</del> 如果拥有 R<del>3</del> ，此时是不允许申请 R<del>1</del>，除非释放 R<del>3</del> 资源</p>
<p>  <a style="color:red;">1. 进程只可以顺序申请比自己拥有的资源编号大的资源；如果申请资源编号小的，必须释放自己拥有的资源</a></p>
<p>  2 资源的编号必须尽可能考虑到资源使用的顺序，否则会出现先申请编号较大的资源，再申请编号较小的资源的情况 -&gt; 资源利用效率较低</p>
<p>  <img src="https://i1.xpic.jp/file/xpicjp/2021/05/26/a50e2bf8e69302e79e11dd128c00064e.png" alt="a50e2bf8e69302e79e11dd128c00064e.png"></p>
</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li>四种方式只需要采用一种就可以防止死锁的发生</li>
<li><a style="color:red;">可以确保操作系统永远不会出现死锁的状态 &lt;-&gt; 导致操作系统效率变低</a></li>
</ul>
</li>
</ul>

        <h6 id="死锁避免"   >
          <a href="#死锁避免" class="heading-link"><i class="fas fa-link"></i></a><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h6>
      <ul>
<li><p>定义：每个进程交付 ==必要信息== 给操作系统，操作系统利用相应的算法 ==动态检查== 资源分配的状态</p>
<p>  必要信息：进程需要申请的资源，想要如何申请资源…</p>
</li>
<li><p>核心：<a style="color:red;">利用死锁算法避免死锁的发生</a></p>
</li>
<li><p>安全状态：操作系统可以按照 ==特定的顺序== 为进程分配资源并且避免死锁发生，称操作系统处于 ==安全状态==</p>
<ul>
<li><p>解释：每个进程需要按照特定的顺序执行，即等待其余进程执行结束释放资源后再继续执行 -&gt; &lt;P<del>0</del> P<del>1</del> P<del>2</del>&gt; =&gt; &lt;P<del>1</del> P<del>2</del> P<del>0</del>&gt;(执行顺序)</p>
</li>
<li><p>安全序列：进程执行的特定顺序就是安全序列 &amp; 非安全状态：不存在这样的特定序列</p>
</li>
<li><p><a style="color:red;">安全状态不会安全状态一定不会出现死锁状态</a></p>
</li>
<li><p><a style="color:red;">非安全状态不一定导致死锁状态；死锁状态一定属于非安全状态</a></p>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/196811537.html?qbl=relate_question_0&word=%B7%C7%B0%B2%C8%AB%D7%B4%CC%AC%BA%CD%CB%C0%CB%F8%D7%B4%CC%AC" >死锁和非安全状态</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</li>
</ul>
<p>  <img src="https://i1.xpic.jp/file/xpicjp/2021/05/26/600acd2964e4bf2de660adb3e4e69f6f.png" alt="600acd2964e4bf2de660adb3e4e69f6f.png"></p>
</li>
<li><p>算法：</p>
<ul>
<li><p>资源分配图法：<a style="color:red;">仅适用于单实例的资源</a></p>
<ul>
<li><p>核心：引入 ==需求边==：需求边表示进程在将来某个时刻可能会需要的资源</p>
</li>
<li><p>规定：进程在执行前在图中的所有边都是需求边；进程在获取到相应资源后由 ==需求边转为分配边== ；进程结束后 ==分配边再次变为需求边==</p>
</li>
<li><p>检测：如果需求边在转为分配边后会产生环，那么操作系统就不会给当前的进程分配该资源</p>
<p>  <a style="color:red;">检测环是否存在可以使用拓扑排序检测</a></p>
</li>
</ul>
<p>  <img src="https://i1.xpic.jp/file/xpicjp/2021/05/26/213310f2ad02a48c56f77269f427c5b4.png" alt="213310f2ad02a48c56f77269f427c5b4.png"></p>
</li>
<li><p>银行家算法：<a style="color:red;">适用于多实例的资源</a></p>
<ul>
<li><p>数据结构：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Available[n]</code></td>
<td>该数组每个元素表示每种不同类型资源的 ==可分配== 的资源实例数量</td>
</tr>
<tr>
<td><code>Max[n][m]</code></td>
<td>该数组第一个参数表示每个不同的进程；第二个参数表示每个进程正常运行需要的每种类型的 ==全部== 资源实例数</td>
</tr>
<tr>
<td><code>Allocation[n][m]</code></td>
<td>该数组第一个参数表示每个不同的进程；第二个参数表示每个进程 ==已经被分配== 的每种类型的资源实例数</td>
</tr>
<tr>
<td><code>Need[n][m]</code></td>
<td>该数组第一个参数表示每个不同的进程；第二个参数表示每个进程 ==还需要== 的每种类型的资源实例数</td>
</tr>
</tbody></table></div>
<p>  <a style="color:red;">Need = Max - Allocation；之后提到的 Request 并不是 Need</a></p>
</li>
<li><p>安全性算法</p>
<ol>
<li><p>定义并初始化变量：</p>
<p> 定义 <code>Work[]</code> &amp; <code>Finish[]</code> 数组；令 <code>Work = Available</code> &amp; <code>Finish[i] = false (i=0,1,2...n)</code></p>
<p> 问题：为什么不直接使用 <code>Availalbe</code> 变量?</p>
</li>
<li><p>循环遍历进程集合，判断进程还需要的资源实例数和可分配的资源实例数的关系</p>
<ul>
<li><p><code>Finish[i] = true</code> 证明该进程已经执行过并且结束了，开始遍历下一个进程</p>
</li>
<li><p><code>Finish[i] = false</code>  </p>
<p>  <code>Need[i]</code> ≤ <code>Work[i]</code> 就执行第 3 步</p>
<p>  <code>Need[i]</code> ＞ <code>Work[i]</code> 就略过当前进程，开始遍历下一个进程</p>
</li>
<li><p>如果没有下一个进程可以遍历了就执行第 4 步</p>
</li>
</ul>
</li>
<li><p>进程获取资源并执行，执行结束后释放资源</p>
</li>
</ol>
<pre><code>`Work[i] = Work[i] + Allocation[i]` 更新当前可以分配的资源实例数

`Finish[i]` = `true`
</code></pre>
<ol start="4">
<li>如果 <code>Finish[]</code> 数组中所有元素都为 <code>true</code>，证明系统处于安全状态；如果存在至少一个 <code>false</code> 元素，证明系统处于不安全状态</li>
</ol>
</li>
<li><p>资源分配算法</p>
<ul>
<li><p>引入：</p>
<p>  安全性算法只能够判断进程依靠当前拥有的资源是否可以正常执行</p>
<p>  如果进程需要更多的资源才能够正常进行，显然就需要申请资源，那么安全性算法显然就是不够用的</p>
</li>
<li><p>过程：引入变量 <code>Request[n]</code>：表示当前进程申请的每种类型的资源实例数量</p>
<ol>
<li>判断进程 ==申请== 的资源实例数量和 ==还需要== 的资源实例数量<ul>
<li><code>Request[i]</code> ≤ <code>Need[i]</code> 就执行第 2 步</li>
<li><code>Request[i]</code> ＞ <code>Need[i]</code> 将会提示出错；进程申请的资源实例数量超过了正常执行还需要的资源实例数</li>
</ul>
</li>
<li>判断进程 ==申请== 的资源实例数量和 ==可分配== 的资源实例数量<ul>
<li><code>Request[i]</code> ≤ <code>Available[i]</code> 就执行第 3 步</li>
<li><code>Request[i]</code> ＞ <code>Available[i]</code> 证明当前可分配资源不足以支撑进程的执行，该进程就需要 ==等待==</li>
</ul>
</li>
<li>操作系统 ==假设== 分配给进程相应的资源实例数量<ul>
<li><code>Available[i]</code> = <code>Available[i]</code> - <code>Request[i]</code></li>
<li><code>Need[i]</code> = <code>Need[i]</code> - <code>Request[i]</code></li>
<li><code>Allocation[i]</code> = <code>Allocation[i]</code> + <code>Request[i]</code></li>
</ul>
</li>
<li><a style="color:red;">执行安全性算法判断在进程申请资源后系统是否处于安全状态</a><ul>
<li>如果系统处于安全状态，那么系统就真正将资源分配给进程</li>
<li>如果系统处于非安全状态，那么系统就恢复原来的资源分配状态，并且让该进程处于 ==等待==</li>
</ul>
</li>
</ol>
</li>
<li><p>细节：</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>死锁避免 &amp; 死锁预防：</p>
<ul>
<li><p>死锁预防：死锁预防是从一开始就不允许进程进行某种操作（比如破坏循环等待就不允许申请编号小的资源）</p>
</li>
<li><p>死锁避免：死锁避免则是在一定程度上允许这些操作，通过设计好的算法在运行过程中协调进程，避免死锁的发生</p>
</li>
<li><p><a style="color:red;">死锁避免允许四个必要条件一起发生 &lt;-&gt; 死锁预防根本不会允许四个条件一起发生</a></p>
<p>  解释：因为即使四个必要条件一起发生也不一定会导致死锁的出现，所以死锁避免只要采用相应的算法避免就好</p>
</li>
<li><p>死锁避免限制条件弱，但是难以实现相应的算法 &lt;-&gt; 死锁预防限制条件强，容易实现相应的限制</p>
</li>
</ul>
</li>
</ul>

        <h5 id="死锁检测-amp-恢复"   >
          <a href="#死锁检测-amp-恢复" class="heading-link"><i class="fas fa-link"></i></a><a href="#死锁检测-amp-恢复" class="headerlink" title="死锁检测 &amp; 恢复"></a>死锁检测 &amp; 恢复</h5>
      <ul>
<li>定义：检测系统是否处于死锁状态并且能够从死锁状态中恢复</li>
</ul>

        <h6 id="死锁检测"   >
          <a href="#死锁检测" class="heading-link"><i class="fas fa-link"></i></a><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h6>
      <ul>
<li><p>核心：<a style="color:red;">并不是阻止死锁发生的算法，只能够用于检测死锁是否发生</a></p>
</li>
<li><p>算法：</p>
<ul>
<li><p>等待图：<a style="color:red;">仅适用于单实例的资源</a></p>
<ul>
<li><p>核心：去除资源分配图中的所有资源节点，仅剩下进程节点</p>
</li>
<li><p>规定：只有当 P<del>i</del> -&gt;R<del>j</del> &amp;&amp; R<del>j</del> -&gt; P<del>k</del> 时，两个进程之间才会存在边</p>
</li>
<li><p>检测：仍然检测等待图中是否存在环结构 </p>
<p>  <a style="color:red;">检测环是否存在可以使用拓扑排序检测</a></p>
</li>
</ul>
<p>  <img src="https://i1.xpic.jp/file/xpicjp/2021/05/27/1770ebff969afcef1aeacc6acba8b7d2.png" alt="1770ebff969afcef1aeacc6acba8b7d2.png"></p>
</li>
<li><p>类银行家算法：<a style="color:red;">适用于多实例的资源</a></p>
<ul>
<li><p>数据结构：和之前的银行家算法有些微区别</p>
<div class="table-container"><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Available[n]</code></td>
<td>该数组每个元素表示每种不同类型资源的 ==可分配== 的资源实例数量</td>
</tr>
<tr>
<td><code>Allocation[n][m]</code></td>
<td>该数组第一个参数表示每个不同的进程；第二个参数表示每个进程 ==已经被分配== 的每种类型的资源实例数</td>
</tr>
<tr>
<td><code>Request[n][m]</code></td>
<td>该数组的每个元素表示每个进程 ==申请== 的资源实例数量</td>
</tr>
</tbody></table></div>
</li>
<li><p>过程：</p>
<ol>
<li><p>定义并初始化变量，根据</p>
<p> 定义 <code>Work[]</code> &amp; <code>Finish[]</code> 数组；令 <code>Work = Available</code></p>
<p> 如果 <code>Allocation[i]</code> = 0  就令  <code>Finish[i]</code> = <code>true</code></p>
<p> 如果 <code>Allocation[i]</code> ≠ 0 就令 <code>Finish[i]</code> = <code>false</code></p>
<p> <a style="color:red;">如果当前进程没有被分配任何资源，那么该进程不可能是造成死锁的原因，相当于破坏了持有并等待的条件</a></p>
</li>
<li><p>循环遍历进程集合，判断每个进程申请的资源实例数量和可分配的资源实例数量</p>
<p> <code>Request[i]</code> ≤ <code>Work</code> 证明当前资源足够支撑该进程运行；令 <code>Finish[i]</code> = <code>true</code> ；再执行第 3 步</p>
<p> <a style="color:red;">如果申请的资源大于可分配的，也不可以立刻断言当前系统处于死锁，如果之后有进程执行结束释放资源，说不定当前进程就可以执行了</a></p>
</li>
<li><p>操作系统 ==假设== 分配给进程相应的资源实例数量</p>
<p> <code>Work</code> = <code>Work</code> + <code>Allocation[i]</code></p>
</li>
<li><p>循环遍历 <code>Finish[]</code> ，如果存在元素值仍未 <code>false</code>，<a style="color:red;">证明当前系统处于死锁状态</a>（注意不是非安全状态）</p>
<p> <a style="color:red;">这里是直接断言系统处于死锁状态，而不是非安全状态，因为多个进程同时提出申请，的确非常容易造成死锁</a></p>
</li>
</ol>
</li>
<li><p>细节：</p>
<ol>
<li>死锁避免银行家算法 vs 死锁检测银行家算法<ul>
<li>死锁避免：每次 ==只有一个进程== 提出申请，然后执行安全性检测，如果不安全就会驳回进程的申请</li>
<li>死锁检测：所有进程都可以 ==同时== 提出申请，这就很容易直接造成死锁，该算法是利用所有进程的申请在计算</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>细节：死锁检测通常都是配合而死锁恢复一起使用</p>
</li>
</ul>

        <h6 id="死锁恢复"   >
          <a href="#死锁恢复" class="heading-link"><i class="fas fa-link"></i></a><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h6>
      <ul>
<li><p>资源抢占</p>
<ul>
<li><p>核心：<a style="color:red;">允许进程抢占资源打破死锁</a></p>
</li>
<li><p>细节：</p>
<ul>
<li><p>回滚：被抢占资源的进程需要回滚到到足够打破死锁的状态</p>
<p>  <a style="color:red;">进程在回滚的过程中会不断地释放资源</a> (主动释放资源)</p>
</li>
<li><p>牺牲进程：选择被抢占资源的进程，尽可能使得代价最小 (被动释放资源)</p>
</li>
<li><p>饥饿：不能够无限次地选择同一个进程被抢占资源</p>
<p>  <a style="color:red;">通常将进程回滚的次数作为考虑牺牲进程的因素</a></p>
</li>
</ul>
<p>  注：资源抢占的核心，就是一个进程释放资源，一个进程获取这个释放的资源，考虑上述的三个细节仅仅只是能够更好抢占，避免抢占造成严重后果</p>
</li>
</ul>
</li>
<li><p>进程终止</p>
<ul>
<li><p>核心：<a style="color:red;">终止造成死锁的进程来打破死锁</a></p>
</li>
<li><p>方式</p>
<ul>
<li><p>终止 ==所有== 进程：（几乎类似于重启系统） </p>
<ul>
<li><p>缺陷：==代价== 非常大，容易导致被终止的进程之前的 ==任务进程丢失==</p>
<p>  代价：这里的代价应该是对于进程而言的，因为可能会造成很多有效数据的丢失</p>
</li>
</ul>
</li>
<li><p>终止 ==部分== 进程</p>
<ul>
<li><p>方式：每次终止一个进程后都需要继续调用死锁检测算法判断当前系统是否仍处于死锁</p>
<p>  解释：需要不断尝试当前系统是否处于死锁状态，如果仍然处于死锁状态，也需要继续死锁检测算法寻找造成死锁的进程</p>
</li>
<li><p>缺陷： ==代价== 非常大</p>
<p>  代价：这里的代价应该是在每次都要执行死锁检测算法确定终止进程所造成的开销</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h5 id="忽略"   >
          <a href="#忽略" class="heading-link"><i class="fas fa-link"></i></a><a href="#忽略" class="headerlink" title="忽略"></a>忽略</h5>
      <ul>
<li><p>定义：操作系统认为死锁不可能在系统中发生</p>
</li>
<li><p>细节：</p>
<ul>
<li><p>Linux &amp; Windows 等大多数现代操作系统都是采用 ==忽略死锁== 的方式</p>
<p>  <a style="color:red;">每个应用程序需要编写相应的算法避免和其他进程之间发生死锁，而不是依靠操作系统来避免</a></p>
</li>
</ul>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/28/jvm/classloader/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/">类加载机制-类加载过程</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-28</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="加载"   >
          <a href="#加载" class="heading-link"><i class="fas fa-link"></i></a><a href="#加载" class="headerlink" title="加载"></a>加载</h2>
      <ul>
<li><p>目的：[IO 读取字节码存储在方法区中，并由类加载器生成 Class 对象]{.red}</p>
<ul>
<li><p>IO 根据类的 [全限定名称]{.red} 获取该类的字节码文件</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 类的全限定名</span></span><br><span class="line">java.lang.String</span><br></pre></td></tr></table></div></figure></li>
<li><p>类加载器将静态存储的字节码文件存储在 [方法区]{.red} </p>
<p>  [注：字节码文件必须经过 <strong>验证阶段</strong> 才可以存储在方法区]{.red}</p>
</li>
<li><p>类加载器在内存中生成类对应的 Class 对象</p>
<p>  [Class 对象也称为 DNA 元数据模板]{.red}</p>
</li>
</ul>
</li>
<li><p>加载时机：</p>
<ul>
<li><p>调用 new (创建对象)、getstatic (读取静态变量)、putstatic (设置静态变量)、invokestatic (调用静态方法) 四条字节码指令时开始加载类</p>
<blockquote>
<p>[注：创建对象前显然是需要类的存在的；静态成员是属于类的，显然也需要加载类]{.blue}</p>
</blockquote>
</li>
<li><p>反射调用</p>
</li>
<li><p>子类加载前优先加载父类</p>
</li>
<li><p>含有 [main]{.red} 方法的类优先加载</p>
</li>
<li><p>动态代理</p>
</li>
<li><p>接口实现类被加载前优先加载接口</p>
</li>
</ul>
<blockquote>
<ul>
<li><p>[上述六种情况出现时虚拟机必须立刻对相应的类进行加载]{.red}</p>
</li>
<li><p>[有且仅有这六种情况是必须要立刻加载的；其余的类加载由虚拟机的具体实现决定]{.red}</p>
</li>
</ul>
</blockquote>
</li>
<li><p>字节码文件的获取方式：</p>
<ul>
<li><p>[本地加载得到]{.red}</p>
</li>
<li><p>[压缩文件获取（zip，jar，war）]{.red}</p>
<blockquote>
<ul>
<li>[jar 包里面存放的就是字节码文件；war 包是 web 应用开发的压缩包]{.red}</li>
<li>Maven 管理的就是各种各样的 jar 包</li>
</ul>
</blockquote>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.mysql.jdbc.Driver</span><br></pre></td></tr></table></div></figure>

  <img src="https://i1.xpic.jp/file/xpicjp/2021/05/16/f29c8a9c04e9d600b0921e523608e39a.png" alt="f29c8a9c04e9d600b0921e523608e39a.png" style="zoom:80%;" />

  <img src="https://i1.xpic.jp/file/xpicjp/2021/05/16/0474b737a23553c66d67a8f284ee98fa.png" alt="0474b737a23553c66d67a8f284ee98fa.png" style="zoom:80%;" /></li>
<li><p>网络获取：Applet</p>
</li>
<li><p>[运行时计算生成：动态代理（反射）]{.red}</p>
<p>  [动态代理类能够在运行的时候生成接口对应的实现类，再编译成相应的字节码文件]{.red}</p>
</li>
<li><p>数据库中获取</p>
</li>
<li><p>加密文件中获取</p>
</li>
</ul>
<p>  <a target="_blank" rel="noopener" href="https://xpic.jp/image/0BSB"><img src="https://i1.xpic.jp/file/xpicjp/2021/05/16/e486c7b9469cf5c061e033fb8b97dcbb.png" alt="e486c7b9469cf5c061e033fb8b97dcbb.png" style="zoom:80%;" /></a></p>
</li>
<li><p>图示：[加载]{.red} 的完整过程</p>
</li>
</ul>
<img src="https://i1.xpic.jp/file/xpicjp/2021/05/16/97321fa1890963012f978d81a04d0d3f.jpg" alt="97321fa1890963012f978d81a04d0d3f.jpg" style="zoom:80%;" />


        <h2 id="连接"   >
          <a href="#连接" class="heading-link"><i class="fas fa-link"></i></a><a href="#连接" class="headerlink" title="连接"></a>连接</h2>
      <ul>
<li>核心：[验证 + 准备 + 解析]{.red}</li>
</ul>

        <h3 id="验证"   >
          <a href="#验证" class="heading-link"><i class="fas fa-link"></i></a><a href="#验证" class="headerlink" title="验证"></a>验证</h3>
      <ul>
<li><p>目的：</p>
<ul>
<li>保证字节码文件符合虚拟机规范</li>
<li>保证字节码被加载后不会危害虚拟机安全</li>
</ul>
</li>
<li><p>验证方式</p>
<ul>
<li><p>文件格式验证：验证加载的字节码是否符合字节码文件规范形式，且是否可以被当前版本的虚拟机执行</p>
<ul>
<li><p>[字节码文件是否以魔数 0xCAFEBABE 开头]{.red}</p>
<blockquote>
<p> notepad++ 中安装 hex-editor 插件可以查看字节码的 16 进制格式</p>
</blockquote>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/05/16/7a47e10f5a257079392bb286dce4f5b2.png" alt="7a47e10f5a257079392bb286dce4f5b2.png" style="zoom:80%;" /></li>
<li><p>文件格式验证通过之后字节码加载生成的 Class 对象才可以进入方法区中存储</p>
</li>
</ul>
</li>
<li><p>元数据验证：对字节码文件进行语义分析，确保不与虚拟机规定的语义有所违背</p>
<blockquote>
<p>没太明白是个啥…</p>
</blockquote>
</li>
<li><p>[字节码验证]{.red}（最复杂的阶段）：通过数据流和控制流分析字节码文件中的 &lt; Code &gt; 属性，确保字节码文件不会做出危害虚拟机安全的操作</p>
<ul>
<li>[翻译：对被加载的 Class 对象的具体方法进行校验 -&gt; 确保符合 Java 语法规范]{.red}</li>
<li>无论经过多么严密的检查都不可能完全保证字节码一定安全（<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.zhihu.com/question/20081359/answer/275107187" >停机问题</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>）</li>
<li>JDK 6 之前采用 [类型推导]{.red} 的方式检验；JDK 7 之后强制采用 [StackMapTable]{.red} 属性检验</li>
</ul>
</li>
<li><p>符号引用验证：</p>
<ul>
<li>翻译：</li>
<li>符号引用验证发生在 [解析]{.red} 阶段中</li>
</ul>
</li>
</ul>
</li>
<li><p>细节：如果字节码文件已经被反复验证过了，可以尝试关闭大部分验证措施</p>
</li>
</ul>

        <h3 id="准备"   >
          <a href="#准备" class="heading-link"><i class="fas fa-link"></i></a><a href="#准备" class="headerlink" title="准备"></a>准备</h3>
      <ul>
<li><p>目的：[为 <strong>类变量分配内存</strong> 并且设置 <strong>类变量的初始值</strong>]{.red}</p>
<ul>
<li><p>类变量 &amp; 实例变量</p>
<ul>
<li><p>类变量：属于类的变量 -&gt; 静态变量</p>
</li>
<li><p>实例变量：属于实例对象的变量 -&gt; 成员变量</p>
<blockquote>
<p>[JDK 6 之前类变量应该分配在方法区中 -&gt; JDK 7 之后类变量跟随 Class 对象分配在堆中]{.red}</p>
</blockquote>
</li>
</ul>
</li>
<li><p>常量值：采用 static + final 共同修饰的并不属于类变量</p>
<ul>
<li><p>常量值在 [编译阶段]{.red} 设置初始值，在准备阶段赋值</p>
<blockquote>
<ul>
<li>编译阶段：将 Java源代码（.java）编译成 字节码文件（.class）的过程</li>
<li>设置初始值：给该类型的设置为默认值；赋值：给该类型设置程序员提供的值</li>
</ul>
</blockquote>
</li>
<li><p>[常量值实际并不属于所在类，而是属于运行的主类]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常量值所在类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstantClass</span></span>&#123;</span><br><span class="line">    <span class="comment">// 常量值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> constantValue = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 常量值所在的运行类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitializationClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 引用类的常量值</span></span><br><span class="line">        System.out.println(Constant.constantValue);</span><br><span class="line">        <span class="comment">// 编译阶段通过常量传播优化，常量值并没有存储在 ConstantClass 的常量池中，而是存储在 NotInitializationClass 类中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>设置初始值：</p>
<ul>
<li><p>设置初始值 ≠ 赋值</p>
</li>
<li><p>类变量的值会被设置为当前类型的默认值</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetValue</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 准备阶段 value 被分配内存空间，同时被设置初始值为 0</span></span><br><span class="line">   	<span class="comment">// 2. 初始化阶段 value 被赋值，设置值为 2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  :::primary</p>
<ul>
<li><p>[赋值的行为是在初始化阶段进行的]{.red}</p>
</li>
<li><p>[每种数据类型的默认值都是不同的]{.red}</p>
</li>
</ul>
<p>  :::</p>
</li>
</ul>
<div class="table-container"><table>
<thead>
<tr>
<th>数据类型</th>
<th>默认值</th>
<th>数据类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>0</td>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
<td>double</td>
<td>0.0d</td>
</tr>
<tr>
<td>char</td>
<td>‘\u0000’（采用的unicode编码）</td>
<td>reference（引用类型）</td>
<td>null</td>
</tr>
<tr>
<td>byte</td>
<td>(byte)0</td>
<td></td>
<td></td>
</tr>
</tbody></table></div>
</li>
</ul>

        <h3 id="解析"   >
          <a href="#解析" class="heading-link"><i class="fas fa-link"></i></a><a href="#解析" class="headerlink" title="解析"></a>解析</h3>
      <ul>
<li><p>目的：[将常量池内的符号引用转换为直接引用]{.red}</p>
<ul>
<li><p>符号引用：用于代替被引用类的未知地址</p>
<p>  解释：某个类中引用了其他类，但是虚拟机并不知道这个引用类的实际地址，使用 ++符号引用++ 来暂时表示这个引用类的地址，等到解析阶段确定真正的地址</p>
</li>
<li><p>直接引用：引用类在虚拟机内存中的实际地址</p>
<p>  [符号引用是无效的，必须转换成直接引用才有用]{.red}</p>
</li>
</ul>
</li>
<li><p>解析类型：</p>
</li>
</ul>
<p>:::info</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34402394/article/details/72793119" >符号引用和直接引用(1)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41490593/article/details/95110259?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control" >符号引用和直接引用(2)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>

        <h2 id="初始化"   >
          <a href="#初始化" class="heading-link"><i class="fas fa-link"></i></a><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2>
      <ul>
<li><p>目的：[执行 类构造器 &lt; clinit &gt; 方法的过程]{.red}</p>
<ul>
<li>&lt; clinit &gt; &amp; &lt; init &gt;<ul>
<li>&lt; clinit &gt; 方法：编译器自动收集类中的 [静态变量]{.red} 和 [静态代码块(static{ })]{.red} 合并而成</li>
<li>&lt; init &gt; 方法：类的构造器方法 -&gt; 虚拟机认为这是实例构造器</li>
</ul>
</li>
<li>编译器是按照从上到下的代码顺序进行收集的</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">	<span class="comment">// 类中的构造器就是虚拟机中的 &lt;init&gt; 方法	</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;类正在初始化...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 类中的静态变量 + 静态代码块就是虚拟机中的 &lt;clinit&gt; 方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> staticValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        staticValue = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态变量初始化...&quot;</span>);</span><br><span class="line">        <span class="comment">// 问题：为什么可以先赋值后声明变量</span></span><br><span class="line">        <span class="comment">// 1. 在准备阶段中虚拟机就已经为静态变量分配了对应的内存空间并且设置了初始值</span></span><br><span class="line">        <span class="comment">// 2. 在初始化阶段虚拟机才会执行 &lt;clinit&gt; 方法，也就意味着静态代码块才会被调用</span></span><br><span class="line">        <span class="comment">// 3. 总结：虚拟机会先将所有定义好的静态变量设置初始值，然后再执行 &lt;clinit&gt; 方法中的内容</span></span><br><span class="line">        afterStaticValue = <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 问题：那么为什么可以赋值，但是却不可以调用呢?（调用会抛出前向引用变量的错误）</span></span><br><span class="line">        System.out.println(afterStaticValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态代码块之后的静态变量可以进行赋值但是不可以调用</span></span><br><span class="line">    <span class="comment">// 如果代码中出现两次赋值，根据自上而下的顺序赋值，因为编译器是自上而下收集的，这里最后的值是 4</span></span><br><span class="line">    <span class="comment">// 静态变量先在准备阶段赋值为0，然后在初始化阶段被赋值为3，最后再被赋值为4</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> afterStaticValue = <span class="number">4</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>父子类关系（<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://fuyusakaiori.github.io/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" >静态代码块和构造方法的先后调用关系</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>）：</p>
<ul>
<li><p>&lt; init &gt; 方法：子类初始化需要使用父类时才会显式调用父类的 &lt; init &gt; 方法</p>
</li>
<li><p>&lt; clinit &gt; 方法：无论子类初始化是否需要使用父类，虚拟机都会执行父类的 &lt; clinit &gt; 方法</p>
<blockquote>
<p>[父类的&lt; init &gt;和&lt; clinit &gt;都是优先于子类执行，但是区别在于是否显式调用，&lt; clinit &gt; 不被调用也会优先执行]{.red}</p>
</blockquote>
</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类代码块初始化...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类静态代码块初始化...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类初始化...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brother</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Brother</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;兄弟类被初始化...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Brother brother = <span class="keyword">new</span> Brother();</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类代码块初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类静态代码块初始化...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类初始化...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li><p>如果类中没有任何的类变量和静态代码块，编译器不会生成对应的 &lt; clinit &gt; 方法</p>
</li>
<li><p>接口的 &lt; clinit &gt; 方法</p>
<ul>
<li><p>[执行子接口的 &lt; clinit &gt; 方法不需要优先执行父接口的 &lt; clinit &gt; 方法 -&gt; 父接口被使用时才会执行 &lt; clinit &gt; 方法]{.red}</p>
</li>
<li><p>[执行接口实现类的 &lt; clinit &gt; 方法不需要优先执行父接口的 &lt; clinit &gt; 方法]{.red}</p>
</li>
<li><p>接口中没有类变量但是拥有常量，所有的常量在初始化阶段仍然需要赋值操作</p>
<blockquote>
<p>问题在于，字节码文件中并没有看到 &lt; clinit &gt; 方法啊…</p>
</blockquote>
</li>
</ul>
</li>
<li><p>[&lt; clinit &gt; 方法在多线程环境下需要正确的加锁]{.red}</p>
<blockquote>
<p>解释：</p>
<p>(1) 多个线程都想初始化同一个类时只允许一个线程优先初始化这个类，其余线程只能够等待，所以 &lt; clinit &gt; 方法也只能够被一个线程使用</p>
<p>(2) 其余线程虽然会被阻塞，但是在当前线程执行结束 &lt; clinit &gt; 方法之后，其余线程也不会再执行，因为 &lt; clinit &gt; 方法包含的是属于类的静态成员，类仅加载一次，所以 &lt; clinit &gt; 方法也只执行一次</p>
</blockquote>
</li>
</ul>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/05/16/f7dda6ef44ee19a60138b4b166d9ca3f.png" alt="f7dda6ef44ee19a60138b4b166d9ca3f.png" style="zoom:80%;" /></li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/28/jvm/classloader/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/">类加载机制-双亲委派机制</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-28</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="双亲委派机制"   >
          <a href="#双亲委派机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/28/jvm/classloader/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-%E6%A6%82%E8%BF%B0/">类加载机制-概述</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-28</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h2>
      <blockquote>
<p><strong>什么是类加载机制?</strong></p>
</blockquote>
<ul>
<li>定义：[类加载器将进程需要使用的类加载到虚拟机内存中的过程]{.blue}</li>
</ul>
<blockquote>
<p><strong>为什么需要提供类加载机制?</strong></p>
</blockquote>
<ul>
<li>先从两门计算机专业课的知识中了解其必要性：<ul>
<li>计算机组成原理：[现代计算机体系结构都是以存储器（内存）为中心]{.blue}</li>
<li>操作系统：[所有进程都必须被加载到内存后才可以运行]{.blue}</li>
</ul>
</li>
<li>再从虚拟机的运行了解其必要性<ul>
<li>虚拟机也是特殊的操作系统，进程显然也必须被加载到虚拟机的内存中才可以运行</li>
<li>[那么进程需要的各种各样的类显然也必须被加载虚拟机中才可以使用]{.blue}</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>什么时候执行类加载?</strong></p>
</blockquote>
<ul>
<li>静态加载：类加载器在 [进程在启动时]{.red} 就将需要的类全部加载到虚拟机内存中<ul>
<li>优点：[避免进程运行期间加载大量的类导致用户线程卡顿]{.red}</li>
<li>缺点：[进程启动时加载大量类就会导致进程启动过程缓慢]{.red}</li>
</ul>
</li>
<li>动态加载：类加载器在 [进程运行时]{.red} 才将需要的类加载的虚拟机内存中<ul>
<li>优点 &amp; 缺点：动态加载的优缺点和静态记载刚好相反</li>
<li>机制：动态加载 = 动态链接 + 反射</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>类加载过程完整图示</strong></p>
</blockquote>
<img src="https://i1.xpic.jp/file/xpicjp/2021/05/16/7108d1081625dffb3cb53ba03c575081.png" alt="7108d1081625dffb3cb53ba03c575081.png" style="zoom:80%;" />

<p>:::warning</p>
<p>[注：加载 -&gt; 连接 -&gt; 初始化 三个阶段通常是交叉混合进行的而不是按照顺序执行的]{.red}</p>
<p>举例：加载的过程中会生成类对应的 [Class 对象]{.red} ，但是需要经过验证阶段才会被允许进入方法区中存储</p>
<p>:::</p>

        <h2 id="加载"   >
          <a href="#加载" class="heading-link"><i class="fas fa-link"></i></a><a href="#加载" class="headerlink" title="加载"></a>加载</h2>
      
        <h3 id="类加载器"   >
          <a href="#类加载器" class="heading-link"><i class="fas fa-link"></i></a><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3>
      <ul>
<li><p>目的：[生成字节码对应的 Class 对象]{.red}</p>
</li>
<li><p>分类：[类加载实际仅分为两类：引导类加载器 + 自定义类加载器]{.red}</p>
<ul>
<li>自定义类加载器实际上包括 [扩展类加载器，应用类加载器，用户自定义类加载器]{.red}</li>
<li>[Java 中将派生于抽象类 ClassLoader 的类加载器都称为自定义类加载器]{.red}</li>
</ul>
</li>
<li><p>实例：查看类加载器</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前类的类加载器（AppClassLoader）</span></span><br><span class="line">    ClassLoader appClassLoader = ClassLoader.getSystemClassLoader(); </span><br><span class="line">    <span class="comment">// 自定义的类都是采用应用类加载器加载的</span></span><br><span class="line">    System.out.println(appClassLoader); </span><br><span class="line">    <span class="comment">// 获取类加载器的上一级类加载器（ExtClassLoader）</span></span><br><span class="line">    ClassLoader extClassLoader = appClassLoader.getParent();</span><br><span class="line">    <span class="comment">// 应用类加载器的上一级是扩展类加载器；扩展类加载器负责扩展包中的类</span></span><br><span class="line">    System.out.println(extClassLoader); </span><br><span class="line">    <span class="comment">// 获取类加载器的上一级类加载器（BootStrapClassLoader）</span></span><br><span class="line">    ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line">    <span class="comment">// 引导类加载器是打印不出来的 -&gt; null</span></span><br><span class="line">    System.out.println(bootstrapClassLoader); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>关系：类加载器之间的关系</p>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/05/16/d82ebe08a7b77572c958564f15183cb3.png" alt="d82ebe08a7b77572c958564f15183cb3.png" style="zoom:80%;" /></li>
</ul>

        <h4 id="引导类加载器"   >
          <a href="#引导类加载器" class="heading-link"><i class="fas fa-link"></i></a><a href="#引导类加载器" class="headerlink" title="引导类加载器"></a>引导类加载器</h4>
      <ul>
<li><p>[BoostrapClassLoader]{.blue}</p>
</li>
<li><p>细节：</p>
<ul>
<li><p>引导类加载器采用 [C++]{.red} 编写</p>
<blockquote>
<ul>
<li>[扩展类加载器，应用类加载器都是采用纯 Java 语言编写的]{.red}</li>
<li>[Hotpot 虚拟机在 JDK9 之前引导类加载器完全采用 C++ 实现，JDK9 以后引导类加载器采用 C++ 配合 Java 实体类的方式实现]{.red}</li>
<li>J9 &amp; JRockit 都是采用这种方式实现的，只不过是 C 配合 Java 实体类实现；MRP，Maxine 虚拟机是完全采用 Java 实现的</li>
</ul>
</blockquote>
</li>
<li><p>引导类加载器是无法通过编辑器查看其内容的，仅能查看其存放的路径</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">file:/D:/Java/jdk%201.8/jdk/jre/lib/resources.jar</span></span><br><span class="line"><span class="comment">file:/D:/Java/jdk%201.8/jdk/jre/lib/rt.jar</span></span><br><span class="line"><span class="comment">file:/D:/Java/jdk%201.8/jdk/jre/lib/sunrsasign.jar</span></span><br><span class="line"><span class="comment">file:/D:/Java/jdk%201.8/jdk/jre/lib/jsse.jar</span></span><br><span class="line"><span class="comment">file:/D:/Java/jdk%201.8/jdk/jre/lib/jce.jar</span></span><br><span class="line"><span class="comment">file:/D:/Java/jdk%201.8/jdk/jre/lib/charsets.jar</span></span><br><span class="line"><span class="comment">file:/D:/Java/jdk%201.8/jdk/jre/lib/jfr.jar</span></span><br><span class="line"><span class="comment">file:/D:/Java/jdk%201.8/jdk/jre/classes</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取引导类加载器所在的路径</span></span><br><span class="line">    URL[] urLs = Launcher.getBootstrapClassPath().getURLs(); </span><br><span class="line">    List&lt;URL&gt; urls = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 将获取到的路径存放在链表中</span></span><br><span class="line">    Collections.addAll(urls, Launcher.getBootstrapClassPath().getURLs());</span><br><span class="line">    <span class="comment">// 打印所有的路径名</span></span><br><span class="line">    urls.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>引导类加载器用于加载 Java 核心类库 -&gt; 用于加载 java、javax、sun 等开头的包</p>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/05/16/3395ef2a1e2bf74002e342b6bea6bf7d.png" alt="3395ef2a1e2bf74002e342b6bea6bf7d.png" style="zoom:80%;" /></li>
<li><p>引导类加载器也负责 [扩展类加载器和应用类加载器]{.red} 的 ++加载++；引导类加载器没有父类</p>
</li>
</ul>
</li>
</ul>

        <h4 id="扩展类加载器"   >
          <a href="#扩展类加载器" class="heading-link"><i class="fas fa-link"></i></a><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h4>
      <ul>
<li><p>[ExtClassLoader]{.red}</p>
</li>
<li><p>细节：</p>
<ul>
<li><p>扩展类加载器采用纯 Java 编写，在 [Launcher 类中以 内部类]{.red} 实现</p>
</li>
<li><p>扩展类加载器的父类加载器是引导类加载器</p>
</li>
<li><p>扩展类加载器加载 ..\jdk\jre\lib\ext 目录下的所有包</p>
<p>  [如果用户创建的 jar 包放在这个路径下也是会被扩展类加载器加载的…]{.red}</p>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/05/16/e63c02da600f145ce6164a324c49028a.png" alt="e63c02da600f145ce6164a324c49028a.png" style="zoom:80%;" /></li>
</ul>
</li>
</ul>

        <h4 id="应用类加载器"   >
          <a href="#应用类加载器" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用类加载器" class="headerlink" title="应用类加载器"></a>应用类加载器</h4>
      <ul>
<li>[AppClassLoader]{.red}</li>
<li>细节<ul>
<li>应用类加载器采用纯 Java 编写，在 [Launcher 类中以 内部类]{.red} 实现</li>
<li>应用类加载器的父类加载器是引导类加载器</li>
<li>应用类加载器通常负责所有 [自定义类]{.red} 的加载，[也负责加载环境变量中 classpath 指定的类库]{.red}</li>
</ul>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/28/jvm/garbage-collection/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/">垃圾回收-垃圾回收器</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-03</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="垃圾回收器"   >
          <a href="#垃圾回收器" class="heading-link"><i class="fas fa-link"></i></a><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1>
      
        <h2 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h2>
      <p>:::warning</p>
<p>① 垃圾回收器是虚拟机中具体执行垃圾回收的部分，也是垃圾回收算法的具体实现</p>
<p>② 不过后续许多的垃圾回收器并不是严格使用此前提到的算法，有非常多不同的改进</p>
<p>③ Java 社区中的许多公司都开发了自己的虚拟机，诸如 IBM、Oracle、RedHat 等等</p>
<p>④ 不同的公司研发的不同的虚拟机，以及虚拟机的逐步改进，可能会让初看的同学感到混乱</p>
<p>⑤ 所以我打算先把垃圾回收器的发展历史写出来，先了解大致有什么垃圾回收器，再进一步了解</p>
<p>:::</p>

        <h3 id="历史"   >
          <a href="#历史" class="heading-link"><i class="fas fa-link"></i></a><a href="#历史" class="headerlink" title="历史"></a>历史</h3>
      <ul>
<li>伴随 Java 虚拟机诞生的 [两款串行执行垃圾回收器应该是 Serial 和 Serial Old]{.red}<ul>
<li>[Serial 主要用于收集年轻代、Serial Old 主要用于收集老年代]{.red}</li>
</ul>
</li>
<li>JDK 1.3 推出了第一款能够 [并行执行的垃圾回收器 ParNew]{.red}<ul>
<li>ParNew 是 Serial 垃圾回收器的多线程版本</li>
</ul>
</li>
<li>JDK 1.4 推出了 [高吞吐量的并行执行的垃圾回收器 Parallel Scavenge]{.red}<ul>
<li>[Parallel Scavenge 主要用于收集年轻代]{.red}</li>
<li>Parallel Scavenge 并不是采用 HotSpot 虚拟机规定的分代框架，导致后面无法和 Concurrent Mark Sweep 配合</li>
</ul>
</li>
<li>JDK 5 推出了能够 [并发执行的垃圾回收器 Concurrent Mark Sweep]{.red}<ul>
<li>Concurrent Mark Sweep 是第一款能够实现并发的垃圾回收器</li>
<li>[Concurrent Mark Sweep 主要和 ParNew 进行配合]{.red}</li>
</ul>
</li>
<li>JDK 6 时推出 [Prarallel Old 垃圾回收器]{.red}<ul>
<li>Prarallel Old 垃圾回收器主要用于收集老年代</li>
<li>[默认使用 Concurrent Mark Sweep + ParNew 的组合]{.red}</li>
</ul>
</li>
<li>JDK 7 时 [全能垃圾回收器 Garbage First]{.red} 被推出</li>
<li>JDK 8 时 [默认使用 Parallel Scavenge + Parallel Old 组合]{.red}</li>
<li>JDK 9 时 使用 Garbage First 垃圾回收器替代此前的组合<ul>
<li>Concurrent Mark Sweep 垃圾回收器则不被推荐使用</li>
</ul>
</li>
<li>JDK 11 时引入 [两款前沿的垃圾回收器 Epsilon 和 ZGC]{.red}<ul>
<li>Epsilon 是无操作垃圾回收器</li>
<li>[ZGC 是 Oralce 自主开发的垃圾回收器，仍然处于实验性质]{.blue}</li>
</ul>
</li>
<li>JDK 12 时引入 [Shenandoah 垃圾回收器]{.red}<ul>
<li>[Shenandoah 垃圾回收器是由 RedHat 开发的]{.blue}</li>
</ul>
</li>
<li>JDK 14 时彻底移除 Concurrent Mark Sweep 垃圾回收器</li>
</ul>
<p>:::info</p>
<p>① 关于这个发展历史，我觉得非常搞笑的一点是，网络上大多数博客提到的都是 JDK 1.3 开始采用第一款垃圾回收器</p>
<p>② 可是 JDK 1.0 到 JDK 1.3 中间有三年的过度，那不可能这三年间虚拟机没有垃圾回收器吧，太扯了</p>
<p>③ 《深入理解虚拟机》中提到 JDK 1.3 之前都是采用的 Serial 垃圾回收器，我觉得还比较合理</p>
<p>:::</p>

        <h3 id="分类"   >
          <a href="#分类" class="heading-link"><i class="fas fa-link"></i></a><a href="#分类" class="headerlink" title="分类"></a>分类</h3>
      <p>:::info</p>
<p>不同的垃圾回收器针对的堆空间区域不同，而且有并行与并发的区别</p>
<p>:::</p>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/垃圾回收器分类.fg1iu3bz6ww.png" alt="垃圾回收器分类" style="zoom:80%;" />

<ul>
<li><p>按照垃圾回收线程数量分类</p>
<ul>
<li>垃圾回收的执行过程中可以启用多条垃圾回收线程并行执行，也可以单线程串行执行</li>
<li>[串行（单线程）：常用于客户端模式的下的虚拟机中；在单核处理器中的表现甚至优于并行执行的效率]{.red}</li>
<li>[并行（多线程）：常用于服务端模式下的虚拟机中；在多核处理器中的效果较好]{.red}</li>
</ul>
</li>
<li><p>按照垃圾回收线程和用户线程关系分类</p>
</li>
<li><p>按照工作区域分类</p>
<ul>
<li>垃圾回收算法中提到了分代算法，针对不同的堆空间区域采用不同的算法</li>
<li>垃圾回收算法的具体实现又是垃圾回收器，所以最早垃圾回收器也是针对不同区域设计的</li>
</ul>
</li>
</ul>

        <h3 id="组合"   >
          <a href="#组合" class="heading-link"><i class="fas fa-link"></i></a><a href="#组合" class="headerlink" title="组合"></a>组合</h3>
      <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/垃圾回收器组合图示.2b22lycmp7b4.png" alt="垃圾回收器组合图示" style="zoom:80%;" />

<ul>
<li>[最早的垃圾回收器组合：Serial + Serial Old]{.blue}</li>
<li>[JDK 6 时代的垃圾回收器组合：ParNew + CMS]{.blue}</li>
<li>[JDK 8 时代的垃圾回收器组合：Parallel Scavenge + Parallel Old]{.blue}</li>
<li>[JDK 9 时代的垃圾回收器：G1]{.blue}</li>
</ul>

        <h3 id="性能指标"   >
          <a href="#性能指标" class="heading-link"><i class="fas fa-link"></i></a><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3>
      <p>:::info</p>
<p>就好比采用时间复杂度衡量算法的好坏一样，需要有相应的标准衡量垃圾回收器性能的好坏</p>
<p>:::</p>
<ul>
<li><p>核心指标：</p>
<ul>
<li>[延迟（Latency）：垃圾回收过程中用户线程暂停的总时间]{.red}</li>
<li>[吞吐量（Throughput）：$$\frac{\text{用户线程运行时间}}{用户线程运行时间 + 垃圾回收时间}$$]{.red}</li>
<li>[内存占用（Footprint）：堆空间的大小]{.red}</li>
</ul>
</li>
<li><p>不可能三角（类似于分布式系统中的 CAP 理论）</p>
<ul>
<li><p>垃圾回收器想要减少 STW 带来的延迟影响就只能够允许并发，将整个垃圾回收过程分成几个阶段进行</p>
<p>  但是分阶段之后就会造成吞吐量的下降，所以这两个条件是很难一起满足的</p>
</li>
<li><p>虚拟机想要使用更大的堆空间，那么回收的过程需要垃圾回收器扫描的区域就变大了，耗费的时间就变长了</p>
<p>  STW 带来的延迟影响就更加明显，所以这两个条件也是非常难以同时满足的</p>
</li>
<li><p>总结：[最优秀的垃圾回收器也最多只能够满足其中的两个条件，是无法同时满足三个条件的]{.red}</p>
</li>
<li><p>问题：可能初学的时候会觉得延迟和吞吐量并不是矛盾的，无法理解为什么分阶段之后就会造成吞吐量下降，这里用图示来演示</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/吞吐量与延迟.tunha27nl68.png" alt="吞吐量与延迟" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>其余指标：[垃圾回收器为了标记清除垃圾所维护的额外信息占用的内存]{.blue}</p>
<ul>
<li>可达性分析中维护引用采用的 Oopmap 占用的空间</li>
<li>记录跨代引用的卡表占用的空间，以及维护卡表所需要的操作开销</li>
</ul>
</li>
<li><p>核心：[未来所有垃圾回收器都是朝着在 <strong>确保延迟可控的情况尽最大可能提升吞吐量</strong> 的方向努力]{.red}</p>
</li>
</ul>

        <h2 id="垃圾回收器-1"   >
          <a href="#垃圾回收器-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#垃圾回收器-1" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2>
      
        <h3 id="7-大经典垃圾回收器"   >
          <a href="#7-大经典垃圾回收器" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-大经典垃圾回收器" class="headerlink" title="7 大经典垃圾回收器"></a>7 大经典垃圾回收器</h3>
      <p>:::info</p>
<p>① 前面的串行和并行垃圾收集器都是比较简单，算法都是基于此前提到过的基础算法</p>
<p>② 后面的并发和全能回收器的理解具有一定的难度，一些细节是缺失的，算法是有改进的</p>
<p>:::</p>

        <h4 id="串行垃圾回收器"   >
          <a href="#串行垃圾回收器" class="heading-link"><i class="fas fa-link"></i></a><a href="#串行垃圾回收器" class="headerlink" title="串行垃圾回收器"></a>串行垃圾回收器</h4>
      
        <h5 id="Serial-垃圾回收器"   >
          <a href="#Serial-垃圾回收器" class="heading-link"><i class="fas fa-link"></i></a><a href="#Serial-垃圾回收器" class="headerlink" title="Serial 垃圾回收器"></a>Serial 垃圾回收器</h5>
      <ul>
<li><p>历史：JDK 1.3 之前新生代垃圾收集器的唯一选择，是历史最长最基础的垃圾收集器</p>
</li>
<li><p>特点：</p>
<ul>
<li>[针对堆空间中的新生代回收垃圾]{.red}</li>
<li>[采用 <strong>标记-复制</strong> 算法 <strong>串行回收</strong> 新生代的垃圾]{.red}<ul>
<li>标记-复制算法效率相对较高</li>
<li>串行回收不仅造成用户线程长时间的暂停，还因为其单线程所以总的效率相对较低</li>
</ul>
</li>
<li>[默认在客户端模式下采用的垃圾回收器，也可以手动设置为服务器端下使用（没啥意义）]{.red}</li>
<li>默认 Serial 和 Serial Old 进行搭配</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>[所有垃圾收集器中占用额外内存最小的（不需要记录太多的信息辅助垃圾收集）]{.red}</li>
<li>[单核处理器下运行效果非常好，相比于其他串行垃圾收集器简单高效]{.red}<ul>
<li>可以在桌面应用程序中应用</li>
<li>也可以在微服务中应用（客户端）</li>
</ul>
</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>[串行回收会造成长时间的用户线程暂停，效率相对来说较低]{.green}</li>
<li>[多核处理器下就明显比不过并行的垃圾回收器，无法应用于服务器端]{.green}</li>
</ul>
</li>
<li><p>设置命令：[-XX:+UseSerialGC]{.blue}</p>
<ul>
<li><p>指定新生代垃圾回收器为 Serial 的同时，老年代默认设置为 Serial Old</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/查看-Serial-垃圾回收器.59tbi2y2k3k0.png" alt="查看-Serial-垃圾回收器" style="zoom:80%;" /></li>
</ul>
</li>
</ul>

        <h5 id="Serial-Old-垃圾回收器"   >
          <a href="#Serial-Old-垃圾回收器" class="heading-link"><i class="fas fa-link"></i></a><a href="#Serial-Old-垃圾回收器" class="headerlink" title="Serial Old 垃圾回收器"></a>Serial Old 垃圾回收器</h5>
      <ul>
<li>历史：伴随 Serial 垃圾收集器诞生的老年代垃圾收集器</li>
<li>特点：<ul>
<li>[针对堆空间中的老年代回收垃圾]{.red}</li>
<li>[采用 <strong>标记-整理</strong> 算法 <strong>串行回收</strong> 老年代的垃圾]{.red}</li>
<li>[默认在客户端下使用的垃圾回收器，可以设置为服务器端下使用]{.red}<ul>
<li>用于服务器端的目的①：[配合 Parallel Scavenge 新生代收集器使用（JDK 9 中废弃）]{.blue}</li>
<li>用于服务器端的目的②：[用于 CMS 出现失败时（Concurrent Mode Failure）的后备垃圾收集器]{.blue}</li>
</ul>
</li>
</ul>
</li>
<li>优点缺点和 Serial 垃圾收集器基本一致</li>
</ul>

        <h4 id="并行垃圾回收器"   >
          <a href="#并行垃圾回收器" class="heading-link"><i class="fas fa-link"></i></a><a href="#并行垃圾回收器" class="headerlink" title="并行垃圾回收器"></a>并行垃圾回收器</h4>
      <ul>
<li>所有的并行垃圾回收器都可以设置并行的 GC 线程数量</li>
<li>[开启的 GC 线程数量最好不要超过处理器计算核的数量，避免引起线程并发带来的性能下降问题]{.red}</li>
</ul>

        <h5 id="ParNew-垃圾回收器"   >
          <a href="#ParNew-垃圾回收器" class="heading-link"><i class="fas fa-link"></i></a><a href="#ParNew-垃圾回收器" class="headerlink" title="ParNew 垃圾回收器"></a>ParNew 垃圾回收器</h5>
      <ul>
<li>历史：JDK 1.3 推出第一款并行的垃圾回收器</li>
<li>特点：<ul>
<li>[针对堆空间中的新生代回收垃圾]{.red}</li>
<li>[采用 <strong>标记-复制</strong> 算法 <strong>并行回收</strong> 新生代的垃圾]{.red}</li>
<li>[默认在服务器端下采用的垃圾回收器，默认开启的线程数量和服务器的计算核数量一致]{.red}</li>
<li>JDK 6 默认 ParNew 和 CMS 进行搭配使用</li>
</ul>
</li>
<li>优点：[能够非常高效地利用多核处理器的计算优势，尽快地完成垃圾回收]{.red}</li>
<li>缺点：[单核处理器下的垃圾回收效率并没有 Serial 垃圾回收的效果好]{.green}</li>
<li>细节：ParNew 垃圾回收器除了是多线程并行之外，和 Serial 没有太多的区别</li>
<li>设置命令：<ul>
<li>[-XX:UseParNewGC 启用 ParNew 垃圾回收器]{.blue}</li>
<li>[-XX:ParallelGCThreads 设置 ParNew 启用的垃圾回收线程数量]{.blue}</li>
</ul>
</li>
</ul>

        <h5 id="Parallel-Scavenge-垃圾回收器"   >
          <a href="#Parallel-Scavenge-垃圾回收器" class="heading-link"><i class="fas fa-link"></i></a><a href="#Parallel-Scavenge-垃圾回收器" class="headerlink" title="Parallel Scavenge 垃圾回收器"></a>Parallel Scavenge 垃圾回收器</h5>
      <ul>
<li><p>历史：JDK 1.4 推出，采用不同于 HotSpot 虚拟机规定的垃圾回收器框架，导致该垃圾回收器非常“特别”</p>
</li>
<li><p>特点：</p>
<ul>
<li>[针对堆空间中的新生代回收垃圾]{.red}</li>
<li>[采用 <strong>标记-复制</strong> 算法并行垃圾回收新生代的垃圾]{.red}</li>
<li>[唯一 <strong>优先确保吞吐量</strong> 的垃圾回收器，其余垃圾回收器几乎都是优先确保低延迟]{.red}<ul>
<li><p>开发者可以通过设置 [预期延迟时间]{.red} 控制垃圾回收器的吞吐量大小</p>
</li>
<li><p>开发者也可以通过设置 [垃圾回收时间占比]{.red} 控制吞吐量大小（默认值为 ）</p>
<p>  :::info</p>
<p>  ① Parallel Scavenge 和 Garbage First 垃圾回收器都可以设置预期延迟时间，只不过两者的控制方式不一致</p>
<p>  ② 前者为了达到预期时间是通过缩小新生代空间完成的，后者是通过减少回收的内存区域完成的</p>
<p>  ③ 两者的相同点是都会造成吞吐量的下降，只不过后者下降得更少</p>
<p>  :::</p>
</li>
</ul>
</li>
<li>[采用自适应调节策略：虚拟机自主对内存空间进行调优]{.red}<ul>
<li>在开发者对调优细节并不了解的情况下可以采用这种方式</li>
<li>堆空间中伊甸园区和幸存者区默认比例是 8:1:1，采用了自适应策略实际采用的比例并不是 8:1:1</li>
</ul>
</li>
<li>[默认在服务器端下采用的垃圾回收器]{.red}<ul>
<li>服务器端不需要太多和用户（开发者）交互的时间，需要处理大量的请求数据，高吞吐量的垃圾回收器更合适</li>
</ul>
</li>
<li>JDK 8 默认采用 Parallel Scavenge 和 Parallel Old 垃圾回收器配合</li>
</ul>
</li>
<li><p>优点</p>
</li>
<li><p>缺点：[采用的垃圾回收器框架不同，导致无法和并发垃圾回收器 CMS 配合使用]{.green}</p>
</li>
<li><p>设置命令</p>
<ul>
<li>[-XX:+UseParallelGC 采用 Parallel Scavenge 新生代垃圾回收器]{.blue}</li>
</ul>
</li>
<li><p>开启 Parallel Scavenge 垃圾回收器的同时默认开启 Parallel Old 老年代垃圾回收器</p>
<ul>
<li>[-XX:ParallelGCThreads=count 设置垃圾回收器开启的线程数量]{.blue}</li>
<li>处理器计算核的数量不超过 8 个的时候：[默认 GC 线程的数量等于处理器计算核的数量]{.red}<ul>
<li>处理器计算核的数量超过 8 个的时候：[默认 GC 线程数量 = 3 + ( 5 * CPU_Count / 8)]{.red}</li>
</ul>
</li>
</ul>
</li>
<li><p>[-XX:MaxGCPauseMillis=time 设置预期延迟时间]{.blue}</p>
<pre><code>  * 垃圾回收器会尽可能达到用户设定预期延迟时间，通过减小吞吐量和新生代空间（不可能三角）
  * 最好不要去设置这个参数
</code></pre>
</li>
<li><p>[-XX:GCTimeRatio=time 设置垃圾回收时间占比]{.blue}</p>
<ul>
<li>虽然这个参数是这个意思，但是实际设置的参数应该是用户运行时间，然后虚拟机会自动计算出垃圾回收时间占比</li>
<li>[默认值为 99，所以垃圾回收时间占比为 $$ \frac{1}{用户运行时间 + 1} $$]{.red}（优先关注吞吐量）</li>
<li>[-XX:+UseAdaptiveSizePolicy 开启自适应调节机制]{.blue}</li>
<li>无法利用这个参数直接关闭自适应调节机制</li>
</ul>
</li>
</ul>
<p>​            </p>

        <h5 id="Parallel-Old-垃圾回收器"   >
          <a href="#Parallel-Old-垃圾回收器" class="heading-link"><i class="fas fa-link"></i></a><a href="#Parallel-Old-垃圾回收器" class="headerlink" title="Parallel Old 垃圾回收器"></a>Parallel Old 垃圾回收器</h5>
      <ul>
<li>历史：JDK 6 推出的老年代的并行垃圾收集器（《深入理解虚拟机》中提到这是个并发收集器，我觉得是写错了）</li>
<li>特点：<ul>
<li>[针对老年代进行垃圾回收]{.red}</li>
<li>[采用 <strong>标记-整理</strong> 算法 <strong>并行回收</strong> 老年代的垃圾]{.red}</li>
</ul>
</li>
</ul>

        <h4 id="并发垃圾回收器"   >
          <a href="#并发垃圾回收器" class="heading-link"><i class="fas fa-link"></i></a><a href="#并发垃圾回收器" class="headerlink" title="并发垃圾回收器"></a>并发垃圾回收器</h4>
      <p>:::primary</p>
<p>参考博客：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/zqz_zqz/article/details/70568819" >CMS垃圾回收器详解</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36697880/article/details/105201936" >Java虚拟机 —-CMS 垃圾回收器</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>

        <h5 id="CMS-垃圾回收器"   >
          <a href="#CMS-垃圾回收器" class="heading-link"><i class="fas fa-link"></i></a><a href="#CMS-垃圾回收器" class="headerlink" title="CMS 垃圾回收器"></a>CMS 垃圾回收器</h5>
      <ul>
<li><p>历史：</p>
<ul>
<li>JDK 5 时期推出的第一款并发式垃圾回收器，真正意义上实现了 GC 线程和用户线程同时执行</li>
<li>JDK 6 时默认采用 CMS + ParNew 的组合，无法和新推出的 Parallel Scavenge 配合</li>
<li>JDK 14 时直接被 Oracle 官方移除</li>
</ul>
</li>
<li><p>执行过程（细粒度划分）：</p>
<ul>
<li>标记阶段<ul>
<li>初始标记（initial mark）<ul>
<li>内容：[标记 GC Roots 直接关联到的对象]{.red}</li>
<li>细节：采用 STW 机制，用户线程依然需要停止，不过初始标记非常迅速，造成的时延很短</li>
</ul>
</li>
<li>并发标记（concurrent mark）<ul>
<li>内容：[从 GC Roots 直接关联的对象开始遍历整个对象图]{.red}</li>
<li>细节：不采用 STW 机制，用户线程和 GC 线程同时执行</li>
</ul>
</li>
<li>重新标记（remark）<ul>
<li>内容：[修正并发标记过程中因用户线程持续运行出现变动的标记]{.red}</li>
<li>细节：采用 STW 机制，用户线程依然需要停止，不过重新标记速度也相对较快，时延步长</li>
</ul>
</li>
</ul>
</li>
<li>清除阶段<ul>
<li>并发清除<ul>
<li>内容：[清除所有 <strong>没有</strong> 被标记的对象，释放内存空间]{.red}</li>
<li>方式：标记-清除 / 标记-整理</li>
<li>细节：不采用 STW 机制，用户线程和 GC 线程同时执行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>[针对老年代设计的垃圾回收器]{.red}</li>
<li>[采用 <strong>标记-清除 + 标记-整理</strong> 算法进行 <strong>并发式</strong> 的垃圾回收]{.red}<ul>
<li>[CMS 能够在不影响对象分配的情况下，容忍标记清除算法带来的碎片问题]{.red}</li>
<li>[CMS 将会在执行 Full GC 的时候，启用标记-整理算法用以消除碎片问题]{.red}<ul>
<li>[标记-整理算法会移动对象的位置，此时运行的用户线程就无法找到对象，所以采用标记-整理算法时无法并发执行，会产生长时间的 STW]{.red}</li>
</ul>
</li>
<li>[CMS 采用增量更新的方式解决并发可达性分析的问题]{.red}</li>
</ul>
</li>
</ul>
</li>
<li><p>优点：[虽然初始标记和重新标记依旧具有时延，但是整体上仍然有效降低 STW 造成的时延]{.red}</p>
</li>
<li><p>缺点：</p>
<ul>
<li>[需要占用处理器资源执行垃圾回收，将会降低用户线程的吞吐量]{.green}</li>
<li>[需要确保并发运行期间有足够的预留内存供用户线程使用]{.green}<ul>
<li>因为并发运行时用户线程依然会使用内存空间，所以没有预留空间用户线程就无法运行</li>
<li>[如果预留空间不足或者用户线程使用内存的速度超过回收速度，那么就会切换至 Serial Old 执行，将会长时间冻结用户线程执行]{.aqua}</li>
</ul>
</li>
<li>[需要确保可达性分析的一致性]{.green}<ul>
<li>[采用 <strong>增量更新</strong> 保持可达性分析的一致性]{.aqua}</li>
</ul>
</li>
<li>[无法处理浮动垃圾问题]{.green}<ul>
<li>浮动垃圾：用户线程在 GC 线程标记阶段之后产生的垃圾对象</li>
<li>细节：只能够等待下次垃圾回收发生时再去回收浮动垃圾</li>
</ul>
</li>
</ul>
</li>
<li><p>设置命令：</p>
<ul>
<li><p>[-XX:+UseConcMarkSweep 启用 CMS 垃圾回收器]{.blue}</p>
<ul>
<li>新生代默认使用 ParNew 垃圾回收器</li>
<li>还会默认将 Serial Old 作为紧急情况下的老年代回收器</li>
</ul>
</li>
<li><p>[-XX:ParallelCMSThreads=count 设置 CMS 使用的 GC 线程数量]{.red}</p>
<ul>
<li>并发式收集中同样可以启用多条 GC 线程，只不过可能面临交替运行的情况</li>
<li>[默认使用的线程数量 = (CPU_Count + 3) / 4]{.red}</li>
<li>[多线程占用的处理器资源比例会随着处理器计算核数量的增加而减少]{.red}（建议自己算一算）<ul>
<li>意味着处理器计算核数量越多，GC 线程就可以开得更多</li>
<li>计算核数量低于 4 个时，多条 GC 线程就会严重影响用户线程的运行</li>
</ul>
</li>
</ul>
</li>
<li><p>[-XX:CMSInitiatingOccupancyFraction=threshold 设置 CMS 开始回收的阈值]{.blue}</p>
<ul>
<li><p>JDK 5 以前默认设置的值为 68%，JDK 6 之后默认值为 92%</p>
</li>
<li><p>[老年代增长较快的时候应该降低阈值，避免触发紧急情况]{.red}</p>
<p>  [老年大增长较慢时应该提升阈值，避免频繁触发 Major GC]{.red}</p>
</li>
</ul>
</li>
<li><p>[-XX:+UseCMSCompactAtFullCollection 执行 Full GC 时启用标记整理算法]{.blue}</p>
<ul>
<li>默认在 CMS 中开启这个选项</li>
</ul>
</li>
<li><p>[-XX:CMSFullGCBeforeCompaction=count 设置执行几次 Full GC 后才使用标记整理算法]{.blue}</p>
<ul>
<li>设置为 0 的话就是每次执行 Full GC 都采用标记整理算法</li>
<li>默认值为 0</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h5 id="G1-垃圾回收器"   >
          <a href="#G1-垃圾回收器" class="heading-link"><i class="fas fa-link"></i></a><a href="#G1-垃圾回收器" class="headerlink" title="G1 垃圾回收器"></a>G1 垃圾回收器</h5>
      <p>:::primary</p>
<p>参考博客：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/coderlius/article/details/79272773" >详解 JVM Garbage First(G1) 垃圾收集器</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>

        <h6 id="概述-1"   >
          <a href="#概述-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述-1" class="headerlink" title="概述"></a>概述</h6>
      <ul>
<li>历史<ul>
<li>G1 是垃圾回收器技术发展史上的里程碑，开创了面向局部收集的设计思路和基于 Region 的布局方式</li>
<li>JDK 6 中作为实验性质的垃圾回收器被推出</li>
<li>JDK 7 中正式作为可商用的垃圾回收器推出</li>
<li>JDK 8 中支持回收方法区</li>
<li>JDK 9 中作为默认使用的垃圾回收器</li>
</ul>
</li>
<li>核心进化：[在延迟可控的情况下尽最大可能提升吞吐量]{.red}<ul>
<li>如何实现延迟可控：<ul>
<li>采用启发式垃圾回收的方式</li>
<li>建立可靠的停顿时间模型</li>
</ul>
</li>
<li>回顾此前的垃圾回收器：都无法控制垃圾回收的延迟的，只有 Parallel Scavenge 可以控制吞吐量</li>
</ul>
</li>
<li>特点：<ul>
<li>[面向具有大内存和多处理器的服务器端]{.red}</li>
<li>[针对 <strong>整个堆空间</strong>（老年代+新生代）进行垃圾回收]{.red}</li>
<li>[局部上看采用 <strong>标记-复制</strong> 算法进行垃圾回收、整体上看可以认为是采用 <strong>标记-整理</strong> 算法进行垃圾回收]{.red}<ul>
<li>标记-复制：将 Region 中存活的对象全部复制到另外的空的 Region 区域中</li>
<li>标记-整理：整个堆空间是由多个相等的 Region 构成的，每次回收可以看做是在移动碎片</li>
</ul>
</li>
<li>[]{.red}</li>
</ul>
</li>
</ul>

        <h6 id="Region-布局"   >
          <a href="#Region-布局" class="heading-link"><i class="fas fa-link"></i></a><a href="#Region-布局" class="headerlink" title="Region 布局"></a>Region 布局</h6>
      <ul>
<li>前提：[不再采用 <strong>连续内存分配</strong> 的方式为对象分配空间，而是采用 <strong>非连续内存</strong> 的方式]{.red}<ul>
<li>连续内存分配：以前大多数对象通常占据的空间都是连续的</li>
<li>非连续内存分配：现在对象占据的空间都是可以不连续的</li>
</ul>
</li>
<li>核心：[将整个堆空间划分多个大小相等的独立区域（Region）]{.red}</li>
<li>大小：<ul>
<li>默认值：[默认 Region 的大小是 1MB]{.red}</li>
<li>设置命令：[-XX:G1HeapRegionSize=size 设置 Region 区域的大小]{.blue}</li>
<li>细节：<ul>
<li>Region 大小在进程运行期间都是不会发生改变的</li>
<li>通常规定 Region 大小的取值范围在 1MB~32MB 之间且最好是 2 的次幂</li>
<li>实际上设置的 Region 大小超过范围或者不是 2 的次幂也不会报错</li>
</ul>
</li>
</ul>
</li>
<li>分类：<ul>
<li>普通 Region：存放普通大小的对象</li>
<li>巨型 Region（Humongous）：<ul>
<li>定义：<ul>
<li>巨型 Region 是多个连续的普通 Region 的组合</li>
<li>起始的 Region 被称为开始巨型、后面的 Region 被称为连续巨型</li>
</ul>
</li>
<li>用途：[存放大小超过 Region 大小一半的巨大对象]{.red}</li>
<li>细节：[如果垃圾回收器找不到多个连续的 Region 组成 Humongous，那么可能需要启动 Full GC]{.red}</li>
</ul>
</li>
</ul>
</li>
<li>记忆集：<ul>
<li>[每个 Region 都需要维护自己的记忆集]{.red}</li>
<li>[每个记忆集不仅维护其他 Region 对自己的引用，而且还维护自己对其他 Region 的引用]{.red}</li>
</ul>
</li>
<li>动态分代<ul>
<li>定义：<ul>
<li>[新生代和老年代可以有多个并不连续的 Region 组成]{.red}</li>
<li>[组成新生代和老年代的 Region 数量并不固定，取决于多个参数]{.red}</li>
</ul>
</li>
<li>细节：<ul>
<li>新生代初始被分配的空间大小为 5%，随着程序的运行而变化大小</li>
</ul>
</li>
</ul>
</li>
<li>TAMS（Top At Mark Start）：<ul>
<li>定义：[用于划分用户线程使用的空间和 GC 回收的空间的指针]{.red}</li>
<li>原因：用户线程和 GC 线程是并发执行的，所以需要在 Region 中预留一部分空间给用户线程使用</li>
</ul>
</li>
<li>启发式垃圾收集<ul>
<li>每次都会将各个 Region 按照回收价值和成本进行排序</li>
<li>依据用户设定的期望停顿时间来选择合适的 Region 组合回收集</li>
</ul>
</li>
<li>停顿时间模型<ul>
<li>定义：[支持在指定的 M 毫秒的时间片段内，垃圾回收占用的时间 <strong>大概率</strong> 不超过 N 毫秒]{.red}</li>
<li>实现：<ul>
<li>垃圾回收器每次都会根据回收 Region 消耗的时间以及 Region 记忆集中脏卡的数量等参数决定其价值</li>
<li>每个 Region 的价值被决定之后就会采用启发式垃圾收集从而完成停顿时间模型要求的目标</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h6 id="回收模式"   >
          <a href="#回收模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#回收模式" class="headerlink" title="回收模式"></a>回收模式</h6>
      <ul>
<li>新生代回收（Minor GC / Young GC）：<ul>
<li>内容：采用标记-复制算法将伊甸园区+幸存者区的 Region 中存活的对象复制到空的 Region 中去</li>
<li>回收条件：[新生代的大小占据整个堆空间的 60% 的时候开始执行新生代回收]{.blue}</li>
</ul>
</li>
<li>混合回收（Mixed GC）<ul>
<li>内容：采用标记-复制算法将新生代+老年代 Region 中存活的对象全部复制到空的 Region 中去 </li>
<li>回收条件：[老年代的大小占据整个堆空间的 45% 的时候开始执行混合回收]{.blue}</li>
</ul>
</li>
<li>细节：<ul>
<li>[G1 两种回收模式都会回收新生代，老年代只有混合回收中才会回收]{.red}</li>
<li>[G1 混合回收老年代的时候只会依据价值高低回收部分的 Region 而不是全部]{.red}</li>
</ul>
</li>
</ul>

        <h6 id="回收过程"   >
          <a href="#回收过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#回收过程" class="headerlink" title="回收过程"></a>回收过程</h6>
      <ul>
<li><p>前提：无论采用哪种回收模式，其回收过程都是完全一致的</p>
</li>
<li><p>标记阶段</p>
<ul>
<li>初始标记（Initial Marking）<ul>
<li>内容：[标记 GC Roots 能够直接关联到的对象，并且修改 TAMS 的位置为用户线程留出空间]{.red}</li>
<li>细节：依然需要采用 STW 机制不过耗时非常短</li>
</ul>
</li>
<li>并发标记（Concurrent Marking）</li>
<li>最终标记（Final Marking）<ul>
<li>内容：</li>
</ul>
</li>
</ul>
</li>
<li><p>清除阶段</p>
<ul>
<li>筛选回收</li>
</ul>
</li>
</ul>

        <h6 id="优点与缺点"   >
          <a href="#优点与缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h6>
      <ul>
<li>优点</li>
<li>缺点</li>
<li>命令<ul>
<li>[-XX:UseG1GC 启用 G1 垃圾回收器]{.blue}<ul>
<li>G1 垃圾回收器不需要和任何垃圾回收器搭配</li>
</ul>
</li>
<li>[-XX:MaxGCPauseMillis 设置期望的垃圾回收时延]{.blue}</li>
<li>[-XX:GCTimeRatio=time 设置垃圾回收时间占比]{.blue}<ul>
<li>Parallel Scavenge 中提供的参数，默认值为 99</li>
<li>G1 中同样提供的参数，默认值为 9</li>
</ul>
</li>
<li>[]{.blue}</li>
</ul>
</li>
</ul>

        <h3 id="3-大前沿垃圾回收器"   >
          <a href="#3-大前沿垃圾回收器" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-大前沿垃圾回收器" class="headerlink" title="3 大前沿垃圾回收器"></a>3 大前沿垃圾回收器</h3>
      
        <h4 id="Shenandoah-垃圾回收器"   >
          <a href="#Shenandoah-垃圾回收器" class="heading-link"><i class="fas fa-link"></i></a><a href="#Shenandoah-垃圾回收器" class="headerlink" title="Shenandoah 垃圾回收器"></a>Shenandoah 垃圾回收器</h4>
      
        <h4 id="ZGC-垃圾回收器"   >
          <a href="#ZGC-垃圾回收器" class="heading-link"><i class="fas fa-link"></i></a><a href="#ZGC-垃圾回收器" class="headerlink" title="ZGC 垃圾回收器"></a>ZGC 垃圾回收器</h4>
      
        <h4 id="Epsilon-垃圾回收器"   >
          <a href="#Epsilon-垃圾回收器" class="heading-link"><i class="fas fa-link"></i></a><a href="#Epsilon-垃圾回收器" class="headerlink" title="Epsilon 垃圾回收器"></a>Epsilon 垃圾回收器</h4>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/28/jvm/garbage-collection/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/">垃圾回收-垃圾回收算法</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-03</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="垃圾回收算法"   >
          <a href="#垃圾回收算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1>
      
        <h2 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h2>
      <blockquote>
<p><strong>两类不同的垃圾回收算法</strong></p>
</blockquote>
<ul>
<li>依据：[依据判断对象消亡的方式划分的两类垃圾回收算法]{.red}</li>
<li>分类：<ul>
<li>引用计数式垃圾收集（Referrence Counting）</li>
<li>追踪式垃圾收集（Tracing GC）</li>
</ul>
</li>
<li>细节：Java 虚拟机中采用的是追踪式垃圾收集，所有以下所有算法都是基于追踪式垃圾收集</li>
</ul>
<p>:::info</p>
<p>① 希望了解更多关于垃圾回收算法的相关内容可以阅读《垃圾回收算法手册》</p>
<p>② 不建议全部读完，挑自己有一定疑惑的部分阅读是非常有帮助的</p>
<p>:::</p>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/垃圾回收算法.2w99m0uoabk0.png" alt="垃圾回收算法" style="zoom:67%;" />


        <h2 id="引用计数式垃圾收集"   >
          <a href="#引用计数式垃圾收集" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用计数式垃圾收集" class="headerlink" title="引用计数式垃圾收集"></a>引用计数式垃圾收集</h2>
      
        <h3 id="引用计数法"   >
          <a href="#引用计数法" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3>
      <ul>
<li><p>名称：引用计数法（Referrence Counting）</p>
</li>
<li><p>代表语言：Python、JavaScript（[Java 采用的不是引用计数法]{.red}）</p>
</li>
<li><p>定义：</p>
<ul>
<li>[为每个对象都维护相应的引用计数器，对象的引用增加时，计数器增加；对象的引用减少时，计数器减少]{.blue}</li>
<li>[如果引用计数器归零，那么该对象就会被回收，如果引用计数器不为零，那么对象就继续存活]{.blue}</li>
</ul>
</li>
<li><p>特点：[每个对象拥有的计数器通常保存在自己的对象头中]{.orange}</p>
<ul>
<li>CPython 中将引用计数器保存在对象头中</li>
<li>C++ 中的有些库将引用计数器保存在对象之外</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>[对象在成为垃圾之后能够 <strong>立刻</strong> 被垃圾回收器回收]{.red}<ul>
<li>[立刻回收垃圾不代表引用计数法不会造成 STW 延迟]{.red}</li>
</ul>
</li>
<li>[引用计数器保存在对象头中，即使垃圾回收器部分出现故障，对象依然可以被回收]{.red}</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><p>[每个对象的引用数量过多时会造成大量的空间开销]{.green}</p>
</li>
<li><p>[每次维护（增加/删除）对象的引用数量时具有的操作开销]{.green}</p>
<ul>
<li>[多线程环境下需要确保增加/删除操作的原子性，即需要对操作进行同步]{.aqua}</li>
<li>[对象的引用变化十分频繁，相应的增加/删除的操作也非常的频繁]{.aqua}</li>
</ul>
</li>
<li><p>[难以解决的循环引用问题]{.green}</p>
</li>
<li><p>[某些极端情况下会导致递归删除引用，造成比追踪式垃圾收集更长的延迟]{.green}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/引用计数-STW.2n347vi0lc80.png" alt="引用计数-STW" style="zoom:80%;" /></li>
</ul>
</li>
</ul>

        <h3 id="循环引用问题"   >
          <a href="#循环引用问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h3>
      <ul>
<li><p>问题描述</p>
<ul>
<li>变量 A 引用的对象实例引用了变量 B 引用的对象</li>
<li>变量 B 引用的对象实例又引用了变量 A 引用的对象</li>
</ul>
</li>
<li><p>问题图示：</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/循环引用.wm033zi8pxs.png" alt="循环引用" style="zoom: 67%;" /></li>
<li><p>解决方式：</p>
<ul>
<li>手动去除两个对象实例之间的循环引用</li>
<li>[采用引用计数+追踪式结合的方式回收]{.red}<ul>
<li>引用计数收集大多数没有出现循环引用的对象</li>
<li>追踪式垃圾收集处理偶尔发生的循环引用的对象</li>
</ul>
</li>
<li>[引入弱引用的概念解决循环引用：所有可达对象均为强引用，强引用不产生环]{.red}<ul>
<li>维护引用计数器的时候会更改引用的强弱程度，处于弱引用的对象就会被直接回收</li>
<li>弱引用解决循环引用问题并不是特别的安全，会导致有些对象被提前回收（?）</li>
</ul>
</li>
<li>实验删除算法（?）</li>
</ul>
</li>
<li><p>测试：Java 是否采用引用计数法</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试: Java 是否采用引用计数算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferrenceCountingGC</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 成员变量:</span></span><br><span class="line">    <span class="keyword">private</span> Object referrence;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 占用内存的对象: 确保触发内存回收机制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 变量 A 引用对象实例</span></span><br><span class="line">        ReferrenceCountingGC objA = <span class="keyword">new</span> ReferrenceCountingGC();</span><br><span class="line">        <span class="comment">// 变量 B 引用对象实例</span></span><br><span class="line">        ReferrenceCountingGC objB = <span class="keyword">new</span> ReferrenceCountingGC();</span><br><span class="line">        <span class="comment">// A 引用的对象实例去引用 B 引用的对象实例</span></span><br><span class="line">        objA.referrence = objB;</span><br><span class="line">        <span class="comment">// B 引用的对象实例去引用 A 引用的对象实例</span></span><br><span class="line">        objB.referrence = objA;</span><br><span class="line">        <span class="comment">// 显示调用垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 显式执行垃圾回收之后, 内存相比于没有执行垃圾回收发生了明显的变化:</span></span><br><span class="line">        <span class="comment">// 结论：Java 采用的不是引用计数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

</li>
</ul>

        <h2 id="追踪式垃圾收集"   >
          <a href="#追踪式垃圾收集" class="heading-link"><i class="fas fa-link"></i></a><a href="#追踪式垃圾收集" class="headerlink" title="追踪式垃圾收集"></a>追踪式垃圾收集</h2>
      
        <h3 id="可达性分析"   >
          <a href="#可达性分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3>
      
        <h4 id="基本内容"   >
          <a href="#基本内容" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h4>
      <p>:::primary</p>
<p>① 可达性分析本身不难理解，但是在关于 GC Roots 到底是对象还是引用存在疑问</p>
<p>②《深入理解虚拟机》中提到 GC Roots 是一组对象，网络上大多数博客都是直接照抄的书所以也是对象</p>
<p>③ 宋红康老师的视频中没有点明 GC Roots 到底是什么，黑马视频中认为 GC Roots 也是对象</p>
<p>④ 最后找到一篇博客和 R大 的回答，他们认为 GC Roots 还是引用</p>
<p>⑤ 这本身倒是一个无足轻重的概念，估计面试官大多数也分不清楚吧</p>
<p>参考博客和回答</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/KyleYang2016/article/details/79459050" >Java GC 内存回收机制详解（二）GC Roots 和 可达链</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.zhihu.com/question/53613423/answer/135743258" >java的gc为什么要分代？</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<ul>
<li><p>名称：可达性分析 （Reachability Analysis）</p>
</li>
<li><p>代表语言：Java、C#、Lisp</p>
</li>
<li><p>定义：</p>
<ul>
<li><p>[枚举根结点集合（GC Roots） 后开始根据引用关系向下遍历，沿着引用关系遍历过的路径称为引用链]{.blue}</p>
</li>
<li><p>[如果对象与根结点集合没有任何引用链相连，称为不可达对象；反之就是可达对象]{.blue}</p>
</li>
<li><p>[垃圾回收器会标记可达对象后 <strong>回收那些没有被标记的对象</strong>（不可达对象）]{.blue}</p>
<p>:::info</p>
<p>标记的是可达对象而不是不可达对象，但是垃圾回收的是不可达对象</p>
<p>《深入理解虚拟机》中提到既可以标记可达对象也可以标记不可达对象，但是不可达对象显然没有办法标记到</p>
<p>:::</p>
</li>
</ul>
</li>
<li><p>图示：</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/可达.4j5e6janf9c0.png" alt="可达" style="zoom:80%;" /></li>
<li><p>优点：[避免循环引用造成内存泄漏问题]{.red}</p>
</li>
<li><p>缺点：[标记阶段必须确保可达性分析过程的一致性]{.green}</p>
<ul>
<li>串行/并行式垃圾回收器采用 STW 机制确保用户线程不会干扰可达性分析的过程</li>
<li>并发式垃圾回收器避免对用户线程采用 STW 机制，所以需要采用增量更新/原始快照两种方式保证一致性</li>
</ul>
</li>
</ul>
<p>:::info</p>
<p>如果不了解什么是 STW 或者说不明白什么叫保证可达性分析的一致性，请参考我此前写的笔记 <a href="">垃圾回收概述-STW</a></p>
<p>:::</p>

        <h4 id="根结点枚举"   >
          <a href="#根结点枚举" class="heading-link"><i class="fas fa-link"></i></a><a href="#根结点枚举" class="headerlink" title="根结点枚举"></a>根结点枚举</h4>
      <p>:::primary</p>
<p>① 这几个算法的实现细节是真的抽象，书上也没说清楚，网上讲清楚的人也少之又少，真的很难彻底弄明白</p>
<p>② 借用《深入理解虚拟机》中的话，如果觉得看不明白或者很枯燥的话，建议直接先跳过，或者理解个大概吧</p>
<p>参考博客：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/plxx/p/4217812.html" >JVM-如何判断一段数据是真正的数据，还是对象的引用</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.pianshen.com/article/18882045496/" >我对OopMap,安全点，安全区域的理解</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<blockquote>
<p><strong>什么是根结点?</strong></p>
</blockquote>
<ul>
<li><p>名称：GC Roots</p>
</li>
<li><p>定义：[根结点集合是一组长期活跃的 <strong>引用</strong>]{.red}</p>
</li>
<li><p>固定的根结点集合：</p>
<ul>
<li>[虚拟机栈中的引用类型变量（指向堆中的对象）：局部变量、参数、临时变量都可以作为根结点]{.red}</li>
<li>方法区中的变量（两种变量在 JDK 7 之后都被移动到堆空间中了）<ul>
<li>[静态的引用类型变量]{.red}</li>
<li>[引用类型的常量（字符串）]{.red}</li>
</ul>
</li>
<li>[本地方法栈中的引用类型变量]{.red}</li>
<li>[虚拟机内部的引用（指向 Class 对象、异常对象、类加载器对象）]{.red}</li>
<li>[被同步锁持有的对象的引用]{.red}</li>
<li>反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调和本地代码缓存等（不知道是啥）</li>
</ul>
</li>
<li><p>非固定的根结点集合：[跨代引用：老年代的对象引用年轻代的对象]{.red}</p>
<ul>
<li>仅关注老年代的垃圾回收器，在回收年轻代的时候是不会关心老年代的</li>
<li>但是老年代有可能对年轻代产生引用，所以说此时老年代的引用也可以认为是 GC Roots</li>
</ul>
<p>  :::info</p>
<p>  ① 年轻代引用老年代其实也是跨代引用，但是由于这种跨代引用不会造成任何实质性的影响，所以就不在此解释</p>
<p>  ② 想要了解为什么没有影响，可以参考《深入理解虚拟机》</p>
<p>  :::</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/可达分析.7gsnx9hk3uo0.png" alt="可达分析" style="zoom:80%;" />

<blockquote>
<p><strong>如何找到根结点?</strong></p>
</blockquote>
<ul>
<li><p>引入：可达性分析的前提是必须获取根结点集合（GC Roots），那么根结点集合是怎么得到的呢？</p>
</li>
<li><p>方式：</p>
<ul>
<li><p>保守式垃圾回收</p>
<ul>
<li><p>历史：早期的 Classic 虚拟机就是采用这种方式</p>
</li>
<li><p>内容：[遍历所有可能存放 GC Roots 的区域进行寻找]{.green}</p>
</li>
<li><p>优点：实现简单便于嵌入没有实现自动垃圾回收机制的语言中（C/C++）</p>
</li>
<li><p>缺陷：</p>
<ul>
<li><p>[如果程序使用的内存空间非常大，那么遍历所有可能的区域就是非常消耗时间的]{.green}</p>
</li>
<li><p>疑似 GC Roots 的引用可能指向将要被回收的对象导致其无法被回收，导致内存泄漏</p>
</li>
<li><p>虚拟机无法对遍历过程中可能出现的疑似 GC Roots 做出判断，所以疑似 GC Roots 的引用都无法被修改</p>
<p>  也就意味着对象无法移动，早期的 Classic 虚拟机采用句柄式访问解决了这个问题，但是效率很差</p>
</li>
<li><p>[无法采用需要移动对象的清除算法（标记整理、标记复制算法）]{.green}</p>
</li>
</ul>
<p>  :::info</p>
<p>  问题：这个疑似指针（GC Roots）是个什么东西？</p>
<p>  :::</p>
</li>
</ul>
</li>
<li><p>半保守式垃圾回收（可以跳过）</p>
<p>  :::warning</p>
<p>  ① 半保守和保守式在寻找 GC Roots 上没有任何区别，只能够采用遍历的方式</p>
<p>  ② 区别在于半保守在确定引用类型上会比保守式更快</p>
<p>  :::</p>
<ul>
<li><p>历史：Android 操作系统中早期的 Dalvik 虚拟机采用的方式</p>
</li>
<li><p>内容：</p>
<ul>
<li>在每个对象中添加类型信息，在遍历到对象的时候就可以直接知道对象拥有的是什么引用了</li>
<li>确定 GC Roots 仍然需要去遍历各个可能的区域</li>
</ul>
</li>
<li><p>缺陷：</p>
<ul>
<li><p>半保守式垃圾回收也具有保守式垃圾回收的前两个缺点</p>
</li>
<li><p>半保守式垃圾回收对于直接扫描到的对象是不可以移动的，但是对象引用的对象是可以移动的</p>
<p>  因为对象已经准确记录了引用的类型，不需要虚拟机再来判断了，只要移动对象后修改即可</p>
</li>
<li><p>[可以采用移动对象的算法（标记整理、标记复制算法）]{.green}</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>[准确式垃圾回收]{.red}</p>
<p>  :::warning</p>
<p>  ① 前两者都是采用的最为常见的遍历去查找 GC Roots，显然是非常消耗时间的</p>
<p>  ② 那么能不能采用某种方式减少这种时间开销呢？显然，空间换时间是非常自然的想法</p>
<p>  :::</p>
<ul>
<li><p>历史：HotSpot、JRockit、J9等主流的虚拟机都是采用这种方式</p>
</li>
<li><p>内容：</p>
<ul>
<li>[采用映射表将对象的引用和对象使用的引用保存下来]{.red}</li>
<li>[垃圾回收线程就根据对象的引用不断向上递归遍历，最后查找到 GC Roots]{.red}</li>
</ul>
<p>  :::info</p>
<p>  ① 映射表中的并不会直接存储 GC Roots，而是存储的对象的引用</p>
<p>  ② 每个对象都具有自己的映射表，也就是说映射表并不是全局唯一的</p>
<p>  :::</p>
</li>
<li><p>映射表名称：HotSpot 中称为 Oopmap、JRockit 中称为 livemap、J9 称为 GC map</p>
</li>
<li><p>映射表如何得到：</p>
<ul>
<li>[类加载阶段就]{.red} 将每个对象的大小计算完成，能够明确知道对象的引用和对象成员变量的数据类型</li>
<li>[即时编译阶段（JIT）也会生成相应的映射表]{.red}</li>
</ul>
</li>
<li><p>映射表如何使用：</p>
<ul>
<li>[解释式使用（HotSpot采用）：每次都会遍历原始的映射表并且递归查找 GC Roots]{.blue}</li>
<li>[编译式使用：为每个映射表都生成执行代码，每次只需要执行相应的代码就可以找到 GC Roots]{.blue}</li>
</ul>
</li>
<li><p>优点：[避免对整个内存空间的遍历，减少枚举根结点的时间]{.red}</p>
</li>
<li><p>缺点：增加垃圾回收过程占用的内存空间</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>问题：我们是否真的需要将所有对象的引用都保存在 Oopmap 中?</strong></p>
</blockquote>

        <h4 id="安全点与安全区域"   >
          <a href="#安全点与安全区域" class="heading-link"><i class="fas fa-link"></i></a><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h4>
      
        <h5 id="安全点"   >
          <a href="#安全点" class="heading-link"><i class="fas fa-link"></i></a><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h5>
      <blockquote>
<p><strong>什么是安全点?</strong></p>
</blockquote>
<ul>
<li>定义：[虚拟机在特定的位置生成的映射表，这些特定的位置就称为安全点]{.red}</li>
<li>特点：<ul>
<li>[用户线程将会在安全点停止(STW)，垃圾回收线程开始根据映射表进行根结点枚举，最后执行可达性分析]{.red}</li>
<li>所以垃圾回收线程无法想执行就执行其中之一的原因就是因为映射表不是到处都有，另外一个原因就是因为线程优先级太低</li>
</ul>
</li>
</ul>
<p>:::info</p>
<p>① 解释：没有安全点的位置也就没有映射表，没有映射表就无法进行根结点枚举，无法执行可达性分析</p>
<p>② 至于为什么用户线程需要暂停，参考为什么需要采用 STW</p>
<p>:::</p>
<blockquote>
<p><strong>为什么需要使用安全点</strong></p>
</blockquote>
<ul>
<li>原因：<ul>
<li>[堆空间中有非常多的对象，相应的引用数量也非常多，为每个对象都记录引用会占用巨大的内存空间]{.red}</li>
<li>[对象的引用会随着程序的执行发生变化，每次变化都去修改大量的映射表，开销太大]{.red}</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>如何选取安全点?</strong></p>
</blockquote>
<ul>
<li>核心：[指令序列可以复用的位置可以被选作安全点]{.red}<ul>
<li>方法调用</li>
<li>循环跳转</li>
<li>异常跳转</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>虚拟机要进行垃圾回收的时候，没有在安全点的线程如何到达安全点?</strong></p>
</blockquote>
<ul>
<li>抢先式中断（Preemptive Suspension）<ul>
<li>定义：[没有到达安全点的线程尽快执行到距离最近的安全点，然后暂停执行]{.green}</li>
<li>细节：没有任何虚拟机采用这种实现</li>
</ul>
</li>
<li>主动式中断（Voluntary Suspension）<ul>
<li>定义：<ul>
<li>[每个安全点都设置相应的标志位，用户线程每次执行到安全点都判断标志位是否为真]{.red}</li>
<li>[如果标志位为真就自行停止，反之就继续执行，垃圾回收线程就等待所有用户线程主动停止]{.red}</li>
</ul>
</li>
<li>细节：虚拟机将询问暂停的操作交给操作系统完成了，仅采用一条汇编指令</li>
</ul>
</li>
</ul>

        <h5 id="安全区域"   >
          <a href="#安全区域" class="heading-link"><i class="fas fa-link"></i></a><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h5>
      <blockquote>
<p><strong>什么是安全区域?</strong></p>
</blockquote>
<ul>
<li>定义：[用户线程不会造成对象引用关系变化的代码区域称为安全区域]{.red}</li>
</ul>
<blockquote>
<p><strong>为什么需要使用安全区域?</strong></p>
</blockquote>
<ul>
<li>用户线程无论采用哪种方式都需要自己执行到最近的安全点区</li>
<li>如果线程处于无限期等待状态或者阻塞态，那么显然是永远不可能移动到安全点去的</li>
<li>那也就意味着垃圾回收线程永远无法执行了</li>
<li>只要用户线程处于安全区域内，[对象的引用不会改变]{.red}，那么垃圾回收线程就可以开始工作</li>
</ul>
<blockquote>
<p><strong>用户线程在安全区域中行为</strong></p>
</blockquote>
<ul>
<li>[用户线程进入安全区域后会标识自己已经进入安全区域，并且通知垃圾回收线程]{.red}</li>
<li>[只要所有线程都处于安全区域或者安全点中，垃圾回收线程就可以开始执行]{.red}</li>
<li>[用户线程可以在安全区域中继续执行，在即将离开安全区域的时候询问垃圾回收线程]{.red}<ul>
<li>如果垃圾回收线程已经完成所有工作，那么用户线程就可以离开安全区域</li>
<li>如果垃圾回收线程还没有完成回收，那么用户线程只能够继续在安全区域中等待</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>垃圾回收线程开始执行的时候，线程可能处于安全区域外吗?</strong></p>
</blockquote>
<ul>
<li>答案：[不可能]{.red}</li>
<li>解释：<ul>
<li>用户线程只要不进入安全区域或者安全点，垃圾回收线程就不可能开始执行</li>
<li>因为用户线程还没有停止，垃圾回收线程与其并行显然会造成标记的不一致性</li>
<li>只有等到所有用户线程进入安全区域或者安全点的时候，垃圾回收线程才会开始执行</li>
</ul>
</li>
</ul>
<p>:::info</p>
<p>这是我自己之前看视频的时候想到的一个问题，不知道有没有人又类似的迷惑</p>
<p>:::</p>

        <h4 id="并发可达性分析"   >
          <a href="#并发可达性分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#并发可达性分析" class="headerlink" title="并发可达性分析"></a>并发可达性分析</h4>
      <p>:::info</p>
<p>参考博客：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.jianshu.com/p/12544c0ad5c1" >三色标记法与读写屏障</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<blockquote>
<p><strong>什么是并发可达分析</strong></p>
</blockquote>
<ul>
<li>定义：允许在标记阶段用户线程和 GC 线程并发执行，不再对用户线程采用 STW 机制</li>
</ul>
<blockquote>
<p><strong>为什么需要采用并发可达性分析?</strong></p>
</blockquote>
<ul>
<li>可达性分析时延<ul>
<li>根结点枚举：[根结点枚举造成的时延相对固定：因为根结点的数量较少且比较固定（就那么几类）]{.red}</li>
<li>遍历对象图：[遍历的时间和堆空间大小以及对象的数量成正比：对象数量越多，遍历的时延越长]{.red}</li>
</ul>
</li>
<li>核心原因：[减少在可达性分析过程中用户线程暂停的时间]{.red}</li>
</ul>
<blockquote>
<p><strong>并发可达性分析存在什么问题?如何解决?</strong></p>
</blockquote>
<ul>
<li><p>问题描述：可达性分析前后不一致</p>
</li>
<li><p>三色标记：</p>
<ul>
<li><p>目的：利用三色标记推导并发情况下出现的可达性分析不一致的情况</p>
</li>
<li><p>颜色：</p>
<ul>
<li>白色：表示没有被标记的对象（不可达对象）</li>
<li>黑色：表示被标记过的对象且该对象引用的其他对象也已经被标记过</li>
<li>灰色：表示被标记过的对象但是该对象引用的其他对象还没有被全部标记</li>
</ul>
</li>
<li><p>过程：</p>
<ul>
<li><p>[GC Roots 直接关联的对象全部灰色集合中]{.blue}</p>
<ul>
<li>因为没有后续的扫描，所以无法知道直接关联的对象是否有其他引用，所以不能直接放入黑色集合</li>
</ul>
</li>
<li><p>[遍历对象图：扫描直接关联对象引用的对象]{.blue}</p>
<ul>
<li>如果直接关联对象没有引用其他对象，就可以直接放入黑色集合中</li>
<li>如果直接关联对象引用的其他对象都已经被遍历完成，可以直接放入黑色集合中；反之，仍为灰色</li>
</ul>
</li>
<li><p>[遍历结束后 <strong>仍为白色</strong> 的对象将被直接回收]{.blue}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/三色标记.23ekizvhmmbk.webp" alt="三色标记" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>问题：</p>
<ul>
<li><p>多标：</p>
<ul>
<li><p>定义：[垃圾回收器将本应该被回收的垃圾误标成存活对象，导致无法回收]{.red}</p>
</li>
<li><p>过程：（这并不是唯一导致多标的情况）</p>
<ul>
<li>用户线程在 GC 线程标记 E 对象结束之后立刻将引用断开</li>
<li>GC 线程无法得知用户线程的操作依然认为 E 对象是可达的，沿着引用链遍历其余对象</li>
<li>最后 E、F、G 三个对象都将被标记为黑色，成为当次无法被回收的浮动垃圾</li>
<li>注：没有被红色框包含的的对象本身就是垃圾</li>
</ul>
</li>
<li><p>后果：[不会对程序造成太大的影响（除非垃圾对象太大），只需要等待到下次垃圾回收时回收即可]{.green}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/多标.1y2uzlcqy4u8.jpg" alt="多标" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>漏标：</p>
<ul>
<li><p>定义：[垃圾回收器将本来存活的对象标记成垃圾，导致直接被回收]{.red}</p>
</li>
<li><p>过程：</p>
<ul>
<li>用户线程在 GC 线程标记对象之前立刻将引用断开</li>
<li>在 GC 线程标记其他对象的同时，用户线程又将引用重新指向此前的对象</li>
<li>GC 线程依然无法得知用户线程的操作，将会在标记结束的阶段回收这些垃圾</li>
</ul>
</li>
<li><p>后果：[本应存活的对象被当成垃圾回收显然会对程序的运行造成非常严重的影响]{.green}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/漏标.2vjnzlchmbk0.webp" alt="漏标" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>解决方式：</p>
<ul>
<li>前提：解决方式主要针对的是漏标的情况<ul>
<li>多标产生的后果非常容易解决，只需要等待下次垃圾回收发生就行</li>
<li>漏标就没有办法依靠垃圾回收器自身解决了，需要为其设计一定的方式来解决</li>
</ul>
</li>
<li>发生条件（下列条件同时满足）<ul>
<li>[用户线程在 GC 过程中 <strong>新增黑色对象到白色对象的引用</strong>]{.red}</li>
<li>[用户线程在 GC 过程中 <strong>删除灰色对象到白色对象的引用</strong>]{.red}</li>
</ul>
</li>
<li>核心：破坏其中一个条件就可以避免出现漏标的情况<ul>
<li>增量更新（Incremental Update）<ul>
<li>定义：<ul>
<li>[每次用户线程增加黑色对象到白色对象间引用时，将该引用记录下来]{.red}</li>
<li>[并发标记结束之后，<strong>采用 STW 机制</strong> 以黑色对象为根重新扫描 <strong>记录</strong> 的引用关系]{.red}</li>
</ul>
</li>
<li>细节：增量更新破坏第一个条件从而避免对象消失</li>
</ul>
</li>
<li>原始快照（Snapshot At The Beginning SATB）<ul>
<li>定义：<ul>
<li>[每次用户线程删除灰色对象到白色对象的引用时，将其引用记录下来（相当于保留原始对象图）]{.red}</li>
<li>[并发标记结束后，采用 STW 机制以 <strong>灰色对象</strong> 为根重新扫描记录的引用关系]{.red}</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h3 id="回收算法"   >
          <a href="#回收算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h3>
      <p>:::warning</p>
<p>① 在此前运行时数据区中关于堆空间的分代布局已经提到过了</p>
<p>② 所有的清除算法理论上是既可以用于新生代，又用于老年代的</p>
<p>③ 但是在分代算法提出之后，不同的清除算法就应用于不同的分代了</p>
<p>④ [下列介绍的所有回收算法都是基于可达性分析算法而不是引用计数法]{.red}</p>
<p>:::</p>

        <h4 id="标记-清除算法"   >
          <a href="#标记-清除算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4>
      <ul>
<li><p>名称：标记-清除算法（Mark Sweep）</p>
</li>
<li><p>定义：[标记阶段结束后直接清除所有不可达对象]{.red}</p>
</li>
<li><p>特点：</p>
<ul>
<li>[标记-清除算法主要应用于老年代的回收算法]{.red}</li>
<li>[标记-清除算法需要搭配空闲列表的方式分配内存]{.red}</li>
<li>标记-清除算法是其余所有回收算法的基础</li>
</ul>
</li>
<li><p>优点：[不需要改变存活对象在内存中的位置，也就不需要改变存活对象的引用]{.red}</p>
</li>
<li><p>缺点：</p>
<ul>
<li>回收不可达对象的效率偏低</li>
<li>[不可达对象被回收之后容易造成大量的内存碎片，需要连续内存空间的大对象无法存放]{.green}</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/标记-清除算法.6zne694tsgs0.png" alt="标记-清除算法" style="zoom:80%;" />


        <h4 id="标记-复制算法"   >
          <a href="#标记-复制算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4>
      <ul>
<li><p>名称：标记-复制算法（Mark Copying）</p>
</li>
<li><p>定义：</p>
<ul>
<li>[将内存区域划分为大小相等的两块，每次仅使用其中的一块]{.red}</li>
<li>[标记阶段执行的同时就将所有存活的对象全部 <strong>复制</strong> 到另一块空的内存区域中]{.red}</li>
<li>[复制的过程中会将对象在内存中 <strong>按照顺序</strong> 存放]{.red}</li>
<li>[更新所有对象的引用指向的地址]{.red}</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>[标记-复制算法主要针对新生代的算法]{.red}</li>
<li>[标记-复制算法搭配指针碰撞使用]{.red}<ul>
<li>对象在被复制完成后是按照顺序规整存放的，所以可以直接使用指针碰撞</li>
</ul>
</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>[核心：避免碎片问题的产生，提高内存的利用率]{.red}</li>
<li>[复制算法的执行过程中 “没有” 标记阶段，减少操作开销]{.red}<ul>
<li>并不是真正意义上的没有标记过程，只是在标记不可达对象的同时就将对象复制到另一块区域中了</li>
</ul>
</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>[浪费内存空间，内存空间将会有一半没有被使用]{.green}</li>
<li>[每次都需要执行复制对象的操作，具有一定的操作开销]{.green}</li>
</ul>
</li>
<li><p>问题：</p>
<p>  +++danger 为什么标记-复制算法主要针对年轻代而不针对老年代呢?</p>
<p>  ① 年轻代的存活对象相对较少，每次进行复制操作的开销较少</p>
<p>  ② 老年代大多数对象都是存活的，对老年代采用复制算法无疑会产生大量对象的复制开销</p>
<p>  ③ 老年代的内存空间相对于年轻代要大一倍，对老年代采用复制算法无疑会浪费更多的空间</p>
<p>  +++</p>
<p>  +++danger 标记-复制算法难道不会浪费年轻代的空间吗?</p>
<p>  ① 大多数对象都是“朝生夕灭”的，生命周期非常短暂，也就意味着存活的对象非常少</p>
<p>  ② 没有太大必要等比例划分新生代空间，将其中的一半用来存放少量的存活对象</p>
<p>  ③ 所以此后采用了更加优化的半区复制策略，不是简单地将新生代 1:1 划分，而是采用 8:1:1 的比例划分为伊甸园区和幸存者区</p>
<p>  ④ 只有两块幸存者区中会出现来回复制，这样即减少了内存的浪费，又避免了的内存碎片的问题</p>
<p>  +++</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/标记-复制算法.6f4ipp1elys0.png" alt="标记-复制算法" style="zoom:80%;" />


        <h4 id="标记-整理算法"   >
          <a href="#标记-整理算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4>
      <ul>
<li>名称：标记-整理算法（Mark Compact）</li>
<li>定义：<ul>
<li>标记阶段结束后清除所有不可达对象</li>
<li>[将所有存活的对象全部向内存的一端移动，将其按照顺序紧密排列]{.red}</li>
<li>[更新所有被移动对象的引用指向的地址]{.red}</li>
</ul>
</li>
<li>特点：<ul>
<li>[标记-整理算法主要针对老年代的算法]{.red}</li>
<li>[标记-整理算法搭配指针碰撞分配内存]{.red}</li>
</ul>
</li>
<li>优点：<ul>
<li>[避免内存碎片的产生，提高内存空间的利用率]{.red}</li>
<li>[消除标记-复制算法带来的内存减半的高额代价]{.red}</li>
</ul>
</li>
<li>缺点：<ul>
<li>[每次都需要移动大量的对象和更改大量的引用地址，操作开销特别大]{.green}</li>
<li>[造成用户线程暂停时间（STW）是三种算法中最长的]{.green}</li>
<li>[效率相对较低]{.green}</li>
</ul>
</li>
</ul>

        <h4 id="分代算法"   >
          <a href="#分代算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#分代算法" class="headerlink" title="分代算法"></a>分代算法</h4>
      
        <h5 id="基本内容-1"   >
          <a href="#基本内容-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本内容-1" class="headerlink" title="基本内容"></a>基本内容</h5>
      <ul>
<li>前提：与其说分代收集是一种算法不如说是一种理论</li>
<li>定义：<ul>
<li>[堆空间划分为不同的区域（年轻代 + 老年代）]{.red}</li>
<li>[不同的区域采用不同的算法，不同的垃圾回收器收集的区域也不同]{.red}</li>
<li>[年轻代采用标记-复制算法，老年代采用标记-整理或者采用标记-清除算法]{.red}</li>
</ul>
</li>
<li>优点：[避免垃圾回收器整堆收集，提升垃圾回收效率]{.red}（参考<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://47.101.45.234/jvm/runtime/HeapSpace/%E6%A6%82%E8%BF%B0/" >堆空间-概述</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>）</li>
<li>缺点：[存在跨代引用问题]{.green}</li>
<li>细节：现代几乎所有虚拟机/垃圾收集器都采用分代收集算法（ZGC、Shenandoah 默认不采用分代算法）</li>
</ul>

        <h5 id="卡表与记忆集"   >
          <a href="#卡表与记忆集" class="heading-link"><i class="fas fa-link"></i></a><a href="#卡表与记忆集" class="headerlink" title="卡表与记忆集"></a>卡表与记忆集</h5>
      <blockquote>
<p><strong>什么是跨代引用</strong></p>
</blockquote>
<ul>
<li>描述：<ul>
<li>分代收集理论导致垃圾回收器可能仅对年轻代或者老年代进行收集</li>
<li>[但是没有被收集的区域的对象可能引用了收集区域的对象 =&gt; 跨代引用]{.red}</li>
</ul>
</li>
<li>带来的问题：<ul>
<li>垃圾回收器如何才能够得知哪些收集区域的对象被非收集区域的对象所引用呢？</li>
</ul>
</li>
<li>方式：<ul>
<li>[遍历非收集区域的对象并将其加入 GC Roots 后进行可达性分析]{.green}<ul>
<li>优点：实现简单</li>
<li>缺点：[非收集区域空间太大或者对象数量太多的情况下会严重影响根结点枚举的时间]{.aqua}</li>
</ul>
</li>
<li>[记忆集：直接记录存在跨代引用的内存区域，将其直接加入 GC Roots 后进行可达性分析]{.red}</li>
</ul>
</li>
<li>细节：[只要采用分代收集算法或者分区算法的垃圾回收器都存在跨代引用问题]{.red}</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/跨代引用.5w18ofsn7k80.png" alt="跨代引用" style="zoom:80%;" />

<blockquote>
<p><strong>为什么需要使用记忆集</strong></p>
</blockquote>
<ul>
<li><p>直接原因：避免被跨代引用的对象被识别不可达对象，从而垃圾回收器回收</p>
</li>
<li><p>核心原因：[避免采用遍历的方式去搜索非收集区域中的 GC Roots，减少根结点枚举时的开销]{.red}</p>
</li>
</ul>
<blockquote>
<p><strong>什么是记忆集?</strong></p>
</blockquote>
<ul>
<li><p>名称：Remember Set</p>
</li>
<li><p>定义：[用于存储非收集区域对象引用收集区域对象的指针集合的 <strong>抽象数据结构</strong>]{.red}</p>
</li>
<li><p>具体实现：</p>
<ul>
<li>字长精度：记忆集保存记录了跨代引用的机器字长</li>
<li>卡精度：[记忆集保存内存区域的地址，该内存区域中存在对象包含跨代指针]{.red}</li>
<li>对象精度：[记忆集直接保存跨代引用收集区域的对象，对象中包含跨代指针]{.green}</li>
</ul>
<p>  +++ 为什么不使用对象精度的记忆集而是使用卡精度的记忆集呢？</p>
<p>  ① 每个对象包含的数据非常多，记忆集只需要知道跨代引用在哪里就可以了，不需要关心其他的数据</p>
<p>  ② 所有就不需要以对象为单位那么高的精度，只需要记录跨代引用可能存在的位置就行</p>
<p>  +++</p>
</li>
<li><p>优点：[避免遍历非收集区域寻找 GC Roots，节省根结点枚举的时间]{.red}</p>
</li>
<li><p>缺点：</p>
<ul>
<li>[需要采用写屏障的技术维护记忆集]{.green}</li>
<li>[记忆集需要占用一定的空间（Garbage First 垃圾回收器的记忆集占用空间特别大（20%左右））]{.green}</li>
</ul>
</li>
</ul>
<p>:::info</p>
<p>① 我们可以做个类比，大概就能够明白记忆集是个什么东西了</p>
<p>② 此前我们为了确定哪些是 GC Roots 首先想到的方法就是遍历整个内存空间，但是为了避免遍历的开销采用了 Oopmap 优化这个过程</p>
<p>③ 现在我们为了确定跨代引用的对象首先想到的依然是遍历整个非收集区域，但是为了避免遍历的开销采用了 Remember Set 优化</p>
<p>④ 总结来说，记忆集就是为了确保被跨代引用的对象不会被错误识别成垃圾，同时优化根结点枚举过程的手段</p>
<p>:::</p>
<blockquote>
<p><strong>什么是卡表?</strong></p>
</blockquote>
<ul>
<li>定义：采用卡精度实现的记忆集就是卡表</li>
<li>原理：<ul>
<li>[采用 HashTable / HashMap 实现]{.red}</li>
<li>每个 Card_Table（key）都对应一块 Card_Page（内存区域 value）</li>
<li>如果 Card_Page 中存在对象包含跨代引用，那么该 Card_Page 就会被标记（Dirty）</li>
<li>如果 Card_Page 中不存在对象包含跨代引用，那么该 Card_Page 就不会被标记</li>
</ul>
</li>
<li>分类<ul>
<li>单向卡表：[仅记录非收集区域对收集区域对象的引用]{.red}</li>
<li>双向卡表：[]{.red}</li>
</ul>
</li>
</ul>

        <h5 id="写屏障"   >
          <a href="#写屏障" class="heading-link"><i class="fas fa-link"></i></a><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h5>
      <blockquote>
<p><strong>问题：记忆集用于记录跨代引用，那么跨代引用是怎么被记录进去的呢?</strong></p>
</blockquote>
<ul>
<li><p>定义：</p>
<ul>
<li>写屏障会检查该引用是否为跨代引用</li>
<li>如果是跨代引用，就会写入记忆集；如果不是跨代引用，就不会写入记忆集</li>
</ul>
</li>
<li><p>触发条件：[每次对象的引用更新时触发写屏障操作]{.red}</p>
</li>
<li><p>特点：[无论是否为跨代引用都会产生写屏障的操作]{.red}</p>
</li>
<li><p>代码：</p>
  <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oop_field_store</span><span class="params">(oop* field, oop new_value)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    *field = new_value; </span><br><span class="line">    <span class="comment">// 写屏障-写后操作：① 检查是否为跨代引用 ② 如果是跨代引用就会写入记忆集</span></span><br><span class="line">    <span class="built_in">post_write_barrier</span>(field, value); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h4 id="增量更新"   >
          <a href="#增量更新" class="heading-link"><i class="fas fa-link"></i></a><a href="#增量更新" class="headerlink" title="增量更新"></a>增量更新</h4>
      
        <h4 id="分区算法"   >
          <a href="#分区算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h4>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/28/jvm/garbage-collection/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E6%A6%82%E8%BF%B0/">垃圾回收-概述</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-03</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h1>
      
        <h2 id="垃圾回收机制简介"   >
          <a href="#垃圾回收机制简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#垃圾回收机制简介" class="headerlink" title="垃圾回收机制简介"></a>垃圾回收机制简介</h2>
      
        <h3 id="什么是垃圾回收机制？"   >
          <a href="#什么是垃圾回收机制？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是垃圾回收机制？" class="headerlink" title="什么是垃圾回收机制？"></a>什么是垃圾回收机制？</h3>
      <blockquote>
<p><strong>1. 先来聊聊有关垃圾回收机制的历史吧</strong></p>
</blockquote>
<ul>
<li>历史①：垃圾回收机制也称为自动内存管理，旨在由虚拟机自动管理内存空间而不需要开发者的介入</li>
<li>历史②：Lisp 语言是世界第一门采用动态内存分配和垃圾收集技术的语言</li>
<li>历史③：手动垃圾回收与自动垃圾回收<ul>
<li>手动垃圾回收<ul>
<li>代表语言：C/C++</li>
<li>定义：[开发者必须手动调用方法去回收内存中的垃圾]{.blue}</li>
<li>优点：[开发者能够直接对内存进行更加灵活的管理，更加清楚内存分配的细节]{.red}</li>
<li>缺点：[频繁地手动进行内存分配和垃圾回收是十分麻烦的]{.green}</li>
</ul>
</li>
<li>自动管理：<ul>
<li>代表语言：Java、C#</li>
<li>定义：[虚拟机自动回收堆空间中的垃圾，不再需要程序员关心]{.blue}</li>
<li>优点：[虚拟机代替开发者对堆空间进行管理，开发者能够更加集中于应用开发]{.red}</li>
<li>缺点：[堆空间出现溢出问题，开发者难以直接对其进行管理，只能够通过配置虚拟机参数间接管控]{.green}</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>2. 了解历史之后，再来看看垃圾回收机制的主要任务吧</strong></p>
</blockquote>
<ul>
<li>核心任务<ul>
<li>[为新对象分配相应的内存空间]{.red}<ul>
<li>[两种分配方式(<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://47.101.45.234/jvm/runtime/HeapSpace/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/" >堆空间-对象创建</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 已经提到过)：① 指针碰撞 ② 空闲列表]{.red}</li>
<li>[采用的对象的分配方式取决于回收堆空间的方式]{.red}</li>
</ul>
</li>
<li>[标记内存空间的垃圾并对垃圾进行清除]{.red}<ul>
<li>方式：两个阶段采用的不同算法<ul>
<li>[标记算法：可达性分析]{.orange}</li>
<li>[清除算法：引用计数法、标记-清除、标记-整理、标记-复制]{.orange}</li>
</ul>
</li>
<li>区域：[频繁收集新生代，较少收集老年代，基本不动方法区]{.red}<ul>
<li>[新生代：只针对新生代的收集称为 Minor GC / Young GC]{.orange}</li>
<li>[老年代：只针对老年代的收集称为 Major GC]{.orange}</li>
<li>[整堆：针对方法区和堆区的收集称为 Full GC]{.orange}</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>其余任务：负责堆的管理和布局、与解释器和编译的协作、与监控子系统协作等等职责</li>
</ul>
<blockquote>
<p><strong>3. 垃圾回收的垃圾指的是什么?垃圾回收真的只回收垃圾吗?</strong></p>
</blockquote>
<ul>
<li>核心：垃圾回收机制主要回收 [内存空间中的垃圾和非必要的对象]{.red}<ul>
<li>垃圾（主要）：[不再被任何变量引用的对象就是垃圾]{.red}</li>
<li>非必要的对象（次要）：[仅被软引用、弱引用、虚引用指向的对象]{.red}（<a href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B">引用类型</a>）</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/什么是垃圾.4ftyge19sly0.png" alt="什么是垃圾" style="zoom:80%;" />


        <h3 id="为什么需要垃圾回收机制？"   >
          <a href="#为什么需要垃圾回收机制？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么需要垃圾回收机制？" class="headerlink" title="为什么需要垃圾回收机制？"></a>为什么需要垃圾回收机制？</h3>
      <ul>
<li>核心：为了保证程序能够正常高效地运作<ul>
<li>[没有垃圾回收将会使得内存空间被很快消耗殆尽，从而导致 OutOfMemoryError 异常]{.red}<ul>
<li>消耗内存的原因①：<a href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA">内存溢出</a></li>
<li>消耗内存的原因②：<a href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">内存泄漏</a></li>
</ul>
</li>
<li>[没有垃圾回收将会使得内存空间产生大量的碎片，从而导致大对象无法被存放在堆空间中]{.red}<ul>
<li>[Java 堆空间采用的是连续内存分配，只要对象被回收之后必定会产生碎片问题]{.orange}</li>
<li>[大对象必须使用连续的内存空间，不能够拆分成几部分存储，原因是因为实现简单高效]{.orange}</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>:::info</p>
<p>① 连续内存分配是操作系统中的概念，可以阅读我写的 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://47.101.45.234/operating-system/memory/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" >操作系统有关内存的笔记</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 进行了解</p>
<p>② 内存碎片的概念也是操作系统中的，可以细分为内部碎片和外部碎片，也可以参考我的操作系统笔记进行了解</p>
<p>:::</p>

        <h3 id="什么时候执行垃圾回收？"   >
          <a href="#什么时候执行垃圾回收？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么时候执行垃圾回收？" class="headerlink" title="什么时候执行垃圾回收？"></a>什么时候执行垃圾回收？</h3>
      <ul>
<li>主动发起：手动调用 <a href="#System.gc()">System.gc()</a> 等相关方法<ul>
<li>虚拟机并不会立刻开始执行垃圾回收：<ul>
<li>[① 垃圾回收线程优先级太低 ]{.red}</li>
<li>[② 需要等待所有线程进入安全区域或者安全点才会开始回收]{.red}</li>
</ul>
</li>
</ul>
</li>
<li>被动发起：[新生代中的伊甸园区或者老年代将要 <strong>用尽</strong> 的时候]{.red}<ul>
<li>[新生代中的幸存者区不会触发垃圾回收机制的执行]{.red}</li>
<li>分区算法</li>
</ul>
</li>
</ul>

        <h3 id="垃圾回收机制如何执行"   >
          <a href="#垃圾回收机制如何执行" class="heading-link"><i class="fas fa-link"></i></a><a href="#垃圾回收机制如何执行" class="headerlink" title="垃圾回收机制如何执行?"></a>垃圾回收机制如何执行?</h3>
      <ul>
<li><p>垃圾回收器：</p>
<ul>
<li><p>垃圾回收器是虚拟机中执行垃圾回收机制的部分</p>
</li>
<li><p>分类：[7 大经典垃圾回收器 + 3 大前沿的垃圾回收器]{.blue}</p>
</li>
<li><p>过程：</p>
<ul>
<li>[标记阶段：判断哪些对象不再被变量引用并标记为垃圾]{.red}</li>
<li>[清理阶段：清除那些被标记为垃圾的对象]{.red}</li>
</ul>
</li>
<li><p>细节：[所有垃圾回收器在执行的过程中的两个阶段都会造成用户线程暂停（<a href="#STW">STW</a>）]{.red}</p>
<ul>
<li>采用不同的设计方式的垃圾回收器带来的 STW 时延并不一致</li>
<li>STW 将会在后面的细节中详细介绍</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h2 id="垃圾回收细节"   >
          <a href="#垃圾回收细节" class="heading-link"><i class="fas fa-link"></i></a><a href="#垃圾回收细节" class="headerlink" title="垃圾回收细节"></a>垃圾回收细节</h2>
      
        <h3 id="引用类型"   >
          <a href="#引用类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3>
      <blockquote>
<p><strong>为什么引用还需细分类型?</strong></p>
</blockquote>
<ul>
<li>核心：[尽可能应对所有可能面临的应用场景]{.red}</li>
<li>场景：[如果我们希望某些对象能够在内存充足的时候存活，而在内存紧张的时候被回收呢？（缓存）]{.blue}<ul>
<li>普通的引用显然无法满足这个要求，普通的引用只要指向某个对象，那么这个对象就不可能被回收</li>
<li>我们也不可能根据内存的情况，手动地解除引用，毕竟内存是由虚拟机维护的</li>
<li>基于这些可能面临的场景，才会进一步提出细分引用的类型</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>五种引用类型</strong></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/引用类型图示.p069iddb3rk.png" alt="引用类型图示" style="zoom:80%;" />

<p>:::info</p>
<p>① JDK 1.2 对引用的概念进行了扩充并且新增了四种引用类型：软引用、弱引用、虚引用、终结器引用</p>
<p>② 新增的三种引用类型都归属于反射包下（java.lang.ref）</p>
<p>:::</p>
<ul>
<li><p>前提：</p>
<ul>
<li>没有被引用指向的对象是一定会被回收的</li>
<li>[被引用指向的对象也是有可能被对象回收的]{.blue}</li>
</ul>
</li>
<li><p>强引用（Strong Referrence）</p>
<ul>
<li><p>定义：默认对象都是被强引用所指向的（采用常规创建对象的方式得到的变量都是强引用）</p>
</li>
<li><p>特点：[只要被强引用指向的对象绝对不会被垃圾回收器回收]{.red}</p>
</li>
<li><p>细节：99 % 的开发中都是使用的强引用</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置虚拟机参数 -XX:PrintGCDetails 年轻代没有任何变化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 两个强引用同时指向一个实例对象</span></span><br><span class="line">    StringBuilder str1 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Hello, World&quot;</span>);</span><br><span class="line">    StringBuilder str2 = str1;</span><br><span class="line">    <span class="comment">// 解除其中一个引用</span></span><br><span class="line">    str1 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 主动调用垃圾回收：对象显然不会被回收</span></span><br><span class="line">    System.gc();</span><br><span class="line">    <span class="comment">// 确保垃圾回收线程可以被执行</span></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="comment">// 测试两者的内容: 前者为 null, 后者为 Hello World</span></span><br><span class="line">    System.out.println(str1);</span><br><span class="line">    System.out.println(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>软引用（Soft Referrence）</p>
<ul>
<li><p>定义：用于描述那些有用但是非必须的对象</p>
</li>
<li><p>特点：[软引用指向的对象只有内存空间非常紧张的情况下才会被垃圾回收器回收]{.red}</p>
</li>
<li><p>细节：[可以用于实现高速缓存（Spring、Mybatis 缓存底层就是采用这种引用实现的）]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试：软引用指向的对象是否将会在内存紧张的情况下被回收</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftReferrenceTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@ToString</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(id + <span class="string">&quot;: 对象被回收...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 注意: 软引用指向的对象当前是没有强引用指向的</span></span><br><span class="line">        SoftReference&lt;User&gt; object = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">&quot;冬坂五百里&quot;</span>));</span><br><span class="line">        <span class="comment">// 强引用指向的对象</span></span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="number">2</span>,<span class="string">&quot;斧乃木余接&quot;</span>);</span><br><span class="line">        <span class="comment">// 主动调用垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// ① 查看对象是否被回收: 内存充足的情况没有被回收</span></span><br><span class="line">        System.out.println(object.get());</span><br><span class="line">        <span class="comment">// ② 采用大对象占用堆空间, 逼迫垃圾回收器开始回收弱引用对象</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">7</span> - <span class="number">1024</span> * <span class="number">600</span>];</span><br><span class="line">        <span class="comment">// 测试结果有点意外，即使在老年代已经被占用 99% 的情况下依然没有被回收</span></span><br><span class="line">        <span class="comment">// 但是在发生溢出之后就被回收掉了，作为对比，那个强引用指向的对象至始至终没有被回收</span></span><br><span class="line">        System.out.println(object.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>弱引用（Weak Referrence）</p>
<ul>
<li><p>定义：用于描述那些非必须的对象，仅使用一次的对象</p>
</li>
<li><p>特点：[弱引用指向的对象在下次垃圾回收器开始回收时就会直接被回收掉]{.red}</p>
</li>
<li><p>细节：</p>
<ul>
<li><p>[垃圾回收的线程优先级非常低，所以弱引用指向的对象也可以存活很长时间（可用于实现缓存）]{.red}</p>
<p>  :::info</p>
<p>  你可以尝试把下面代码中的输出和休眠代码交换顺序，你会发现弱引用指向的对象依然存活</p>
<p>  :::</p>
</li>
<li><p>弱引用不需要通过标记算法确定是否回收，因为无论是否存活都会被回收，相比于软引用效率更高</p>
</li>
<li><p>集合框架中的工具类 <a href="">WeakHashMap</a> 就是采用弱引用实现的</p>
</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意: 弱引用指向的对象当前是没有强引用指向的</span></span><br><span class="line">    WeakReference&lt;StringBuilder&gt; str = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> StringBuilder(<span class="string">&quot;Hello, World&quot;</span>));</span><br><span class="line">    <span class="comment">// 主动调用垃圾回收</span></span><br><span class="line">    System.gc();</span><br><span class="line">    <span class="comment">// 确保垃圾回收线程能够执行</span></span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    System.out.println(str.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>虚引用（Phantom Referrence）</p>
<ul>
<li><p>定义：用于在垃圾回收对象时得到相应的通知（需要借助引用队列）</p>
<ul>
<li>引用队列（Referrence Queue）：所有被标记需要回收的对象都会被添加进入引用队列</li>
<li>弱引用和软引用都可以使用引用队列用来获取对象被销毁的通知，是可选的</li>
<li>虚引用必须借助引用队列来获取对象被销毁的通知</li>
</ul>
<p>  +++ 为什么虚引用必须要使用引用队列而弱引用和软引用不需要呢？</p>
<p>  ① 因为虚引用无法获取对象的任何信息，还不借助引用队列，那就彻底没有价值了</p>
<p>  ② 软引用和弱引用可以获取对象实例来确认对象是否已经被回收</p>
<p>  +++</p>
</li>
<li><p>特点：</p>
<ul>
<li>[虚引用指向的对象也会在下次垃圾回收器开始回收时就被回收]{.red}</li>
<li>[虚引用指向的对象是无法通过虚引用来获得的]{.red}</li>
</ul>
</li>
<li><p>细节：你可以认为这种引用基本没有什么卵用</p>
</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReferrenceTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 必须传入引用队列，最后需要借助引用队列来获取销毁对象的通知</span></span><br><span class="line">        ReferenceQueue&lt;StringBuilder&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">        PhantomReference&lt;StringBuilder&gt; str = <span class="keyword">new</span> PhantomReference&lt;&gt;(<span class="keyword">new</span> StringBuilder(<span class="string">&quot;Hello, World&quot;</span>), queue);</span><br><span class="line">        <span class="comment">// 使用虚引用获得实例对象: 获取不到</span></span><br><span class="line">        System.out.println(str.get());</span><br><span class="line">        <span class="comment">// 主动调用垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 引用队列中取出元素: 如果弱引用对象没有被销毁, 线程将会被阻塞, 如果被销毁将会返回对象</span></span><br><span class="line">        Reference&lt;StringBuilder&gt; msg = (Reference&lt;StringBuilder&gt;) queue.remove();</span><br><span class="line">        <span class="comment">// 测试虚引用指向的对象是否被回收</span></span><br><span class="line">        System.out.println(msg == <span class="keyword">null</span> ? <span class="string">&quot;对象没有被回收...&quot;</span> : <span class="string">&quot;对象被回收...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>终结器引用（Final Referrence）</p>
<ul>
<li>定义：没有强引用指向的对象虚拟机会为其默认添加的引用就是终结器引用</li>
<li>特点：终结器引用的对象将会被添加的 F-Queue 队列中等待被回收</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li><p>[同一个对象可以被多个不同的类型的引用所指向]{.red}</p>
</li>
<li><p>[只有强引用指向的对象才会导致内存溢出，其余引用类型指向的对象不可能导致溢出]{.red}</p>
<blockquote>
<p>因为其余引用类型指向的对象将会在内存发生溢出之前就会被回收掉</p>
</blockquote>
</li>
</ul>
</li>
</ul>

        <h3 id="内存溢出"   >
          <a href="#内存溢出" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3>
      <blockquote>
<p><strong>什么是内存溢出</strong></p>
</blockquote>
<ul>
<li>定义：[内存空间无法再容纳新的对象]{.red}</li>
</ul>

        <h3 id="内存泄漏"   >
          <a href="#内存泄漏" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3>
      <p>:::info</p>
<p>参考博客：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://stackoverflow.com/questions/6470651/how-can-i-create-a-memory-leak-in-java" >How can I create a memory leak in Java?</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_32015283/article/details/87916080" >什么是内存泄漏，常见引起引起内存泄漏的原因,及解决办法</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/32540739" >详解Java应用程序中的内存泄露是如何发生的</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<blockquote>
<p><strong>什么是内存泄露?</strong></p>
</blockquote>
<ul>
<li><p>定义：</p>
<ul>
<li>[狭义：不再被使用的对象无法被垃圾回收器回收 / 对象使用完毕之后没有释放相应的空间]{.red}</li>
<li>[广义：对象的生命周期被无限期延长导致垃圾回收器无法回收]{.red}</li>
</ul>
</li>
<li><p>图示：</p>
<ul>
<li><p>举例：</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/内存泄漏例子.1dfunfqeku74.png" alt="内存泄漏例子" style="zoom:80%;" /></li>
<li><p>抽象：</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/内存泄露.46zfc578yuw0.png" alt="内存泄露" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>造成内存泄露的原因是什么?</strong></p>
</blockquote>
<p>:::warning</p>
<p>① 不少博客上的例子是存在一定问题的，你只要亲手实验了就会发现</p>
<p>② 所以以下列举出的原因并不一定是准确的，即使在 StackOverFlow 上关于内存泄漏的情况都是有争议的</p>
<p>:::</p>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/内存泄露示意图.32lpbpj83a60.png" alt="内存泄露示意图" style="zoom:80%;" />

<ul>
<li><p>原因：</p>
<ul>
<li><p>[静态变量：静态变量和类的生命周期一致，使用完成之后没有即时释放就非常容易造成内存泄露]{.red}</p>
<ul>
<li><p>单例模式</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryLeak</span></span>&#123;</span><br><span class="line">    <span class="comment">// 难以被回收的静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MemoryLeak memoryLeak = <span class="keyword">null</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MemoryLeak</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MemoryLeak <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memoryLeak == <span class="keyword">null</span> ? <span class="keyword">new</span> MemoryLeak() : memoryLeak;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>类变量</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryLeak</span></span>&#123;</span><br><span class="line">    <span class="comment">// 声明了静态变量，但是你使用结束后又没有显示的释放空间，就非常容易造成内存溢出</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MemoryLeak memoryLeak = <span class="keyword">new</span> MemoryLeak();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>[集合：不再使用的元素没有被移除就会导致集合长期持有对象的引用，无法被垃圾回收清除，导致内存泄漏]{.red}</p>
<p>  无论集合是成员变量还是局部变量都有可能产生这个问题</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryLeak</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;我被回收了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        List&lt;MemoryLeak&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 集合中的第一个对象我不想再使用的了，但是我忘了移除这个元素</span></span><br><span class="line">        <span class="comment">// 垃圾回收器就无法对其进行回收</span></span><br><span class="line">        Collections.addAll(list, <span class="keyword">new</span> MemoryLeak(),</span><br><span class="line">                           <span class="keyword">new</span> MemoryLeak(),</span><br><span class="line">                           <span class="keyword">new</span> MemoryLeak(),</span><br><span class="line">                           <span class="keyword">new</span> MemoryLeak());</span><br><span class="line">        <span class="comment">// 主动调用垃圾回收机制，对象肯定无法被回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>[非静态内部类：]{.red}</p>
<ul>
<li>[非静态内部类持有外部类的引用，即使外部类对象不再被引用了，内部类对象仍被引用，也无法被回收]{.red}</li>
<li>IDEA 通常会建议你将非静态内部类变成内部类</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryLeak</span></span>&#123;</span><br><span class="line">    <span class="comment">// 即使外部类使用完毕，但是由于内部类还在使用，就会导致外部类无法被垃圾回收</span></span><br><span class="line">    <span class="keyword">private</span> InnerClass innerClass = <span class="keyword">new</span> InnerClass();</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>[未关闭的流或者连接：数据库连接，网络连接，IO 流]{.red}</p>
<ul>
<li>StackOverFlow 上有部分人认为没有关闭的流或者连接不算做内存泄漏</li>
<li>但是我觉得既然连接用完了，没有关闭的连接肯定是要占用资源的</li>
</ul>
</li>
</ul>
</li>
<li><p>总结：[所有内存泄漏的原因归根究底都是你的代码写的有问题，所以要注意自己的代码质量]{.red}</p>
</li>
</ul>

        <h3 id="并行与并发"   >
          <a href="#并行与并发" class="heading-link"><i class="fas fa-link"></i></a><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3>
      <p>:::danger</p>
<p>① 如果你已经学习过操作系统中的并行与并发的话，请最好忘记这两个概念在操作系统中的含义</p>
<p>② 垃圾回收机制中的并行与并发和操作系统中的定义完全不同，不要用操作系统中的并行与并发去看待垃圾回收中的</p>
<p>③ 如果你实在无法忘记，我也会尽可能阐释这两者之间的联系和区别</p>
<p>④ 此后提到的所有并行和并发都是指的垃圾回收层面的</p>
<p>最好的参考资料：《垃圾回收算法手册》P257、P286 两页非常清楚地说明了垃圾回收层面的并行和并发</p>
<p>:::</p>

        <h4 id="操作系统角度（可以跳过）"   >
          <a href="#操作系统角度（可以跳过）" class="heading-link"><i class="fas fa-link"></i></a><a href="#操作系统角度（可以跳过）" class="headerlink" title="操作系统角度（可以跳过）"></a>操作系统角度（可以跳过）</h4>
      <ul>
<li><p>前提：[每个计算核在某个时刻仅能够执行一个进程或者线程]{.blue}</p>
</li>
<li><p>操作系统层面：并行与并发</p>
<ul>
<li><p>并发（Concurrent）：</p>
<ul>
<li><p>定义：[多个进程或者线程交替执行，在某个时间段内可以认为同时执行]{.red}</p>
</li>
<li><p>特点：[单核处理器仅能够实现并发]{.red}</p>
<ul>
<li>单核处理器只具有单个计算核，所以只可以在 [同一时刻]{.red} 执行一个进程或者线程</li>
<li>但是单核处理器可以在 [某个时间段内]{.red} 交替进程或者线程执行，看起来像是同时执行（伪并行）</li>
</ul>
</li>
</ul>
</li>
<li><p>并行（Parallel）：</p>
<ul>
<li><p>定义：[多个进程同时执行]{.red}</p>
</li>
<li><p>特点：[仅有多核处理器能够实现并行]{.red}</p>
<ul>
<li>多核处理器具有多个计算核，所以可以在 [同一时刻]{.red} 同时执行多个进程</li>
</ul>
</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li>[并行和并发不是相互矛盾的概念，两者和串行是矛盾的概念]{.red}<ul>
<li>单核处理器：并发意味着可以交替线程执行，串行就只能按照顺序执行</li>
<li>多核处理器：并行意味着可以同时执行多个线程，串行就只能够每次使用单个计算核按照顺序执行</li>
</ul>
</li>
<li>[并行和并发既然不是矛盾的概念，意味着并行中允许实现并发]{.red}<ul>
<li>多核处理器同时执行多个进程或者线程，但是进程或者线程的数量超过了计算核的数量</li>
<li>那么每个处理器就需要交替执行不同的进程或者线程，也就实现了进程或者线程的并发性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/操作系统并行与并发.osvyf1lgpgg.png" alt="操作系统并行与并发" style="zoom: 67%;" />


        <h4 id="垃圾回收角度（重要）"   >
          <a href="#垃圾回收角度（重要）" class="heading-link"><i class="fas fa-link"></i></a><a href="#垃圾回收角度（重要）" class="headerlink" title="垃圾回收角度（重要）"></a>垃圾回收角度（重要）</h4>
      <p>:::danger</p>
<p>理解垃圾回收的并行与并发是非常关键的，因为具体的垃圾回收器就是从这两个方面着手改进的</p>
<p>:::</p>
<ul>
<li><p>串行：</p>
<ul>
<li>定义：[GC 线程执行完成后才能够轮到用户线程执行]{.red}</li>
<li>代表性垃圾回收器：Serial、Serial Old</li>
</ul>
</li>
<li><p>并行：</p>
<ul>
<li>定义：[垃圾回收器启用多条 GC 线程同时执行，默认对用户线程使用 STW 机制]{.red}<ul>
<li>只有多条 GC 线程同时执行：不符合操作系统中的并行概念，但是在垃圾回收中就是并行</li>
<li>[并行中默认对用户线程使用 STW 机制，因为不采用 STW 机制就是并发了]{.red}</li>
</ul>
</li>
<li>优点：提高了单次垃圾回收的效率，降低了单次垃圾回收造成的 STW 时延</li>
<li>代表性垃圾回收器：Parallel Scavenge、ParNew、Parallel Old </li>
</ul>
<p>  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%A4%BA/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C.n5t4t801e3k.png" alt="垃圾回收并行执行"></p>
</li>
<li><p>并发：</p>
<ul>
<li>定义：[用户线程和 GC 线程同时执行，不对用户线程使用 STW 机制]{.red}<ul>
<li>[多条用户线程和多条 GC 线程同时执行]{.red}<ul>
<li>符合操作系统的并行概念，但在垃圾回收层面视为并发</li>
<li>GC 线程数量超过自己拥有的处理器数量就会出现操作系统中的并发现象，需要交替执行</li>
<li>用户线程数量超过自己拥有的处理器数量就会出现操作系统中的并发现象，也需要交替执行</li>
<li>[两者并发执行不会相互干扰，即不会出现 GC 线程抢占用户线程执行的情况，能够继续保持并行]{.orange}</li>
</ul>
</li>
<li>[不对用户线程使用 STW 机制不代表并发垃圾回收器没有延迟]{.red}<ul>
<li>[垃圾回收器的执行是分阶段，部分阶段可以并发，部分阶段依然只能够并行]{.orange}</li>
<li>[所以非即时垃圾回收器都是会有 STW 造成的时延的，不可能消除只能够避免]{.orange}</li>
</ul>
</li>
</ul>
</li>
<li>总结：<ul>
<li>[垃圾回收层面是并发包含并行，操作系统层面是并行包含并发]{.blue}</li>
<li>在操作系统角度看来，垃圾回收器的并行与并发都可以是并行，线程都在同时执行</li>
</ul>
</li>
<li>代表性垃圾回收器：CMS、G1 </li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/垃圾回收并发执行.6pwdax9p0o40.png" alt="垃圾回收并发执行" style="zoom:80%;" /></li>
</ul>

        <h3 id="STW"   >
          <a href="#STW" class="heading-link"><i class="fas fa-link"></i></a><a href="#STW" class="headerlink" title="STW"></a>STW</h3>
      <blockquote>
<p><strong>什么是 STW</strong></p>
</blockquote>
<ul>
<li>名称：Stop the World</li>
<li>定义：[垃圾回收器开始工作时，会暂停用户线程执行的情况]{.red}<ul>
<li>用户线程被暂停就会让用户明显感觉到“卡顿”，也就是时延</li>
<li>垃圾回收器工作的时间越长，用户感觉“卡顿”的时间就久</li>
</ul>
</li>
<li>特点：<ul>
<li>[只有基于可达性分析的标记型算法才会出现 STW ，基于引用计数法的所有延伸算法是没有这个问题的]{.red}</li>
<li>[Java 采用的就是可达性分析算法，所以 Java 虚拟机中的所有垃圾回收器都是无法避免 STW 带来的时延的]{.red}</li>
</ul>
</li>
</ul>
<p>:::info</p>
<p>① 先简单了解下可达性分析，它是一种标记存活对象的方式，用于确定哪些是可以回收的对象</p>
<p>② 详细了解：<a href="">可达性分析</a></p>
<p>:::</p>
<blockquote>
<p><strong>为什么需要 STW</strong></p>
</blockquote>
<ul>
<li>核心：[<strong>确保可达性分析过程的一致性</strong>]{.red}<ul>
<li>什么叫可达性分析的一致性<ul>
<li>如果在可达性分析的过程中，用户线程和 GC 线程并发执行</li>
<li>那么在分析的过程中对象间的引用不断随着用户线程的执行而变化</li>
<li>最终导致 GC 线程无法精准识别哪些对象是垃圾，哪些对象是存活的</li>
</ul>
</li>
<li>那么此前提到的并发式垃圾回收器是如何做到不采用 STW 呢？<ul>
<li>并发式垃圾回收器并不是完全并发，只是在某些阶段是并发的，其余阶段依然并行，依然需要采用 STW</li>
<li>并发式垃圾回收器在并发的阶段会采用某些手段来确保可达性分析的一致性<ul>
<li>增量更新（CMS 垃圾回收器采用的方式）</li>
<li>原始快照（G1 垃圾回收器采用的方式）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>如何降低 STW 带来的延迟影响呢?</strong></p>
</blockquote>
<ul>
<li>增量算法：<ul>
<li>定义：将 GC 线程的回收过程分成几个阶段执行</li>
<li>优点：[减少单次 STW 造成的时延影响，实际上总的时延是增加了的]{.red}</li>
<li>缺点：[会造成程序吞吐量的下降]{.green}</li>
</ul>
</li>
<li>允许用户线程和 GC 线程并发执行<ul>
<li>优点：<ul>
<li>[有效降低 STW 造成的时延]{.red}</li>
<li>[吞吐量下降的幅度相对较小]{.red}</li>
</ul>
</li>
<li>缺点：[需要采用手段避免可达性分析的不一致性]{.green}</li>
</ul>
</li>
</ul>
<p>:::info</p>
<p>增量算法和增量更新是两个不一样的东西</p>
<p>:::</p>

        <h3 id="主动发起垃圾回收方法"   >
          <a href="#主动发起垃圾回收方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#主动发起垃圾回收方法" class="headerlink" title="主动发起垃圾回收方法"></a>主动发起垃圾回收方法</h3>
      
        <h4 id="System-gc"   >
          <a href="#System-gc" class="heading-link"><i class="fas fa-link"></i></a><a href="#System-gc" class="headerlink" title="System.gc()"></a>System.gc()</h4>
      <p>:::warning</p>
<p>① 默认情况下，虚拟机都是自行决定什么时候执行垃圾回收的</p>
<p>② 但是我们也可以调用相应的方法使得虚拟机执行垃圾回收</p>
<p>:::</p>
<p><code>System.gc() / Runtime.getRuntime.gc()</code></p>
<ul>
<li><p>作用：[<strong>建议或者提醒</strong> 虚拟机执行垃圾回收]{.red}</p>
<ul>
<li>意味着调用该方法之后虚拟机不一定立刻执行垃圾回收</li>
<li>原因是虚拟机给垃圾回收线程（Finalizer 线程）设置的优先级非常低，不一定能够立即执行</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li><p>调用 <code>System.gc()</code> 会直接触发 [Full GC]{.red} 对整个堆空间和方法区都进行回收</p>
</li>
<li><p>调用 <code>System.runFinalization()</code> 会强制要求虚拟机立刻执行垃圾回收</p>
</li>
<li><p><code>Runtime.getRuntime.gc()</code> 和 <code>System.gc()</code> 没有任何区别（从源码中可以看出）</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// System 类中的 gc 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Runtime.getRuntime().gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>[调用 <code>System.gc()</code> 适用于使用堆外内存的时候，垃圾回收器难以直接对堆外内存进行回收，所以手动回收]{.red}</p>
<p>  :::info</p>
<p>  正因为方法区在 JDK 8 之后采用元空间实现，所以方法区变得更加难以收集了，所以 ZGC 干脆不支持收集方法区了</p>
<p>  :::</p>
</li>
</ul>
</li>
<li><p>命令：</p>
<ul>
<li>[-XX:+DisableExplicitGC 禁止手动触发垃圾回收]{.blue}</li>
<li>给虚拟机配置该参数之后，调用 <code>System.gc()</code> 是不会生效的</li>
</ul>
</li>
<li><p>测试（测试结果可能会让你惊讶，也有可能不会）</p>
<ul>
<li><p>没有强制执行的垃圾回收的情况下，由于垃圾回收线程优先级较低，</p>
<p>  所以你可能看不到相应的输出语句，但也有可能看得到</p>
</li>
<li><p>强制执行垃圾回收的情况下，你是一定能够看到输出语句的</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试: System.gc() 是否能够立即执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemGCTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 注：这个对象没有被任何变量引用，所以是会被回收的</span></span><br><span class="line">        <span class="keyword">new</span> SystemGCTest();</span><br><span class="line">        <span class="comment">// 建议虚拟机执行垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 强制执行垃圾回收</span></span><br><span class="line">        System.runFinalization();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象被销毁之前虚拟机会调用该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;对象将要被销毁...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>例子</p>
</li>
</ul>

        <h4 id="finalize"   >
          <a href="#finalize" class="heading-link"><i class="fas fa-link"></i></a><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h4>
      <ul>
<li><p>前提：</p>
<ul>
<li><p><code>finalize()</code> 方法是 Object 类中自带的没有任何实现的方法</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123; </span><br><span class="line">    <span class="comment">// 空的方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p><code>finalize()</code> 方法必须被子类重写才会有作用，否则没有任何用</p>
</li>
</ul>
</li>
<li><p>作用：[对象被垃圾回收器回收之前自动调用的方法，使得开发者在对象消亡前 <strong>自定义逻辑</strong>]{.red}</p>
<ul>
<li><p>可以在对象消亡前释放连接，关闭文件等资源关闭操作</p>
</li>
<li><p>[可以将对象从死亡的边缘拉回来一次：复活对象]{.green}</p>
<p>  :::info</p>
<p>  至于对象复活的方式将在稍后提到</p>
<p>  :::</p>
</li>
</ul>
</li>
<li><p>对象状态</p>
<ul>
<li>[可触及态：对象仍被变量引用的情况]{.red}</li>
<li>[可复活态：对象没有被变量所引用，但是 finalize 方法没有被调用过]{.red}</li>
<li>[不可触及态：对象已经被垃圾回收器回收完成了，不可能再复活了]{.red}</li>
</ul>
<p>  :::info</p>
<p>  由于对象可能在 finalize 方法中被复活，所以对象具有三种状态</p>
<p>  :::</p>
</li>
<li><p>细节：</p>
<ul>
<li><p><code>finalize()</code> 方法在 JDK 9 中被废弃了</p>
<p>+++ 为什么要在之后 JDK 版本中废弃这个方法呢？</p>
<p>① finalize 方法中编写的逻辑太差会严重影响垃圾回收的性能（试了下递归，但是没有报错，很奇怪）</p>
<p>② finalize 方法的执行依赖于垃圾回收发生的时间，里面执行的逻辑是没有任何保障的</p>
<p>③ 总结：所以在编写程序的时候尽可能不要再去使用这个方法</p>
<p>+++</p>
</li>
<li><p>[<code>finalize()</code> 方法仅会对象被调用一次]{.red}</p>
</li>
</ul>
</li>
<li><p>对象“复活”</p>
<ul>
<li><p>过程：</p>
<ul>
<li><p>对象被垃圾回收的条件就是没有变量引用对象</p>
<p>  那么我们只要在对象死亡前让变量重新引用该对象，对象就不会消亡了</p>
</li>
<li><p>但是此前提到 <code>finalize()</code> 方法只会被执行一次，所以对象也只可以复活一次</p>
</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li>对象重写该方法的方法没有被执行，那么该对象将会被GC线程添加到F-Queue队列中等待执行 <code>finalize()</code></li>
<li>对象如果在执行 <code>finalize()</code> 的过程中被“复活”，那么将会被移出 F-Queue 队列</li>
</ul>
</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试: 对象“复活”</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaveObject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 类变量才可以作为 GC Roots, 实例变量是不可以作为 GC Roots 的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SaveObject object;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 重写 finalize 方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;开始执行垃圾回收...&quot;</span>);</span><br><span class="line">        <span class="comment">// 让对象重新被 GC Roots 引用</span></span><br><span class="line">        object = <span class="keyword">this</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象复活...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// GC Roots 指向堆中的对象</span></span><br><span class="line">        object = <span class="keyword">new</span> SaveObject();</span><br><span class="line">        <span class="comment">// 取消 GC Roots 到对象的引用</span></span><br><span class="line">        object = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 开始执行垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 暂停主线程: Finalizer 优先级非常低, 有可能主线程执行结束了, 它还没有执行</span></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="comment">// 测试对象是否死亡</span></span><br><span class="line">        System.out.println(object == <span class="keyword">null</span> ? <span class="string">&quot;对象死亡...&quot;</span> : <span class="string">&quot;对象没有死亡...&quot;</span>);</span><br><span class="line">        <span class="comment">// 可以继续进行后续的测试: 即对象第二次死亡还可以复活吗?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

</li>
</ul>
<p>​        </p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/4/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/6/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/随机图库/1641882498931.3kditdl6ds40.webp" alt="avatar"></div><p class="sidebar-ov-author__text">什么都不会的废物</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/fuyusakaiori" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://weibo.com/Sakiless/home?topnav=1&amp;wvr=6" target="_blank" rel="noopener" data-popover="微博" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weibo"></i></span></a><a class="sidebar-ov-social-item" href="670232228" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">108</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">33</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-nd.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020~2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>小忍的甜甜圈</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1.0.1/dist/canvas-nest.min.js" color="0,0,0" opacity="0.6" count="99" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>