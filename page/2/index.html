<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="啥也不会的大三狗">
<meta property="og:type" content="website">
<meta property="og:title" content="天鹅绒房间">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="天鹅绒房间">
<meta property="og:description" content="啥也不会的大三狗">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Fuyusakaiori">
<meta name="twitter:card" content="summary"><title>天鹅绒房间</title><link ref="canonical" href="http://example.com/page/2/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">天鹅绒房间</div><div class="header-banner-info__subtitle">Velvet Room</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/11/04/juc/juc-design/%E7%8A%B9%E8%B1%AB%E6%A8%A1%E5%BC%8F/">犹豫模式</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-11-04</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-11-04</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="犹豫模式"   >
          <a href="#犹豫模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#犹豫模式" class="headerlink" title="犹豫模式"></a>犹豫模式</h1>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/11/04/juc/juc-design/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/">生产者消费者模式</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-11-04</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-11-04</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="生产者消费者模式"   >
          <a href="#生产者消费者模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h1>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/11/04/juc/juc-design/%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C%E6%A8%A1%E5%BC%8F/">保护性暂停模式</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-11-04</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-11-04</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="保护性暂停模式"   >
          <a href="#保护性暂停模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#保护性暂停模式" class="headerlink" title="保护性暂停模式"></a>保护性暂停模式</h1>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/11/04/juc/juc-design/%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F/">两阶段终止模式</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-11-04</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-11-04</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="两阶段终止模式"   >
          <a href="#两阶段终止模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#两阶段终止模式" class="headerlink" title="两阶段终止模式"></a>两阶段终止模式</h1>
      
        <h2 id="什么是两阶段终止模式"   >
          <a href="#什么是两阶段终止模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是两阶段终止模式" class="headerlink" title="什么是两阶段终止模式"></a>什么是两阶段终止模式</h2>
      <ul>
<li>核心：[实现正在运行的线程可以被其余线程优雅的终止]{.red}</li>
</ul>
<blockquote>
<p>细节：之前已经借助了中断方法实现了优雅的中断线程，现在将这种中断方式抽象成一种模式来实现</p>
</blockquote>

        <h2 id="为什么要使用两阶段终止模式"   >
          <a href="#为什么要使用两阶段终止模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么要使用两阶段终止模式" class="headerlink" title="为什么要使用两阶段终止模式"></a>为什么要使用两阶段终止模式</h2>
      <ul>
<li><p>情景：线程之间需要相互通信协作的时候，会出现某些线程想要终止其他线程的情况</p>
</li>
<li><p>方式：</p>
<ul>
<li><p><code>stop()</code> 方法</p>
<ul>
<li><p>前提：[Stop 方法在 JDK 中已经内废弃了]{.gray}</p>
</li>
<li><p>作用：[强制性杀死需要中断的线程，无论线程自身是否想要被终止]{.red}</p>
</li>
<li><p>缺陷：[被杀死的线程不会释放持有的资源的锁]{.aqua}</p>
<p>  :::info</p>
<p>  因为线程被杀死，所以它之后也没有机会再释放锁，其余线程也永远无法获取这把锁</p>
<p>  :::</p>
</li>
</ul>
</li>
<li><p><code>System.exit(1)</code>方法</p>
<ul>
<li>作用：[直接结束整个进程]{.red}</li>
<li>缺陷：[导致不想要被中断的线程也被一起中断，显然是非常不好的]{.aqua}</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h2 id="如何实现两阶段终止模式"   >
          <a href="#如何实现两阶段终止模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何实现两阶段终止模式" class="headerlink" title="如何实现两阶段终止模式"></a>如何实现两阶段终止模式</h2>
      <ul>
<li><p>步骤：</p>
<ol>
<li><p>被监视的线程需要提供相应的开始和结束的方法：</p>
<ul>
<li><p>抽象成类</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设计模式: 两阶段终止模式</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TwoPhaseTermination&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoPhaseTermination</span></span>&#123;</span><br><span class="line">    <span class="comment">// 被监视的线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread monitor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>实现开始和结束方法</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设计模式: 两阶段终止模式</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TwoPhaseTermination&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoPhaseTermination</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Thread monitor;</span><br><span class="line">    <span class="comment">// 启动线程的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        monitor = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span> (monitor.isInterrupted())</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                   log.debug(<span class="string">&quot;线程正常运行...&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">                   <span class="comment">// 重新设置中断标记</span></span><br><span class="line">                   monitor.interrupt();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止线程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 中断线程</span></span><br><span class="line">        monitor.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>监视线程只需要调用开始结束方法就可以很容易地控制该线程</p>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设计模式: 两阶段终止模式</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TwoPhaseTermination&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoPhaseTermination</span></span>&#123;</span><br><span class="line">    <span class="comment">// 让线程一可以终止线程二的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TwoPhaseTermination tpt = <span class="keyword">new</span> TwoPhaseTermination();</span><br><span class="line">        tpt.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        tpt.stop();</span><br><span class="line">        log.debug(<span class="string">&quot;线程运行结束...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

</li>
</ol>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/11/02/juc/juc-concurrent/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">线程安全-内存模型</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-11-02</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-11-04</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="内存模型"   >
          <a href="#内存模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1>
      
        <h2 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h2>
      <p>:::info</p>
<p>注：这部分的主要目的用于梳理我自己对于内存模型的思路</p>
<p>:::</p>
<ul>
<li>先来简单了解为什么需要内存模型？<ul>
<li>[中断机制]{.red}<ul>
<li>背景：[处理器同时只能够执行单个进程，效率非常低下]{.aqua}</li>
<li>解决方式：[中断机制避免单个进程长时间独占处理器的使用权]{.aqua}</li>
<li>产生的新问题：[中断机制导致进程间通信时对共享变量的修改结果不确定]{.aqua}</li>
</ul>
</li>
<li>[缓存一致性问题]{.red}<ul>
<li>背景：[处理器的执行速度和内存读取数据的速度存在不匹配的情况]{.aqua}</li>
<li>解决方式：[高速缓存技术]{.aqua}</li>
<li>产生的新问题：[<strong>多核处理器下多个缓存之间</strong> 的存储的内容可能存在不一致的情况]{.aqua}</li>
</ul>
</li>
<li>[指令重排序问题]{.red}<ul>
<li>背景：[单周期处理器吞吐量低下需要进行改善]{.aqua}</li>
<li>解决方式：[流水线技术]{.aqua}</li>
<li>产生的新问题：[多条指令可能存在相关性从而导致数据冒险问题]{.aqua}</li>
<li>解决方式：[使用暂停或者转发技术解决数据冒险问题]{.aqua}</li>
<li>又产生了新问题：[暂停使得处理器效率降低，转发无法解决所有数据冒险问题]{.pink}</li>
<li>终极解决方式：[指令重排序]{.pink}</li>
<li>还是存在问题：[指令重排序会让指令乱序执行从而导致 <strong>多线程下</strong> 执行的结果不确定]{.pink}</li>
</ul>
</li>
</ul>
</li>
<li>如果你对内存模型存在基本的了解，那么你可以发现其三个问题的本质<ul>
<li>原子性问题：[其本质是操作系统采用中断驱动引入多进程/线程并发执行]{.red}</li>
<li>可见性问题：[其本质是因为缓存的不一致性造成的]{.red}</li>
<li>有序性问题：[其本质是因为 <strong>处理器和编译器</strong> 会采用指令重排序的优化手段造成的]{.red}</li>
</ul>
</li>
<li>如果你觉得上述概述已经解决你的问题了，那么接下来的内容就没有必要再看了，因为具体会涉及不少硬件的知识</li>
</ul>

        <h2 id="为什么需要内存模型"   >
          <a href="#为什么需要内存模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么需要内存模型" class="headerlink" title="为什么需要内存模型"></a>为什么需要内存模型</h2>
      
        <h3 id="高速缓存"   >
          <a href="#高速缓存" class="heading-link"><i class="fas fa-link"></i></a><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3>
      <p>:::primary</p>
<p>参考博客：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.jianshu.com/p/8420ade6ff76" >终于有人把Java内存模型(JMM)说清楚了</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>

        <h4 id="基本内容"   >
          <a href="#基本内容" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h4>
      <p>[为什么需要高速缓存？]{.label .primary}</p>
<ul>
<li>核心原因：[处理器的执行速度和内存读写数据的速度存在不匹配的情况]{.red}</li>
</ul>
<p>处理器在执行运算的过程需要频繁地从内存读取或者写入数据，从而完成用户给定的任务</p>
<p>早期的时候处理器的执行速度和内存的读写速度相差不多，所以处理器是可以忍受从内存读写数据的过程的</p>
<p>[但是随着处理器高速发展，处理器的执行速度远超过内存的读写速度，这就出现了处理器和内存速度不匹配的情况]{.red}</p>
<p>[每次处理器完成运算任务都需要长时间等待内存的读写，即使自己只需要花费极少的时间进行运算]{.red}</p>
<p>[什么是高速缓存？]{.label .primary}</p>
<ul>
<li><p>定义：[一种读写速度接近处理器的存储设备]{.red}</p>
</li>
<li><p>特点：</p>
<ul>
<li><p>[容量较小、价格昂贵]{.red}</p>
</li>
<li><p>[多级缓存：避免单级缓存无法容纳处理器需要使用的全部数据]{.red}</p>
</li>
<li><p>[每一级缓存的容量都会逐渐增大，缓存的制作难度也会逐渐变低]{.red}</p>
</li>
<li><p>[单级缓存都是每个处理器独占的，多级缓存可能会被多个处理器共享]{.red}</p>
</li>
</ul>
</li>
<li><p>图示：</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%A4%BA/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98.7hk1cp6zd000.png" alt="多级缓存"></p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/高速缓存.1rjc223a33pc.png" alt="高速缓存" style="zoom:80%;" /></li>
</ul>
<p>[如何利用高速缓存解决速度不匹配的问题呢？]{.label .primary}</p>
<ul>
<li><p>解决方式：</p>
<ul>
<li>[在处理器和内存之间添加 <strong>一层或者多层</strong> 运算速度接近处理器的高速缓存]{.red}</li>
<li>[采用高速缓存作为处理器和内存之间交换数据的缓冲区，避免处理器和内存直接交互造成时间的浪费]{.red}</li>
</ul>
</li>
<li><p>改进之后的处理器执行过程</p>
<ul>
<li>[处理器在执行之前会先将自己需要使用的所有指令和数据全部从内存中拷贝到高速缓存中]{.red}</li>
<li>[此后处理器在运算过程中就直接可以在高速缓存读写数据，而不需要和内存进行交互]{.red}</li>
<li>[处理器在运算结束之后再将高速缓存中的内容同步到内存中去]{.red}</li>
</ul>
</li>
</ul>
<p>[总结]{.label .primary}</p>
<p>采用高速缓存避免了处理器直接和内存交互造成的长时间等待，而由高速缓存负责和内存进行数据的交互</p>

        <h4 id="缓存一致性"   >
          <a href="#缓存一致性" class="heading-link"><i class="fas fa-link"></i></a><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h4>
      <p>[什么是缓存一致性问题]{.label .primary}</p>
<ul>
<li>核心：[<strong>多核处理器下各自缓存之间</strong> 的存储的内容可能存在不一致的情况]{.red}</li>
<li>细节：<ul>
<li>[只有多核处理器才会出现缓存一致性问题，单核处理器完全不存在这个问题]{.pink}</li>
<li>[而多核处理器下只有多线程并行才会引发，只是单纯的并发是没有这个问题的]{.pinnk}</li>
</ul>
</li>
</ul>
<p>现代处理器基本都是多核处理器，每个处理器通常都具有自己独立的高速缓存，那么这时候问题就来了：</p>
<p>如果多个处理器需要同时使用内存中相同的数据空间，那么根据高速缓存的机制，[多个处理器显然会分别将内存中共享的数据拷贝到自己的缓存空间中，然后在各自的高速缓存中使用这些共享数据，彼此之间是不可见的]{.red}</p>
<p>[每个处理器执行的运算过程的不同就会导致每个处理器的缓存之间存储内容的不同，而在运算过程结束之后处理器就会分别将自己高速缓存中的数据同步到主存中，那么同步的数据究竟以谁为准？如果没有任何规定，那么后同步进去的数据肯定会覆盖先同步进去的数据，这显然是不能被允许的]{.red}</p>
<p>[如何解决缓存一致性问题]{.label .primary}</p>
<ul>
<li>解决方式：[<strong>内存模型制定相应的协议</strong> 规定处理器访问缓存的方式和时机，从而避免出现缓存不一致的问题]{.red}</li>
<li>缓存协议：[MSI、MESI、MOSI、Synapse、Firefly]{.pink}</li>
<li>细节：[不同的处理器架构采用的缓存一致性协议是不同的]{.pink}</li>
</ul>
<p>[总结]{.label .primary}</p>
<p>计算机内存模型是如何制定协议解决缓存一致性问题的这里就不再详细展开，不同的处理器架构采用的缓存一致性协议是不同的，介绍缓存一致性的问题主要是为了明确 Java 虚拟机中出现的可见性问题的本质是什么，之后会详细讲述 Java 内存模型是如何解决缓存一致性问题，也就是可见性问题的</p>

        <h3 id="流水线技术"   >
          <a href="#流水线技术" class="heading-link"><i class="fas fa-link"></i></a><a href="#流水线技术" class="headerlink" title="流水线技术"></a>流水线技术</h3>
      <p>:::primary</p>
<p>参考博客：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/myseries/p/14458367.html" >CPU 流水线</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>

        <h4 id="基本内容-1"   >
          <a href="#基本内容-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本内容-1" class="headerlink" title="基本内容"></a>基本内容</h4>
      <p>[为什么需要流水线技术]{.label .primary}</p>
<ul>
<li>核心原因：[单周期处理器的 <strong>吞吐量非常低并且总体时延非常高</strong> ]{.red}</li>
<li>细节：<ul>
<li>[现代处理器几乎没有采用单周期设计的或者说几乎没有采用顺序一致性模型]{.pink}</li>
<li>[仅存在单个时钟周期，并且单个时钟周期的时间特别长]{.pink}</li>
</ul>
</li>
</ul>
<p><strong>单周期处理器是如何工作的呢？</strong></p>
<ul>
<li>核心内容：[单个时钟寄存器控制指令顺序执行]{.red}</li>
</ul>
<p>[单周期处理器设计非常简单，每经过一个时钟周期，时钟信号上升沿到来之后，时钟寄存器读取一条指令，其余的指令必须等待下一个时钟信号上升沿到来，也就是再等待一个时钟周期才能够轮到自己]{.aqua}</p>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/微处理器体系结构-单周期.63kwio06rrc0.png" alt="微处理器体系结构-单周期" style="zoom:80%;" />

<p><strong>为什么会带来低吞吐量和高延迟呢？</strong></p>
<ul>
<li>核心原因：[单个时钟寄存器为了确保耗时最长的指令正常执行而设定的很长的时钟周期，导致时钟频率很低]{.red}</li>
</ul>
<p>[单周期处理器仅采用唯一的时钟寄存器控制指令的读取，而每个时钟寄存器设定的时钟周期都固定的]{.aqua}</p>
<p>[这就意味着每条指令无论实际执行时间的长短，消耗的时间都是完全相同，因为时钟周期被固定了，即使指令提前执行完成，下条指令也会因为等待时钟信号而无法立刻执行]{.aqua}</p>
<p>你可能会想，那么把时钟周期设置得短点不就行了？这肯定是不可以的，所有指令的实际执行时间是不同的，如果设置得太短会导致执行时间较长的指令在还没有执行完成的情况下，下条指令就被读取并执行了，指令之间可能就会相互干扰，所以必须保证耗时最长的指令能够正常结束</p>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/单周期处理器.4jkcz6todeo0.png" alt="单周期处理器" style="zoom:80%;" />

<p>[如何解决单周期处理器带来的问题呢？]{.label .primary}</p>
<ul>
<li><p>核心：[让多条指令能够并行执行就可以显著提升处理器的吞吐量]{.red}</p>
</li>
<li><p>超标量处理器（空间并行）：</p>
<ul>
<li>定义：[微处理器中成倍地增加硬件从而提高效率]{.red}</li>
<li>细节：[微处理器中增加硬件是非常昂贵的，所以早期并没有采用这种方式]{.red}</li>
</ul>
</li>
<li><p>流水线技术（时间并行）</p>
</li>
<li><p>总结：为什么需要流水线技术？</p>
<ul>
<li>单周期处理器造成的低吞吐量和高延迟</li>
<li>超标量处理器带来高昂成本</li>
</ul>
</li>
</ul>
<p>[什么是流水线技术？]{.label .primary}</p>
<ul>
<li>核心内容：[多个时钟寄存器控制不同的阶段从而让多条指令可以同时处于不同的阶段，达到并行执行的效果]{.red}</li>
<li>指令划分：<ul>
<li>[取指（IF：Instruction Fetch）：时钟寄存器获取指令地址后，从内存中读取指令]{.red}</li>
<li>[译码（ID：Instruction Decode）：解析每条指令的含义，比如需要使用的常数或者寄存器]{.red}</li>
<li>[执行（EX：Execute）：ALU 获取常数和寄存器中的内容后开始计算]{.red}</li>
<li>[访存（MEM：Memory）：ALU 计算得到的数据写入内存中或者读取数据]{.red}</li>
<li>[写回（WB：Wirte Back）：ALU 计算得到的数据更新到目标寄存器中去]{.red}</li>
</ul>
</li>
<li>细节：<ul>
<li>[流水线划分阶段的行为会造成单条指令时延的略微上升]{.green}</li>
<li>[流水线技术提高了处理器的吞吐量并且降低处理器执行指令的总体时延]{.red}</li>
<li>[不是所有指令都需要 <strong>实际执行</strong> 上述五个步骤，但是所有指令都必须满足上述的流程]{.red}<ul>
<li>举个栗子，只对寄存器执行加法的指令，实际上是不需要去访问内存的</li>
<li>但是由于流水线已经划分好阶段了，即使你不访问内存也是需要等待这个过程结束的</li>
<li>这是流水线造成单条指令延时上升的，以及过深的流水线造成收益下降的原因</li>
</ul>
</li>
<li>// TODO</li>
</ul>
</li>
</ul>
<p><strong>流水线通用原理</strong></p>
<p>[汇编指令在底层几乎都会分为上述五个步骤完成，每个步骤使用的硬件都是不同的]{.red}</p>
<p>[那么只要当前指令完成某个阶段的执行，该阶段使用的硬件就会空闲出来，那么 <strong>该阶段的时钟寄存器</strong> 就可以立刻让 <strong>下条指令进入这个阶段并执行</strong>，而当前指令就会进入下个阶段执行]{.red}</p>
<p>[这种方式就充分利用了硬件资源，避免单周期中因等待时钟信号造成的硬件空闲]{.red}</p>
<p><img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%A4%BA/%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E6%B5%81%E6%B0%B4%E7%BA%BF.3fo2dlxku500.png" alt="微处理器体系结构-流水线"></p>
<p><strong>流水线处理器是如何工作的呢？</strong></p>
<p>[取指阶段的时钟寄存器读取第一条指令，并开始执行取指，此时无论如何其他指令都必须等待]{.red}</p>
<p>[第一条指令完成取指阶段之后就，译码阶段的时钟寄存器就会让第一条指令进入译码阶段，此时第二条指令就可以被取指阶段的时钟寄存器读取进入取指阶段]{.red}</p>
<p>[第一条指令完成译码阶段之后会相应进入执行阶段，第二条和第三条指令就会分别进入译码和取指的阶段，以此类推，这样多条指令可以处于不同阶段从而达到时间上并行执行的效果]{.red}</p>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/流水线-3.1es3k21cl2m8.png" alt="流水线-3" style="zoom:80%;" />






        <h4 id="数据冒险"   >
          <a href="#数据冒险" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h4>
      <p>:::info</p>
<p>流水线技术引入带反馈的系统中就会引发很多问题。这些问题主要分为两类，第一类就是接下来要讲述的数据冒险问题，另一类是控制冒险问题，由于后者和指令重排序关系不大，所以不再讲述</p>
<p>:::</p>
<p>[什么是带反馈的流水线？]{.label .primary}</p>
<ul>
<li>定义：[采用流水线设计的处理器执行的指令之间存在相互依赖的关系，就称为带反馈的流水线]{.red}</li>
</ul>
<p>[什么是数据冒险问题]{.label .primary}</p>
<ul>
<li>定义：[带反馈的流水线带来的指令相关性 <strong>可能</strong> 会造成处理器在计算过程中产生错误，就称为数据冒险问题]{.red}</li>
</ul>
<p>举个栗子</p>
<p><img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%A4%BA/%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A9%E9%97%AE%E9%A2%98.2160yky0js1s.png" alt="数据冒险问题"></p>
<p>[如何解决数据冒险问题呢？]{.label .primary}</p>
<ul>
<li><p>用暂停避免数据冒险</p>
<ul>
<li><p>定义：[在依赖前面指令结果的指令之前添加气泡指令，推迟该指令的执行]{.aqua}</p>
</li>
<li><p>细节：</p>
</li>
<li><p>图示：</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/暂停避免数据冒险.7bhuadrleps0.png" alt="暂停避免数据冒险" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>用转发避免数据冒险</p>
<ul>
<li><p>定义：[不等待前面的指令向寄存器更新结果，而是直接将结果从内存中传入该指令]{.aqua}</p>
</li>
<li><p>细节：</p>
</li>
<li><p>图示：</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/转发避免数据冒险.6ygnrtyo85s0.png" alt="转发避免数据冒险" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>用加载 / 使用避免数据冒险</p>
</li>
</ul>
<p>[总结]{.label .primary}</p>
<p>仔细观察就会发现，暂停能够解决所有数据冒险问题，但是处理器的效率显然会因此而降低；转发虽然不需要暂停处理器，但是没有办法解决所有问题；最后一种方法只是弥补转发的缺陷，但是仍然需要暂停</p>
<p>[对于追求性能的处理器来说，频繁的暂停显然是难以接受的，会严重影响处理器的执行效率，所以引入了优化方式：指令重排序]{.aqua}</p>

        <h4 id="指令重排序"   >
          <a href="#指令重排序" class="heading-link"><i class="fas fa-link"></i></a><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h4>
      <p>:::primary</p>
<p>参考内容：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.zhihu.com/question/36293510" >当目标CPU具有乱序执行的能力时，编译器做指令重排序优化的意义有多大？</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.icode9.com/content-4-1109500.html" >什么是指令重排序？为什么要重排序？</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>《数字设计和计算机体系结构》</p>
<p>:::</p>
<p>[什么是指令重排序？]{.label .primary}</p>
<ul>
<li><p>定义：[处理器在确保和顺序执行结果一致的情况下，会将输入的指令重新进行排序]{.red}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/指令重排序.46k5wqg5kuk0.png" alt="指令重排序" style="zoom:80%;" /></li>
<li><p>细节：</p>
<ul>
<li>[单个处理器（线程）内是无法感知到指令是否被重排序了，因为乱序和顺序的执行结果是一致的，这也就是很多文章或者书上解释的 “线程内部表现为串行的语义”]{.pink}</li>
<li>[多个处理器（线程）之间是无法感知到彼此执行代码的顺序的，也就是说线程与线程之间的执行顺序天然就是乱序的]{.pink}</li>
</ul>
</li>
<li><p>[编译器重排序]{.red}</p>
<ul>
<li>定义：[编译器在对 <strong>所有代码进行编译</strong> 的时候就会调整代码执行的顺序]{.red}</li>
<li>细节：<ul>
<li>[Java 中提供指令重排序的是 <strong>JIT 即时编译器</strong> 而不是 Javac 前端编译器]{.red}</li>
<li>[编译器能够看到程序的全局视图，能够获取更多的信息进行指令重排序]{.red}</li>
</ul>
</li>
</ul>
</li>
<li><p>[处理器重排序]{.red}</p>
<ul>
<li>定义：[处理器在 <strong>执行指令的时候</strong> 才开始调整指令执行的顺序]{.red}</li>
<li>细节：[处理器只能够在动态执行指令的时候重排序，只能依靠局部的信息进行重排序]{.red}</li>
</ul>
</li>
<li><p>[内存重排序]{.red}</p>
<ul>
<li>定义：[由可见性或者说缓存一致性问题带来的“重排序”]{.pink}</li>
<li>举个栗子：<ul>
<li>在多核处理器下，每个处理器缓存中存放的共享数据可能是不同的，也就是缓存一致性问题</li>
<li>那么 CPU-Core-1 已经对共享数据进行修改了，但是 CPU-Core-2 在自己的缓存中无法得知</li>
<li>接下来只要 CPU-Core-2 先于 CPU-Core-1 执行，那么就会呈现出先读取后修改的情况</li>
<li>而实际情况却是先修改后读取，出现了这种类似于指令重排序的情况</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>大致介绍完指令重排序之后，你可能会产生一些疑问。最基本的问题，为什么要使用指令重排序，它和之前提到的流水线有什么关系吗？还有为什么要同时提供编译器和处理器两种重排序？不能够只提供一种吗？接下来会解答这些疑问</p>
<p>[为什么需要使用指令重排序？]{.label .success}</p>
<p>之前在流水线技术中已经提到，在带反馈的流水线系统中存在数据冒险的问题，而解决数据冒险使用的方式主要是三种：暂停、转发、加载 / 使用。这三种解决数据冒险的方式几乎都会造成处理器的停顿，而指令存在相关性的情况又非常多，所以处理器就会频繁的停顿，最终造成处理器性能的下降。</p>
<p>[指令重排序就可以将后续等待执行的无关指令重排到存在相关性的指令之间，使其提前执行，也就相当于用无关指令替代了气泡指令的存在，从而避免处理器的频繁暂停以提高处理器的执行效率]{.red}</p>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/处理器重排序.xdo5djqp2o0.png" alt="处理器重排序" style="zoom:80%;" />

<p>[为什么编译器也需要提供指令重排序的优化策略？]{.label .success}</p>
<p>[刚才在提到编译器和处理器重排序的时候，特意标注的内容就是编译器是审视所有的代码并进行重排序，而处理器仅仅只是在执行指令的时候对局部的指令进行重排，这也就意味着编译器能够比处理器获得更多的信息去执行指令重排序的优化，从而为处理器提供更加良好的代码，减轻处理器优化的压力]{.pink}</p>
<p>[那么既然编译器的优化能力更强，那为什么还要提供处理器指令重排序的功能呢？这是因为不同架构的处理器的最优指令顺序是完全不同的，编译器难以提供能够满足所有处理器的最优指令顺序，所以依然需要处理器提供指令重排序的能力进行优化]{.red}</p>
<p>[什么是指令重排序问题]{.label .primary}</p>
<ul>
<li>前提：[无论是单核处理器还是多核处理器，只要出现多线程，那么就会存在指令重排序问题]{.red}</li>
<li>核心内容：[<strong>多线程</strong> 情况下由于指令重排序而造成 <strong>意想不到的结果</strong> 出现就称为指令重排序问题]{.red}</li>
</ul>
<p>处理器或者编译器会对每个线程内的代码进行重排序，确保的是单个线程内执行的结果一致，但是多个线程之间可能会出现非常奇怪的结果，这里用代码举个栗子吧（<del>MIPS 的汇编指令确实不太熟悉</del>）</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程-1 需要执行的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        System.out.println(num * num);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        num = <span class="number">1</span>；</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程-2 需要执行的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    num = <span class="number">2</span>;		<span class="comment">// flag = true</span></span><br><span class="line">    flag = <span class="keyword">true</span>;	<span class="comment">// num = 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>[处理器或者编译器认为线程-2执行的方法中两条指令都是不存在依赖的，可以随意交换执行的顺序并且 保证在线程-2中的执行结果是一致的，但是对于其余线程来说这种重排序会造成无法预知的结果]{.aqua}</p>
<p>[指令重排序之后，线程-2会先将 flag 变量修改为 true ，此时执行上下文切换，线程-1立刻进入为 true 的代码块中打印 num*num 的结果，此时 num 还没来得及赋值，所以结果就会出现 0，这个结果 0 其实就是意想不到的结果，因为你在不知道指令重排序的情况下只会认为结果为 4 或者 1]{.aqua}</p>
<p>[如何解决指令重排序问题？]{.label .success}</p>
<ul>
<li>解决方式：[<strong>内存模型使用内存屏障指令</strong> 从而避免流水线中的指令重排序的能力]{.red}</li>
<li>细节：[不同架构的处理器其对应的内存屏障指令显然也是不同的]{.pink}</li>
</ul>
<p>总结：这里依然不详细展开计算机内存模型是如何使用内存屏障避免指令重排序的，之后的 Java 内存模型中会详细提到</p>

        <h4 id="补充"   >
          <a href="#补充" class="heading-link"><i class="fas fa-link"></i></a><a href="#补充" class="headerlink" title="补充"></a>补充</h4>
      <ul>
<li>不一致的划分</li>
<li>过深的流水线</li>
</ul>

        <h2 id="什么是内存模型"   >
          <a href="#什么是内存模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是内存模型" class="headerlink" title="什么是内存模型"></a>什么是内存模型</h2>
      
        <h3 id="计算机内存模型"   >
          <a href="#计算机内存模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#计算机内存模型" class="headerlink" title="计算机内存模型"></a>计算机内存模型</h3>
      <ul>
<li>定义：[内存模型 <strong>制定特殊的协议</strong> 从而 <strong>规范处理器访问内存和高速缓存的过程</strong> ]{.red}<ul>
<li>[换句话说内存模型定义了 <strong>多线程</strong> 对内存和高速缓存读写操作的规范]{.pink}</li>
<li>[从而避免出现之前提到的缓存一致性、指令重排序等内存访问问题]{.pink}</li>
</ul>
</li>
<li>解决方式：[缓存一致性协议 + 内存屏障]{.red}</li>
<li>细节：<ul>
<li>[内存模型不是对物理硬件的抽象而是对处理器访问内存和高速缓存过程的抽象]{.pink}</li>
<li>[不同架构的处理器对应的内存模型是不同的，这也就导致在不同处理器编写多线程程序需要遵循的协议不同]{.red}<ul>
<li>[有些处理器提供强内存模型，保证每个处理器在任何时候看到的都是相同的数据]{.pink}</li>
<li>[有些处理器提供弱内存模型，需要在程序执行的过程中插入特殊的指令才能够保证看到相同数据]{.pink}</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>总结：这里关于计算机内存模型是如何保证多线程程序的正确访问就不再叙述，不是本篇文章的重点</p>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/计算机内存模型.5u7yjh2cqhk0.png" alt="计算机内存模型" style="zoom:80%;" />


        <h3 id="Java-内存模型"   >
          <a href="#Java-内存模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h3>
      <p>:::primary</p>
<p>参考博客：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://xie.infoq.cn/article/739920a92d0d27e2053174ef2" >嘿，同学，你要的 Java 内存模型 (JMM) 来了</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/javazejian/article/details/72772461" >全面理解Java内存模型(JMM)及volatile关键字</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/java-memory-model.html" >Java Memory Model</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html" >JSR 133 (Java Memory Model) FAQ</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>

        <h4 id="基本内容-2"   >
          <a href="#基本内容-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本内容-2" class="headerlink" title="基本内容"></a>基本内容</h4>
      <p>[概述]{.label .primary}</p>
<ul>
<li><p> Java 内存模型：Java Memory Model（JMM）</p>
</li>
<li><p>历史：JMM 在 JDK 2 建立，在 JDK 5 才被正式完善，直至 JDK 8 依然使用的依然是 JDK 5 的 JMM </p>
</li>
<li><p>定义：</p>
<ul>
<li> 核心：[JMM 规定 JVM 在计算机内存中的正确工作方式]{.red}</li>
<li> [规定线程如何正确和计算机内存及高速缓存交互，也就是线程何时同步数据到内存，何时去内存获取数据]{.pink}</li>
<li> [以及编译器和处理器启用优化策略的时机，也就是何时开启指令重排，何时禁用指令重排]{.pink}</li>
</ul>
</li>
<li><p>目的：</p>
<ul>
<li><p>[确保 Java 并发程序不会出现缓存一致性、指令重排序、原子性等并发问题]{.red}</p>
</li>
<li><p>[屏蔽不同处理器内存模型间的差异，使得相同的 Java 并发程序可以在不同架构的处理器下正确运行]{.red}</p>
<ul>
<li> [不同处理器的内存模型的不同，导致在不同处理器下编写多线程程序使用的 API 肯定是不同的]{.aqua}</li>
<li> [Java 为了实现跨平台的特性，制定了自己的内存模型规范，从而避免底层计算内存模型的异构性]{.aqua}</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/JMM-屏蔽底层异构性.656wckq3q4c0.png" alt="JMM-屏蔽底层异构性" style="zoom:80%;" /></li>
<li><p>细节：</p>
<ul>
<li>[C/C++ 没有内存模型的概念]{.red}<ul>
<li> C/C++ 并没有天生支持线程而是依靠其他第三方类库提供的线程支持</li>
<li> 所以 C/C++ 确保线程安全的方式是依靠不同的类库来保证的，没有统一的标准</li>
</ul>
</li>
<li>[Java 内存模型 和 Java 虚拟机的内存结构是不同层面的划分，两者没有直接的联系]{.red}<ul>
<li> 接下来我会详细讲述这两者的区别</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>[主要内容]{.primary}</p>
<ul>
<li><p>线程 &amp; 工作内存 &amp; 主内存</p>
<ul>
<li>线程：[Java 采用的是内核级线程，每个线程运行都会占用相应的处理器（可以直接认为线程就是处理器）]{.red}</li>
<li>工作内存：<ul>
<li>[每个线程都拥有自己 <strong>独立</strong> 的工作内存，存放的变量只能够被自己操作]{.red}</li>
<li>[每个线程必须将所有需要的变量 <strong>从主内存全部拷贝到工作内存</strong> ，在工作内存中对变量进行操作]{.red}<ul>
<li>这里提到的变量指的是共享变量而不包括非共享变量，因为非共享变量本身就是线程安全的</li>
<li>而内存模型关注的是线程和内存之间的正确交互，即是否线程安全，也就不属于讨论的范围了</li>
</ul>
</li>
<li>[每个线程在结束之前会将 <strong>工作内存中的所有数据全部同步到主内存中</strong>]{.red}</li>
</ul>
</li>
<li>主内存：[存放所有共享变量的区域]{.pink}</li>
</ul>
<p>  :::info</p>
<p>  到现在为止，你是不是觉得工作内存对应的就是虚拟机栈、主内存对应的就是堆空间呢？</p>
<p>  实际上这两者并没有这样直接的对应关系，或者说是两个层面的划分，接下来我会解释这是为什么。</p>
<p>  :::</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/计算机内存模型.348dyx6t8y40.png" alt="计算机内存模型" style="zoom:80%;" /></li>
<li><p>Java 虚拟机内存结构和计算机内存的关系</p>
<p>  [操作系统会在 <strong>JVM 进程初始化时</strong> 在内存中分配相应的内存空间，也就是说 <strong>虚拟机栈、堆空间、方法区、本地方法栈全部都是存放在内存中</strong> 的，但是操作系统为了 <strong>加快 JVM 进程的执行速度</strong>，会将 <strong>部分空间存放在高速缓存或者处理器的寄存器中</strong>]{.aqua}</p>
<p>  至于究竟将哪些空间存放在缓存中，那么空间依然存放在内存中完全取决于操作系统的优化措施</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/JVM与计算机内存.5x2r7mw5llc0.png" alt="JVM与计算机内存" style="zoom:80%;" /></li>
<li><p>Java 内存模型和 Java 虚拟机内存结构的关系</p>
<p>  [JMM 定义的工作内存和主内存实际都属于 JVM 使用的内存，<strong>也就是说你可以认为 JMM 重新将 JVM 进行了一次划分，也就是只把 JVM 内存划分成工作内存 + 主内存两部分，而不存在其余的什么虚拟机栈，堆空间等等</strong>，所以你也会经常看到说工作内存和主内存是一种抽象概念，<strong>因为这个概念只是方便 JMM 接下来制定规则的便利</strong>，而不是实际存在的区域，所有的虚拟机实际上肯定还是采用栈 + 堆的划分方式]{.aqua}</p>
<p>  [和刚才同样的道理，操作系统为了加快 JVM 进程的执行速度，也会将工作内存存放在寄存器或者高速缓存中，因为所有线程都是在工作内存中工作的嘛]{.aqua}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/JVM与JMM.1rcjh0p1quzk.png" alt="JVM与JMM" style="zoom:80%;" /></li>
<li><p>八大基本操作</p>
<ul>
<li>前提：八大操作规定了线程使用工作内存的变量，以及如何从主内存中获取变量</li>
<li>lock &amp; unlock<ul>
<li>lock：[将 <strong>主内存</strong> 中的某个变量变为线程独占状态]{.red}</li>
<li>unlock：[将 <strong>主内存</strong> 中某个处于锁定的变量释放出来]{.red}</li>
</ul>
</li>
<li>read &amp; load<ul>
<li>read：[将 <strong>主内存</strong> 中的变量读取出来放入工作内存中]{.red}</li>
<li>load：[将 <strong>工作内存</strong> 中刚从主内存获取到的变量拷贝到相应的变量副本中去]{.pink}</li>
</ul>
</li>
<li>use &amp; assign：<ul>
<li>use：[将 <strong>工作内存</strong> 的变量副本交付给执行引擎（处理器 \ 线程）使用]{.grey}</li>
<li>assign：[将 <strong>执行引擎</strong> 返回的值更新到工作内存的变量副本中]{.grey}</li>
</ul>
</li>
<li>store &amp; write：<ul>
<li>store：[将 <strong>工作内存</strong> 中的变量放入到主内存中]{.pink}</li>
<li>write：[将 <strong>主内存</strong> 中刚从工作内存中获取到的变量写入主内存中]{.red}</li>
</ul>
</li>
<li>细节：[后续的工作内存和主内存交互协议被改为 4 种操作而不是 8 种：read、write、unlock、lock]{.red}</li>
</ul>
</li>
<li><p>执行顺序</p>
<p>  [每对操作必须按照顺序执行，但是不一定是连续执行，也就是可以在每对操作之间插入其他指令。JMM 为了进一步解决这个问题，更加严格规定了每种操作之间的执行顺序，从而从最底层的操作确保不会出现缓存一致性、指令重排序、原子性问题]{.blue}</p>
<p>  [这里不再详细介绍这些规则，因为没有人会按照这个规则去验证自己的程序是否是线程安全的，后面会介绍相应的等价规则，也就是先行先发生原则来判断。此外，之后所有的同步方式，比如 volatile、synchronized、final 等等，都是基于这这些执行顺序来的]{.blue}</p>
</li>
<li><p>总结</p>
<p>  上述提到的都是 JMM 的基本规则，但是这些规则是如何解决此前提到的原子性问题、缓存一致性问题、以及指令重排序的问题的内容还没有详细介绍，接下来就会讲述这些规则如何解决这些问题</p>
</li>
</ul>

        <h4 id="原子性"   >
          <a href="#原子性" class="heading-link"><i class="fas fa-link"></i></a><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4>
      <p>[什么是原子性？]{.label .primary}</p>
<ul>
<li>定义：[一个操作或者多个操作在执行的过程中不会被任何因素打断，要么全部执行，要么全部都不执行]{.red}</li>
</ul>
<p>[什么是原子性问题？]{.label .primary}</p>
<ul>
<li>定义：[由于线程发生上下文切换从而导致线程的操作被中断，出现错误的结果]{.label .primary}</li>
</ul>
<p>举个栗子</p>
<p>编写存在原子性问题的测试代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increament</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 快捷运算符不是六个基本操作，也就是不是原子性操作</span></span><br><span class="line">    <span class="comment">// 等价于: read count、assing count、write count</span></span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里需要多次测试，因为单次测试很有可能得到的是正确的结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1000</span>;i++)&#123;</span><br><span class="line">           <span class="comment">// 调用方法：这里是伪代码，节省篇幅</span></span><br><span class="line">           increament();</span><br><span class="line">       &#125; </span><br><span class="line">    &#125;);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1000</span>;i++)&#123;</span><br><span class="line">           <span class="comment">// 调用方法：这里是伪代码，节省篇幅</span></span><br><span class="line">           increament();</span><br><span class="line">       &#125; </span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 等待两个线程运行结束后输出结果</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></div></figure>

<p>在不运行的情况下，你觉得正确答案应该是多少？2000？从理论上来说是这样，但是实际的测试中会出现非常奇怪的结果</p>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/原子性问题.1ognt5lvywo0.png" alt="原子性问题" style="zoom:80%;" />

<p>为什么会出现这么多不同的结果？实际上就是因为非原子性的操作因为上下文切换被中断导致的。</p>
<p>刚才提到快捷运算符并不是原子性操作而是由多个操作组合而成的，从字节码的角度也可以证明这一点。[既然这样，线程-1在执行完加法之后，因为线程-2突然想要执行从而导致线程-1的操作被中断无法继续更新结果，那么线程-2此时看到变量值就还是原始的结果，线程-2执行完毕之后将新的结果写回变量，此时线程-1继续执行，但是线程-1并不知道其余线程做了什么，它依旧把自己的结果更新回去，这就导致虽然执行了两次加法，但是最后的结果却只加了一的情况]{.aqua}</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取共享变量</span></span><br><span class="line"><span class="number">2</span>: getfield      #<span class="number">2</span></span><br><span class="line"><span class="comment">// 获取常量</span></span><br><span class="line"><span class="number">5</span>: iconst_1</span><br><span class="line"><span class="comment">// 将共享变量和常量相加</span></span><br><span class="line"><span class="number">6</span>: iadd</span><br><span class="line"><span class="comment">// 将结果写回去    </span></span><br><span class="line"><span class="number">7</span>: putfield      #<span class="number">2</span>                  </span><br></pre></td></tr></table></div></figure>

<p>[如何确保原子性？]{.label .primary}</p>
<ul>
<li>单个操作的原子性：JMM 提供的六个基本操作 read、load、store、write、use、assign 都是原子性操作</li>
<li>多个操作的原子性：JMM 为了确保这些基本操作的组合是原子性的，还提供了 lock、unlock 的操作</li>
<li>细节：<ul>
<li>[lock、unlock 是最底层的指令没有对用户开放使用，而是将 monitorenter、monitorexit 开放给用户]{.red}</li>
<li>[这两条指令反映到代码中就是 synchronized 关键字，所以直接使用 synchronized 就可以确保原子性]{.red}</li>
</ul>
</li>
</ul>
<p>[实际确保原子性的方式]{.label .primary}</p>
<ul>
<li>[synchronized]{.red}</li>
<li>[cas]{.red}</li>
<li>[aqs 锁 &amp; juc 工具类]{.red}</li>
</ul>

        <h4 id="可见性"   >
          <a href="#可见性" class="heading-link"><i class="fas fa-link"></i></a><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4>
      <p>[什么是可见性？]{.label .primary}</p>
<ul>
<li>定义：[当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值]{.red}</li>
</ul>
<p>[什么是可见性问题？]{.label .primary}</p>
<ul>
<li><p>定义：[多个线程各自拥有的工作内存中存储的变量不相同]{.red}</p>
</li>
<li><p>本质：此前提到的缓存一致性问题就是可见性问题</p>
</li>
</ul>
<p>举个栗子</p>
<p>编写存在可见性问题的测试代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>；</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(run)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    thread.start();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 主线程修改标志位</span></span><br><span class="line">    run = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>[实际测试这段代码你会发现在主线程修改标志位之后，子线程会继续运行而不会停下来。这其实就是因为两个线程的工作内存不同，从而导致主线程修改的是自己工作内存中的 run 变量的值，而子线程的 run 变量依然为 true，这就是主线程中工作内存中的内容对于子线程来说是不可见的，其本质也就是因为缓存中对于共享变量的数据不一致]{.aqua}</p>
<p>[如何确保可见性？]{.label .primary}</p>
<p>[实际确保可见性的方式]{.label .primary}</p>
<ul>
<li>[volatile]{.red}</li>
<li>[synchronized]{.red}</li>
</ul>

        <h4 id="有序性"   >
          <a href="#有序性" class="heading-link"><i class="fas fa-link"></i></a><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4>
      <p>[什么是有序性？]{.label .primary}</p>
<p>[什么是有序性问题？]{.label .primary}</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></div></figure>



<p>[如何确保有序性？]{.label .primary}</p>
<p>[实际确保有序性的方式]{.label .primary}</p>
<ul>
<li>[final]{.red}</li>
<li>[volatile]{.red}</li>
<li>[synchronized]{.red}</li>
</ul>

        <h4 id="happens-before-原则"   >
          <a href="#happens-before-原则" class="heading-link"><i class="fas fa-link"></i></a><a href="#happens-before-原则" class="headerlink" title="happens-before 原则"></a>happens-before 原则</h4>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/11/01/java/jcf/Collection-overview/">Collection-overview</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-11-01</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-11-01</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h1>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/11/01/java/jcf/Collection-LinkedList/">Collection-LinkedList</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-11-01</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-11-01</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="LinkedList"   >
          <a href="#LinkedList" class="heading-link"><i class="fas fa-link"></i></a><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1>
      <ul>
<li><p>定义：==链表==</p>
</li>
<li><p>特点：</p>
<ul>
<li><p><a style="color:red;">底层采用 <strong>双向链表</strong> 实现</a>：(1) 链表每个结点采用静态内部类 <code>Node</code> 维护 (2) 首尾结点采用 <code>first</code> &amp; <code>last</code> 成员变量维护 (3) 链表长度采用 <code>size</code> 变量维护 </p>
<p>  注：<code>JDK 1.6</code> 采用循环链表实现 &amp; <code>JDK 1.7</code> 取消循环</p>
</li>
<li><p><a style="color:red;">没有采用同步机制</a>：多线程并发操作 <code>LinkedList</code> 是 <strong>线程不安全</strong> 的</p>
</li>
</ul>
</li>
<li><p>实现 &amp; 继承：(1) 没有实现 <code>RandomAccess</code> 接口 (2) 实现 <code>Deque</code> &amp; <code>Queue</code> 接口 (3) 实现 <code>Serializable</code> 接口</p>
</li>
<li><p>成员变量：</p>
<ul>
<li><code>transient int size = 0;</code> 链表长度 </li>
<li><code>transient Node&lt;E&gt; first;</code> 结点的前驱指针 </li>
<li><code>transient Node&lt;E&gt; last;</code> 结点的后继指针</li>
</ul>
</li>
<li><p>构造方法：</p>
<ul>
<li><p>空参构造：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>有参构造：直接添加传入集合中的元素不使用反射进行检查 -&gt; 因为在添加元素的方法中元素类型会被强制转换</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>方法：(仅列出 <code>List</code> 接口下常用的方法)</p>
<ul>
<li><p><code>add()</code>：时间复杂度都是 <strong>常数</strong> &amp; <strong>默认</strong> 将元素添加到 <strong>链表的末尾</strong></p>
</li>
<li><p><code>remove()</code>：时间复杂度都是 <strong>线性</strong> 的</p>
</li>
<li><p><code>addAll()</code>：内部并没有直接使用 <code>add()</code> 方法</p>
<p>  <a style="color:red;">1. 原因之一是因为循环调用 add 方法效率太低</a></p>
<p>  <a style="color:red;">2. 原因之二是因为批量添加元素 modCount 应该仅增加 1，如果循环调用 add 方法会导致 modCount 增加多次</a></p>
</li>
<li><p><code>get()</code>：传入参数是索引 &amp; 执行的时间复杂度是 <strong>线性</strong> 的</p>
<p>  <a style="color:red;">优化：传入的索引大于链表长度一半时，会自动从末尾开始访问</a></p>
</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li><a style="color:red;"><code>LinkedList</code> 为空的情况下获取首部或者尾部元素都是会抛出异常的</a></li>
<li><code>LinkedList</code> 可以用作多种数据结构的实现：<a style="color:red;">可以用于普通队列、双端队列、栈的实现</a></li>
<li><code>LinkedList</code> 插入和删除元素时不受到元素位置的影响：时间复杂度近似为 <code>O(1)</code> &amp; 指定位置插入元素或者删除时受到其影响：时间复杂度为 <code>O(n)</code></li>
<li><code>LinkedList</code> 对每个 <strong>元素</strong> 都需要 <strong>添加前驱和后继指针</strong> 并包装成 <strong>结点</strong>：每个元素消耗空间比较大</li>
</ul>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/11/01/java/jcf/Collection-ArrayList/">Collection-ArrayList</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-11-01</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-11-01</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="ArrayList"   >
          <a href="#ArrayList" class="heading-link"><i class="fas fa-link"></i></a><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1>
      
        <h2 id="基础知识"   >
          <a href="#基础知识" class="heading-link"><i class="fas fa-link"></i></a><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2>
      <ul>
<li><p>定义：==数组链表==</p>
</li>
<li><p>特点：</p>
<ul>
<li><p><a style="color:red;">底层采用数组实现</a>：<code>size</code> 变量维护当前线程操作的数组大小 &amp; <code>modCount</code> 变量维护对集合的操作次数 (<a style="color:red;">AbstractList 抽象类中维护的变量</a>)</p>
</li>
<li><p><a style="color:red;">没有采用同步机制</a>：多线程并发操作 <code>ArrayList</code> 是 <strong>线程不安全</strong> 的</p>
</li>
<li><p>默认 <code>capacity</code>= <code>10</code> ：默认没有指定容量大小且没有元素时数组为空</p>
<p>  注：<a style="color:red;">数组容量不足以支撑继续存放元素时会采用 <strong>动态扩容</strong> 机制</a></p>
</li>
</ul>
</li>
<li><p>实现 &amp; 继承：(1) 实现 <code>RandomAccess</code> 接口 (2) 实现 <code>Serializable</code> 接口</p>
</li>
<li><p>成员变量</p>
<ul>
<li><code>private static final int DEFAULT_CAPACITY = 10;</code> 集合默认容量大小</li>
<li><code>private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</code> 空参构造器创建后数组的值</li>
<li><code>transient Object[] elementData;</code> 数组对象</li>
<li><code>private int size;</code> 数组容量大小</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li><code>ArrayList</code> 占用总空间较大：会为之后可能添加进入的元素预留一定位置的空间</li>
<li><code>ArrayList</code> 插入和删除元素收到元素位置的影响：插入和删除尾部元素时时间复杂度为 <code>O(1)</code> &amp; 插入和删除其他位置时时间复杂度为 <code>O(n)</code>：需要移动其他元素</li>
<li><code>ArrayList</code> 需要经常进行扩容的话尽可能采用 <code>LinkedList</code> 类</li>
<li><code>ensureCapacityInternal</code> 方法是 <strong>私有</strong> 的用于扩容机制的 &amp; <code>ensureCapacity</code> 方法是 <strong>公共</strong> 的程序员可以主动采用该方法进行扩容</li>
</ul>
</li>
</ul>

        <h2 id="基础方法"   >
          <a href="#基础方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#基础方法" class="headerlink" title="基础方法"></a>基础方法</h2>
      <ul>
<li><p>构造器方法</p>
<ul>
<li><p>空参构造器：调用无参构造创建得到的集合初始容量为 <code>0</code></p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>有参构造器：</p>
<p>  注：<a style="color:red;"><strong>反射</strong>判断传入的集合的类型是否为数组集合</a></p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入参数为集合容量的构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity]; <span class="comment">// 创建的是 Object 数组</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传入的参数为集合的构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">            elementData = a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            elementData = Arrays.copyOf(a, size, Object[].class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>方法：</p>
<ul>
<li><code>add() &amp; addAll()</code> 时间开销和 <strong>插入的位置有关</strong>、 <strong>插入的元素数量</strong></li>
<li><code>remove()</code> ：被移除元素之后的元素都需要向前移动，并且 <strong>显示地将最后一个位置置为 <code>null</code></strong><ul>
<li> <a style="color:red;">确保垃圾回收机制可以正常工作</a> （详情见 <code>remove</code> 方法源码）</li>
<li> 每次执行 <code>add()</code> 或者 <code>remove()</code> 方法后 <code>size</code> &amp; <code>modCount</code> 都需要相应的加减</li>
</ul>
</li>
<li><code>trimToSize()</code>：<a style="color:red;">调整数组大小为当前实际的元素数量</a>：移除所有的空元素 （本质：数组复制）</li>
<li><code>removeIf()</code> 方法：移除集合中所有满足条件的元素 &amp; 传入的参数是 <strong>断定型接口</strong> (<code>Predicate</code>)</li>
<li><code>forEach()</code>方法： 使用集合中的元素（诸如打印等操作）&amp; 传入的参数是消费型接口 (<code>Consumer</code>)</li>
<li><code>removeAll()</code> &amp; <code>addAll()</code> 方法：<strong>批量添加和删除元素</strong> &amp; 传入的参数都是集合 (<code>Colleciton</code>)</li>
</ul>
</li>
</ul>

        <h2 id="底层原理"   >
          <a href="#底层原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2>
      
        <h3 id="自动扩容机制"   >
          <a href="#自动扩容机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#自动扩容机制" class="headerlink" title="自动扩容机制"></a>自动扩容机制</h3>
      <p>:::primary</p>
<p>JDK 7 和 JDK 8 的自动扩容机制在方法上存在变化，这里采用 JDK 8 的版本</p>
<p>:::</p>
<ul>
<li><p>自动扩容过程</p>
<ul>
<li>[每次添加元素之前都会将实际元素数量增加 1 传入 ensureCapacityInternal  方法]{.red}</li>
<li>[ensureCapacityInternal 方法将会调用 calculateCapacity 判断 <strong>传入的最小容量和默认容量的大小</strong>]{.red}<ul>
<li>[取传入的最小容量和默认容量中的最大值]{.pink}</li>
</ul>
</li>
<li>[calculateCapacity 将返回值交给 ensureExplicitCapacity 判断 <strong>当前数组长度和最小容量的大小关系</strong>]{.red}<ul>
<li>[小于就进行扩容，大于就直接添加元素]{.pink}</li>
</ul>
</li>
<li>[扩容的方式就是建立容量为原数组 1.5 倍的新数组并将原数组中的内容拷贝到新数组]{.red}</li>
</ul>
</li>
<li><p>自动扩容流程图</p>
  <img src="https://cdn.jsdelivr.net/gh/shirakamifubuki/image@master/20210724/自动扩容过程.3h7soe4slwu0.png" alt="自动扩容过程" style="zoom: 80%;" /></li>
<li><p>自动扩容源代码</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先计算当前的最小容量</span></span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">// 判断传入的最小容量和默认容量大小</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 如果最小容量大于当前数组的长度就进行扩容，反之则直接添加元素</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 扩容</span></span><br><span class="line">     	grow(minCapacity);    				   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ..</span><br><span class="line">    <span class="comment">// Java 位运算：右移两位相当于除 2</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); </span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 采用 Arrays.copyOf 拷贝数组</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h3 id="快速失败机制"   >
          <a href="#快速失败机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#快速失败机制" class="headerlink" title="快速失败机制"></a>快速失败机制</h3>
      <ul>
<li><p>名称：Fast-Fail </p>
</li>
<li><p>概念：面对并发的修改时，迭代器 <strong>很快</strong> 就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险</p>
</li>
<li><p>产生原因：</p>
<ul>
<li>[多个线程 / 迭代器同时对集合进行 <strong>结构性修改</strong>]{.red}</li>
<li>[单线程下在 <strong>迭代器遍历过程</strong> 中使用集合自身的方法对集合进行修改]{.red}</li>
</ul>
</li>
<li><p>结果：[抛出 ConcurrentModificationException 异常]{.red}</p>
</li>
<li><p>快速失败机制源代码</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这是 AbstractList 内部类 Iterator 中的内容 */</span></span><br><span class="line"><span class="keyword">int</span> expectedModCount = modCount; </span><br><span class="line"><span class="comment">/* modCount 是成员变量 &amp; expectedModCount 是局部变量：每个迭代器都有自己的 expectedModCount 但是 modCount 是唯一的*/</span></span><br><span class="line"><span class="comment">/* modCount 和 expectedModCount 只要不相等就会触发快速失败机制 -&gt; 抛出并发修改异常*/</span></span><br><span class="line"><span class="comment">/* 迭代器内部每次调用集合的 remove 方法修改 modCount 值然后令 expectedModCount = modCount */</span></span><br><span class="line"><span class="comment">/* 多个迭代器就会造成唯一的 modCount 和 多个 expectedModCount 不相等的情况*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每次执行迭代之前都会判断当前迭代器自己的操作数 expectedModCount 是否和 集合的操作数 modCount 相同</span></span><br><span class="line">    checkForComodification();...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查 modCount 变量和 expectedModCount 是否相等</span></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

</li>
</ul>

        <h3 id="数组复制"   >
          <a href="#数组复制" class="heading-link"><i class="fas fa-link"></i></a><a href="#数组复制" class="headerlink" title="数组复制"></a>数组复制</h3>
      <ul>
<li><p>概念：动态扩容中涉及到两种数组的复制方式，需要进行区分</p>
</li>
<li><p>方式：</p>
<p>  (1) <code>Arrays.copyOf(T[] oldArray, int newLength)</code> (还有许多同类型的重载方法)</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] copyOf(<span class="keyword">int</span>[] original, <span class="keyword">int</span> newLength) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[newLength];</span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  (2) <code>System.arraycopy(T[] src,int srcPos,T[] des,int desPos,int length)</code></p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(...)</span></span></span><br></pre></td></tr></table></div></figure></li>
<li><p>区别：</p>
<p>  (1) <a style="color:red;">第一种方式会返回新的数组，第二种方式需要传入新的数组，而不会返回新的数组</a></p>
<p>  (2) <a style="color:red;">第一种内部实际调用了第二种方式，第二种方式的实现使用 C语言中的 <strong>memmove</strong> 方法完成</a></p>
</li>
</ul>

        <h2 id="问题"   >
          <a href="#问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#问题" class="headerlink" title="问题"></a>问题</h2>
      <p>[问题一]{.label .success}</p>
<p>+++danger 每次添加数据时都采用自动扩容机制，是否因为数组复制会导致效率低下? </p>
<p>① 这个问题的答案是根据情况而定的</p>
<p>② 如果经常需要进行扩容，每次都会扩大 1.5 倍，那么当数组长度越来越大的时候，需要扩容的次数也会减少，并没有想象中的那么差</p>
<p>③ 但是如果预先知道数据量非常大，那么依靠自动扩容去达到需要的容量显然是不行的，效率比较低，并且数组复制也会降低效率</p>
<p>④ 举个例子，1k 容量的数组需要扩容约 12 次、 10k 容量的数组需要扩容 17 次、100k 容量的数组需要扩容 23 次 </p>
<p>+++</p>
<p>[问题二]{.label .success}</p>
<p>+++danger 为什么 Java 不对数组对象使用 private 关键字呢?</p>
<p>包可见性便于内部各个类直接访问</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/28/juc/juc-concurrent/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-%E6%A6%82%E8%BF%B0/">线程安全-概述</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-11-08</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="什么是线程安全问题？"   >
          <a href="#什么是线程安全问题？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是线程安全问题？" class="headerlink" title="什么是线程安全问题？"></a>什么是线程安全问题？</h1>
      
        <h2 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h2>
      <p>:::primary</p>
<p>① 详细讲述线程安全之前先来简单感受下什么是线程安全问题</p>
<p>② 感受下出现线程安全问题的大致需要什么样的条件，因为我发现在没有样例的情况怎么写都是不好写的</p>
<p>:::</p>
<ul>
<li><p>线程不安全示例：</p>
<ul>
<li><p>[类提供对成员变量进行读写的方法，而多个线程同时调用类提供的该方法对成员变量递增 1000 次]{.aqua}</p>
</li>
<li><p>[最后得到结果会是我们预想的 2000 吗？还是会得到一个非常奇怪的结果？ ]{.aqua}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronized</span></span>&#123;</span><br><span class="line">	<span class="comment">// 多线程使用的变量    </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">	<span class="comment">// 多线程控制变量的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为了节省代码的篇幅, 仅列出对成员变量和相应的方法，多线程的代码请自己编写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>如果你已经编写好多线程的代码，并且经过测试应该会发现结果可能每次都不一样</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/线程不安全的示例.rnomm14qxww.png" alt="线程不安全的示例" style="zoom:80%;" />

<p>  +++danger 为什么会出现如此奇怪的结果？</p>
<p>  ① 每个线程对成员变量进行相加的过程中并不是简单地执行加法，而是执行了三种操作</p>
<p>  ② 每个线程首先会获取成员变量的值、成员变量加一、最后将结果更新给成员变量</p>
<p>  ③ 如果某个线程在执行完成员变量加一之后，因为线程上下文切换而导致无法执行时，此时的结果依然是原来的值</p>
<p>  ④ 其余线程获取到的成员变量的值就是原来的值，执行完后续两个操作之后，成员变量真正完成了加一的操作</p>
<p>  ⑤ 但是刚才没有执行完的线程并不知道这件事情，它继续将自己的运算得到的结果更新给成员变量</p>
<p>  ⑥ 这就导致最后明明执行两次加法，但是成员变量却只增加了一次</p>
<p>  +++</p>
</li>
</ul>
</li>
<li><p>线程不安全的条件</p>
<ul>
<li>[存在可共享的变量]{.red}</li>
<li>[存在多线程并行或者并发地对共享变量进行读写]{.red}</li>
</ul>
</li>
<li><p>前言：</p>
<ul>
<li>只有确定共享变量之后，才能够分析是否会有线程安全问题，最终才能够确定同步方案<ol>
<li>首先就需要了解如何确定共享变量，哪些变量才是共享变量</li>
<li>其次就需要分析线程安全问题是如何产生的</li>
<li>最后才会思考如何采用合适的同步方案解决线程安全问题</li>
</ol>
</li>
</ul>
</li>
</ul>

        <h2 id="共享变量"   >
          <a href="#共享变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h2>
      <ul>
<li><p>前提：</p>
<ul>
<li>[变量是否共享都是以线程为单位的，而不是对象或者方法之类的]{.orange}</li>
<li>[共享变量是产生线程安全问题的必要条件]{.orange}<ul>
<li>[线程安全问题的产生必然基于对共享变量的操作]{.pink}</li>
<li>[但是共享变量的存在不一定会导致线程安全问题的出现]{.pink}</li>
</ul>
</li>
</ul>
</li>
<li><p>共享变量定义：[多线程可以同时访问的变量称为共享变量]{.grey}</p>
</li>
<li><p>共享变量位置：[Java 虚拟机中的栈空间的变量都是线程私有的，堆空间中的对象都是线程共享的]{.red}</p>
</li>
<li><p>共享变量实例：</p>
<ul>
<li><p>成员变量（实例变量 + 类变量）：</p>
<ul>
<li><p>前提：[无论成员变量是基本数据类型还是引用类型都是 <strong>可能</strong> 共享的]{.orange}</p>
<ul>
<li>对象的成员变量都是分配在堆空间中的，而堆空间是所有线程都共享的区域</li>
</ul>
</li>
<li><p>[如果成员变量在能够直接或者间接地被其他对象使用，那么这些成员变量都是可共享的变量]{.red}</p>
<ul>
<li><p>逸出的方式有非常多种，并不是每种逸出方式都可能造成线程安全的</p>
</li>
<li><p>只能够代表这些变量可以被其他线程所访问到，也就是可共享</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedVariable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// ① 访问权限是公共的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">// ② 访问权限私有的基本数据类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="comment">// 其余线程可以通过方法获取私有成员变量的副本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ③ 访问权限私有的引用数据类型</span></span><br><span class="line">    <span class="keyword">private</span> StringBuilder sb;</span><br><span class="line">    <span class="comment">// 其余线程可以通过方法获取到私有成员变量的引用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">getStringBuilder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ④ 直接对成员变量的使用也是逸出, 不是只有返回成员变量才叫逸出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStringBuilder</span><span class="params">(StringBuilder sb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sb = sb;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 总结:</span></span><br><span class="line">    <span class="comment">// ① ④ 两种方式都涉及到对成员变量的修改, 是很容易产生产生线程安全的</span></span><br><span class="line">    <span class="comment">// ② ③ 两种方式涉及到的知识成员变量的修改, 但是后者会产生线程安全问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>局部变量：</p>
<ul>
<li><p>前提：</p>
<ol>
<li>[基本数据类型的局部变量是 <strong>不可能</strong> 被共享的]{.orange}<ul>
<li>基本数据类型的局部变量是分配在栈空间中的</li>
<li>每个线程访问该局部变量的时候都复制一份到自己的栈空间中</li>
<li>每个线程的栈空间都是私有的，不存在共享变量的可能</li>
</ul>
</li>
<li>[引用类型的局部变量存在是 <strong>可能</strong> 共享的]{.aqua}<ul>
<li>每个线程访问局部变量的时候复制对象的引用到自己栈空间中</li>
<li>每个线程的使用的引用指向的都是堆空间中相同的对象，所以存在共享的可能</li>
</ul>
</li>
</ol>
</li>
<li><p>[如果 <strong>引用类型</strong> 的局部变量能够直接或间接地被其他对象使用，那么这些局部变量都是可共享的变量]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ① 方法的持续调用, 导致局部变量被其他线程所引用</span></span><br><span class="line"><span class="comment">// 个人感觉这种情况比较特殊, 但是既然存在那也写上来吧</span></span><br><span class="line"><span class="comment">// 注：基本数据类型即使这么做也是没有用的, 因为 Java 是值传递, 每个线程都会拿到副本</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 此时的局部变量就已经逸出到其他线程中了, 可以被其他线程所使用</span></span><br><span class="line">        add(list, i + <span class="number">2</span>);</span><br><span class="line">        remove(list, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一个线程可以给链表增加元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        list.add(number);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 另一个线程可以给链表移除元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        list.remove(index);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ② 返回值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getStringBuilder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 是否存在线程安全取决于调用者</span></span><br><span class="line">    <span class="comment">// 返回的对象如果只有一个线程使用, 那就有没有问题</span></span><br><span class="line">    <span class="comment">// 返回的对象如果有多个线程使用，那就有线程安全问题</span></span><br><span class="line">    <span class="comment">// 但是无论怎样, 这个对象都是可以被共享的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>总结：</p>
<ol>
<li>[只要变量不暴露给其他对象使用，那么无论变量是什么类型，它都是不可共享的]{.blue}</li>
<li>[引用类型的变量通常都是可以共享的，基本数据类型的变量是成员变量是才可以共享]{.blue}</li>
<li>[堆中的对象基本可以共享，取决于线程是否开放他，栈中的变量不可能共享]{.blue}</li>
</ol>
</li>
</ul>
</li>
</ul>

        <h2 id="线程安全问题"   >
          <a href="#线程安全问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2>
      <p>:::primary</p>
<p>① 这里会简述代码中常见的线程安全问题，至于这些线程安全问题究竟是如何造成的，稍后再讲</p>
<p>② 这样排版的主要原因是因为，没有对内存模型的认知，是根本不可能深入理解可见性这个概念的</p>
<p>③ 所以造成原子性、可见性、有序性问题的原因都会在 Java 内存模型中讲述</p>
<p>:::</p>

        <h3 id="基本内容"   >
          <a href="#基本内容" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h3>
      <ul>
<li><p>示例：先来看看什么样的是线程安全问题</p>
<ul>
<li>测试代码</li>
<li>测试结果</li>
</ul>
</li>
<li><p>线程安全定义：</p>
<ul>
<li>严谨的定义：<ol>
<li>多个线程并发或者并行访问共享变量的时候</li>
<li>无论运行时采用何种调度方式安排线程的执行，并且不需要任何额外的同步代码</li>
<li>多线程访问共享变量的结果都能够表现出正确的行为，那么就认为是线程安全的</li>
</ol>
</li>
<li>通俗的定义：[多线程按照任意顺序对共享资源进行访问都能够得到正确的结果，就认为是线程安全]{.red}</li>
</ul>
</li>
<li><p>线程安全问题：多线程访问共享变量的结果或者说正确性得不到保证时，就认为出现了线程安全问题</p>
<ul>
<li><p>多线程访问共享变量的方式会直接决定是否会产生线程安全问题</p>
</li>
<li><p>访问方式：读与写</p>
<ul>
<li><p>[多线程 <strong>同时读取共享变量</strong> 不会造成线程安全问题]{.red}</p>
<ul>
<li>解释：同时读取共享变量的行为显然是无论如何打乱，执行的结果一定是符合预期的</li>
</ul>
</li>
<li><p>[多线程 <strong>同时读写或者同时写入</strong> 共享变量都是会造成线程安全问题的]{.red}</p>
<ul>
<li><p>解释：同时的读写或者同时写入的行为被打乱，那么执行的结果是非常有可能不同的</p>
</li>
<li><p>举例：如果某个线程正在对共享变量做递增操作，修改完成之后还没来得及更新变量</p>
<p>  ​              另外一个线程也获取到共享变量并对其进行递增操作，修改完成之后进行更新</p>
<p>  ​              这样就会导致明明变量递增了两次，但是最终只增加了一</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>临界区：[线程访问共享变量的代码块称为临界区]{.red}</p>
</li>
<li><p>竞态条件：[多线程访问共享变量的结果取决于特定的顺序的时候，就认为发生了竞态条件]{.red}</p>
</li>
</ul>

        <h4 id="原子性问题"   >
          <a href="#原子性问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#原子性问题" class="headerlink" title="原子性问题"></a>原子性问题</h4>
      <ul>
<li><p>定义：</p>
</li>
<li><p>测试代码</p>
</li>
</ul>

        <h4 id="可见性问题"   >
          <a href="#可见性问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h4>
      <ul>
<li>定义：</li>
</ul>

        <h4 id="有序性问题"   >
          <a href="#有序性问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#有序性问题" class="headerlink" title="有序性问题"></a>有序性问题</h4>
      <p>:::primary</p>
<p>:::</p>

        <h3 id="线程安全等级"   >
          <a href="#线程安全等级" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程安全等级" class="headerlink" title="线程安全等级"></a>线程安全等级</h3>
      
        <h4 id="不可变"   >
          <a href="#不可变" class="heading-link"><i class="fas fa-link"></i></a><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h4>
      <ul>
<li><p>定义：[不可变的对象或者变量都是不会存在任何线程安全性问题的]{.red}</p>
</li>
<li><p>不可变的变量的线程安全：确保变量的线程安全</p>
</li>
<li><p>不可变对象的线程安全</p>
<ul>
<li><p>[不可变对象只能够代表对象的引用是不可以改变的，但是对象内部的成员变量依旧可以访问并且改变]{.red}</p>
</li>
<li><p>也就是说只能够保证引用的线程安全，对象内部的线程安全是没有保证的，需要对象自行保证</p>
<p>  :::danger</p>
<p>  ① 最简单的方式就是将对象内部的所有变量都声明为不可变</p>
<p>  ② 类声明为不可变只能够代表该类无法被继承，而不是代表线程安全的</p>
<p>  :::</p>
</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/不可变性.752xyg222q00.png" alt="不可变性" style="zoom:80%;" /></li>
<li><p>细节：</p>
<ul>
<li>JDK 5 之后才能够保证不可变对象没有线程安全问题</li>
<li>[不可变对象需要在没有发生 <strong>this 引用逃逸</strong> 的情况下被正确的构建出来才是线程安全的]{.pink}</li>
</ul>
</li>
</ul>

        <h4 id="绝对线程安全"   >
          <a href="#绝对线程安全" class="heading-link"><i class="fas fa-link"></i></a><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h4>
      <ul>
<li>定义：[严格满足线程安全的定义也就是绝对线程安全]{.pink}</li>
<li>细节：绝对线程安全几乎很难做到，Java 提供的大多数线程安全类并不是绝对线程安全的</li>
</ul>

        <h4 id="相对线程安全"   >
          <a href="#相对线程安全" class="heading-link"><i class="fas fa-link"></i></a><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h4>
      <ul>
<li>定义：<ul>
<li>线程单次调用对象中的某个方法时是线程安全的，不需要提供任何同步措施</li>
<li>但是线程组合调用多个线程的方法时需要采用一定的同步措施</li>
</ul>
</li>
<li>细节：相对线程安全就是通常意义上指的线程安全，Java 提供的大多数线程安全类都是相对线程安全的</li>
</ul>

        <h4 id="线程兼容"   >
          <a href="#线程兼容" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h4>
      <ul>
<li>定义：线程调用的对象不具备任何确保线程安全的措施，需要在调用端提供完善的同步措施</li>
</ul>

        <h4 id="线程对立"   >
          <a href="#线程对立" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h4>
      <ul>
<li>定义：[无论线程调用的对象是否采取了同步措施，都没有办法让线程并行或者并发调用该对象]{.red}</li>
<li>例子：<code>suspend()</code> 和 <code>resume()</code> 是线程对立的方法<ul>
<li>两个线程分别调用 <code>suspend()</code> 和 <code>resume()</code> 方法是不现实的</li>
<li>前者用于挂起线程，后者用于恢复线程，这两个方法同时执行显然是不合理的 </li>
</ul>
</li>
<li>细节：Java 天生就支持多线程，所以会产生线程对立的方法都被废弃掉了（此前应该提过几个已经被废弃的方法）</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/28/juc/juc-concurrent/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-synchronized-%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/">线程同步-synchronized-优化策略</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-29</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="优化策略"   >
          <a href="#优化策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h1>
      
        <h2 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h2>
      <ul>
<li>前言：<ul>
<li>[Java 线程采用的是内核级线程实现的]{.aqua}</li>
<li>[Synchronized 每次造成的线程阻塞都会让线程执行上下文切换，从而导致 OS 从用户态陷入内核态]{.aqua}</li>
<li>[OS 从用户态陷入内核态的开销是非常大的，为了避免因频繁的阻塞造成的上下文切换带来的开销]{.aqua}</li>
<li>[JDK 官方在 JDK 6 之后推出了相应的优化策略]{.aqua}</li>
</ul>
</li>
<li>细节：下列所有优化策略对程序员来说都是透明的，全部都是由虚拟机完成的，你只需要知道它的原理</li>
<li> 必备知识：你需要了解对象的内存布局或者对象的组成才能够明白下面的知识</li>
</ul>
<p>:::primary</p>
<p>参考笔记：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://47.101.45.234/jvm/runtime/heapspace/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/" >堆空间 - 对象创建</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>

        <h2 id="轻量级锁"   >
          <a href="#轻量级锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2>
      <ul>
<li><p>定义：[不采用传统的 <strong>管程</strong> 给对象加锁，而是采用更加轻量的 <strong>锁记录空间</strong> 来给对象加锁]{.red}</p>
</li>
<li><p>目的：[在 <strong>多线程不会相互产生竞争</strong> 的情况下减少传统的重量级锁带来的性能消耗]{.red}</p>
<ul>
<li>没有竞争不代表不需要加锁，线程的调度完全是由操作系统完成的，线程是否会错开访问完全是未知的</li>
<li>所以虚拟机会在多线程不产生的竞争的情况下使用轻量级锁来减少开销</li>
</ul>
</li>
<li><p>锁记录空间：</p>
<ul>
<li>存放位置：[每个锁记录都存放在线程各自的虚拟机栈空间中]{.red}</li>
<li>组成：[锁记录 + 锁对象的引用地址]{.red}<ul>
<li>[锁记录用于存放 Mark Word 的内容，引用地址用于指向锁住的对象]{.pink}</li>
<li>[锁记录空间的地址并没有存放在锁记录中]{.pink}</li>
</ul>
</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/锁记录空间.26fv5ehdw3eo.png" alt="锁记录空间" style="zoom:80%;" /></li>
<li><p>加锁过程：</p>
<ol>
<li><p>[虚拟机会在线程的虚拟机栈空间中建立锁记录空间，用于记录锁对象的相关信息]{.pink}</p>
</li>
<li><p>线程尝试获取对象锁：</p>
<ul>
<li>[线程首先将 <strong>Mark Word 内容复制到 Displaced Mark Word 中</strong>]{.pink}</li>
<li>[线程接着尝试使用 CAS 将 <strong>Mark Word 的内容更新为 锁记录地址</strong>，并将 <strong>锁状态更新为轻量级锁（00）</strong>]{.pink}    * 如果锁对象的锁状态是未上锁状态（00），那线程就会成功获取对象锁    * 如果锁对象的锁状态已经是轻量级锁状态（01），那线程获取就会获取失败</li>
</ul>
 <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/轻量级-2.qlz08akomzk.png" alt="轻量级-2" style="zoom:80%;" /></li>
<li><p>线程成功获取对象锁：[线程将锁定对象的地址指向当前需要获取的对象]{.red}</p>
</li>
<li><p>线程获取对象失败：[检查 Mark Word 保存的地址是否指向当前线程的锁记录空间]{.red}</p>
<ul>
<li><p>如果指向的是当前线程的锁记录空间，那么当前线程已经拥有该轻量级锁了，就会执行可重入操作</p>
<ul>
<li><p> [线程会在栈空间中新增一条锁记录]{.pink}</p>
</li>
<li><p> [该锁记录的不保存 Mark Word 的副本而是置为空]{.pink}</p>
</li>
</ul>
<p>  +++danger 为什么要将重入记录的 Displaced Mark Word 置为空？</p>
<p>  +++</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/轻量级-3.5gqwcldvufc.png" alt="轻量级-3" style="zoom:80%;" /></li>
<li><p>[如果指向的不是当前线程的锁记录空间，那么就存在其他线程获取到该轻量级锁，轻量级锁会发生<strong>锁膨胀</strong>]{.pink}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/轻量级-4.5qwtg5kz3lw0.png" alt="轻量级-4" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>线程释放锁：</p>
<ul>
<li>[如果锁记录的锁记录地址为空，那么这就是重入记录，直接将锁记录数量减少一即可]{.pink}</li>
<li>[如果锁记录的锁记录地址不为空，那么线程会采用 CAS 将 Mark Word 更新为原来的内容]{.pink}    * 如果 CAS 操作能够成功，那么线程就可以正常释放锁    * [如果 CAS 操作不成功，那么就认为发生了锁膨胀，需要采用重量级锁的解锁流程]{.pink}</li>
</ul>
</li>
</ol>
</li>
<li><p>锁膨胀</p>
<ul>
<li><p>定义：[轻量锁转变为重量锁]{.red}</p>
</li>
<li><p>原因：存在某个线程已经持有对象的轻量级锁时，其余线程试图获取该对象的轻量级锁，产生线程竞争</p>
</li>
<li><p>膨胀过程：</p>
<ol>
<li><p>[虚拟机创建管程对象，Mark Word 指向管程对象]{.pink}</p>
</li>
<li><p>[管程对象将其拥有者设置为持有轻量级锁的线程]{.pink}</p>
</li>
<li><p>[持有轻量锁的线程在释放锁时采用 CAS 更新 Mark Word 会失败，因为 Mark Word 不是期望的锁记录地址]{.pink}</p>
</li>
<li><p>[此时线程就会进入重量级锁的释放流程]{.pink}</p>
</li>
</ol>
<pre><code>&lt;img src=&quot;https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/锁膨胀.myitqy1y69s.png&quot; alt=&quot;锁膨胀&quot; style=&quot;zoom:80%;&quot; /&gt;
</code></pre>
</li>
</ul>
</li>
</ul>

        <h2 id="偏向锁"   >
          <a href="#偏向锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2>
      <ul>
<li>历史：<ul>
<li>JDK 6 中引入的新的锁优化措施，默认开启偏向锁机制</li>
<li>[JDK 15 中已经默认不开启偏向锁机制 （+XX:UseBiasedLocking 开启偏向锁机制）]{.blue}</li>
</ul>
</li>
</ul>

        <h3 id="偏向"   >
          <a href="#偏向" class="heading-link"><i class="fas fa-link"></i></a><a href="#偏向" class="headerlink" title="偏向"></a>偏向</h3>
      <ul>
<li><p>定义：</p>
<ul>
<li>[如果在线程获得锁之后 <strong>长期没有其余线程来尝试获取锁对象</strong>，那么该锁将会“偏向”当前线程]{.red}</li>
<li>[线程在此之后 <strong>无论重入还是普通调用</strong> 锁对象都不需要再执行任何同步措施]{.red}</li>
</ul>
</li>
<li><p>目的：</p>
<ul>
<li><p>[在轻量级锁机制中每次线程执行锁重入都需要使用 CAS 去更新 Mark Word，每次更新都是存在消耗的]{.red}</p>
</li>
<li><p>[在偏向锁机制中只要锁对象偏向线程后，该线程就可以避免每次调用或重入锁对象造成的 CAS 开销]{.red}</p>
</li>
</ul>
</li>
<li><p>偏向过程：</p>
<ol>
<li><p>检查锁对象是否为可偏向状态</p>
<ul>
<li><p>[如果锁对象 Mark Word 中已经存储了哈希值，那么就不可以再开启偏向模式了]{.pink}</p>
</li>
<li><p>[如果虚拟机参数中已经配置禁止开启偏向锁机制的参数，那么也不可以再开启偏向模式]{.pink}</p>
<p>  :::info</p>
<p>  至于为什么在存储哈希值后就不可以开启偏向模式了，在偏向撤销时讲述</p>
<p>  :::</p>
</li>
</ul>
</li>
<li><p>[锁对象 <strong>第一次被线程获取</strong> 时会开启偏向模式，Mark Word 中偏向模式变为 1，锁记录状态依旧为 01]{.pink}</p>
</li>
<li><p>线程接着尝试使用 CAS 更新对象头中存储的内容</p>
</li>
</ol>
<ul>
<li>[如果对象头中哈希值仍为默认值 0，那 CAS 就可以将 <strong>哈希值</strong> 更新为 <strong>偏向线程的 ID + 偏向的时间戳</strong>]{.pink}</li>
<li>[如果对象头中的哈希值不是默认值 0，那么 <strong>虚拟机就会将对象重新置为未偏向模式</strong>]{.pink}</li>
</ul>
<ol start="4">
<li>[线程接下来的重入或者普通调用过程就不需要执行任何同步措施，直接访问即可]{.pink}</li>
</ol>
</li>
<li><p>细节：[偏向锁机制是默认开启的，但是偏向锁默认是延迟开启的]{.red}</p>
<ul>
<li>前者意味着所有对象在未上锁的状态下都是开启了偏向模式的</li>
<li>后者意味着你打印对象内存布局时会发现对象的依然不处于偏向模式</li>
</ul>
</li>
<li><p>测试偏向锁延迟开启机制</p>
<ol>
<li><p>导入 JOL 工具包用于查看对象的内存布局，也就是对象的组成内容</p>
 <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注意: 这个工具类有好几个版本, 每个版本打印出来的格式不太一样--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></div></figure></li>
<li><p>编写测试代码用于测试偏向锁的存在</p>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.bias&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadBias</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 内部类: 里面什么都没有都可以</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Bias</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Bias</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.number = number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Bias bias = <span class="keyword">new</span> Bias();</span><br><span class="line">        <span class="comment">// 打印对象的内存布局</span></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(bias).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>测试结果-1：意料之中没有开启偏向锁</p>
 <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/偏向锁-1.7bdpes7gfyc0.png" alt="偏向锁-1" style="zoom:80%;" /></li>
<li><p>两种解决方式</p>
<ul>
<li>[线程睡眠一段时间之后再打印对象的内存布局]{.blue}</li>
<li>[改变偏向锁延迟的时间：-XX:BiasedLockingStartupDelay=0]{.blue}</li>
</ul>
</li>
<li><p>测试结果-2：</p>
 <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/偏向锁-2.6u5kv3mk6c40.png" alt="偏向锁-2" style="zoom:80%;" /></li>
</ol>
</li>
<li><p>测试偏向锁机制：[前提是确保偏向锁能够生效，也就是没有延迟，否则是看不到偏向线程 ID 的]{.red}</p>
<ol>
<li><p>编写测试代码</p>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.bias&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadBias</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 内部类不再重复</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Bias bias = <span class="keyword">new</span> Bias(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 查看未上锁的对象的内存布局</span></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(bias).toPrintable());</span><br><span class="line">        <span class="comment">// 给对象上锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (bias)&#123;</span><br><span class="line">            <span class="comment">// 查看处于上锁的对象内存布局</span></span><br><span class="line">            log.debug(ClassLayout.parseInstance(bias).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看释放锁之后的对象内存布局</span></span><br><span class="line">        log.debug(ClassLayout.parseInstance(bias).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>测试结果：对象在被主线程上锁之后就将哈希值更新为偏向线程 ID + 偏向时间戳了</p>
 <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/偏向锁-3.3ud0j12nlto0.png" alt="偏向锁-3" style="zoom:80%;" /></li>
</ol>
</li>
</ul>

        <h3 id="撤销偏向"   >
          <a href="#撤销偏向" class="heading-link"><i class="fas fa-link"></i></a><a href="#撤销偏向" class="headerlink" title="撤销偏向"></a>撤销偏向</h3>
      <ul>
<li><p>原因：[存在其他线程尝试获取锁对象的时候，偏向锁就会被立刻撤销转变为轻量级锁]{.red}</p>
<ul>
<li>其他线程尝试获取锁对象可能是拥有线程没有使用锁对象的时候，也有可能恰好拥有线程正在使用锁对象</li>
<li>这两种情况的不同会导致虚拟机在撤销偏向时给定对象的锁状态的不同，前者更新为未上锁，后者就是轻量级锁</li>
</ul>
</li>
<li><p>撤销方式：</p>
<ul>
<li><p>[其余线程尝试获取锁对象，无论对象是否被拥有线程使用]{.red}</p>
<ul>
<li>细节：[这种撤销方式会导致偏向锁升级为轻量级锁]{.pink}</li>
</ul>
</li>
<li><p>[拥有线程调用计算哈希值的方法]{.red}</p>
<ul>
<li><p>细节：</p>
<ul>
<li>[这种撤销方式会导致偏向锁直接升级为重量级锁]{.pink}</li>
<li>[这个方法会自动禁用偏向锁，并且再也无法进入偏向锁状态]{.pink}</li>
</ul>
<p>  +++danger 为什么调用计算哈希值的方法会自动禁用偏向锁呢？</p>
<p>  ① 未上锁状态下的哈希值默认为 0，可以被偏向线程 ID + 偏向时间戳所替换</p>
<p>  ② 但是如果对象调用了计算哈希值的方法，为了保证哈希值一致性就必须将其存储在对象头中</p>
<p>  ③ 此时对象头就没有存储偏向线程 ID + 偏向时间戳的空间了，也就意味着无法进入偏向锁状态了</p>
<p>  +++</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>撤销过程：</p>
<ol>
<li>[Mark Word 记录的偏向模式标志位立刻变为 0]{.pink}</li>
<li>[如果锁对象正在被原拥有线程使用，那么等待使用结束之后就会先将锁状态标志位置为 01]{.pink}<ul>
<li>偏向锁状态 -&gt; 未上锁状态 -&gt; 轻量级锁状态 -&gt; 未上锁状态</li>
</ul>
</li>
<li>[如果锁对象没有被原拥有线程使用，那么其他线程可以立刻使用锁对象，并且将锁状态标志位置为 00]{.pink}<ul>
<li>偏向锁状态 -&gt; 轻量级锁状态 -&gt; 未上锁状态</li>
</ul>
</li>
</ol>
</li>
<li><p>测试其余线程访问造成的偏向撤销</p>
<ol>
<li>编写测试代码</li>
<li>测试结果</li>
</ol>
</li>
<li><p>测试哈希值撤销偏向锁</p>
<ol>
<li><p>编写测试代码</p>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.bias&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadBias</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Bias bias = <span class="keyword">new</span> Bias(<span class="number">10</span>);</span><br><span class="line">		<span class="comment">// 计算对象的哈希值</span></span><br><span class="line">        bias.hashCode();</span><br><span class="line">        <span class="comment">// 查看未上锁的对象的内存布局</span></span><br><span class="line">        log.debug(ClassLayout.parseInstance(bias).toPrintable());</span><br><span class="line">        <span class="keyword">synchronized</span> (bias)&#123;</span><br><span class="line">            <span class="comment">// 查看处于上锁的对象内存布局</span></span><br><span class="line">            log.debug(ClassLayout.parseInstance(bias).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看释放锁之后的对象内存布局</span></span><br><span class="line">        log.debug(ClassLayout.parseInstance(bias).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>测试结果</p>
 <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/偏向锁-4.7cae935ilg40.png" alt="偏向锁-4" style="zoom:80%;" /></li>
</ol>
</li>
</ul>

        <h3 id="批量重偏向"   >
          <a href="#批量重偏向" class="heading-link"><i class="fas fa-link"></i></a><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h3>
      <ul>
<li><p>定义：[偏向锁的撤销次数达到阈值之后，虚拟机会考虑重新将之后的对象重新偏向给其余的线程]{.red}</p>
<ul>
<li>[撤销次数达到阈值之前撤销的对象都从偏向锁升级为轻量级]{.pink}</li>
<li>[撤销次数达到阈值之后的对象都是直接偏向另一个线程而不会经历撤销的过程]{.pink}</li>
</ul>
</li>
<li><p>批量重偏向次数：</p>
<ul>
<li>默认阈值：[虚拟机默认批量重偏向的阈值是达到 20 次]{.red}</li>
<li>设置阈值：[-XX:BiasedLockingBulkRebiasThreshold=count]{.blue}</li>
<li>统计方式：[撤销次数不是统计 <strong>每个对象</strong> 发生了多少次撤销而是统计 <strong>整个进程</strong> 中发生了多少次撤销]{.red}</li>
</ul>
</li>
<li><p>测试批量重偏向机制</p>
<ol>
<li><p>编写测试代码</p>
<ul>
<li><p>主线程延迟启动确保能够开启偏向锁</p>
</li>
<li><p>第一个线程开始给对象添加偏向锁，然后将其添加到集合中，以便之后其他线程使用</p>
</li>
<li><p>第二个线程获取集合中的对象，就会造成偏向锁被撤销，在达到阈值之后开始批量重偏向</p>
</li>
</ul>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.rebias&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadReBias</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread t1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread t2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 确保偏向锁开启</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 存放对象的集合</span></span><br><span class="line">        List&lt;Inner&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 线程开始给对象加锁</span></span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 循环添加对象, 也就是添加偏向锁的过程</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">                Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">                <span class="keyword">synchronized</span> (inner) &#123;</span><br><span class="line">                    list.add(inner);</span><br><span class="line">                    <span class="comment">// 打印内存布局</span></span><br><span class="line">                    log.debug(temp + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(inner).toPrintable());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 尽可能使用同步工具确保第二个线程不会先于第一个线程执行, 最好不要使用睡眠方法</span></span><br><span class="line">            LockSupport.unpark(t2);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 等待一个线程执行结束</span></span><br><span class="line">            LockSupport.park();</span><br><span class="line">            log.debug(<span class="string">&quot;==============================开始撤销===================================&quot;</span>);</span><br><span class="line">            <span class="comment">// 循环添加对象, 也就是添加偏向锁的过程</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">                Inner inner = list.get(i - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (inner) &#123;</span><br><span class="line">                    <span class="comment">// 只打印加锁过程中的对象内存布局也是可以看出来的</span></span><br><span class="line">                    log.debug(temp + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(inner).toPrintable());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>测试结果</p>
<ul>
<li><p>[锁对象偏向线程-1]{.grey}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/偏向锁-5.762zbh2pxt40.png" alt="偏向锁-5" style="zoom:80%;" /></li>
<li><p>[虚拟机撤销偏向锁升级为轻量级锁]{.grey}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/偏向锁-6.125vu4fc1f7k.png" alt="偏向锁-6" style="zoom:80%;" /></li>
<li><p>[锁对象重偏向线程-2：]{.grey}</p>
<ul>
<li>[小细节：]{.grey}<ul>
<li>[实际撤销次数在达到 19 次的时候就会在下个对象身上立刻触发批量重偏向机制]{.grey}</li>
<li>[也就说批量重偏向的对象数量是 21 个，撤销的次数仅有 19 次]{.grey}</li>
</ul>
</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/偏向锁-7.5cn89see1xs0.png" alt="偏向锁-7" style="zoom:80%;" /></li>
</ul>
</li>
</ol>
</li>
</ul>

        <h3 id="批量撤销"   >
          <a href="#批量撤销" class="heading-link"><i class="fas fa-link"></i></a><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h3>
      <ul>
<li><p>定义：</p>
<ul>
<li>[偏向锁的撤销达到更大的阈值之后，虚拟机会认为根本就不应该重偏向]{.red}</li>
<li>[就会直接禁止 <strong>该类的实例</strong> 使用偏向锁（不是完全禁用偏向模式）]{.red}</li>
</ul>
</li>
<li><p>批量撤销阈值：</p>
<ul>
<li>默认值：[虚拟机默认批量撤销的阈值时 40 次]{.red}</li>
<li>设置阈值：[-XX:BiasedLockingBulkRevokeThreshold=count]{.blue}</li>
<li>细节：[在规定的时间范围内撤销次数没有达到阈值次时，虚拟机将会把撤销次数清零，重新统计]{.red}<ul>
<li>[-XX:BiasedLockingDecayTime=time：设置间隔时间]{.blue}</li>
</ul>
</li>
</ul>
</li>
<li><p>测试批量撤销机制</p>
<ol>
<li><p>编写测试代码：</p>
<ul>
<li><p>主线程延迟启动确保能够开启偏向锁</p>
</li>
<li><p>第一个线程开始给对象添加偏向锁，然后将其添加到集合中，以便之后其他线程使用</p>
</li>
<li><p>第二个线程获取集合中的对象，就会造成偏向锁被撤销，在达到阈值之后开始批量重偏向</p>
</li>
<li><p>第三个线程再次获取集合中的对象，对于前面已经被撤销偏向锁的对象就会直接使用，不会再次撤销</p>
</li>
<li><p>而对于重偏向到第二个线程的对象就会再次开始撤销</p>
</li>
</ul>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.rebias&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadReBias</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread t1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread t2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread t3;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 确保偏向锁开启</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 存放对象的集合</span></span><br><span class="line">        List&lt;Inner&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 线程开始给对象加锁</span></span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 循环添加对象, 也就是添加偏向锁的过程</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">                Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">                <span class="keyword">synchronized</span> (inner) &#123;</span><br><span class="line">                    list.add(inner);</span><br><span class="line">                    <span class="comment">// 打印内存布局</span></span><br><span class="line">                    log.debug(temp + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(inner).toPrintable());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.unpark(t2);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            log.debug(<span class="string">&quot;===============开始撤销===============&quot;</span>);</span><br><span class="line">            <span class="comment">// 循环添加对象, 也就是添加偏向锁的过程</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">                Inner inner = list.get(i - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (inner) &#123;</span><br><span class="line">                    <span class="comment">// 打印内存布局</span></span><br><span class="line">                    log.debug(temp + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(inner).toPrintable());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.unpark(t3);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        t3 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            <span class="comment">// 注意: 这里读者可以自行更改为39次和40次进行对比</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">20</span>)</span><br><span class="line">                    log.debug(<span class="string">&quot;===============开始撤销===============&quot;</span>);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">                Inner inner = list.get(i - <span class="number">1</span>);</span><br><span class="line">                log.debug(temp + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(inner).toPrintable());</span><br><span class="line">                <span class="keyword">synchronized</span> (inner)&#123;</span><br><span class="line">                    <span class="comment">// 打印内存布局</span></span><br><span class="line">                    log.debug(temp + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(inner).toPrintable());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">        t3.join();</span><br><span class="line">        log.debug(ClassLayout.parseInstance(<span class="keyword">new</span> Inner()).toPrintable());</span><br><span class="line">        log.debug(ClassLayout.parseInstance(<span class="keyword">new</span> Inner()).toPrintable());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>测试结果：前两个线程执行的逻辑和此前完全一样，因此从第三个线程开始分析</p>
<ul>
<li><p>[第三个线程开始从集合中取出对象，发现前 19 个线程已经被撤销偏向锁了，所以不需要再次撤销]{.grey}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/偏向锁-9.52k3eianqfs0.png" alt="偏向锁-9" style="zoom:80%;" /></li>
<li><p>[第三个线程在取出第 20 个元素的时候就会发现此后的对象都重偏向到第二个线程，所以又会开始撤销]{.grey}</p>
<ul>
<li>[其实撤销次数达到 39 次的时候，之后该类的实例就已经无法进入偏向模式了]{.grey}</li>
<li>[此前第二个线程已经撤销了 19 次对象的偏向锁，那第三个线程只要撤销 20 次就可以触发批量撤销]{.grey}</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/偏向锁-10.6wadqe6p7jw0.png" alt="偏向锁-10" style="zoom:80%;" /></li>
<li><p>[主线程创建对象并打印内存布局，该类的实例对象再也没有偏向模式]{.grey}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/偏向锁-8.1vx9rgct89eo.png" alt="偏向锁-8" style="zoom:80%;" />

</li>
</ul>
</li>
</ol>
</li>
</ul>

        <h2 id="自旋锁"   >
          <a href="#自旋锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2>
      <ul>
<li>历史：<ul>
<li>JDK 4 中就已经引入自旋锁机制，默认关闭自旋锁机制</li>
<li>JDK 6 中为自旋锁添加自适应机制，默认开启自旋锁机制</li>
<li>[-XX:+UseSpinning 开启自旋锁机制 / -XX:UseSpinning 关闭自旋锁机制]{.blue}</li>
</ul>
</li>
<li>定义：[线程尝试获取对象锁时发现已经被其他线程获取，此时 <strong>不进入阻塞队列等待而是不停地询问锁是否被释放</strong>]{.red}<ul>
<li>如果线程在不停询问的期间发现持有锁的线程释放了锁，那么就可以避免阻塞直接获取锁</li>
<li>如果线程直到询问期结束依然没有获取到锁，那么依然会进入阻塞队列中等待获取锁</li>
</ul>
</li>
<li>原因：<ul>
<li>重量级锁的机制会使得无法获取锁的线程进入阻塞队列中等待</li>
<li>[线程进入阻塞队列等待就必须执行上下文切换，内核线程上下文切换必须从用户态切换到内核态，开销很大]{.aqua}</li>
</ul>
</li>
<li>细节：<ul>
<li>[自旋锁机制只能够在线程可以并行的情况下采用，也就是只能够在多核处理下采用]{.red}<ul>
<li>如果是单核处理器，那么无论如何都会发生上下文切换，换上来的线程采用的自旋是毫无意义的，因为持有锁的线程已经被切换下去了，压根不可能在自旋期间获得锁</li>
<li>只有线程在两个处理器上，其中一个持有锁的线程在执行，另一个线程在自旋，这才是有意义的</li>
</ul>
</li>
<li>[自旋锁本质是忙等待，如果忙等待时间短那效果就会非常好，如果忙等待时间长那就会白白浪费处理器性能]{.red}<ul>
<li>[自旋的次数（询问的次数）默认值为十次：-XX:PreBlockSpin 可以自定义自旋的次数]{.pink}</li>
<li>[JDK 6 之后的自旋锁能够根据即时编译监控收集的信息自动调整自旋的次数，即自适应策略]{.pink}</li>
</ul>
</li>
<li>[自旋锁、轻量级锁、偏向锁这几个策略显然是无法一起使用的]{.pink}<ul>
<li>自旋锁的前提就已经是存在线程之间相互竞争锁了</li>
<li>轻量级锁、偏向锁这两个策略都是基于没有线程竞争的优化策略</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h2 id="锁消除"   >
          <a href="#锁消除" class="heading-link"><i class="fas fa-link"></i></a><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2>
      <ul>
<li><p>前言：Java 虚拟机中采用的同步消除优化策略也就是锁消除策略</p>
</li>
<li><p>定义：[如果虚拟机发现对不存在多线程竞争的资源进行了同步，那么虚拟机会直接消除同步代码块提高性能]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下列情况就是可以同步消除的情况</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 显然内部不存在使用共享变量或者引用对象逃逸的情况</span></span><br><span class="line">    <span class="comment">// 也就是不存在线程安全的情况, 虚拟机(即时编译器)会对其进行同步消除</span></span><br><span class="line"> 	<span class="keyword">int</span> first = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> second = <span class="number">20</span>;</span><br><span class="line">    System.out.println(first + second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>细节：[同步消除的目的不是为了消除你编写的同步代码而是为了 <strong>消除调用的方法中存在的同步代码</strong> ]{.red}</p>
<ul>
<li><p>演示案例：字符串拼接（《深入理解虚拟机》上的例子）</p>
<ul>
<li>[StringBuffer 是线程安全的类，而同步消除就会在拼接操作执行的时候消除这种不必要的同步]{.pink}</li>
<li>除此之外还有非常多的方法自身就涉及到了同步代码，即时编译器都会对他们进行消除</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String first, String second)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JDK 5 以前的方式, 字符串拼接操作会转换成 StringBuffer 进行拼接</span></span><br><span class="line"><span class="comment">// JDK 6 之后会采用 StringBuilder 进行拼接</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String first, String second)</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffe();</span><br><span class="line">    sb.append(first);</span><br><span class="line">    sb.append(second);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>锁消除证明测试</p>
<ol>
<li><p>引入 JMH 工具包</p>
 <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基准测试使用的包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></div></figure></li>
<li><p>编写测试代码</p>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试同步消除</span></span><br><span class="line"><span class="meta">@Fork(1)</span></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line"><span class="meta">@Warmup(iterations = 3)</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 5)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynElimination</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noSynchronizedMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">synchronizedMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            number++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>将项目模块打包后执行</p>
</li>
</ol>
</li>
</ul>

        <h2 id="锁粗化"   >
          <a href="#锁粗化" class="heading-link"><i class="fas fa-link"></i></a><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2>
      </div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/3/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/随机图库/1641882498931.3kditdl6ds40.webp" alt="avatar"></div><p class="sidebar-ov-author__text">什么都不会的废物</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/fuyusakaiori" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://weibo.com/Sakiless/home?topnav=1&amp;wvr=6" target="_blank" rel="noopener" data-popover="微博" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weibo"></i></span></a><a class="sidebar-ov-social-item" href="670232228" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">108</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">32</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-nd.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020~2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>小忍的甜甜圈</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1.0.1/dist/canvas-nest.min.js" color="0,0,0" opacity="0.6" count="99" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>