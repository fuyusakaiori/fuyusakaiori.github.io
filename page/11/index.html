<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="啥也不会的大三狗">
<meta property="og:type" content="website">
<meta property="og:title" content="天鹅绒房间">
<meta property="og:url" content="http://example.com/page/11/index.html">
<meta property="og:site_name" content="天鹅绒房间">
<meta property="og:description" content="啥也不会的大三狗">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Fuyusakaiori">
<meta name="twitter:card" content="summary"><title>天鹅绒房间</title><link ref="canonical" href="http://example.com/page/11/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">天鹅绒房间</div><div class="header-banner-info__subtitle">Velvet Room</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/07/java/interface/%E6%8E%A5%E5%8F%A3/">接口概述</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-07</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-09</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="抽象类"   >
          <a href="#抽象类" class="heading-link"><i class="fas fa-link"></i></a><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1>
      <blockquote>
<p><strong>什么是抽象类？</strong></p>
</blockquote>
<ul>
<li><p>定义：[拥有抽象方法的类或者说采用 abstract 关键字修饰的类]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义的抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义的抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>特点：</p>
<ul>
<li><p>[抽象类中并非所有方法都是抽象的]{.red}：</p>
<ul>
<li>[每个抽象类可以同时拥有具体实现方法和抽象方法]{.blue}</li>
<li>[每个继承抽象类的子类必须实现所有的抽象方法]{.blue}</li>
</ul>
</li>
<li><p>[抽象方法的访问权限不可以是私有的、也不可以是静态或者不可变的]{.red}：这几种情况都会导致子类无法重写或者说实现抽象方法</p>
</li>
<li><p>[抽象类中可以存在任意访问权限的成员变量]{.red}：拥有成员变量也就意味着拥有构造方法</p>
</li>
<li><p>[不可以利用 new 关键字直接创建抽象类实例]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种创建方式是错误的</span></span><br><span class="line">AbstractClass object = <span class="keyword">new</span> AbstractClass();</span><br><span class="line"><span class="comment">// 只能够将抽象类的引用指向具体的实现类来创建：SubClass 继承实现了抽象类</span></span><br><span class="line">AbstractClass object = <span class="keyword">new</span> SubClass();</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>为什么需要提供抽象类？为什么不直接提供一个实现了方法的父类呢？</strong></p>
</blockquote>
<ul>
<li><p>可以将不同的类中拥有相同的变量和方法抽取出来成为抽象类的属性，任何类需要拥有这些属性时只需要继承抽象类就行，[便于代码的继续进行扩展]{.blue}</p>
</li>
<li><p>设计系统架构时很难得知最终如何去实现这些功能，抽象类就能很好地帮助系统的架构设计，不需要提供任何实现，仅考虑需要提供什么，有利于程序架构设计以及之后的重构</p>
</li>
<li><p>普通父类中的所有方法都必须实现，之前提到的在设计系统架构时是很难得知最终如何实现这个方法</p>
</li>
</ul>
<p>:::info</p>
<p>总结：抽象类除了拥有抽象方法之外，其余和普通的类没有什么区别</p>
<p>:::</p>

        <h1 id="接口"   >
          <a href="#接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#接口" class="headerlink" title="接口"></a>接口</h1>
      
        <h2 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h2>
      <ul>
<li><p>定义：[没有具体实现和成员变量，而只是描述类应该完成的需求，没有具体的实现]{.red}</p>
</li>
<li><p>特点：</p>
<ul>
<li><p>[接口中所有方法都没有具体实现，都是公共的抽象方法]{.red}：实现类必须实现所有抽象方法</p>
<blockquote>
<p><code>Java 8</code> 新特性中接口也可以拥有实现的方法</p>
</blockquote>
</li>
<li><p>[接口和接口之间可以继承，类可以实现多个接口]{.red}</p>
<blockquote>
<p>接口继承接口采用的实现 <code>extends</code> 关键字而不是 <code>implements</code></p>
</blockquote>
</li>
<li><p>[接口中默认所有变量都是公共的静态常量]{.red}</p>
<blockquote>
<p>不能有成员变量，也不能有非公共的变量（<code>protected</code>、<code>private</code> 都不可以修饰接口中的变量）</p>
</blockquote>
</li>
<li><p>接口不能采用 <code>new</code> 创建对象仅可以创建接口引用，指向各个实现接口的类</p>
</li>
<li><p>[接口中可以嵌套定义接口，类中也可以嵌套定义接口，接口中也可以嵌套定义内部类（默认为静态内部类）]{.blue}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Walk</span></span>&#123;												<span class="comment">// 接口的定义</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Run</span> <span class="keyword">extends</span> <span class="title">Walk</span></span>&#123;									<span class="comment">// 接口继承接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Run</span>, <span class="title">Comparator</span>&lt;<span class="title">Animal</span>&gt;</span>&#123;			<span class="comment">// 类实现接口，多接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*初始化接口*/</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>新特性：（<code>Java 8</code>后新增加的特性）</p>
<ul>
<li><p>[接口中可以存在静态方法]{.red}</p>
<blockquote>
<p>通常仍然将这些方法放入伴生的工具类中（<code>Collection &amp; Collections</code>前者仍然只是提供抽象方法，后者提供具体方法）</p>
</blockquote>
</li>
<li><p><a style="color:red;">接口中可以存在默认的实现方法</a>：采用 <code>default</code> 关键字修饰；实现类可以重写默认方法可以不重写</p>
<p>  注：这两个新特性实际上是有违接口的设计初衷</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">defaultMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>细节：</p>
<p>  +++ 接口中定义一个默认实现方法，抽象类中也定义一个具有相同名称的实现方法，那么实现接口同时继承抽象类的类会选择哪个方法呢？</p>
<p>  [解决方式：抽象类中的方法将会覆盖其余接口中所有的同名方法，父类优先级最高]{.red}</p>
<p>  +++</p>
<p>  +++ 两个接口同时定义一个具有相同名称的默认实现方法，那么同时实现两个接口的实现类会选择哪个方法呢？</p>
<p>  [解决方式：编译器无法识别实现类到底继承哪个方法，需要实现类 <strong>重写该方法</strong> 从而覆盖两个接口的默认实现]{.red}</p>
<p>  +++</p>
<p>  +++ 一个接口中定义了一个默认的实现方法，另一个接口定义了一个同名的抽象方法，那么同时实现两个接口的类会继承默认的实现方法吗？</p>
<p>  [解决方式：编译器依然直接报错，仍然需要重写，<code>Java</code> 强调一致性，这种二义性依然需要程序员处理]{.red}</p>
<p>  +++</p>
<p>  +++ 两个接口同时定义了一个具有相同名称的抽象方法，那么同时实现两个接口的实现类不会有任何问题，只需要实现就行了</p>
<p>  +++</p>
<p>  +++ 抽象类实现接口，子类继承抽象类</p>
<ul>
<li>抽象类可以选择实现接口中的方法，也可以选择不实现交给继承的子类实现</li>
<li>子类必须实现没有被抽象类实现的方法，也可以选择覆写抽象类实现的方法</li>
</ul>
<p>  +++</p>
</li>
</ul>

        <h2 id="常用接口"   >
          <a href="#常用接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h2>
      
        <h3 id="比较接口"   >
          <a href="#比较接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#比较接口" class="headerlink" title="比较接口"></a>比较接口</h3>
      <ul>
<li><p><code>Comparable&lt;T&gt;</code>：该接口仅提供一个方法</p>
<ul>
<li><p>定义：[实现该接口的类的实例对象是可以相互进行比较的]{.blue}</p>
</li>
<li><p>规则：[泛型接口中传入的类必须是实现该接口的类]{.red}</p>
</li>
<li><p>细节：(1)<code>java.util</code> 包下的方法 (2) 函数式接口</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*接口定义*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*例子*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    ... <span class="comment">// 提供构造方法初始化成员变量</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">		<span class="comment">// 根据对象的年龄进行比较</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age &gt; person.age ? <span class="number">1</span> : (<span class="keyword">this</span>.age == person.age ? <span class="number">0</span> : -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    List&lt;MyClass&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Collections.addAll(list, <span class="keyword">new</span> MyClass(<span class="number">23</span>),</span><br><span class="line">                       <span class="keyword">new</span> MyClass(<span class="number">12</span>),</span><br><span class="line">                       <span class="keyword">new</span> MyClass(<span class="number">98</span>),</span><br><span class="line">                       <span class="keyword">new</span> MyClass(<span class="number">20</span>));</span><br><span class="line">    <span class="comment">// Collections 工具类就可以直接对这种可比较的对象进行排序</span></span><br><span class="line">    Collections.sort(list);															</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Collections sort 方法源码*/</span></span><br><span class="line"><span class="comment">// 如果链表中存放的对象本身就是可比较的那么就不需要传入比较器来比较对象了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">    list.sort(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p><code>Comparator&lt;T&gt;</code>：[该接口仅需要重写一个方法]{.red}，其余方法都是静态的或者默认实现的</p>
<ul>
<li><p>定义：[实现该接口的类是可以去比较其他类的]{.blue}，也就是说实现了该接口的类就是 [比较器]{.red}</p>
</li>
<li><p>要求：[泛型接口中传入的类可以不是实现该接口的类，可以是任何需要比较的类]{.red}</p>
</li>
<li><p>细节：(1) <code>java.lang</code> 包下的方法 (2) 函数式接口</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*接口定义*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*例子*/</span></span><br><span class="line"><span class="comment">// 被比较的类不需要实现任何接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;																			</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    ... <span class="comment">// 提供构造方法初始化成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*比较器：传入的类型就是需要比较的类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonComaprator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person person1, Person person2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person1.age &gt; person2.age ? <span class="number">1</span> : (person1.age == person2.age ? <span class="number">0</span> : -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    List&lt;MyClass&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Collections.addAll(list, <span class="keyword">new</span> MyClass(<span class="number">23</span>),</span><br><span class="line">                       <span class="keyword">new</span> MyClass(<span class="number">12</span>),</span><br><span class="line">                       <span class="keyword">new</span> MyClass(<span class="number">98</span>),</span><br><span class="line">                       <span class="keyword">new</span> MyClass(<span class="number">20</span>));</span><br><span class="line">    <span class="comment">// Collections 工具类就可以直接对这种可比较的对象进行排序</span></span><br><span class="line">    Collections.sort(list， <span class="keyword">new</span> PersonComparator());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Collections sort 方法源码*/</span></span><br><span class="line"><span class="comment">// 如果链表中存放的对象本身是不可比较的，那么就需要传入实现了 Comparator 接口的比较器来对链表元素进行比较</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    list.sort(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>

        <h3 id="克隆接口"   >
          <a href="#克隆接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#克隆接口" class="headerlink" title="克隆接口"></a>克隆接口</h3>
      <p>:::info</p>
<p>参考博客：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Qian123/p/5710533.html"><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/Qian123/p/5710533.html" >Java提高篇——对象克隆（复制）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></a></p>
<p>:::</p>
<blockquote>
<p><strong>什么是克隆？</strong></p>
</blockquote>
<ul>
<li><p>定义：简单来说就是 [复制]{.blue}，将一个变量的值赋给另一个变量</p>
</li>
<li><p>基本数据类型的克隆：[原变量发生变化不会影响到克隆变量的值，两者在栈中具有独立的空间]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 基本数据类型的克隆</span></span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> cloneNumber = number;</span><br><span class="line">    <span class="comment">// 修改原变量的值</span></span><br><span class="line">    number = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 查看两个的变量的值是否相同</span></span><br><span class="line">    System.out.println(number + <span class="string">&quot;\t&quot;</span> + cloneNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>引用类型的克隆：</p>
<ul>
<li><p>思考：引用对象是怎么进行克隆的呢？和基本数据类型相同吗？</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 引用类型的克隆</span></span><br><span class="line">    Student student1 = <span class="keyword">new</span> Student(<span class="number">12</span>, <span class="string">&quot;冬坂五百里&quot;</span>);</span><br><span class="line">    <span class="comment">// 尝试用基本数据类型的克隆方法来完成引用类型的克隆</span></span><br><span class="line">    Student student2 = student1;</span><br><span class="line">    <span class="comment">// 修改第二个对象的年龄</span></span><br><span class="line">    student2.age = <span class="number">24</span>;</span><br><span class="line">    <span class="comment">// 查看两个对象的年龄是否相同</span></span><br><span class="line">    System.out.println(student1.age);</span><br><span class="line">    System.out.println(student2.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>结果：[在我们修改了第二个对象的年龄之后发现两者的年龄居然相同，两者并没有在堆空间独立存在]{.green}</p>
</li>
<li><p>分析：这种方式只是将栈空间中的两个引用指向了堆空间中的同一个对象而已，并没有为克隆变量开辟新的堆空间</p>
<blockquote>
<p>利用 System.identityHashCode(); 方法可以计算对象在堆内存中的地址，结果一定是一样的</p>
</blockquote>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/引用类型.11b5vy5sxfr4.png" alt="引用类型" style="zoom:80%;" /></li>
<li><p>结论：显然这种克隆并不是我们真正想要的克隆方式，我们想要的显然是两个对象是完全独立的，相互不受影响的</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>如何实现克隆？</strong></p>
</blockquote>
<ul>
<li><p>前提：[经过前面的分析可以明确的是，克隆这种技术主要针对的是引用类型的对象，毕竟基础数据类型完全可以直接复制]{.red}</p>
</li>
<li><p>核心：</p>
<ul>
<li><p>[实现 Cloneable 接口，覆写 Object 类提供的 clone 方法后调用即可]{.red}</p>
<blockquote>
<p>Cloneable 接口是 [标志性]{.red} 接口，没有定义任何方法，实现该接口仅仅是标志当前对象可以被克隆</p>
</blockquote>
</li>
<li><p>源码</p>
<ul>
<li><p>[克隆的对象和原对象在堆中具有相互独立的空间，两者不会相互影响]{.red}</p>
</li>
<li><p>克隆的对象类型和原对象的类型相同，并不强制</p>
<blockquote>
<p>clone 方法返回的类型是 Object，可以根据自己的需要强制转换，所以可能出现和原对象类型不相同的情况</p>
</blockquote>
</li>
<li><p>克隆对象和原对象内容是相同的，前提是必须重写 <code>equals</code> 方法</p>
</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 源码中提到的注意事项</span></span><br><span class="line"><span class="comment">* x.clone() != x will be true</span></span><br><span class="line"><span class="comment">* x.clone().getClass() == x.getClass() will be true, but these are not absolute requirements.</span></span><br><span class="line"><span class="comment">* x.clone().equals(x) will be true, this is not an absolute requirement.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>浅克隆与深克隆：</p>
<ul>
<li><p>场景：类中不仅包含基本数据类型的成员变量，同时包含引用类型的成员变量</p>
</li>
<li><p>浅克隆：对象被复制时，仅复制基本数据类型的成员变量和引用类型的引用，[并不会复制引用类型拥有的成员变量]{.red}</p>
<blockquote>
<p>注：意味着只要修改引用类型拥有的成员变量就会导致克隆对象和原对象一起发生改变</p>
</blockquote>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/浅克隆.44pp8d02w0c0.png" alt="浅克隆" style="zoom:80%;" /></li>
<li><p>深克隆：对象被复制时，不仅复制基本数据类型的成员变量，[并且将引用类型拥有的成员变量一起复制]{.red}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/深克隆.6cph705nbow0.png" alt="深克隆" style="zoom:80%;" /></li>
</ul>
<p>  :::info</p>
<p>  简单了解区别之后，再来看这两者具体是怎么实现的，具体的演示也在后面</p>
<p>  :::</p>
</li>
<li><p>浅克隆</p>
<ul>
<li><p>特点：</p>
<ul>
<li>[Object 类默认提供的克隆方式就是浅克隆]{.red}</li>
<li>[不会复制引用类型拥有的成员变量，仅会复制引用类型的引用]{.red}</li>
</ul>
</li>
<li><p>实现：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 克隆的对象必须实现 Cloneable 接口并且重写 clone 方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 为了方便赋值就设为公共的属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age, String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Object 类中默认的克隆方式就是浅拷贝：不需要重写任何代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">    <span class="comment">// 浅克隆: 本质是创建新的对象并且将旧对象的值赋给新对象</span></span><br><span class="line">    Student old_student = <span class="keyword">new</span> Student(<span class="number">12</span>, <span class="string">&quot;冬坂五百里&quot;</span>);</span><br><span class="line">    Student new_student = (Student) old_student.clone();</span><br><span class="line">    <span class="comment">// 修改克隆对象的年龄</span></span><br><span class="line">    new_student.age = <span class="number">24</span>;</span><br><span class="line">    <span class="comment">// 测试两者的年龄是否相同：结果是显然不相同的</span></span><br><span class="line">    System.out.println(old_student.age);</span><br><span class="line">    System.out.println(new_student.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>深克隆</p>
<ul>
<li><p>手动实现：</p>
<ul>
<li><p>特点：</p>
<ul>
<li>[会将引用类型拥有的成员变量一起复制]{.red}</li>
<li>引用类型的成员变量也必须实现 Cloneable 接口并且重写 clone 方法</li>
</ul>
</li>
<li><p>实现：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">(String address)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 克隆的对象必须实现 Cloneable 接口并且重写 clone 方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age, String name, Address address)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Student student = (Student) <span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="comment">// 调用引用类型的成员变量后调用其相应的克隆方法: 手动克隆</span></span><br><span class="line">        student.address = (Address) address.clone();</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">错误测试：更改的是引用类型拥有成员变量而不是引用类型本身</span></span><br><span class="line"><span class="comment">new_student.address = new Address(&quot;中国&quot;)</span></span><br><span class="line"><span class="comment">这样修改就相当于修改了成员变量的引用，无论你是浅克隆还是深克隆，两个对象的地址肯定都是不一样的</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">    <span class="comment">// 手动实现深克隆：在克隆方法中继续调用引用类型的克隆方法就是手动实现</span></span><br><span class="line">    Student old_student = <span class="keyword">new</span> Student(<span class="number">12</span>, <span class="string">&quot;冬坂五百里&quot;</span>);</span><br><span class="line">    Address address = <span class="keyword">new</span> Address(<span class="string">&quot;日本&quot;</span>);</span><br><span class="line">    old_student.address = address;</span><br><span class="line">    Student new_student = (Student) old_student.clone();</span><br><span class="line">    <span class="comment">// 更改克隆对象的引用类型成员变量拥有的成员变量的值</span></span><br><span class="line">    address.address = <span class="string">&quot;中国&quot;</span>;</span><br><span class="line">    <span class="comment">// 测试两个对象的地址是否相同：结果肯定是不同的</span></span><br><span class="line">    System.out.println(old_student.address);</span><br><span class="line">    System.out.println(new_student.address);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>序列化实现</p>
<ul>
<li><p>场景：</p>
<ul>
<li>如果类中的引用类型的成员变量也拥有引用类型的成员变量，或者类中存在多个引用类型的成员变量</li>
<li>前者就需要在克隆方法中不断地嵌套调用克隆方法，后者则是需要同时调用多个克隆方法</li>
<li>这种情况被称作 [多层克隆]{.red}，显然手动实现克隆是非常麻烦的</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>[序列化实现深克隆就可以解决多层克隆这种情况]{.red}</li>
<li>[每个引用类型或者说类都需要实现序列化接口]{.red}</li>
</ul>
</li>
<li><p>实现</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span>  <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; students;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="comment">// 省略不重要的代码</span></span><br><span class="line">	... </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 序列化流</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 反序列化流</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 克隆对象</span></span><br><span class="line">        Teacher teacher = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            ByteArrayOutputStream bao = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="comment">// 将对象写入字节数组输出流中</span></span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(bao);</span><br><span class="line">            oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 从哪里读入数据: 从字节数组输出流中读取数据</span></span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bao.toByteArray()));</span><br><span class="line">            teacher = (Teacher) ois.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException | ClassNotFoundException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> teacher;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 序列化实现深克隆</span></span><br><span class="line">    List&lt;Student&gt; students = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Collections.addAll(students,<span class="keyword">new</span> Student(<span class="number">12</span>, <span class="string">&quot;学生1号&quot;</span>),</span><br><span class="line">                       <span class="keyword">new</span> Student(<span class="number">13</span>, <span class="string">&quot;学生2号&quot;</span>),</span><br><span class="line">                       <span class="keyword">new</span> Student(<span class="number">14</span>, <span class="string">&quot;学生2号&quot;</span>));</span><br><span class="line">    Teacher teacher = <span class="keyword">new</span> Teacher(<span class="number">24</span>, <span class="string">&quot;冬坂五百里&quot;</span>, students,<span class="keyword">new</span> Address(<span class="string">&quot;日本&quot;</span>));</span><br><span class="line">    Teacher clone_teacher = (Teacher) teacher.clone();</span><br><span class="line">    <span class="comment">// 修改克隆对象</span></span><br><span class="line">    clone_teacher.getAddress().setAddress(<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">    clone_teacher.getStudents().remove(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 测试两个对象的集合内容是否相同、以及地址是否相同</span></span><br><span class="line">    teacher.getStudents().forEach(System.out::println);</span><br><span class="line">    clone_teacher.getStudents().forEach(System.out::println);</span><br><span class="line">    System.out.println(teacher.getAddress());</span><br><span class="line">    System.out.println(clone_teacher.getAddress());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>为什么要使用克隆？为什么不直接创建新对象后挨个赋值呢？</strong></p>
</blockquote>
<ul>
<li>理由①：某些情况我们需要暂时保存当前对象的状态，确保我们在修改当前对象后依然能够得知其原有的状态</li>
<li>理由②：<ul>
<li><code>clone</code> 方法的默认实现是本地的，[效率显然会优于循环赋值]{.red}</li>
<li><code>clone</code> 能够简化循环赋值的过程，[代码更加简洁]{.red}</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>细节</strong></p>
</blockquote>
<ul>
<li>字符串对象实际上也是引用类型的对象，但是由于字符串对象具有 [不可变的特性]{.red}，</li>
<li>修改字符串内容实际上修改的是引用指向的内容，而不是在原有的基础上进行修改</li>
<li>所以在浅克隆中修改字符串对象不会导致克隆对象和原对象一起发生，原对象的引用依然指向原来的字符串内容，克隆对象的引用已经指向新的字符串内容了</li>
</ul>

        <h2 id="接口-vs-抽象类"   >
          <a href="#接口-vs-抽象类" class="heading-link"><i class="fas fa-link"></i></a><a href="#接口-vs-抽象类" class="headerlink" title="接口 vs 抽象类"></a>接口 vs 抽象类</h2>
      <div class="table-container"><table>
<thead>
<tr>
<th></th>
<th>接口</th>
<th>抽象类</th>
</tr>
</thead>
<tbody><tr>
<td>继承 &amp; 实现</td>
<td>可以实现多个接口</td>
<td>仅可以继承一个抽象类</td>
</tr>
<tr>
<td>方法</td>
<td>所有方法都是公共的抽象方法</td>
<td>既有抽象方法也有普通方法（[抽象方法默认包可见性]{.red}）</td>
</tr>
<tr>
<td>成员变量</td>
<td>仅拥有静态常量</td>
<td>任意类型成员变量</td>
</tr>
<tr>
<td>耦合度</td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table></div>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/08/20/design/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/">装饰器模式</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-08-20</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-08-20</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="装饰器模式"   >
          <a href="#装饰器模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1>
      <blockquote>
<p><strong>为什么设计装饰器模式</strong></p>
</blockquote>
<ul>
<li><p>核心：[装饰器模式是继承关系的一种替代方案：可以动态地扩展实现类的功能]{.red}</p>
</li>
<li><p>情景：</p>
<ul>
<li><p>经常游玩 <code>FPS</code> 类型游戏的玩家都知道枪械是会有各种配件的</p>
</li>
<li><p>如果不为枪械安装任何配件那么就只是一把最普通的枪，如果需要具有更多功能的枪械显然就需要安装更多的配件</p>
</li>
<li><p>现在将枪械和配件的关系抽象出来，<strong>最直接的解决方案就是继承</strong>：每个具有不同配件的枪械都是普通枪的子类，对普通枪进行扩展</p>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/06/6a1b1256badfadcf7b03d4ae0cb5fc29.png" alt="6a1b1256badfadcf7b03d4ae0cb5fc29.png" style="zoom: 67%;" /></li>
<li><p>继承关系可以在枪械和配件之间建立联系，同时也带来了相应的问题：</p>
<p>  (1) [子类数量会随着需求大量增长]{.red}：存在非常多的配件那么子类的数量就会爆炸</p>
<p>  (2) [难以满足复合的需求]{.red}：有些枪械既需要瞄准镜又需要垂直握把，显然继承关系就难以满足这种复合的需求</p>
</li>
<li><p>重新将枪械和配件的关系抽象出来，<strong>采用装饰器模式</strong>：将枪械的各个配件和普通的枪进行分离，需要什么配件就对普通的枪械进行装饰</p>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/06/1452502dbb05482503a68f7f1bb49d52.png" alt="1452502dbb05482503a68f7f1bb49d52.png" style="zoom:67%;" /></li>
<li><p>装饰器模式显然可以避免继承关系带来的子类数量爆炸的问题并且满足复合需求：[只需要利用组合关系就可以完成装饰器模式]{.red}</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>什么是装饰器模式</strong></p>
</blockquote>
<ul>
<li><p>定义：[<strong>动态地将责任分配到附加到对象上</strong>，如果需要扩展基类的功能，只需要利用组合就可以完成扩展]{.red}</p>
</li>
<li><p>细节：[每个基本类被多个装饰类修饰之后仍然是抽象类的实例]{.red}</p>
</li>
<li><p>优先 &amp; 缺点</p>
<ul>
<li>优点：[<strong>利用组合关系</strong>替代了继承关系显著降低了类与类之间的耦合度]{.red}：每个基本类和装饰类都是相互独立的，只在有需要的时候存在联系</li>
<li>缺点：[装饰类过多时容易造成代码阅读困难和排错困难]{.red}：装饰器模式创建对象通常采用嵌套的方式创建，所以看着会比较迷惑</li>
</ul>
</li>
<li><p>类图：</p>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/06/74690f6c1f6157a138932a9907105d79.png" alt="74690f6c1f6157a138932a9907105d79.png" style="zoom:67%;" /></li>
<li><p>实现：</p>
<ul>
<li><p><code>Component</code> 抽象类：提供该类型的类需要满足的最基本功能</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对应枪械例子中的枪模*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span></span>;    <span class="comment">// 枪械开火</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span></span>;  <span class="comment">// 枪械装弹</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p><code>ConcreteComponent</code>：具有基本功能的实现类（[可以提供多个不同实现的基本类]{.red}）</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对应枪械例子中的普通枪械*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开火...&quot;</span>);				<span class="comment">// 实现枪械最基本的功能：开火</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span></span>&#123;							<span class="comment">//  实现枪械最基本的功能：装弹</span></span><br><span class="line">        System.out.println(<span class="string">&quot;装弹...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p><code>Decorator</code>：装饰类通常 <strong>只是调用基本类</strong> 的方法并不会做进一步的扩展</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对应枪械例子中的配件类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decoration</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component = <span class="keyword">null</span>;			</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decoration</span><span class="params">(Component component)</span></span>&#123;			<span class="comment">// 利用组合获取到基本类</span></span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span></span>&#123;								<span class="comment">// 实现枪械最基本的功能但是不做任何扩展，只是调用基本类的方法</span></span><br><span class="line">        component.fire();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span></span>&#123;</span><br><span class="line">        component.reload();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p><code>ConcreteDecoretor</code>：可以拓展功能的具体装饰类</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorationB</span> <span class="keyword">extends</span> <span class="title">Decoration</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorationB</span><span class="params">(Component component)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;装备垂直握把...&quot;</span>);				<span class="comment">// 拓展的逻辑功能</span></span><br><span class="line">        <span class="keyword">super</span>.fire();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;装备垂直握把...&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.reload();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>创建具有装饰器的基本类</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*装饰器模式创建类通常都采用这种嵌套的写法：根据每个装饰器类的构造方法可以看出，每个装饰器类可以接着嵌套装饰器*/</span></span><br><span class="line">    Component component = <span class="keyword">new</span> ConcreteDecorationA(			<span class="comment">// 装备瞄准镜</span></span><br><span class="line">        				  <span class="keyword">new</span> ConcreteDecorationB(			<span class="comment">// 装备垂直握把</span></span><br><span class="line">                          <span class="keyword">new</span> ConcreteDecorationC(			<span class="comment">// 装备消音器</span></span><br><span class="line">                          <span class="keyword">new</span> ConcreteComponent())));		<span class="comment">// 最基本的类在最里面</span></span><br><span class="line">    component.fire();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>应用装饰器模式</strong></p>
</blockquote>
<ul>
<li><p>核心应用：[Java I/O 框架完全采用装饰器模式设计]{.red}</p>
</li>
<li><p>情景：</p>
<ul>
<li>每个输入源存放的数据类型可能各不相同：有些输入源提供的是字节流（<code>ByteArrayInputStream</code>），有些输入源提供的是文件（<code>FileInputStream</code>），这些都是<strong>基本类</strong></li>
<li>每个输入源在传输数据的过程中的要求也不尽相同：有些输入源可能要求提供缓冲区（<code>BufferedInputStream</code>），有些输入源可能要求提供类型转换的功能（<code>DataInputStream</code>），显然这些类就是 <strong>装饰类</strong></li>
<li>只需要将基本类和装饰类进行组合就可以得到满足要求的输入环境</li>
</ul>
</li>
<li><p>常用基本类：<code>ByteArrayInputStream</code>、<code>FileInputStream</code>、<code>PipeInputStream</code>、<code>SequenceInputStream</code></p>
</li>
<li><p>常用装饰类：<code>DataInputStream</code>、<code>BufferedInputStream</code>、<code>PushBackInputStream</code></p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* FilteInputStream 父装饰类具有成员变量 */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line"><span class="comment">/*构造方法：只需要传入进程了该抽象类的基本类或者装饰类即可*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">FilterInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.in = in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* FilteInputStream 装饰类没有对原有读取进行任何扩展*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> read(b, <span class="number">0</span>, b.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* BufferedStream 装饰类扩展：具有缓冲区*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &gt;= count) &#123;</span><br><span class="line">        fill();</span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= count)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getBufIfOpen()[pos++] &amp; <span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>创建被装饰器修饰的基本类对象</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建被装饰的基本类对象：被装饰的文件传输类就具有了缓冲区和转换数据类型的功能*/</span></span><br><span class="line">InputStream in = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">    <span class="keyword">new</span> DataInputStream(</span><br><span class="line">        <span class="keyword">new</span> FileInputStream(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></div></figure>

</li>
</ul>
<blockquote>
<p>参考博客：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/volcano-liu/p/10897897.html" >什么是装饰器模式？</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/08/20/java/io/%E5%BA%8F%E5%88%97%E5%8C%96/">序列化</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-08-20</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-08-20</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="序列化"   >
          <a href="#序列化" class="heading-link"><i class="fas fa-link"></i></a><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1>
      <blockquote>
<p><strong>什么是序列化和反序列化?</strong></p>
</blockquote>
<ul>
<li>序列化：[将类的实例对象转换成二进制字节序列的过程]{.red}</li>
<li>反序列化：根据二进制字节序列信息重新构建类的实例对象的过程</li>
</ul>
<blockquote>
<p><strong>为什么要使用序列化?</strong></p>
</blockquote>
<ul>
<li><p>核心：[不同的 Java 虚拟机之间共享实例对象的解决方案]{.red}</p>
</li>
<li><p>[持久化]{.pink}：对象的实例变量可以通过序列化成二进制字节序列长期保存在磁盘中，脱离进程独立存在</p>
</li>
<li><p>[网络传输]{.pink}：不同进程之间进行通信需要传输数据，只有二进制数据能够在网络中传输，对象想要在网络中传输必须被序列化</p>
<ul>
<li><code>Socket</code>：客户端和服务器之间进行通信</li>
<li><code>RMI</code> ：采用分布式架构的各个计算机之间进行通信</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li>通常建议所有类都实现序列化接口从而方便对象能够进行网络传输或者持久化存储</li>
<li>序列化核心目的是为了共享实例对象而不是为了持久化存储，毕竟持久化存储已经交给了数据库完成，所以如果你的程序不涉及网络那么序列化也就没什么用了</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>如何实现序列化?</strong></p>
</blockquote>
<ul>
<li><p>Serializable（[标志性接口]{.red}）</p>
<ul>
<li><p>持久化</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*实现接口*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="comment">/*序列化编号：后文将会提到它的作用*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">114514L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, String age, String gender)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*成员变量初始化...*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</span><br><span class="line">    <span class="comment">/*序列化目的：文件、网络、分布传输*/</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;files/person&quot;</span>);</span><br><span class="line">    <span class="comment">/*创建序列化输出流*/</span></span><br><span class="line">    ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">        <span class="keyword">new</span> FileOutputStream(</span><br><span class="line">            file));</span><br><span class="line">    <span class="comment">/*等待被序列化的对象*/</span></span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;24&quot;</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="comment">/*如果文件不存在就创建文件*/</span></span><br><span class="line">    <span class="keyword">if</span> (!file.exists())&#123;</span><br><span class="line">        file.createNewFile();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*调用序列化输出流将对象写入文件进行持久化保存*/</span></span><br><span class="line">    os.writeObject(person);</span><br><span class="line">    <span class="comment">/*关闭序列化输出流*/</span></span><br><span class="line">    os.close();</span><br><span class="line">	<span class="comment">/*创建序列化输入流*/</span></span><br><span class="line">    ObjectInputStream is = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">        <span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">    <span class="comment">/*需要进行强制类型转换才可以得到原对象*/</span></span><br><span class="line">    Person newPerson = (Person) is.readObject();</span><br><span class="line">    System.out.println(newPerson);</span><br><span class="line">    is.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>网络传输</p>
<blockquote>
<p>吐槽一句，明明序列化技术主要就是用于网络传输，但是为什么那么多讲序列化的博客都没有将网络传输作为例子讲呢？</p>
</blockquote>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*服务器和客户端进行交互的例子*/</span></span><br><span class="line"><span class="comment">/*需要发送的消息*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">114514L</span>;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> String date;</span><br><span class="line">    <span class="comment">/*类的其余方法不在此列出，不重要*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*服务器*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span></span>&#123;</span><br><span class="line">    <span class="comment">/*服务器端口号*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_SERVER_PORT = <span class="number">4396</span>;</span><br><span class="line">    <span class="comment">/*服务器端*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</span><br><span class="line">        <span class="comment">// 创建服务器处理请求的端口 Socket</span></span><br><span class="line">        ServerSocket server = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 服务器读取客户端传递的数据</span></span><br><span class="line">        ObjectInputStream reader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 服务器返回给客户端的数据</span></span><br><span class="line">        ObjectOutputStream writer = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        server = <span class="keyword">new</span> ServerSocket(DEFAULT_SERVER_PORT);</span><br><span class="line">        System.out.printf(<span class="string">&quot;服务器[%d]:%s\n&quot;</span>, DEFAULT_SERVER_PORT, <span class="string">&quot;启动完成...&quot;</span>);</span><br><span class="line">        <span class="comment">/*服务器始终运行*/</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            Socket client = server.accept();</span><br><span class="line">            System.out.printf(<span class="string">&quot;客户端[%d]:%s\n&quot;</span>, client.getPort(), <span class="string">&quot;建立连接&quot;</span>);</span><br><span class="line">            <span class="comment">/*传递的消息对象*/</span></span><br><span class="line">            Message message = <span class="keyword">null</span>;</span><br><span class="line">            reader = <span class="keyword">new</span> ObjectInputStream(client.getInputStream());</span><br><span class="line">            writer = <span class="keyword">new</span> ObjectOutputStream(client.getOutputStream());</span><br><span class="line">            <span class="comment">/*读出对象*/</span></span><br><span class="line">            <span class="keyword">while</span> ((message = (Message) reader.readObject()) != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 格式化输出客户端发送的消息</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;客户端[%d]:%s\n&quot;</span>, client.getPort(), message.getMessage() + <span class="string">&quot;\t&quot;</span> + message.getDate());</span><br><span class="line">                <span class="comment">// 向客户端写入对象</span></span><br><span class="line">                writer.writeObject(<span class="keyword">new</span> Message(<span class="string">&quot;服务器[&quot;</span> + DEFAULT_SERVER_PORT + <span class="string">&quot;]:处理完毕&quot;</span>));</span><br><span class="line">                <span class="comment">// 确保缓冲区中所有的内容都被推出: writer 关闭后会自动推出缓冲区中剩余的内容</span></span><br><span class="line">                writer.flush();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.printf(<span class="string">&quot;客户端[%d]:%s&quot;</span>, client.getPort(), <span class="string">&quot;退出连接&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*客户端*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SERVER_HOSTNAME = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_SERVER_PORT = <span class="number">4396</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXIT = <span class="string">&quot;退出&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 客户端访问服务器端口: 客户端的端口是操作系统随机分配的，不需要程序员决定，只需要指定访问哪个服务器端口</span></span><br><span class="line">        Socket server = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 客户端向服务器发送数据</span></span><br><span class="line">        ObjectOutputStream writer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 客户端接收服务器返回的数据</span></span><br><span class="line">        ObjectInputStream reader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 客户端输入需要发送的数据</span></span><br><span class="line">        BufferedReader consoleReader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">            <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                System.in));</span><br><span class="line"></span><br><span class="line">        server = <span class="keyword">new</span> Socket(DEFAULT_SERVER_HOSTNAME, DEFAULT_SERVER_PORT);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端启动成功...&quot;</span>);</span><br><span class="line">        Message message;</span><br><span class="line">        String string;</span><br><span class="line">        writer = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">            		<span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                		server.getOutputStream()));</span><br><span class="line">        <span class="keyword">while</span> (!EXIT.equals(string = consoleReader.readLine()))&#123;</span><br><span class="line">            <span class="comment">/*将控制台输入的字符串封装成对象发送给服务器*/</span></span><br><span class="line">            writer.writeObject(<span class="keyword">new</span> Message(string));</span><br><span class="line">            writer.flush();</span><br><span class="line">            <span class="comment">/*输入流只能够创建在循环内：原因不明*/</span></span><br><span class="line">            reader = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                    server.getInputStream()));</span><br><span class="line">            <span class="comment">/*读出服务器返回的消息对象*/</span></span><br><span class="line">            message = (Message)reader.readObject();</span><br><span class="line">            System.out.println(message.getMessage() + <span class="string">&quot;\t&quot;</span> + message.getDate());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>Externalizable（[需要实现两个方法]{.red}）</p>
<blockquote>
<p>(1) [Externalizable 序列化必须要提供 <strong>空参构造器</strong>]{.red}：否则抛出 java.io.InvalidClassException 异常</p>
<p>(2) Externalizable 序列化强制要求提供空参构造器是因为虚拟机在创建对象的时候采用 [反射机制]{.red} 会调用空参构造器创建对象，然后调用相应的 <code>readObject</code> 方法初始化成员变量</p>
</blockquote>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这里仅列举文件传输的例子不再使用网络传输列子*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Externalizable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">114514L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">	<span class="comment">/*空参构造器必须提供*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, String gender)</span></span>&#123;</span><br><span class="line">			...</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*必须实现以下两个方法*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">/*可以自行选择需要序列化的成员变量*/</span></span><br><span class="line">        out.writeObject(name);</span><br><span class="line">        out.writeObject(age);</span><br><span class="line">        out.writeObject(gender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</span><br><span class="line">        <span class="comment">/*需要按照序列化的顺序进行反序列化*/</span></span><br><span class="line">        <span class="keyword">this</span>.name = (String) in.readObject();</span><br><span class="line">        <span class="keyword">this</span>.age = (<span class="keyword">int</span>)in.readObject();</span><br><span class="line">        <span class="keyword">this</span>.gender = (String)in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;files/person.ser&quot;</span>);</span><br><span class="line">    ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">        <span class="keyword">new</span> FileOutputStream(</span><br><span class="line">            file));</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">24</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!file.exists())&#123;</span><br><span class="line">        file.createNewFile();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*Externalizable 序列化有两种方式使用：这两种方式都可以将对象序列化*/</span></span><br><span class="line">    <span class="comment">/*第一种方式：区别于 Serializable 接口：Externalizable 是对象调用自己的方法来进行序列化*/</span></span><br><span class="line">    person.writeExternal(os);</span><br><span class="line">    <span class="comment">/*第二种方式：采用和 Serializable 接口 一样的方式 */</span></span><br><span class="line">    os.writeObject(person);</span><br><span class="line">    os.close();</span><br><span class="line">	</span><br><span class="line">    ObjectInputStream is = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">        <span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">    <span class="comment">/*Externalizable 反序列化对应也有两种方式使用：这两种方式都可以将对象反序列化*/</span></span><br><span class="line">    <span class="comment">/*第一种方式：采用和 Serializable 接口一样的方式 */</span></span><br><span class="line">    os.readObject(person);</span><br><span class="line">    <span class="comment">/*第二种方式：需要先创建对象后再调用反序列化方法*/</span></span><br><span class="line">    Person newPerson = <span class="keyword">new</span> Person();</span><br><span class="line">    <span class="comment">/*区别于 Serializable 接口：Externalizable 是对象调用自己的方法来进行反序列化*/</span></span><br><span class="line">    newPerson.readExternal(is);</span><br><span class="line">    System.out.println(newPerson);</span><br><span class="line">    is.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>细节：</p>
<ul>
<li><p>[序列化技术仅会将 <strong>对象的成员变量</strong> 转换成字节序列，也就意味着 <strong>静态变量和方法</strong> 都是不会被序列化的]{.red}</p>
<p>  从定义中也可以看出，毕竟序列化的是实例对象，显然静态属性不属于对象</p>
</li>
<li><p>[如果同时实现 Externalizable 和 Serializable 接口会导致 Serializable 接口直接失效]{.red}</p>
</li>
</ul>
</li>
<li><p>区别：[通常仍然采用 Serializable 接口进行序列化]{.red}</p>
<ul>
<li>Externalizable 性能相对较好；Serializable 性能相对较差</li>
<li>Externalizable 可以 [选择性序列化成员变量]{.red} 并且可以 [定制序列化方式]{.red}；Serializable [默认序列化所有成员变量]{.red}</li>
<li>Externalizable 必须实现两个方法（[实现繁琐]{.red}）；Serializable 是标志性接口不需要实现任何方法（[实现简单]{.red}）</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>序列化如何实现的?</strong></p>
</blockquote>
<img src="https://i1.xpic.jp/file/xpicjp/2021/08/15/1af32568725763ed6be092c20fe49bfc.png" alt="1af32568725763ed6be092c20fe49bfc.png" style="zoom:80%;" />

<ul>
<li><p>ObjectStreamClass 类：保存对象对应的 <strong>Class 对象</strong> 以及对象所有 <strong>成员变量的数据信息</strong></p>
<blockquote>
<p>官方文档描述：用于描述类的描述符，主要包含类的名称和类的版本号（serialVersionUID），可以调用自身的 <code>lookup</code> 方法并且利用自身的信息构建对象 </p>
</blockquote>
</li>
<li><p>序列化原理</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject0</span><span class="params">(Object obj, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 构建相关对象之前需要完成的相关检查事项</span></span><br><span class="line">            <span class="keyword">int</span> h;</span><br><span class="line">            <span class="keyword">if</span> ((obj = subs.lookup(obj)) == <span class="keyword">null</span>) &#123;								<span class="comment">// 检查当前对象是否为：调用 writeNull 方法后返回</span></span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;			<span class="comment">// 检查当前对象是否已经被序列化过：调用 writeHandle 方法后返回</span></span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;									<span class="comment">// 检查当前对象是否为 Class 对象：调用 writeClass 方法后返回</span></span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;						<span class="comment">// 检查当前对象是否为 ObjectStreamClass 对象 writeClassDesc 方法后返回</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Object orig = obj;</span><br><span class="line">            Class&lt;?&gt; cl = obj.getClass();										<span class="comment">// 获取当前对象的 Class 对象信息</span></span><br><span class="line">            ObjectStreamClass desc;					</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Class&lt;?&gt; repCl;</span><br><span class="line">                desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);						<span class="comment">// 利用当前对象的 Class 对象构建 ObjectStreamClass 对象</span></span><br><span class="line">                <span class="keyword">if</span> (!desc.hasWriteReplaceMethod() ||							<span class="comment">// 利用 ObjectStreamClass 对象判断该对象是否可以序列化</span></span><br><span class="line">                    (obj = desc.invokeWriteReplace(obj)) == <span class="keyword">null</span> ||				<span class="comment">// 接着判断 ObjectStreamClass 对象是否和具体的对象关联</span></span><br><span class="line">                    (repCl = obj.getClass()) == cl)								<span class="comment">// 最后判断 ObjectStreamClass 对象关联的对象是否和我们传入的对象为同一个</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cl = repCl;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;										<span class="comment">// 字符串类型有相应的序列化方法可以直接被序列化</span></span><br><span class="line">                    writeString((String) obj, unshared);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;											<span class="comment">// 数组类型有相应的序列化方法可以直接被序列化</span></span><br><span class="line">                    writeArray(obj, desc, unshared);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;									<span class="comment">// 枚举类型有相应的序列化方法可以直接被序列化</span></span><br><span class="line">                    writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;							<span class="comment">// 实现了 Serializable 接口的自定义类</span></span><br><span class="line">                    writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeOrdinaryObject</span><span class="params">(Object obj, ObjectStreamClass desc, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            desc.checkSerialize();</span><br><span class="line">            bout.writeByte(TC_OBJECT);													<span class="comment">// 先向文件中写入提示信息：表示这是一个新的对象</span></span><br><span class="line">            writeClassDesc(desc, <span class="keyword">false</span>);												<span class="comment">// 写入所有成员变量的类型信息</span></span><br><span class="line">            handles.assign(unshared ? <span class="keyword">null</span> : obj);</span><br><span class="line">            <span class="keyword">if</span> (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123;</span><br><span class="line">                writeExternalData((Externalizable) obj);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;																	<span class="comment">// 写入所有成员变量对应的实际数据信息</span></span><br><span class="line">                writeSerialData(obj, desc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeClassDesc</span><span class="params">(ObjectStreamClass desc, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> handle;</span><br><span class="line">    <span class="keyword">if</span> (desc == <span class="keyword">null</span>) &#123;																	<span class="comment">// 检查 ObjectStreamClass 对象是否为空</span></span><br><span class="line">        writeNull();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (handle = handles.lookup(desc)) != -<span class="number">1</span>) &#123;					<span class="comment">// 检查 ObjectStreamClass 对象是否已经存在</span></span><br><span class="line">        writeHandle(handle);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (desc.isProxy()) &#123;														<span class="comment">// ObjectStreamClass 对象是否为动态代理类</span></span><br><span class="line">        writeProxyDesc(desc, unshared);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;																			<span class="comment">// 通常会走这个方法</span></span><br><span class="line">        writeNonProxyDesc(desc, unshared);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeNonProxyDesc</span><span class="params">(ObjectStreamClass desc, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bout.writeByte(TC_CLASSDESC);</span><br><span class="line">    handles.assign(unshared ? <span class="keyword">null</span> : desc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (protocol == PROTOCOL_VERSION_1) &#123;</span><br><span class="line">        desc.writeNonProxy(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        writeClassDescriptor(desc);													<span class="comment">// 进入这个方法</span></span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">    writeClassDesc(desc.getSuperDesc(), <span class="keyword">false</span>);										<span class="comment">// 子类序列化结束之后就会序列化父类：前提是父类可以序列化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeNonProxy</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    out.writeUTF(name);																	<span class="comment">// 写入类的名称</span></span><br><span class="line">    out.writeLong(getSerialVersionUID());												<span class="comment">// 写入序列化版本号：虽然序列化版本号是静态的，但是依然可以写入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span> flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (externalizable) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serializable) &#123;</span><br><span class="line">        flags |= ObjectStreamConstants.SC_SERIALIZABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">        out.writeByte(flags);																<span class="comment">// 写入相关信息</span></span><br><span class="line"></span><br><span class="line">    out.writeShort(fields.length);														<span class="comment">// 写入成员变量的数量											</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;											<span class="comment">// 循环写入成员变量的类型信息</span></span><br><span class="line">        ObjectStreamField f = fields[i];</span><br><span class="line">        out.writeByte(f.getTypeCode());</span><br><span class="line">        out.writeUTF(f.getName());</span><br><span class="line">        <span class="keyword">if</span> (!f.isPrimitive()) &#123;</span><br><span class="line">            out.writeTypeString(f.getTypeString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>反序列化原理</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">	</span><br></pre></td></tr></table></div></figure>

</li>
</ul>
<blockquote>
<p><strong>序列化细节</strong></p>
</blockquote>
<ul>
<li><p>transient（瞬时的）</p>
<ul>
<li>定义：[transient 关键字修饰的成员变量不会被序列化]{.red}：反序列化创建对象时该属性就会为默认值</li>
<li>目的：① 某些数据传输过程是不安全的所以避免序列化 ② 某些对象就是没有序列化的必要（Socket、Thread之类的）</li>
</ul>
</li>
<li><p>serialVersionUID（版本号）：</p>
<ul>
<li><p>定义：每个类、Class 对象、ObjectStreamClass 对象、序列化文件都具有的版本号</p>
</li>
<li><p>目的：[保证虚拟机的反序列化过程能够成功]{.red}</p>
</li>
<li><p>生成方式</p>
<ul>
<li><p>虚拟机默认生成：[虚拟机根据对象的实际信息计算出相应的版本号]{.red}，也就意味着只要对象发生“变化”版本号就很有可能一起变化，最终导致反序列化失败</p>
<blockquote>
<p>解释：也就意味着可能你修改了类中的信息，但是别人没有修改，导致你传输过去的版本号和别人的版本号不一致，最终是不可能反序列化成功的</p>
</blockquote>
</li>
<li><p>显示指定：[版本号必须为私有静态常量]{.red}（推荐使用这种方法）</p>
</li>
</ul>
</li>
<li><p>检验过程：</p>
<ul>
<li>从序列化文件中获取类的名字</li>
<li>调用 <code>Class.forname(name)</code> 后获取到类对应的 Class 对象</li>
<li>利用 Class 对象生成 ObjectStreamClass 对象</li>
<li>利用 ObjectStreamClass 对象创建类的对象</li>
</ul>
</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*源码：检查是否一致*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initNonProxy</span><span class="params">(ObjectStreamClass model, Class&lt;?&gt; cl, ClassNotFoundException resolveEx, ObjectStreamClass superDesc)</span> <span class="keyword">throws</span> InvalidClassException</span>&#123;</span><br><span class="line">    <span class="keyword">long</span> suid = Long.valueOf(model.getSerialVersionUID());</span><br><span class="line">    ObjectStreamClass osc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 利用 Class 对象获取到相应的 ObjectStreamClass 对象</span></span><br><span class="line">        osc = lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (model.serializable == osc.serializable &amp;&amp;</span><br><span class="line">            !cl.isArray() &amp;&amp;</span><br><span class="line">            <span class="comment">// 检查从序列化文件中读出的版本号是否和当前查询到的版本号一致：如果不一致将会抛出异常</span></span><br><span class="line">            suid != osc.getSerialVersionUID()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>多次序列化同一个对象：</p>
<ul>
<li><p>核心：</p>
<ul>
<li>[序列化过程中会检查该对象是否已经被序列化过]{.red}</li>
<li>如果对象已经被序列化过，那么只会向流中写入一些提示信息，<strong>序列化文件不会做任何改变</strong></li>
</ul>
</li>
<li><p>细节：对象被序列化和对象内容被修改是两件事情，如果此前已经序列化过该对象，后来修改对象内容后再次序列化是不会成功的，序列化文件保存的仍然是之前的信息</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*例子*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;files/person.ser&quot;</span>);</span><br><span class="line">    ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">        <span class="keyword">new</span> FileOutputStream(</span><br><span class="line">            file));</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">24</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!file.exists())&#123;</span><br><span class="line">        file.createNewFile();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*第一次序列化对象*/</span></span><br><span class="line">    os.writeObject(getPerson(person));</span><br><span class="line">    <span class="comment">/*修改对象后第二次序列化对象*/</span></span><br><span class="line">    person.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    os.writeObject(getPerson(person));</span><br><span class="line">    os.close();</span><br><span class="line"></span><br><span class="line">    ObjectInputStream is = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">        <span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">    <span class="comment">/*最后反序列化对象时会发现内容没有任何改变*/</span></span><br><span class="line">    Person newPerson = getPerson((Person) is.readObject());</span><br><span class="line">    System.out.println(newPerson);</span><br><span class="line">    is.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*源码*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject0</span><span class="params">(Object obj, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// handle previously written and non-replaceable objects</span></span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">if</span> ((obj = subs.lookup(obj)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">                <span class="comment">/*注意这个分支就是判断当前对象是否序列化过*/</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/*lookup 方法就是查找当前对象被序列化：如果已经被序列化就会进入分支，如果没有就会继续执行后续方法*/</span></span><br><span class="line">            writeHandle(h);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*向流中写入提示信息*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeHandle</span><span class="params">(<span class="keyword">int</span> handle)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 第一个信息是该对象已经存在的信息，第二个信息不知道是什么</span></span><br><span class="line">    bout.writeByte(TC_REFERENCE);</span><br><span class="line">    bout.writeInt(baseWireHandle + handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>组合和继承中的序列化</p>
<ul>
<li><p>组合中的序列化：可序列化的类中拥有 [引用类型]{.red} 的成员变量，[该引用类型必须实现序列化接口，否则会导致整个对象都无法被序列化]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*例子*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="comment">/*该类没有实现序列化的任何接口*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="comment">/*作为成员变量在其他可序列化的类中出现*/</span></span><br><span class="line">    <span class="comment">/*该类最终无法被实例化*/</span></span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*源码*/</span></span><br></pre></td></tr></table></div></figure></li>
<li><p>继承中的序列化</p>
<ul>
<li>[如果父类已经实现序列化接口，那么子类同样可以被序列化]{.red}</li>
<li>如果子类实现序列化接口，那么父类是不可以被序列化的</li>
</ul>
</li>
</ul>
</li>
<li><p>反序列化构造对象</p>
<ul>
<li>不存在继承关系时：利用 Class 对象 + ObjectStreamClass 对象（[反射机制]{.red}）构造的对象而 <strong>不会调用构造方法创建的对象</strong></li>
<li>存在继承关系时：<ul>
<li>子类和父类都可以被序列化时：根据之前序列化的原理，显然子类和父类的信息都会被存储在序列化文件中，所有反序列化构造对象时两者都不会走构造方法</li>
<li>子类可以序列化但是父类不能序列化时：反射构建子类的过程中同样需要初始化父类，所以显然会调用构造方法</li>
</ul>
</li>
</ul>
</li>
<li><p>自定义序列化：</p>
<ul>
<li><p>方式：重写 <code>writeObject &amp; readObject</code> 方法</p>
</li>
<li><p>目的：[可能需要对该成员变量进行加密或者其他处理后再序列化]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">114514L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="comment">/*ArrayList 源码中就采用这种设计方式*/</span></span><br><span class="line">    <span class="comment">/*我们不想要序列化整个数组，因为数组中的空间并不会被全部使用，我们只希望序列化数组中的有效元素*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] elements;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, String gender, <span class="keyword">int</span>[] elements)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*自定义序列化必须重写两个方法：writeObject、readObject*/</span></span><br><span class="line">    <span class="comment">/*自定义序列化如果采用了某种规则那么反序列化时也需要采用相反的那种规则*/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/*反转字符串*/</span></span><br><span class="line">        out.writeObject(<span class="keyword">new</span> StringBuffer(<span class="keyword">this</span>.name).reverse().toString());</span><br><span class="line">        out.writeObject(age);</span><br><span class="line">        out.writeObject(gender);</span><br><span class="line">        <span class="comment">/*我们只想序列化不为 0 的元素*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;elements.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(elements[i]!=<span class="number">0</span>)</span><br><span class="line">            out.writeObject(elements[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/*需要再次反转回来*/</span></span><br><span class="line">        <span class="keyword">this</span>.name = <span class="keyword">new</span> StringBuffer((String) in.readObject()).reverse().toString();</span><br><span class="line">        <span class="keyword">this</span>.age = (<span class="keyword">int</span>) in.readObject();</span><br><span class="line">        <span class="keyword">this</span>.gender = (String) in.readObject();</span><br><span class="line">        <span class="comment">/*只需要填充就行了*/</span></span><br><span class="line">        <span class="keyword">this</span>.elements = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>)in.readOnject()]			<span class="comment">// 通常数组的长度也需要被序列化进去否则反序列化会不知道数组有多少元素，导致抛出异常</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">            <span class="keyword">this</span>.elements[i] = (<span class="keyword">int</span>[]) in.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/08/19/java/io/IO/">IO</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-08-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-14</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="IO"   >
          <a href="#IO" class="heading-link"><i class="fas fa-link"></i></a><a href="#IO" class="headerlink" title="IO"></a>IO</h1>
      
        <h2 id="流"   >
          <a href="#流" class="heading-link"><i class="fas fa-link"></i></a><a href="#流" class="headerlink" title="流"></a>流</h2>
      <ul>
<li><p>定义：[流是一组有 <strong>顺序的，单向的，动态</strong> 的字符或者字节的集合]{.red}</p>
<blockquote>
<p>《Java 编程思想》定义：流代表了任何有能力产出数据的 <strong>数据源对象</strong> 或者是有能力接收数据的 <strong>接收端对象</strong>（流为什么会是一种对象呢?）</p>
</blockquote>
</li>
<li><p>核心：[屏蔽输入输出设备实际处理数据的细节]{.red}</p>
<blockquote>
<p>理解：就是不需要手动创建缓冲区等结构去处理数据，只需要创建流对象就可以帮助我们完成数据的传输</p>
</blockquote>
</li>
<li><p>分类：</p>
<ul>
<li><p>按照流向分类：输入流和输出流</p>
<ul>
<li><p>核心：[输入输出流的名称都是相对而言的]{.red}</p>
</li>
<li><p>输入流：从数据输入源流向数据接收源（外部设备数据流向内存）</p>
</li>
<li><p>输出流：从数据接收源流向数据接收源（内存数据流向外部设备）</p>
</li>
</ul>
</li>
<li><p>按照功能分类：节点流（基本类）和处理流（装饰类）</p>
<ul>
<li><p>核心：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://fuyusakaiori.github.io/design/装饰器模式" >设计模式：装饰器模式</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>（<code>Java I/O</code> 就是围绕装饰器模式进行设计的）</p>
</li>
<li><p>节点类：进行最基本的数据传输功能的类：<code>CharArrayReader、ByteArrayReader...</code></p>
</li>
<li><p>处理类：扩展数据传输功能的类：<code>BufferedReader...</code></p>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/15/a6e24a137dc7e2736fed6d47cbe26246.png" alt="a6e24a137dc7e2736fed6d47cbe26246.png" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>按照数据单位分类：字节流和字符流</p>
<ul>
<li><p>字节流：[可以读取任何类型的文件]{.red}，主要用于读取二进制文件（图片、视频文件等）：<code>InputStream、OutputStream..</code></p>
</li>
<li><p>字符流：[仅能够读取文本文件]{.red}：<code>Reader、Writer...</code></p>
</li>
<li><p>细节：</p>
<ul>
<li><p>[设计之初时字节流是没有自带缓冲区的，后续添加的字符流就默认携带缓冲区]{.red}</p>
</li>
<li><p><code>JVM</code> 内部运行采用 <code>UTF-16BE</code> 编码，<code>class</code> 文件采用 <code>UTF-8</code> 编码，<code>Java</code> 源代码可以采用任何形式编码</p>
<blockquote>
<p>注：<code>JVM</code> 内部和 <code>class</code> 文件采用的编码并不相同，也就意味着中间会发生转换</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h2 id="核心类"   >
          <a href="#核心类" class="heading-link"><i class="fas fa-link"></i></a><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2>
      
        <h3 id="文件类"   >
          <a href="#文件类" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件类" class="headerlink" title="文件类"></a>文件类</h3>
      <p>:::info</p>
<ul>
<li>文件工具类在 JDK 1.7 之后又进行了更新 -&gt; 提供了更加方便的方法</li>
<li>实际开发中已经很少直接操作文件了，通常借助数据库管理文件</li>
</ul>
<p>:::</p>
<ul>
<li><p>定义：提供操作文件相关的方法，[不包含读取和写入文件内容的操作]{.red}</p>
</li>
<li><p>特点：文件类既可以表示文件也可以表示目录</p>
</li>
<li><p>继承 &amp; 实现：</p>
<ul>
<li>实现 <code>Serializable</code> 接口：文件类可以进行序列化操作</li>
<li>实现 <code>Comparable</code> 接口：文件类可以相互比较</li>
</ul>
</li>
<li><p>构造方法：[只有有参构造器没有无参构造器]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*最常使用的构造方法：传入文件的路径名称*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String pathname)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果传入的路径是空才会报错，如果传入的路径是错误的是不会抛出异常的</span></span><br><span class="line">    <span class="keyword">if</span> (pathname == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*第一个参数传入父目录，第二个参数传入子目录*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String parent, String child)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">/*传入文件的 URI 地址*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(URI uri)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>方法</p>
<ul>
<li><p>创建文件、目录、删除文件、目录</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建文件</span></span><br><span class="line">    file.createNewFile();</span><br><span class="line">    <span class="comment">// 单级目录</span></span><br><span class="line">    File directory = <span class="keyword">new</span> File(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建单级目录</span></span><br><span class="line">    directory.mkdir();</span><br><span class="line">    <span class="comment">// 多级目录</span></span><br><span class="line">    File directories = <span class="keyword">new</span> File(<span class="string">&quot;first/second&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建多级目录</span></span><br><span class="line">    directories.mkdirs();</span><br><span class="line">    <span class="comment">// 删除文件或者目录</span></span><br><span class="line">    file.delete();</span><br><span class="line">    directory.delete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>判断路径表示的是文件还是目录</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">judge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 判断路径表示文件或者目录是否存在</span></span><br><span class="line">    file.exists();</span><br><span class="line">    <span class="comment">// 判断是否是文件</span></span><br><span class="line">    file.isFile();</span><br><span class="line">    <span class="comment">// 判断是否为目录</span></span><br><span class="line">    file.isDirectory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>获取表示文件或者目录的路径</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getPath</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    File directory = <span class="keyword">new</span> File(<span class="string">&quot;D:\\JavaWeb\\Java 网络编程\\src\\main\\java\\myio&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取路径表示的目录或者文件名称</span></span><br><span class="line">    directory.getName();</span><br><span class="line">    <span class="comment">// 获取该目录或者文件的父路径</span></span><br><span class="line">    directory.getParent();</span><br><span class="line">    <span class="comment">// 获取绝对路径</span></span><br><span class="line">    directory.getAbsolutePath();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>遍历目录</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listFile</span><span class="params">(File directory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果文件不存在就创建目录</span></span><br><span class="line">    <span class="keyword">if</span> (!directory.exists())</span><br><span class="line">        directory.mkdir();</span><br><span class="line">    <span class="comment">// 如果不是目录就直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!directory.isDirectory())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;这不是目录!&quot;</span>);</span><br><span class="line">    String[] files = directory.list();</span><br><span class="line">    <span class="keyword">for</span> (String file : files)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子路径: &quot;</span> + file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listFileByRecursive</span><span class="params">(File directory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果文件不存在就创建目录</span></span><br><span class="line">    <span class="keyword">if</span> (!directory.exists())</span><br><span class="line">        directory.mkdir();</span><br><span class="line">    <span class="comment">// 如果传入的是文件就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (directory.isFile())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    File[] files = directory.listFiles();</span><br><span class="line">    <span class="keyword">for</span> (File file : files)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (directory.isDirectory())</span><br><span class="line">            listFileByRecursive(file);</span><br><span class="line">        System.out.println(<span class="string">&quot;父路径: &quot;</span> + file.getParent() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;子路径： &quot;</span> + file.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;绝对路径: &quot;</span> + file.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>

        <h3 id="网络类"   >
          <a href="#网络类" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络类" class="headerlink" title="网络类"></a>网络类</h3>
      <blockquote>
<p><strong>InetSocketAddress 类</strong></p>
</blockquote>
<ul>
<li><p>定义：用于表示套接字的类</p>
<p>  [注：Socket 类构造方法内部就是创建了 InetSocketAddress 对象，所以也表示套接字]{.blue}</p>
</li>
<li><p>构造方法</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器常调用的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InetSocketAddress</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(InetAddress.anyLocalAddress(), port);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 客户端常调用的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InetSocketAddress</span><span class="params">(String hostname, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    checkHost(hostname);</span><br><span class="line">    InetAddress addr = <span class="keyword">null</span>;</span><br><span class="line">    String host = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        addr = InetAddress.getByName(hostname);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(UnknownHostException e) &#123;</span><br><span class="line">        host = hostname;</span><br><span class="line">    &#125;</span><br><span class="line">    holder = <span class="keyword">new</span> InetSocketAddressHolder(host, addr, checkPort(port));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
<blockquote>
<p><strong>URL 类</strong></p>
</blockquote>
<ul>
<li><p>定义：表示统一资源定位符，也就是表示某个网页的资源</p>
</li>
<li><p>构造方法</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅指定 URL 地址</span></span><br><span class="line"><span class="comment">// 不指定端口号时，访问该网址的时候使用默认端口号，但是调用获取端口号的方法时就会返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URL</span><span class="params">(String spec)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, spec);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 访问的 URL 采用的协议、IP 地址、端口号、需要获取的资源的地址</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URL</span><span class="params">(String protocol, String host, <span class="keyword">int</span> port, String file)</span> <span class="keyword">throws</span> MalformedURLException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(protocol, host, port, file, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>方法</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取该 URL 携带的查询参数：? 之后表示的就是携带的参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getQuery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> query;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取该 URL 的端口号：如果没有指定就会返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> port;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取 URL 采用的协议</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> protocol;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取该 URL 的流对象：可以借助流对象传输 URL 表示的资源信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> InputStream <span class="title">openStream</span><span class="params">()</span> <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> openConnection().getInputStream();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取该 URL 表示的内容：实际获取的是网页的源代码（前端）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">getContent</span><span class="params">()</span> <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> openConnection().getContent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
<blockquote>
<p><strong>Socket 类</strong></p>
</blockquote>
<ul>
<li><p>核心：[基于 <strong>TCP</strong> 协议设计的网络通信类]{.red}</p>
</li>
<li><p>前提：每个采用 TCP 协议并且想要参与网络通信的进程都需要创建 自己的 [Socket（套接字）]{.blue}</p>
</li>
<li><p>客户端（Socket 类）：</p>
<ul>
<li><p>构造方法：[需要传入访问的服务器的端口和服务器的主机地址]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Socket 类常用的构造方法*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Socket</span><span class="params">(String host, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> UnknownHostException, IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(host != <span class="keyword">null</span> ? <span class="keyword">new</span> InetSocketAddress(host, port) :</span><br><span class="line">         <span class="keyword">new</span> InetSocketAddress(InetAddress.getByName(<span class="keyword">null</span>), port),</span><br><span class="line">         (SocketAddress) <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Socket</span><span class="params">(SocketAddress address, SocketAddress localAddr, <span class="keyword">boolean</span> stream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 客户端连接到服务器的端口号</span></span><br><span class="line">    connect(address)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>服务器（ServerSocket 类）：</p>
<ul>
<li><p>构造方法：[仅需要传入服务器当前的端口号；默认主机地址为 127.0.0.1]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*ServerSocket 类常用的构造方法*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServerSocket</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(port, <span class="number">50</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*调用的另一个构造方法*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServerSocket</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">int</span> backlog, InetAddress bindAddr)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">   	<span class="comment">/*将服务器创建的套接字绑定到相应的网卡设备上：如果没有绑定是没有办法通信的*/</span></span><br><span class="line">    bind(<span class="keyword">new</span> InetSocketAddress(bindAddr, port), backlog);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>核心方法：<code>accept()</code> ==阻塞式监听端口==：只要没有客户端连接就一直阻塞在当前位置监听；客户端发送连接请求，该方法立刻返回相应的客户端套接字</p>
</li>
</ul>
</li>
</ul>

        <h3 id="流类"   >
          <a href="#流类" class="heading-link"><i class="fas fa-link"></i></a><a href="#流类" class="headerlink" title="流类"></a>流类</h3>
      <p>:::info</p>
<p>所有传统的 I/O 工具类的核心方法都是输入输出和各式各样的重载，没有太大的难度</p>
<p>参考博客：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/mu_wind/article/details/108674284" >【Java基础-3】吃透Java IO：字节流、字符流、缓冲流</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<p>:::warning</p>
<ul>
<li>装饰类通常会添加许多基础类没有的方法，所以可以额外增加基本类的功能</li>
<li>[多个装饰类叠加的时候可能导致重写了同一个方法，所以这样就只能使用最外面那个装饰类的方法]{.blue}</li>
</ul>
<p>:::</p>
<blockquote>
<p><strong>字节流框架图</strong></p>
</blockquote>
<p>:::info</p>
<p>通常不再使用字节流，因为效率相对字符流较低</p>
<p>:::</p>
<img src="https://i1.xpic.jp/file/xpicjp/2021/08/07/f18048073f2e60c18823536388883e6e.png" alt="f18048073f2e60c18823536388883e6e.png" style="zoom:80%;" />

<blockquote>
<p><strong>字节输入流</strong></p>
</blockquote>
<ul>
<li>节点类（基本类）<ul>
<li><code>ByteArrayInputStream</code>：数据输入源是 [字节数组]{.red}</li>
<li><code>FileInputStream</code>：数据输入源是 [文件]{.red}</li>
<li><code>PipeInputStream</code>：数据输入源是 [流]{.red}（从其他线程共用的管道流中获取数据）</li>
</ul>
</li>
<li>处理类（装饰类）<ul>
<li><code>BufferedInputStream</code>：为节点类的增加缓冲区功能（[字节流默认没有缓冲机制所以需要手动添加缓冲区]{.red}）</li>
<li><code>DataInputStream</code>：为节点类可以读出各式各样的数据的功能，可以直接读出整型、字符、布尔、浮点数等类型，不需要通过字节进行转换</li>
<li><code>PushBackInputStream</code></li>
<li><del><code>LineNumberInputStream</code></del>：已经被废弃的类</li>
</ul>
</li>
<li>序列化：<code>ObjectInputStream</code>：数据输入源是 [对象]{.red}</li>
</ul>
<blockquote>
<p><strong>字节输出流</strong></p>
</blockquote>
<ul>
<li>节点类（基本类）<ul>
<li><code>ByteArrayOutputStream</code></li>
<li><code>FileOutputStream</code></li>
<li><code>PipeOutputStream</code></li>
</ul>
</li>
<li>处理类（装饰类）<ul>
<li><code>DataOutputStream</code></li>
<li><code>BufferedOutputStream</code></li>
<li><code>PrintStream</code>：[格式化打印流；可以将数据按照一定格式放入流中]{.red}</li>
</ul>
</li>
<li>序列化：<code>ObjectOutputStream</code></li>
</ul>
<blockquote>
<p><strong>字节流方法</strong></p>
</blockquote>
<ul>
<li><p>读方法</p>
<ul>
<li><p>节点类：① 仅列出常用的方法 ② 所有节点类的方法基本相同</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次仅读取一个字节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 每次读取一个数组大小的字节数量：相当于数组是缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="comment">// 判断还有多少字节数量没有读取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure></li>
<li><p>处理类：仅列出新增的方法</p>
<ul>
<li><p><code>DataInputStream</code></p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取布尔类型的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readBoolean</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>; </span><br><span class="line"><span class="comment">// 读取短整型的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">short</span> <span class="title">readShort</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="comment">// 读取整型数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="comment">// 读取长整型的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">readLong</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="comment">// 读取字符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">char</span> <span class="title">readChar</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="comment">// 读取单精度浮点数的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">float</span> <span class="title">readFloat</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="comment">// 读取双精度浮点数的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></div></figure></li>
<li><p><code>BufferedInputStream</code>：只是为节点类增加了缓冲区，没有新增任何方法</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>写方法</p>
<ul>
<li><p>节点类：① 仅列出常用的方法 ② 所有节点类的方法基本相同</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入单个字节：虽然写入的是整型，但是在实现中会将其强制转换为字节类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">// 写入字节数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="comment">// 输出流中存在的字节数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure></li>
<li><p>处理类：仅列出新增的方法</p>
<ul>
<li><p><code>DataOutputStream</code></p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入布尔类型的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writeBoolean</span><span class="params">(<span class="keyword">boolean</span> v)</span> <span class="keyword">throws</span> IOException</span>; </span><br><span class="line"><span class="comment">// 写入短整型的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">short</span> <span class="title">writeShort</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="comment">// 写入整型数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeInt</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="comment">// 写入长整型数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeLong</span><span class="params">(<span class="keyword">long</span> v)</span> <span class="keyword">throws</span> IOException&#x27;</span></span><br><span class="line"><span class="function"><span class="comment">// 写入单个字符</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeChar</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="comment">// 写入字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeChars</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="comment">// 写入单精度浮点数的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">float</span> <span class="title">writeFloat</span><span class="params">(<span class="keyword">float</span> v)</span> <span class="keyword">throws</span> IOException；</span></span><br><span class="line"><span class="function"><span class="comment">// 写入双精度浮点数的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> <span class="title">writeDouble</span><span class="params">(<span class="keyword">double</span> v)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></div></figure></li>
<li><p><code>PrintStream</code>：如果不使用格式化类，那么输出内容时需要自己手动添加换行符等结束信息，否则接收信息时可能接收不到</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅列出常用的：还有各种重载</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> PrintStream <span class="title">printf</span><span class="params">(String format, Object ... args)</span></span>;</span><br></pre></td></tr></table></div></figure></li>
<li><p><code>BufferedOutputStream</code>：只是为节点类增加了缓冲区，没有新增任何方法</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>字符流框架图</strong></p>
</blockquote>
<img src="https://i1.xpic.jp/file/xpicjp/2021/08/07/0f9da60b5bbd7e20578e361b30f1cc2d.png" alt="0f9da60b5bbd7e20578e361b30f1cc2d.png" style="zoom:80%;" />

<blockquote>
<p><strong>字符输入流</strong></p>
</blockquote>
<ul>
<li><p>节点类：</p>
<ul>
<li><code>CharArrayReader</code>：数据输入源是 [字符数组]{.red}</li>
<li><code>StringReader</code>：数据输入源是 [字符串]{.red}</li>
<li><code>PipeReader</code>：数据输入源是 [流]{.red}（从其他线程共用的管道流中获取数据）</li>
</ul>
</li>
<li><p>处理类：</p>
<ul>
<li><p><code>BufferedReader</code>：为节点类增加缓冲区功能（<code>JDK 1.1</code> 之后添加的 [字符流默认携带缓冲区]{.red}）</p>
<p>  注：<code>BufferedReader</code> 不是 <code>FilterReader</code> 的子类</p>
</li>
</ul>
</li>
<li><p>字节转换类：</p>
<ul>
<li><p><code>InputStreamReader</code>：[将字节流转换成字符流，网络通信中经常使用该类]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将客户端的字节流转换成字符流*/</span></span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">    <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">        socket.getInputStream()))</span><br></pre></td></tr></table></div></figure></li>
<li><p><code>FileReader</code>：[便捷类]{.red}</p>
<ul>
<li>负责将文件字节流转换成文件字符流</li>
<li>[直接继承 InputStreamReader 类；内部直接调用父类的构造方法]{.red}</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*下面两者是完全等价的*/</span></span><br><span class="line">InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(filename));</span><br><span class="line">FileReader reader = <span class="keyword">new</span> FileReader(filename);</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>字符输出流</strong></p>
</blockquote>
<ul>
<li>节点类<ul>
<li><code>CharArrayWriter</code></li>
<li><code>StringWriter</code></li>
<li><code>PipeWriter</code></li>
</ul>
</li>
<li>处理类<ul>
<li><code>BufferedWriter</code></li>
<li><code>PrintWriter</code></li>
</ul>
</li>
<li>字节转换类：<ul>
<li><code>OutputStreamWriter</code></li>
<li><code>FilterWriter</code></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>字符流方法</strong></p>
</blockquote>
<ul>
<li><p>前提：</p>
<ul>
<li>方法基本和字节流没有什么区别，只不过读出和写入的类型有一定的变化</li>
<li>[字符流的所有方法默认自带缓冲区，即使使用缓冲区装饰类效果也一般]{.red}</li>
</ul>
</li>
<li><p>读方法：<code>BufferedReader</code></p>
  <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">	// 最常使用的读取方法</span><br><span class="line">	public String readLine() throws IOException;</span><br><span class="line"></span><br><span class="line">* 写方法</span><br><span class="line"></span><br><span class="line">&gt; **实例：结合网络类 + 流对象编写的例子**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">// 客户端</span><br><span class="line">public static void main(String[] args) throws IOException</span><br><span class="line">&#123;</span><br><span class="line">    // 客户端访问服务器端口: 客户端的端口是操作系统随机分配的，不需要程序员决定，只需要指定访问哪个服务器端口</span><br><span class="line">    Socket client = null;</span><br><span class="line">    // 客户端向服务器发送数据</span><br><span class="line">    PrintWriter writer = null;</span><br><span class="line">    // 客户端接收服务器返回的数据</span><br><span class="line">    BufferedReader reader = null;</span><br><span class="line">    // 客户端输入需要发送的数据</span><br><span class="line">    BufferedReader consoleReader = new BufferedReader(</span><br><span class="line">        new InputStreamReader(</span><br><span class="line">            System.in));</span><br><span class="line">    client = new Socket(DEFAULT_SERVER_HOSTNAME, DEFAULT_SERVER_PORT);</span><br><span class="line">    System.out.println(&quot;客户端启动成功...&quot;);</span><br><span class="line">    // 向服务器端发送数据并且接收返回的数据</span><br><span class="line">    String string;</span><br><span class="line">    writer = new PrintWriter(</span><br><span class="line">        new BufferedWriter(</span><br><span class="line">            new OutputStreamWriter(</span><br><span class="line">                client.getOutputStream())));</span><br><span class="line"></span><br><span class="line">    // 客户端输入 exit 就退出</span><br><span class="line">    while (!EXIT.equals(string = consoleReader.readLine()))</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(string);</span><br><span class="line">        writer.println(string);</span><br><span class="line">        writer.flush();</span><br><span class="line">        reader = new BufferedReader(</span><br><span class="line">            new InputStreamReader(</span><br><span class="line">                client.getInputStream()));</span><br><span class="line">        System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reader.close();</span><br><span class="line">    writer.close();</span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br><span class="line">// 服务器</span><br><span class="line">public static void main(String[] args) throws IOException</span><br><span class="line">&#123;</span><br><span class="line">    // 创建服务器处理请求的端口 Socket</span><br><span class="line">    ServerSocket server = null;</span><br><span class="line">    // 服务器读取客户端传递的数据</span><br><span class="line">    BufferedReader reader = null;</span><br><span class="line">    // 服务器返回给客户端的数据</span><br><span class="line">    PrintWriter writer = null;</span><br><span class="line"></span><br><span class="line">    server = new ServerSocket(DEFAULT_SERVER_PORT);</span><br><span class="line">    System.out.printf(&quot;服务器[%d]:%s\n&quot;, DEFAULT_SERVER_PORT, &quot;启动完成...&quot;);</span><br><span class="line">    while (true)</span><br><span class="line">    &#123;</span><br><span class="line">        // 服务器等待客户端发出请求，采用阻塞式调用：如果没有客户端发出请求就一直等待</span><br><span class="line">        Socket client = server.accept();</span><br><span class="line">        System.out.printf(&quot;客户端[%d]:%s\n&quot;, client.getPort(), &quot;建立连接&quot;);</span><br><span class="line">        /*</span><br><span class="line">                    1. 读取客户端发出的请求并处理并向客户端返回消息</span><br><span class="line">                    2. 传输过程中采用的是字节传输，所以 Socket 也只能获得字节流而不是字符流</span><br><span class="line">                 */</span><br><span class="line">        String string;</span><br><span class="line">        reader = new BufferedReader(</span><br><span class="line">            new InputStreamReader(</span><br><span class="line">                client.getInputStream()));</span><br><span class="line">        writer = new PrintWriter(</span><br><span class="line">            new BufferedWriter(</span><br><span class="line">                new OutputStreamWriter(</span><br><span class="line">                    client.getOutputStream())));</span><br><span class="line">        while ((string = reader.readLine()) != null)</span><br><span class="line">        &#123;</span><br><span class="line">            // 格式化输出客户端发送的消息</span><br><span class="line">            System.out.printf(&quot;客户端[%d]:%s\n&quot;, client.getPort(), string);</span><br><span class="line">            // 向客户端返回消息</span><br><span class="line">            writer.println(&quot;服务器处理完毕&quot;);</span><br><span class="line">            // 确保缓冲区中所有的内容都被推出: writer 关闭后会自动推出缓冲区中剩余的内容</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(&quot;客户端[%d]:%s&quot;, client.getPort(), &quot;退出连接&quot;);</span><br><span class="line"></span><br><span class="line">        reader.close();</span><br><span class="line">        writer.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h2 id="实例：多人聊天室"   >
          <a href="#实例：多人聊天室" class="heading-link"><i class="fas fa-link"></i></a><a href="#实例：多人聊天室" class="headerlink" title="实例：多人聊天室"></a>实例：多人聊天室</h2>
      <blockquote>
<p><strong>服务器端</strong></p>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">MyServer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 现在仅提供了多人聊天服务器的套接字</span></span><br><span class="line">    CHATSERVER(<span class="number">8888</span>, <span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个套接字都具有端口号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="comment">// 每个套接字都具有 IP 地址</span></span><br><span class="line">    <span class="keyword">private</span> String hostname;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举类型的构造方法始终都是私有的</span></span><br><span class="line">    MyServer(<span class="keyword">int</span> port, String hostname)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.hostname = hostname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供相应的方法以便获取枚举实例中的值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHostname</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hostname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.v2.chatserver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. v1 版本创建线程的方式采用的是 Lambda 表达式: 变量的使用和流的关闭都受到很大的限制；主要原因还是在于其本质是内部类&lt;/br&gt;</span></span><br><span class="line"><span class="comment"> * 2. v1 版本此前将控制台输入线程作为主线程处理，导致主线程被堵塞后，子线程全部被堵塞&lt;/br&gt;</span></span><br><span class="line"><span class="comment"> *    主要原因在于线程的不可控：Java 中的线程调度几乎是随机的，设置优先级仍然无法改善，并且主线程的优先级始终都是很高的&lt;/br&gt;</span></span><br><span class="line"><span class="comment"> * 3. v2 版本采用实现接口的形式创建线程，并且改进此前的错误设计&lt;/br&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXIT = <span class="string">&quot;退出&quot;</span>;</span><br><span class="line">    <span class="comment">// 服务器绑定端口</span></span><br><span class="line">    <span class="keyword">private</span> ServerSocket server;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     1. 记录聊天室目前在线人数，方便之后转发消息</span></span><br><span class="line"><span class="comment">     2. 采用哈希表的原因</span></span><br><span class="line"><span class="comment">        2.1 每个哈希表可以保存当前向客户端输出的流，方便之后关闭；如果采用链表保存，则每次转发消息都需要创建输出流，非常不好用</span></span><br><span class="line"><span class="comment">        2.2 没有采用原始的哈希表，因为服务器会创建多个线程，原始的哈希表是线程不安全的，容易导致并发问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;Integer, PrintWriter&gt; clients;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法用于初始化哈希表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatServer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        clients = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端连接到服务器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> client 客户端套接字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException 抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addClient</span><span class="params">(Socket client)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 确保传入的客户端套接字不为空</span></span><br><span class="line">        <span class="keyword">if</span> (client != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将客户端的端口号作为 Key, 将客户端的输出流作为 Value</span></span><br><span class="line">            clients.put(client.getPort(), <span class="keyword">new</span> PrintWriter(</span><br><span class="line">                <span class="keyword">new</span> BufferedWriter(</span><br><span class="line">                    <span class="keyword">new</span> OutputStreamWriter(</span><br><span class="line">                        client.getOutputStream()))));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端断开连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> client 断开连接的套接字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException 抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeClient</span><span class="params">(Socket client)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 确保套接字不是空并且存在于哈希表中</span></span><br><span class="line">        <span class="keyword">if</span> (client != <span class="keyword">null</span> &amp;&amp; clients.containsKey(client.getPort()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 移除哈希表中的客户端之前应该先关闭对客户端的输出流</span></span><br><span class="line">            clients.get(client.getPort()).close();</span><br><span class="line">            <span class="comment">// 移除</span></span><br><span class="line">            clients.remove(client.getPort());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务器进程结束时需要释放的资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 可以选择直接关闭套接字</span></span><br><span class="line">        <span class="keyword">if</span> (server != <span class="keyword">null</span> &amp;&amp; !server.isClosed())</span><br><span class="line">        &#123;</span><br><span class="line">            server.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程转发客户端发送的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> client 发送消息的客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 发送的消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException 抛出的异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forward</span><span class="params">(Socket client, String message)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 如果发送的是退出消息,那么就只发送回给原客户端,提示它可以退出了</span></span><br><span class="line">        <span class="keyword">if</span>(EXIT.equals(message))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (clients.containsKey(client.getPort()))</span><br><span class="line">            &#123;</span><br><span class="line">                PrintWriter writer = clients.get(client.getPort());</span><br><span class="line">                writer.println(message);</span><br><span class="line">                writer.flush();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clients.containsKey(client.getPort()))</span><br><span class="line">            clients.forEach((value, key)-&gt;&#123;</span><br><span class="line">                <span class="keyword">if</span> (value != client.getPort())</span><br><span class="line">                    key.println(message);</span><br><span class="line">                key.flush();</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用其他所有方法，并且负责为客户端创建服务线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 服务器绑定端口号</span></span><br><span class="line">            server = <span class="keyword">new</span> ServerSocket(MyServer.CHATSERVER.getPort());</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器:启动成功&quot;</span>);</span><br><span class="line">            <span class="comment">// 服务器永久运行</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 服务器采用阻塞式调用获取客户端: 只要没有客户端连接, 服务器进行将始终阻塞在这里</span></span><br><span class="line">                Socket socket = server.accept();</span><br><span class="line">                <span class="comment">// 为客户端创建相应的服务线程:</span></span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> ChatServerThread(<span class="keyword">this</span>, socket)).start();</span><br><span class="line">                System.out.printf(<span class="string">&quot;客户端[%d]:%s&quot;</span>, socket.getPort(), <span class="string">&quot;连接成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 启动服务器</span></span><br><span class="line">        <span class="keyword">new</span> ChatServer().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.v2.chatserver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务器线程用于处理每个客户端的请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatServerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXIT = <span class="string">&quot;退出&quot;</span>;</span><br><span class="line">    <span class="comment">// 线程需要完成的任务：建立和客户端的连接、断开和客户端的连接、转发消息、读取消息：需要服务器才能够调用方法</span></span><br><span class="line">    <span class="keyword">private</span> ChatServer server;</span><br><span class="line">    <span class="comment">// 每个客户端都具有相应的服务线程：所以需要记录当前线程服务的哪个客户端</span></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="comment">// 线程读取客户端的输入流</span></span><br><span class="line">    <span class="keyword">private</span> BufferedReader reader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最好不要在构造方法中抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatServerThread</span><span class="params">(ChatServer server, Socket socket)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.server = server;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器:创建线程成功&quot;</span>);</span><br><span class="line">            <span class="comment">// 将客户端放入在线列表中</span></span><br><span class="line">            server.addClient(socket);</span><br><span class="line">            reader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                        <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                                socket.getInputStream()));</span><br><span class="line">            <span class="comment">// 线程读取客户端的输入流并且转发消息</span></span><br><span class="line">            String message;</span><br><span class="line">            <span class="comment">// 格式化信息</span></span><br><span class="line">            String formatMessage;</span><br><span class="line">            <span class="comment">// 只要客户端的输入流没有关闭, 那么线程就会一直在这个循环的判断条件中被阻塞; 输入流已关闭就会立刻跳出循环</span></span><br><span class="line">            <span class="comment">// readLine 读入到换行符结束,所以客户端发送的消息必须有换行符,否则认为客户端没有发送结束</span></span><br><span class="line">            <span class="keyword">while</span> ((message = reader.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                formatMessage = <span class="string">&quot;客户端[&quot;</span> + socket.getPort() +<span class="string">&quot;]:&quot;</span> + message;</span><br><span class="line">                <span class="comment">// 服务器查看客户端发送的信息</span></span><br><span class="line">                System.out.println(formatMessage);</span><br><span class="line">                <span class="comment">// 服务器将客户端的信息转发给其余客户端</span></span><br><span class="line">                server.forward(socket, EXIT.equals(message) ? message :formatMessage);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 客户端退出提示信息</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;客户端[%d]:%s&quot;</span>, socket.getPort(), <span class="string">&quot;断开连接&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 关闭输入流</span></span><br><span class="line">                reader.close();</span><br><span class="line">                <span class="comment">// 关闭输出流</span></span><br><span class="line">                server.removeClient(socket);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IOException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<blockquote>
<p><strong>客户端</strong></p>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.v2.chatclient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> chatroom.v2.chatserver.MyServer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. idea 默认客户端不可以并行运行，可以在设置中修改</span></span><br><span class="line"><span class="comment"> * 2. 控制台的输入线程不能够作为主线程，否则会导致子线程也被堵塞</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 客户端退出使用的常量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXIT = <span class="string">&quot;退出&quot;</span>;</span><br><span class="line">    <span class="comment">// 客户端同样需要端口</span></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="comment">// 主线程：客户端向服务器输出流</span></span><br><span class="line">    <span class="keyword">private</span> PrintWriter writer;</span><br><span class="line">    <span class="comment">// 主线程：客户端读取服务器输入流</span></span><br><span class="line">    <span class="keyword">private</span> BufferedReader reader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子线程发送消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 发送的消息没办法格式化,因为不知道进程的端口号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="keyword">null</span>)</span><br><span class="line">            writer.println(message);</span><br><span class="line">            writer.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收服务器转发的消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 转发的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">receive</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String message;</span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="keyword">null</span> &amp;&amp; (message = reader.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用其他所有方法：主线程只负责接收消息，子线程负责发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 客户端绑定端口号</span></span><br><span class="line">            socket = <span class="keyword">new</span> Socket(MyServer.CHATSERVER.getHostname(), MyServer.CHATSERVER.getPort());</span><br><span class="line">            writer = <span class="keyword">new</span> PrintWriter(</span><br><span class="line">                    <span class="keyword">new</span> BufferedWriter(</span><br><span class="line">                            <span class="keyword">new</span> OutputStreamWriter(</span><br><span class="line">                                    socket.getOutputStream())));</span><br><span class="line">            reader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                    <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                            socket.getInputStream()));</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端:启动成功&quot;</span>);</span><br><span class="line">            <span class="comment">// 启动子线程：等待控制台输入</span></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ChatClientThread(<span class="keyword">this</span>)).start();</span><br><span class="line">            <span class="comment">// 客户端不断循环直到想要退出为止</span></span><br><span class="line">            String message;</span><br><span class="line">            <span class="keyword">while</span> (!EXIT.equals(message = receive()))</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(message);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;退出....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">                writer.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IOException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ChatClient().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.v2.chatclient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClientThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXIT = <span class="string">&quot;退出&quot;</span>;</span><br><span class="line">    <span class="comment">// 用于读取控制台的流</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BufferedReader READER = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">        <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">            System.in));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ChatClient client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClientThread</span><span class="params">(ChatClient client)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String message;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端:线程启动成功&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> ((message = READER.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                客户端的主线程负责接收消息,子线程负责发送消息同时管理控制台的输入</span></span><br><span class="line"><span class="comment">                我们没有办法在主线程中获取子线程中的输入内容,也就没有办法直接通过控制台的内容去关闭客户端</span></span><br><span class="line"><span class="comment">                只能够先通知服务器,我们要关闭了后,由服务器返回消息给我们,主线程才可以关闭</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                client.send(message);</span><br><span class="line">                <span class="keyword">if</span> (EXIT.equals(message))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                System.out.println(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                READER.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IOException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/08/19/java/io/%E6%A6%82%E8%BF%B0/">概述</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-08-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-09</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h1>
      
        <h2 id="知识框架"   >
          <a href="#知识框架" class="heading-link"><i class="fas fa-link"></i></a><a href="#知识框架" class="headerlink" title="知识框架"></a>知识框架</h2>
      <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/IO 知识框架.7jak8kqrfgk0.png" alt="IO 知识框架" style="zoom:80%;" />


        <h2 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h2>
      <blockquote>
<p><strong>Java I/O系统 是什么?</strong></p>
</blockquote>
<ul>
<li><p>全称：<code>Input/Output</code></p>
</li>
<li><p>定义：<code>IO</code> 系统全称为输入输出系统，通常应用于 [设备之间]{.red} 进行数据传输</p>
</li>
<li><p>设备：通常交换数据的设备在 [文件和进程之间（文件编程）、客户端和服务器之间（网络编程）]{.red}</p>
</li>
<li><p>细节：</p>
<ul>
<li><code>I/O</code> 的主要应用场景就是网络编程，[用于客户端和服务器之间传递数据，而不是用于读取文件的]{.blue}，文件已经被数据库取代</li>
<li><code>Tomcat</code> 是应用服务器，仅能够解析 <code>HTTP</code> 请求，底层理所应当地是采用 [I/O + 网络编程]{.red} 实现的</li>
<li><code>Netty</code> 是通信框架，能够自定义解析各种各样的请求，底层自然也是采用 [I/O + 网络编程]{.red} 实现的</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Java I/O 发展历史</strong></p>
</blockquote>
<ul>
<li><code>BIO(Blocking I/O)</code>：<code>JDK 1.0</code> 提供最基本的 [阻塞式]{.red} <code>IO</code> 框架</li>
<li><code>NIO(New I/O)</code>：<code>JDK 1.4</code> 进一步提供 [非阻塞式]{.red} 的 <code>IO</code> 框架</li>
<li><code>AIO(Asynchronous I/O)</code>：<code>JDK 1.7</code> 提供额外的 [异步式]{.red} 的 <code>IO</code> 框架  </li>
</ul>
<img src="https://i1.xpic.jp/file/xpicjp/2021/08/07/403449fef38a2b39746f574e59b3a6f1.png" alt="403449fef38a2b39746f574e59b3a6f1.png" style="zoom:80%;" />


        <h2 id="编码格式"   >
          <a href="#编码格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h2>
      <blockquote>
<p><strong>编码格式</strong></p>
</blockquote>
<ul>
<li><p>前提：<code>IO</code> 框架涉及到字符和字节的转换，就有必要了解字节的编码格式</p>
</li>
<li><p>定义：编码就是把字符转换成字节表示并存储，解码就是把字节转换成字符表示</p>
</li>
<li><p>字符集和编码规则：</p>
<ul>
<li>字符集：<code>Unicode</code></li>
<li>编码规则：<code>UTF-8</code>、<code>UTF-16</code>、<code>UTF-32</code>、<code>ASCII</code>、<code>GB2312</code>、<code>GBK</code>、<code>GB18030</code></li>
</ul>
</li>
<li><p>历史：</p>
<ul>
<li><p>ASCII 编码：早期计算机仅有英文国家使用，所以仅采用 [7 bit (128)]{.red} 对英文字符进行编码，后来随着使用计算机的国家变多，[8 bit (256)]{.red} 全被用于编码使用</p>
</li>
<li><p>GB2312 编码：ASCII 编码没有足够的位数给中文字符编码，所以中国抛弃了后面的 128 个字符，[规定 两个 ASCII 编码大于 127 字符连接在一起就表示汉字]{.red}</p>
</li>
<li><p>GBK、GB18030 编码：随着时代发展不能够提供足够使用汉字，所以又在 GB2312 的基础上进行改进，得到了 GBK、GB18030 等国标码</p>
<p>  [注：GB2312 等国标码都是在 ASCII 码的基础上扩展而来的]{.red}</p>
</li>
<li><p>UTF-8、UTF-16编码：</p>
<ul>
<li>每个国家为了在计算机中使用自己的文字，都制定了只有自己才能够使用的编码方案，不利于各个国家的交流，所以最后 ISO 制定了 Unicode 字符集，为世界上每个字符都分配了编码</li>
<li>UTF-8、UTF-16 则是具体的编码方案，将每 [8 bit、16bit]{.red} 组成一个编码单元，并且使用特定的标志位为计算机提供信息</li>
</ul>
</li>
</ul>
</li>
<li><p><code>UTF-8</code></p>
<ul>
<li><p>范围：0x0000 ~ 0x10FFFF</p>
</li>
<li><p>规则：根据每个字符的 Unicode 编码找到对应的编码格式，然后将二进制的 Unicode 编码分别填入 x 中，最后就得到了 UTF-8 编码</p>
<blockquote>
<p>0x0000 ~ 0x007F: 0xxxxxxx</p>
<p>0x0080 ~ 0x07FF: 110xxxxxx 10xxxxxx</p>
<p>0x0800 ~ 0xFFFF: 1110xxxx 10xxxxxx 10xxxxxx</p>
<p>0x10000 ~ 0x10FFFF:11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</p>
<p>[知] Unicode 编码为 30693，二进制编码为 1110111 11100101, 填入第三行的编码格式得到 UTF-8 编码 11100111 10011111 10100101，采用十六进制表示：E79FA5</p>
</blockquote>
</li>
<li><p>字节数量</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="left"></th>
<th>UTF-8</th>
<th>UTF-16</th>
<th>GBK</th>
</tr>
</thead>
<tbody><tr>
<td align="left">英文英文字符</td>
<td><code>1B</code></td>
<td><code>2B</code></td>
<td><code>1B</code></td>
</tr>
<tr>
<td align="left">汉字汉字字符</td>
<td><code>3B</code></td>
<td><code>2B</code></td>
<td><code>2B</code></td>
</tr>
</tbody></table></div>
</li>
</ul>
</li>
<li><p>问题</p>
<ul>
<li><blockquote>
<p><strong>为什么 UTF-8 和 UTF-16 对于中文编码的字节数量不一样？</strong></p>
</blockquote>
<p>  UTF-8 提供的标志位更多，每个编码单元能存储的实际信息相对 UTF-16 要少，所以需要采用更多的字节来编码中文</p>
</li>
<li><blockquote>
<p><strong>字符集和编码规则有什么区别？</strong></p>
</blockquote>
<p>  字符集只是对每个不同的字符 [分配唯一的编号（码位、码点）]{.red}：[知] Unicode 编号为 30693；十六进制表示为 0x77E5</p>
<p>  编码规则则是根据 [特定的方式]{.red} 将字符的编号转换成二进制进行存储：[知] 11100111 10011111 10100101</p>
<p>  你可以尝试将二进制再换算成十六进制，得到的值肯定是不一样的，这就是因为具体的编码规则不同导致的，这里采用是 UTF-8</p>
<p>  [注：字符集是对全世界的字符编码的规范，编码格式则是存储字符的具体实现]{.red}</p>
</li>
<li><blockquote>
<p><strong>为什么要分别提供字符集和编码规则呢？</strong></p>
</blockquote>
<p>  如果直接将字符集提供的编号转换成二进制存储就会出现问题：[每个字符编号长度不同就会造成计算机在读取时的歧义]{.red}</p>
<p>  [知] 二进制表示为 1110111 11100101 [W] 二进制表示为：1110111：显然计算机就会直接将 [知] 的前半部分解读为 [W]，这是显然错误的</p>
<p>  为了正确解读每个字符的编号显然需要使用 [标志位]{.red}，从而让计算机意识到解读开始和解读结束</p>
<p>  因为 [标志位]{.red} 设计的不同就导致诞生了不同格式的编码规则</p>
</li>
<li><blockquote>
<p><strong>为什么已经存在 UTF-8 等国际化的编码，中文编码仍在使用</strong></p>
</blockquote>
<p>  等待更新…</p>
</li>
</ul>
</li>
<li><p>细节：[Java 虚拟机内部采用 UTF-16 编码，字节码采用 UTF-8 编码、源代码可以自行设定编码格式]{.red}</p>
</li>
</ul>

        <h2 id="同步与阻塞"   >
          <a href="#同步与阻塞" class="heading-link"><i class="fas fa-link"></i></a><a href="#同步与阻塞" class="headerlink" title="同步与阻塞"></a>同步与阻塞</h2>
      <blockquote>
<p><strong>阻塞、非阻塞、同步、异步</strong></p>
</blockquote>
<p>:::info</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36573828/article/details/89149057" >同步、异步、阻塞、非阻塞IO总结（IO模型总结）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/lengxiao1993/article/details/78154467" >同步/异步，阻塞/非阻塞概念深度解析</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.zhihu.com/question/19732473" >怎样理解阻塞非阻塞与同步异步的区别？</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>（这个知乎上有个回答基本解决了我的疑惑）</p>
<p>:::</p>
<p>:::warning</p>
<p>I/O 的同步、异步的概念和并发中的同步、异步的概念是完全不同的</p>
<p>:::</p>
<blockquote>
<p>① 先来了解数据进程（程序）究竟是如何通过 I/O 获取到数据的</p>
</blockquote>
<img src="https://i1.xpic.jp/file/xpicjp/2021/08/21/a99748a07ca5c0f198e3e65059f968e5.png" alt="a99748a07ca5c0f198e3e65059f968e5.png" style="zoom:80%;" />

<ul>
<li><p>前提：[理解这幅图需要 <strong>操作系统</strong> 的相关知识]{.red}</p>
</li>
<li><p>I/O 流程</p>
<ul>
<li><p>发起请求：</p>
<ul>
<li><p>进程使用 recvfrom 系统调用发起 I/O 请求（应用程序层面的 I/O 请求）</p>
</li>
<li><p>操作系统 查找相应驱动程序发起 I/O 请求 （操作系统层面的 I/O 请求）</p>
</li>
<li><p>控制器完成实际的 I/O 操作</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/IO 流程.25dyfqwn03mo.png" alt="IO 流程" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>接收数据：</p>
<ul>
<li>网络或者磁盘中的数据经由总线传输进入内核缓冲区中：操作系统层面的 I/O 操作完成</li>
<li>内核缓冲区中的数据拷贝进入进程所占用的内存空间中：应用程序层面的 I/O 操作完成</li>
</ul>
</li>
</ul>
</li>
<li><p>同步与阻塞</p>
<ul>
<li>应用程序发起 I/O 请求实际涉及到两次 I/O 操作：一次是操作系统层面的，一次是应用程序层面的</li>
<li>那么我们在讨论同步和阻塞的时候应该将这两次 I/O 操作分开讨论，混为一谈容易导致概念混乱<ul>
<li>操作系统层面的 I/O 操作：现代操作系统的 I/O 操作全部都是异步非阻塞式的，因为效率高</li>
<li>应用程序层面的 I/O 操作：现代操作系统提供给程序员的方法都是同步式的（阻塞或者非阻塞），为了程序员编程的便利</li>
</ul>
</li>
<li>因为操作系统层面的 I/O 操作的设计已经固定，所以通常不去讨论，接下来所有的讨论都是针对应用程序层面的</li>
</ul>
</li>
</ul>
<blockquote>
<p>② 再来了解阻塞、非阻塞、同步、异步的概念</p>
</blockquote>
<ul>
<li><p>阻塞和非阻塞</p>
<ul>
<li>定义：阻塞和非阻塞描述的是 [进程的状态]{.red} </li>
<li>阻塞：请求发送方在请求结果返回之前都 [不完成其他任何任务]{.red}</li>
<li>非阻塞：请求发送方在请求调用结果返回之前 [可以完成其他任务]{.red}</li>
</ul>
</li>
<li><p>同步和异步</p>
<ul>
<li>定义：同步和异步描述的是 [进程之间协作完成事件的动作]{.red}</li>
<li>同步：[请求接收方为了和请求发送方保持一致性，在处理完请求之前不会返回任何结果]{.red}</li>
<li>异步：<ul>
<li>[请求接收方不想和请求发送方保持一致性，那么就会立刻返回确认请求]{.red}</li>
<li>[请求发送方在接收到确认请求后就可以去完成其他的任务]{.red}</li>
<li>[请求接收方处理结束后就利用事件通知请求发送方，请求发送方就利用回调函数继续处理]{.red}</li>
</ul>
</li>
</ul>
</li>
<li><p>区别：</p>
<ul>
<li>同步、异步 与 阻塞、非阻塞的关系<ul>
<li>同步和异步表示的 [行为]{.red} &lt;-&gt; 阻塞和非阻塞表示的是 [状态]{.red}</li>
<li>同步和异步是从 [接收方]{.red} 的角度看待的 &lt;-&gt; 阻塞和非阻塞是从 [发送方]{.red} 的角度看待的</li>
</ul>
</li>
<li>同步和异步的区别：<ul>
<li>同步：应用程序层面的 I/O 操作始终必须由自己主导完成</li>
<li>异步：应用程序层面的 I/O 操作完全交给操作系统一起完成，自己只需要等待数据进入自己的内存空间就行</li>
</ul>
</li>
</ul>
</li>
<li><p>组合：[两组概念可以两两任意组合]{.red}</p>
<ul>
<li>同步阻塞：<ul>
<li>请求发送方等待返回结果，确保和请求接收方的一致性</li>
<li>采用这种组合就会导致请求发送方在等待的过程中什么都不做，工作效率低</li>
</ul>
</li>
<li>同步非阻塞：<ul>
<li>请求发送方等待返回结果的期间会不停地询问请求接收方，确保能及时接收到返回结果保持一致性</li>
<li>采用这种组合就会导致发送方长时间运行，[导致处理器满负荷运行，非常占用系统资源]{.red}</li>
</ul>
</li>
<li>异步非阻塞：<ul>
<li>请求发送方在发送请求之后就不再关心返回结果，只需要等待请求接收方返回结果</li>
</ul>
</li>
<li>异步阻塞：理论存在的情况，实际并没有人使用</li>
</ul>
</li>
</ul>
<blockquote>
<p>③ 同步与阻塞的相关问题</p>
</blockquote>
<ul>
<li>同步和阻塞、异步和非阻塞有必然的联系吗？<ul>
<li>同步和异步是进程间协作的方式，确实可以导致进程出现阻塞或者非阻塞的状态。</li>
<li>[但是并没有必然的联系]{.blue}，同步不一定导致进程阻塞，异步也不一定导致进程处于非阻塞。</li>
</ul>
</li>
<li>操作系统层面是异步非阻塞式操作，但是应用程序层面使用同步式调用难道不会导致操作系统阻塞吗？<ul>
<li>同步式调用只会导致请求发送方出现阻塞的状态，请求接收方是不会出现的</li>
<li>操作系统由于采用的异步非阻塞式的 I/O 操作，所以在 I/O 控制器没有完成之前，操作系统是可以继续做其他事情的</li>
<li>应用程序采用的是同步式调用，始终在等待操作系统返回相应的结果，操作系统在没有收到数据前也是不会返回结果的</li>
<li>所以等待的始终只会是进程而不是操作系统</li>
</ul>
</li>
</ul>
<blockquote>
<p>④ 总结</p>
</blockquote>
<ul>
<li>阻塞&amp;非阻塞 与 同步&amp;异步仅仅只是看待问题的角度不同而已</li>
<li>不存在说同步&amp;异步是操作系统层面的概念，阻塞&amp;非阻塞是进程层面的概念</li>
<li>详细分析 IO 流程，显然是有两次 I/O 操作的，而在这两次 I/O 操作中是可以根据需要选择组合方案的</li>
<li>只不过现代操作系统通常采用异步非阻塞式、提供给应用程序使用的通常是同步式调用</li>
<li>实际上，应用程序也可以直接使用操作系统的异步非阻塞式调用</li>
</ul>

        <h2 id="Linux-通信模型"   >
          <a href="#Linux-通信模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#Linux-通信模型" class="headerlink" title="Linux 通信模型"></a>Linux 通信模型</h2>
      <blockquote>
<p><strong>Linux 通信模型</strong></p>
</blockquote>
<p>:::info</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&mid=2247484746&idx=1&sn=c0a7f9129d780786cabfcac0a8aa6bb7&source=41#wechat_redirect" >漫话：如何给女朋友解释什么是Linux的五种IO模型？</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36573828/article/details/89149057" >同步、异步、阻塞、非阻塞IO总结（IO模型总结）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.pdai.tech/md/java/io/java-io-model.html#io-%e5%a4%8d%e7%94%a8" >IO 模型 - Unix IO 模型</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<ul>
<li><p>前提：</p>
<ul>
<li>Linux 通信模型是对上面概念的实际实现，能够帮助更好的理解同步与阻塞的概念</li>
<li>Linux 通信模型不再涉及对操作系统层面 I/O 操作的讨论，因为基本都是异步非阻塞式的</li>
<li>[五种通信模型都是操作系统层面的模型，Java 通信模型是在操作系统层面的通信模型的封装]{.blue}</li>
</ul>
</li>
<li><p>同步 I/O 模型</p>
<ul>
<li><p>阻塞式 I/O 模型</p>
<ul>
<li><p>进程使用 <code>recvfrom</code> 同步阻塞式方法发起 I/O 请求等待数据进入内存中：进程变为阻塞态</p>
</li>
<li><p>网卡或者磁盘中的数据进入操作系统的缓冲区中：数据到达缓冲区</p>
</li>
<li><p>进程解除阻塞状态继续执行 <code>recvfrom</code> 同步阻塞式的方法：缓冲区中的数据进入进程所属内存中</p>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/22/beced3d854b7a17012e9473eadb252dc.png" alt="beced3d854b7a17012e9473eadb252dc.png" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>非阻塞式 I/O 模型</p>
<ul>
<li>进程设置为同步非阻塞：进程不会进入阻塞态</li>
<li>进程不停地使用 <code>recvfrom</code> 同步阻塞式方法，询问操作系统数据是否到达缓冲区中：进程始终处于运行态</li>
<li>网卡或者磁盘中的数据进入操作系统的缓冲区中：数据到达缓冲区</li>
<li>进程解除阻塞状态继续执行 <code>recvfrom</code> 同步阻塞式的方法：缓冲区中的数据进入进程所属内存中<img src="https://i1.xpic.jp/file/xpicjp/2021/08/22/2d5e244e2864ee0fe10d1af4ad59029a.png" alt="2d5e244e2864ee0fe10d1af4ad59029a.png" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>[多路复用式 I/O 模型]{.red}：</p>
<ul>
<li><p>进程设置为同步非阻塞：[进程不会阻塞在 I/O 操作上而是阻塞在方法上]{.red}</p>
</li>
<li><p>进程使用 <code>select、poll、epoll、kqueue</code> 同步阻塞式的方法：</p>
</li>
<li><p><code>select、poll、epoll、kqueue</code> 方法监视并且不断轮询操作系统，询问操作系统数据是否到达缓冲区中</p>
</li>
<li><p><code>select、poll、epoll、kqueue</code> 方法监视到数据进入操作系统缓冲区后就通知进程</p>
<p>+++ 细节</p>
<ul>
<li>这种模型的优势在于可以可以同时处理多个发生的 I/O 事件，而不像阻塞式模型仅能够处理单个 I/O 事件</li>
<li><code>select</code> 方法采用的是集合存储，<code>poll</code> 方法采用的是链表存储</li>
<li><code>epoll</code> 方法不需要存储多个事件，它为每个事件关联一个句柄，哪个事件发生，它立刻就会返回该事件，而不是一个集合</li>
</ul>
<p>+++</p>
</li>
<li><p>进程解除阻塞状态继续执行 <code>recvfrom</code> 同步阻塞式的方法：缓冲区中的数据进入进程所属内存中</p>
</li>
</ul>
<img src="https://i1.xpic.jp/file/xpicjp/2021/08/22/4b2259ebfaaccc22fd365434a302e7d0.png" alt="4b2259ebfaaccc22fd365434a302e7d0.png" style="zoom:80%;" /></li>
<li><p>信号驱动式 I/O 模型：</p>
<ul>
<li>进程使用 sigaction` 方法发起 I/O 请求后收到确认请求，继续执行其他任务：进程处于运行态</li>
<li>网卡或者磁盘中的数据进入操作系统的缓冲区中：数据到达缓冲区</li>
<li>SIGIO 信号处理程序发出信号 <code>SIGIO</code> 通知进程可以开始读取数据</li>
<li>进程使用 <code>recvfrom</code> 同步阻塞式方法发起 I/O 请求将数据读取到进程内存中  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/22/5c9278b107be64e5de694dcf905b137d.png" alt="5c9278b107be64e5de694dcf905b137d.png" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
</li>
<li><p>异步 I/O 模型：</p>
<ul>
<li>进程使用 <code>aio_read</code> 异步非阻塞式的方法发起 I/O 请求后继续执行自己的任务：始终处于运行态</li>
<li>[网卡或者磁盘中的数据进入操作系统的缓冲区中，操作系统将缓冲区的数据拷贝到进程内存空间]{.red}</li>
<li>操作系统通知进程数据已经准备完成可以直接使用  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/22/18a67cc67534c5479aa3fb04963553aa.png" alt="18a67cc67534c5479aa3fb04963553aa.png" style="zoom:80%;" /></li>
</ul>
</li>
</ul>

        <h2 id="Java-通信模型"   >
          <a href="#Java-通信模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java-通信模型" class="headerlink" title="Java 通信模型"></a>Java 通信模型</h2>
      <blockquote>
<p><strong>Java 通信模型</strong></p>
</blockquote>
<ul>
<li><p>前提：Linux 通信模型或者 Java 通信模型都是为了服务器开发而设计的，并不是客户端开发</p>
</li>
<li><p>BIO 编程模型</p>
<ul>
<li><p>对应关系：[Linux 阻塞式通信模型]{.red}</p>
</li>
<li><p>工具类：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://fuyusakaiori.github.io/Java/io/IO/" >传统 IO 类</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>服务器设计</p>
<ul>
<li><p>单线程模型：</p>
<ul>
<li>传统 IO 类提供的方法都是 [同步阻塞式]{.red} 的，所以单个线程仅能够负责单个用户</li>
<li>[如果服务器端仅提供单个线程，显然服务器就只能够为单个客户端提供服务，造成服务器端资源的浪费]{.blue}</li>
</ul>
</li>
<li><p>多线程模型</p>
<ul>
<li><p>v1：</p>
<ul>
<li><p>解决方案：++为了解决单线程模型的问题最直接的办法就是为每个连接的客户端都提供一个线程，每个线程都负责一个用户++</p>
<p>  +++ 缺点</p>
<ul>
<li>[大量线程的创建和销毁需要占用非常多的服务器资源]{.green}</li>
<li>[大量线程的创建和销毁需要占用非常多的服务器资源 大量线程的存在会导致服务器频繁的执行上下文切换，浪费线程的执行时间]{.green}</li>
</ul>
<p>  +++</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/BIO 通信模型.1h4z3970je9s.png" alt="BIO 通信模型" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>v2：（伪异步模型）</p>
<ul>
<li><p>解决方案：++为了避免v1版的多线程模型下创建销毁线程的开销，最直接的办法就是提供线程池，每个用户仅能够由已存在的线程提供服务++</p>
<p>  +++ 缺点</p>
<ul>
<li>[大量的线程依然会导致频繁的执行上下文切换]{.green}</li>
<li>[线程池的线程数量是固定的就会导致在大量请求同时发出时，必然存在客户端长时间等待的情况]{.green}</li>
</ul>
<p>  +++</p>
<p>  +++ 优点</p>
<p>  [避免服务器创建和销毁大量的线程造成的资源浪费]{.red}</p>
<p>  +++</p>
</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/伪异步.1u0xqicyiyrk.png" alt="伪异步" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>NIO 编程模型</p>
<ul>
<li><p>对应关系：</p>
<ul>
<li>原生 NIO 模型：Linux 同步非阻塞式模型</li>
<li>原生 NIO 模型 + Selector：Linux 多路复用式模型</li>
</ul>
</li>
<li><p>工具类：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://fuyusakaiori.github.io/Java/io/NIO/" >NIO 类</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>服务器设计：</p>
<ul>
<li><p>单线程版</p>
<ul>
<li><p>核心：</p>
<p>  伪异步模型中使用了线程池依然避免不了大量线程的存在，从而导致频繁的上下文切换，以及用户过长的等待时间</p>
<p>  最直接的解决方案依然是仅在客户端发出请求时，服务器端才给予相应的处理</p>
</li>
<li><p>同步非阻塞式模型（轮询模型）</p>
<ul>
<li><p>解决方案：++服务器端会不断地询问客户端是否有请求需要处理，如果没有则服务器端继续完成剩下的代码，如果有就处理客户端的请求++</p>
<p>  +++ 优点</p>
<p>  [减少服务器需要的线程数量，即单个线程就可以完成，避免资源的大量占用和上下文切换占用的时间]{.red}</p>
<p>  +++</p>
<p>  +++ 缺点</p>
<ul>
<li>[单个线程可能来不及 <strong>同时</strong> 处理多个客户端请求，依然存在客户端等待的情况]{.green}</li>
<li>[没有任何客户端发出请求时，服务器端存在 <strong>空转</strong> 的情况，浪费服务器资源]{.green}</li>
</ul>
<p>  +++</p>
</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/轮询模型.5v6m9wj7dfo0.png" alt="轮询模型" style="zoom:80%;" /></li>
<li><p>多路复用式模型</p>
<ul>
<li><p>解决方案：++为了处理轮询模型中出现的服务器端空转现象，最直接的方法就是只有在客户端发出请求的时候服务器端才处理，其余时候阻塞，利用 Selector 类可以做到监视客户端的功能，从而确认当前是否有事件发生++</p>
<p>  +++ 优点</p>
<ul>
<li>[减少服务器需要的线程数量，即单个线程就可以完成，避免资源的大量占用和上下文切换占用的时间]{.red}</li>
<li>[服务器不存在空转现象，只在有需要的时候提供服务，其余时候阻塞即可]{.red}</li>
</ul>
<p>  +++</p>
<p>  +++ 缺点</p>
<p>  [单个线程可能来不及 <strong>同时</strong> 处理多个客户端请求，依然存在客户端等待的情况]{.green}</p>
<p>  +++</p>
</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/多路复用.2shl0b9ohn40.png" alt="多路复用" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>多线程版：<a href="">Reactor</a>、<a href="">Proactor</a></p>
<blockquote>
<p>利用多线程彻底解决此前模型的等待问题</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>AIO 编程模型</p>
<ul>
<li><p>对应关系：Linux 异步非阻塞模型</p>
</li>
<li><p>工具类：<a href="">AIO 工具类</a></p>
</li>
<li><p>服务器设计</p>
<ul>
<li><p>解决方案：++进程向操作系统注册后继续完成自己的其他任务，操作系统在 IO 事件发生之后会自行寻找 AsynchronousChannelGroup 对象，调用线程池中的线程去执行之前编写好的回调函数，回调函数处理发生的 IO 事件，也就意味着进程在自己不知道的情况下就已经完成了 IO 事件++</p>
<p>  +++ 优点</p>
<ul>
<li>[异步非阻塞式模型不需要采用 Selector 轮询处理事件的方式而是采用订阅-通知的方式处理事件，效率更高]{.red}</li>
<li>[Linux 并没有实现真正的异步非阻塞式调用而是采用同步式的 epoll 调用进行模拟的，之前提到过 epoll，确实很类似 AIO]{.red}</li>
<li>[Windows 下实现了真正的异步非阻塞式调用，采用的是 IOCP 技术]{.red}</li>
</ul>
<p>  +++</p>
<p>  +++ 缺点</p>
<p>  [程序的编写相对复杂并且不是很好理解]{.green}</p>
<p>  +++</p>
</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/AIO.i95xm33f7co.png" alt="AIO" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/08/18/java/io/NIO/">NIO</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-08-18</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-14</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="NIO"   >
          <a href="#NIO" class="heading-link"><i class="fas fa-link"></i></a><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1>
      <p>:::primary</p>
<p>前提：熟练掌握传统 <code>I/O</code> 核心思想及其核心类，便于和新 <code>I/O</code> 进行相应的对比学习</p>
<p>:::</p>

        <h2 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h2>
      <blockquote>
<p><strong>什么是 NIO？</strong></p>
</blockquote>
<ul>
<li>名称：<ul>
<li><code>NIO</code> 在 <code>JDK 1.4</code> 之后提供，所以官方定义为 <code>New I/O</code>，用于区别 <code>JDK 1.1</code> 提供的传统 <code>I/O</code></li>
<li><code>NIO</code> 具有 ++非阻塞++ 的特性，所以也通常被称为 <code>No-Blocking I/O</code>，用于区别传统的 <code>Blocking I/O</code></li>
</ul>
</li>
<li>细节：[推出 NIO 之后，传统 I/O 的底层重新采用 NIO 实现了一次，从而提升传统 I/O 的速度]{.blue}</li>
</ul>
<blockquote>
<p><strong>什么是阻塞式 I/O？什么又是非阻塞式 I/O</strong>（之前 I/O 概述中已经提到过再次重复一遍）</p>
</blockquote>
<ul>
<li>阻塞与非阻塞：[读写方法是否为阻塞式调用]{.red}<ul>
<li>阻塞式：服务器的线程调用 <code>传统 I/O</code>，此线程就必须一直等待客户端发送消息，[线程在此期间什么都不能做]{.red}</li>
<li>非阻塞式：服务器的线程调用 <code>新 I/O</code>，此线程只需要在客户端发送消息的时候才去接收，[线程在此期间可以完成其他任务]{.red}</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>为什么需要提供非阻塞式的 I/O？</strong></p>
</blockquote>
<ul>
<li><p>核心：[减少线程对于服务器资源的占用以及服务器上下文切换占用的时间]{.red}</p>
<p>  !!线程、线程池以及上下文切换的概念及其特性参考操作系统相关知识!!{.bulr}</p>
</li>
<li><p>服务器初期设计（<code>BIO</code>）：</p>
<ul>
<li><p>背景：服务器显然需要处理大量客户端发来的请求，每个线程因为采用传统 <code>I/O</code>，所以仅能够处理一个客户端请求</p>
</li>
<li><p>核心：</p>
<ul>
<li><p>[多线程处理用户请求]{.red}</p>
</li>
<li><p>每个客户端发来请求时，服务器都 [创建相应的线程]{.red} 负责处理客户端的请求，处理结束后 [线程销毁]{.red}</p>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/18/85bed0bbdb4705d0e11ebf6ebe860b23.png" alt="85bed0bbdb4705d0e11ebf6ebe860b23.png" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>[大量线程的创建和销毁需要占用非常多的服务器资源]{.green}</li>
<li>[大量线程的存在会导致服务器频繁的执行上下文切换，浪费线程的执行时间]{.green}</li>
</ul>
</li>
</ul>
</li>
<li><p>服务器改进设计（<code>伪异步 I/O</code>）：</p>
<ul>
<li><p>背景：没有推出 <code>新 I/O</code> 的情况下，显然想要避免大量线程的创建和销毁就只能采用 [线程池技术]{.blue}</p>
</li>
<li><p>核心：</p>
<ul>
<li><p>[线程池技术]{.red}</p>
</li>
<li><p>服务器创建线程池，线程的管理全部交给线程池负责，服务器 [“可以完成其他的任务”]{.blue}，这就是所谓的伪异步</p>
</li>
<li><p>服务器 “可以完成其他任务”只是给人的一种错觉，因为只要建立的是 [TCP]{.red} 连接，那么服务器只能处于阻塞状态，等待客户端发来请求</p>
<p>  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/18/5ab06e96145063ffd4c734a80e1b4551.png" alt="5ab06e96145063ffd4c734a80e1b4551.png"></p>
</li>
</ul>
</li>
<li><p>优点：[避免服务器创建和销毁大量的线程造成的资源浪费]{.red}</p>
</li>
<li><p>缺点：</p>
<ul>
<li>[大量的线程依然会导致频繁的执行上下文切换]{.green}</li>
<li>[线程池的线程数量是固定的就会导致在大量请求同时发出时，必然存在客户端长时间等待的情况]{.green}</li>
</ul>
</li>
</ul>
</li>
<li><p>服务器现有设计（<code>NIO</code>）：</p>
<ul>
<li><p>背景：无论如何，大量的线程都会造成服务器资源消耗，所以考虑能不能 [每个线程处理多个客户端请求]{.blue}，从而减少线程的数量</p>
</li>
<li><p>核心：</p>
<ul>
<li><p>[Channel 类使得线程可以采用非阻塞式的读写方法，而不需要一直等待客户端请求]{.red}</p>
<blockquote>
<p><strong>那么线程如何才能在做其他事情的时候，知道有客户端发送请求了呢？</strong></p>
</blockquote>
</li>
<li><p>[Selector 类可以监视多个客户端是否发送消息]{.red}</p>
</li>
<li><p>服务器只需要创建少量的线程，线程监视每个客户端</p>
<ol>
<li>如果没有任何客户端发送请求，线程可以根据服务器的需要完成其他的事件</li>
<li>如果某个客户端突然发送请求，线程立刻就回去处理该客户端发送的请求</li>
<li>如果线程监视的多个客户端同时发送请求，线程需要按照一定的顺序依次处理</li>
</ol>
</li>
</ul>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/18/1509fb72aeea89d73f037b7c9cada762.png" alt="1509fb72aeea89d73f037b7c9cada762.png" style="zoom:80%;" /></li>
<li><p>优点：[减少服务器需要的线程数量，避免资源的大量占用和上下文切换占用的时间]{.red}</p>
</li>
<li><p>缺点：[单个线程可能来不及同时处理多个客户端请求，依然存在客户端等待的情况]{.green}</p>
</li>
</ul>
</li>
</ul>

        <h2 id="核心类"   >
          <a href="#核心类" class="heading-link"><i class="fas fa-link"></i></a><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2>
      
        <h3 id="新特性"   >
          <a href="#新特性" class="heading-link"><i class="fas fa-link"></i></a><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3>
      <ul>
<li><p>核心：[传统 I/O 是 <strong>面向流</strong> 设计的，新 I/O 是面向 <strong>缓冲区</strong> 设计的]{.red}</p>
</li>
<li><p><code>Channel</code>：</p>
<ul>
<li>名称：通常直译为通道</li>
<li>新特性：<ul>
<li>[Channel 取代传统 I/O 中的 InputStream 和 OutputStream，实现双向读写]{.blue}</li>
<li>[Channel 具有非阻塞的特性，不过需要手动设置，默认为阻塞]{.blue}</li>
</ul>
</li>
<li>细节：<ul>
<li>[Channel 必须借助缓冲区 Buffer 才可以将数据交付给进程]{.blue}</li>
<li>[Channel 之间可以直接交换数据]{.blue}</li>
</ul>
</li>
</ul>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/22/5689b4d52a045ff5ae72f35155029a89.png" alt="5689b4d52a045ff5ae72f35155029a89.png" style="zoom:80%;" /></li>
<li><p><code>Buffer</code>：</p>
<ul>
<li>名称：缓冲区</li>
<li>新特性：[可以存储大量的数据，便于一次性读写完成，实现双向读写]{.blue}</li>
</ul>
</li>
<li><p><code>Selector</code></p>
<ul>
<li>名称：选择器</li>
<li>新特性：<ul>
<li>[采用轮询的方式监视多个 Channel 上的事件，如果发生事件就会通知服务器进行处理，如果没有发生事件就阻塞服务器]{.blue}</li>
<li>[实现 I/O 多路复用模型中的 Reactor 模型]{.blue}</li>
</ul>
</li>
</ul>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/22/bb0faea705a6c70db4c16fe1b510a1ba.png" alt="bb0faea705a6c70db4c16fe1b510a1ba.png" style="zoom:80%;" /></li>
</ul>

        <h3 id="Buffer"   >
          <a href="#Buffer" class="heading-link"><i class="fas fa-link"></i></a><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3>
      <blockquote>
<p><strong>缓冲区：基础知识</strong></p>
</blockquote>
<ul>
<li><p>定义：每个<code>Channel</code> 都需要先将 [数据写入缓冲区或者从缓冲区中读入数据]{.blue}，然后客户端或者服务器从缓冲区中获取数据</p>
</li>
<li><p>特点：① 抽象类 ② [底层采用数组实现]{.red} ③ [既可以读取也可以写入]{.red}</p>
</li>
<li><p>子类</p>
<ul>
<li><p>[核心子类]{.red}：<code>ByteBuffer</code></p>
</li>
<li><p>其余子类：<code>IntBuffer、LongBuffer、CharBuffer、FloatBuffer、DoubleBuffer</code></p>
<p>  注：[ByteBuffer 用于传输二进制的数据，也就意味着可以传输任何类型的文件，用途相比于其他子类更加广泛]{.blue}</p>
</li>
</ul>
</li>
<li><p>内部结构</p>
<ul>
<li><p>写模式：每次向缓冲区中写入数据，<code>position</code> 指针都会相应的向前移动</p>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/18/b8e02b3c24bb877d3e9d5a8f2039228b.png" alt="b8e02b3c24bb877d3e9d5a8f2039228b.png" style="zoom:80%;" /></li>
<li><p>翻转：</p>
<ul>
<li><p>缓冲区读取数据是从起始指针开始读取的，而写模式下的 <code>position</code> 指针并没有指向写入的数据</p>
</li>
<li><p>[处于写模式下的缓冲区是无法直接读取到写入的数据，需要经过翻转操作后才可以读取数据]{.red}</p>
</li>
<li><p><code>position</code> 指针重新指向缓冲区开头，<code>limit</code> 指针指向写入数据的末尾</p>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/18/b81a2df08a90aca872acf6bff4326eca.png" alt="b81a2df08a90aca872acf6bff4326eca.png" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>读模式：</p>
<ul>
<li><p>每次从缓冲区中读出数据，<code>position</code> 指针都会向前移动</p>
</li>
<li><p>读取数据存在两种情况：</p>
<ol>
<li><p>缓冲区中的数据已经被读取完毕：调用 [清空]{.red} 的方法重新返回写模式</p>
</li>
<li><p>缓冲区中的数据没有被全部读取：调用 [压缩]{.red} 的方法重新返回写模式</p>
 <img src="https://i1.xpic.jp/file/xpicjp/2021/08/18/95c63f409ed4df541187e6340ae63989.png" alt="95c63f409ed4df541187e6340ae63989.png" style="zoom:80%;" /></li>
</ol>
</li>
</ul>
</li>
<li><p>清空：<code>position</code> 指针重新移动到缓冲区开头，<code>limit</code> 指针重新移动到缓冲区结尾</p>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/18/6e570f500925a0f79dcc168c90cec5a7.png" alt="6e570f500925a0f79dcc168c90cec5a7.png" style="zoom:80%;" /></li>
<li><p>压缩：[将没有被读取的数据移动到缓冲区开头]{.red}，<code>position</code> 指针移动到没有被读取的数据后面，<code>limit</code> 指针重新移动到缓冲区结尾</p>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/18/af734a77fd91f2110f46b4f77e9ab622.png" alt="af734a77fd91f2110f46b4f77e9ab622.png" style="zoom:80%;" />

<p>  注：[无论是清空还是压缩方法，缓冲区中的数据都没有被实际清除，仅仅只是将指针重新移动到开始的位置而已]{.red}</p>
</li>
</ul>
</li>
<li><p>构造方法：[缓冲区抽象类创建对象采用单例模式，也就是说构造方法是私有的]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Buffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap) &#123;       <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">if</span> (cap &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Negative capacity: &quot;</span> + cap);</span><br><span class="line">    <span class="keyword">this</span>.capacity = cap;</span><br><span class="line">    limit(lim);</span><br><span class="line">    position(pos);</span><br><span class="line">    <span class="keyword">if</span> (mark &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mark &gt; pos)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;mark &gt; position: (&quot;</span></span><br><span class="line">                                               + mark + <span class="string">&quot; &gt; &quot;</span> + pos + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.mark = mark;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>方法</p>
<ul>
<li><p><code>put() &amp; get()</code>：[Buffer 抽象类没有提供读取和写入方法具体实现 -&gt; 交付给子类自行实现读取和写入的方法]{.red}</p>
</li>
<li><p><code>compact()</code>：[Buffer 抽象类也没有提供压缩方法的具体实现]</p>
</li>
<li><p><code>flip()</code>：[缓冲区从写模式切换到读模式]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*不允许子类重写的方法*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// limit 指针移动到 position 指针处</span></span><br><span class="line">    limit = position;</span><br><span class="line">    <span class="comment">// position 指针重新移动到缓冲区开始的位置</span></span><br><span class="line">    position = <span class="number">0</span>;		</span><br><span class="line">    mark = -<span class="number">1</span>;			</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;				</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p><code>clear()</code>：[清空缓冲区并且从读模式切换到写模式]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p><code>rewind()</code>：[重新将 <code>position</code> 指针移动到缓冲区起始位置]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p><code>hasremaning()</code>：[缓冲区中是否还存在数据]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasRemaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> position &lt; limit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>

        <h4 id="ByteBuffer"   >
          <a href="#ByteBuffer" class="heading-link"><i class="fas fa-link"></i></a><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h4>
      <blockquote>
<p><strong>字节缓冲区：基础知识</strong></p>
</blockquote>
<ul>
<li>特点：仅能够存放字节类型的数据</li>
<li>子类：<ul>
<li><code>MappedByteBuffer</code></li>
<li><code>DirectByteBuffer</code>：[采用物理机中的真实内存作为缓冲区，读写效率高，创建效率低，容易出现内存泄露问题]{.red}</li>
<li><code>HeadByteBuffer</code>：[采用虚拟机中的堆内存作为缓冲区，读写效率较低，创建效率较高]{.red}</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>字节缓冲区：方法</strong></p>
</blockquote>
<ul>
<li><p>创建缓冲区对象</p>
<ul>
<li><p>实例：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建缓冲区对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createBuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 缓冲区使用堆内存: 缓冲区中的数据会受到虚拟机的垃圾回收机制的影响, 读写效率相对较低</span></span><br><span class="line">    ByteBuffer heapBuffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 缓冲区采用直接内存(系统内存): </span></span><br><span class="line">    <span class="comment">// 缓冲区中的数据不会收到垃圾回收机制的影响, 读写效率高, 创建对象效率较低</span></span><br><span class="line">    <span class="comment">// 缓冲区中的数据如果没有合理释放,容易导致内存溢出或者泄露</span></span><br><span class="line">    ByteBuffer directBuffer = ByteBuffer.allocateDirect(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>方法：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*堆内存缓冲区*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 返回的是 HeapByteBuffer 对象，也就是 ByteBuffer 的子类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(capacity, capacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*直接内存缓冲区*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回的是 DirectByteBuffer 对象，也就是 ByteBuffer 的子类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>读取和写入缓冲区：</p>
<ul>
<li><p>字符串转换为字节方式：[缓冲区只能够存放字节类型的数据，所以需要将发送的数据转换为字节类型]{.blue}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串转换为字节类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stringToBytes</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 缓冲区</span></span><br><span class="line">    ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">50</span>);</span><br><span class="line">    <span class="comment">// 1.直接利用字符串类提供的方法</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="string">&quot;Hello,World!&quot;</span>.getBytes();</span><br><span class="line">    <span class="comment">// 手动将字节数组放入缓冲区中</span></span><br><span class="line">    buffer1.put(bytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.利用 NIO 提供的字符串转换方式：方法返回值就是缓冲区，不需要手动添加数据</span></span><br><span class="line">    ByteBuffer buffer2 = StandardCharsets.UTF_16.encode(<span class="string">&quot;Hello,World&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 利用缓冲区自身提供的方法实现字符串转换</span></span><br><span class="line">    ByteBuffer buffer3 = ByteBuffer.wrap(<span class="string">&quot;Hello,World!&quot;</span>.getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>读取和写入方式</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取和写入缓冲区的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readOrWriteBuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="comment">// 仅写入单个字符</span></span><br><span class="line">    buffer.put((<span class="keyword">byte</span>)<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    <span class="comment">// 指定字符写入的位置</span></span><br><span class="line">    buffer.put(<span class="number">1</span>, (<span class="keyword">byte</span>)<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    <span class="comment">// 写入字符数组</span></span><br><span class="line">    buffer.put(<span class="string">&quot;Hello,World&quot;</span>.getBytes());</span><br><span class="line">    <span class="comment">// 写入其他的缓冲区</span></span><br><span class="line">    buffer.put(StandardCharsets.UTF_16.encode(<span class="string">&quot;你好~&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲区记得翻转</span></span><br><span class="line">    buffer.flip();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;当前位置: &quot;</span> + buffer.position());</span><br><span class="line">    <span class="comment">// 读取单个字节：每次读取, position 指针是会向前移动的</span></span><br><span class="line">    System.out.println((<span class="keyword">char</span>) buffer.get());</span><br><span class="line">    System.out.println(<span class="string">&quot;当前位置: &quot;</span> + buffer.position());</span><br><span class="line">    <span class="comment">// 读取指定位置的字节: 每次读取, position 指针都是不会移动的</span></span><br><span class="line">    <span class="comment">// 指定的位置：当前 position 指针 + 给出的 index</span></span><br><span class="line">    System.out.println((<span class="keyword">char</span>) buffer.get(<span class="number">2</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;当前位置: &quot;</span> + buffer.position());</span><br><span class="line">    <span class="comment">// 读取字节数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 每次读取一个字节数组的大小，将字节存放在字节数组中，并且 position指针 也是会向前移动的</span></span><br><span class="line">    <span class="comment">// 返回值是 ByteBuffer：并不是新创建一个缓冲区，而是返回当前缓冲区在读取一个字节数组之后的状态</span></span><br><span class="line">    ByteBuffer byteBuffer = buffer.get(bytes);</span><br><span class="line">    System.out.println(<span class="string">&quot;当前位置: &quot;</span> + buffer.position());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>读写文件：[需要提前用到 Channel ]{.blue}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用 NIO 核心类读取文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFileByNIO</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 利用文件流获取到相应的通道</span></span><br><span class="line">    FileChannel channel = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;file.txt&quot;</span>)).getChannel();</span><br><span class="line">    <span class="comment">// 为缓冲区分配大小</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 从通道中读取数据 -&gt; 将通道中读取的数据写入缓冲区 -&gt; 服务器/客户端从缓冲区中接收数据</span></span><br><span class="line">    <span class="comment">// 读取次数</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环读取通道中的数据: 这里缓冲区大小仅有 5 字节, 而文本含有 12 字节, 显然需要读 3 次</span></span><br><span class="line">    <span class="keyword">while</span> (channel.read(buffer) != -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将缓冲区中的数据读取出来: 先进行翻转后读取</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="comment">// 循环读出缓冲区中的数据</span></span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 只能一个字节一个字节地读取</span></span><br><span class="line">            System.out.print((<span class="keyword">char</span>) buffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n读取次数: &quot;</span> + ++count);</span><br><span class="line">        <span class="comment">// 需要再次向缓冲区中写入数据：先将缓冲区清空后写入</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭通道</span></span><br><span class="line">    channel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
<p>​    </p>
<blockquote>
<p><strong>字节缓冲区：分散读取 + 集中写入</strong></p>
</blockquote>
<ul>
<li><p>分散读取（ScatteringRead）：[从通道中的读取的数据同时向多个缓冲区写入数据 -&gt; 最后从多个缓冲区中读取数据]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分散读取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scatteringRead</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FileChannel fileChannel = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;file.txt&quot;</span>)).getChannel();</span><br><span class="line">    <span class="comment">// 多个缓冲区</span></span><br><span class="line">    ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">    ByteBuffer buffer2 = ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    ByteBuffer buffer3 = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 通道中的数据同时写入到多个缓冲区中</span></span><br><span class="line">    fileChannel.read(<span class="keyword">new</span> ByteBuffer[]&#123;buffer1, buffer2, buffer3&#125;);</span><br><span class="line">    <span class="comment">// 从多个缓冲区中分别读取数据：分散读取</span></span><br><span class="line">    buffer1.flip();</span><br><span class="line">    <span class="keyword">while</span> (buffer1.hasRemaining())</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print((<span class="keyword">char</span>) buffer1.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>集中写入（GatheringWrites）：[向缓冲区中写入数据 -&gt; 同时从多个缓冲区中读取数据并且写入通道中]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gatheringWrites</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FileChannel fileChannel = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;newfile.txt&quot;</span>)).getChannel();</span><br><span class="line">    <span class="comment">// 多个缓冲区</span></span><br><span class="line">    ByteBuffer buffer1 = StandardCharsets.UTF_8.encode(<span class="string">&quot;Hello,World\n&quot;</span>);</span><br><span class="line">    ByteBuffer buffer2 = Charset.defaultCharset().encode(<span class="string">&quot;你好~\n&quot;</span>);</span><br><span class="line">    ByteBuffer buffer3 = ByteBuffer.wrap(<span class="string">&quot;I/O 模型是个啥啊\n&quot;</span>.getBytes());</span><br><span class="line">    <span class="comment">// 同时从多个缓冲区中读取数据后写入通道中</span></span><br><span class="line">    fileChannel.write(<span class="keyword">new</span> ByteBuffer[]&#123;buffer1, buffer2, buffer3&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
<blockquote>
<p><strong>字节缓冲区：黏包半包分析</strong></p>
</blockquote>
<ul>
<li><p>问题：</p>
<ul>
<li><p>客户端向服务器发送多条消息，每条消息采用换行符分割开来</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送的消息: </span></span><br><span class="line"><span class="string">&quot;Hello,World!\n&quot;</span> </span><br><span class="line"><span class="string">&quot;Persona5\n&quot;</span> </span><br><span class="line"><span class="string">&quot;Tohou\n&quot;</span></span><br></pre></td></tr></table></div></figure></li>
<li><p>通道能够写入的数据是 [有限]{.red} 的，缓冲区可能一次无法将所有的数据全部写入通道中</p>
<p>  导致缓冲区中遗留下来的数据和下次写入缓冲区中的数据进行重新组合，接收方接收到混乱的数据</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 黏包半包现象</span></span><br><span class="line"><span class="comment">// 半包现象：仅有部分数据被接收到</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="comment">// 黏包想象：多个数据被连接起来形成一条数据</span></span><br><span class="line"><span class="string">&quot;,World!\nPersona5\nTohou&quot;</span></span><br></pre></td></tr></table></div></figure></li>
<li><p>简单的解决方案</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单解决黏包半包现象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(ByteBuffer buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 缓冲区切换成读模式</span></span><br><span class="line">    buffer.flip();</span><br><span class="line">    <span class="comment">// 存放完整消息的缓冲区</span></span><br><span class="line">    ByteBuffer destination;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.limit(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果读取到换行符就把前面所有字节读取出来</span></span><br><span class="line">        <span class="keyword">if</span> (buffer.get(i) == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[i + <span class="number">1</span> - buffer.position()];</span><br><span class="line">            buffer.get(bytes);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>)b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后如果缓冲区中仍然存在不完整的消息：那么将剩余数据压缩到缓冲区头部</span></span><br><span class="line">    buffer.compact();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>

        <h3 id="Channel"   >
          <a href="#Channel" class="heading-link"><i class="fas fa-link"></i></a><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3>
      <ul>
<li>特点：① 抽象类 ② 可读可写 ③ 通道中的数据必须经过缓冲区后才可以输出 ④ 通道提供的方法默认为阻塞式调用，可以选择设置为非阻塞式调用</li>
<li>子类<ul>
<li>文件通道：<code>FileChannel</code><ul>
<li><code>FileChannel</code> 仅提供阻塞式方法，并且不能够使用 <code>Selector</code> 优化传输过程</li>
<li><code>FileChannel</code> 可以创建单向的通道对象，也可以创建双向的通道对象</li>
</ul>
</li>
<li>网络通道：<ul>
<li><p>UDP 连接：<code>DatagramChannel</code></p>
</li>
<li><p>TCP 连接：<code>ServerSocketChannel、SocketChannel</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h4 id="FileChannel"   >
          <a href="#FileChannel" class="heading-link"><i class="fas fa-link"></i></a><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h4>
      <blockquote>
<p><strong>文件通道：基础知识</strong></p>
</blockquote>
<ul>
<li>定义：文件之间交互数据的通道</li>
<li>特点：<ul>
<li>可以利用流对象和随机流对象创建文件通道：流对象创建的通道是单向的，随机流对象创建的通道可以双向可以单向</li>
<li>可以利用静态方法创建对象（单例模式）</li>
<li>[文件通道仅能够采用阻塞式方法进行数据的传输]{.red}</li>
<li>[文件通道之间可以不借助缓冲区直接交互数据、其余通道子类必须借助缓冲区交互数据]{.red}</li>
<li>[写入文件通道的数据并不会立刻被操作系统写入文件，而是会先写入内存的缓冲区，等待缓冲区充满之后才会全部写入]{.red}</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>文件通道：方法</strong></p>
</blockquote>
<ul>
<li><p>创建文件通道</p>
<ul>
<li><p>利用文件流获取通道：<code>FileInputStream</code> 获取通道；<code>FileOutputStream</code> 获取通道</p>
<ul>
<li><p>[通道本身具有双向性，但是通过文件流获取的通道依然只能够单向传输]{.red}</p>
</li>
<li><p>[单向通道不可以调用反向的方法，否则会抛出异常]{.red}（<code>NonWritableChannelException、NonReadableChannelException</code>）</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文件通道</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getFileChannel</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FileChannel fileInputChannel = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;file.txt&quot;</span>)).getChannel();</span><br><span class="line">    FileChannel fileOutputChannel = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;file.txt&quot;</span>)).getChannel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>利用随机文件流获取通道：[指定随机文件流为可读可写时，获取的通道才具有双向性]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文件通道</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getFileChannel</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FileChannel fileChannel = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">&quot;file.txt&quot;</span>), <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line">    <span class="comment">// 既可以读取也可以写入</span></span><br><span class="line">    filechannel.read(...);</span><br><span class="line">    filechannel.write(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>利用工具类创建获取通道</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建双向的文件通道</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getDoubleChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 指定当前的通道类型：只能够指定一个</span></span><br><span class="line">    FileChannel fileChannel1 = FileChannel.open(Paths.get(<span class="string">&quot;file.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">    <span class="comment">// 指定当前通道的类型：可以指定多个，也就意味着通道可以实现双向性</span></span><br><span class="line">    Set&lt;OpenOption&gt; openOptions = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Collections.addAll(openOptions, StandardOpenOption.WRITE, StandardOpenOption.READ);</span><br><span class="line">    FileChannel fileChannel2 = FileChannel.open(Paths.get(<span class="string">&quot;file.txt&quot;</span>), openOptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>文件通道读写方法</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通道的读写方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">channelReadAndWrite</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用双向的文件通道</span></span><br><span class="line">    Set&lt;OpenOption&gt; openOptions = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Collections.addAll(openOptions, StandardOpenOption.WRITE, StandardOpenOption.READ);</span><br><span class="line">    FileChannel fileChannel = FileChannel.open(Paths.get(<span class="string">&quot;file.txt&quot;</span>), openOptions);</span><br><span class="line">    ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">12</span>);</span><br><span class="line">    ByteBuffer buffer2 = ByteBuffer.allocate(<span class="number">12</span>);</span><br><span class="line">    ByteBuffer buffer3 = ByteBuffer.allocate(<span class="number">12</span>);</span><br><span class="line">    <span class="comment">// 写入单个缓冲区</span></span><br><span class="line">    fileChannel.read(buffer1);</span><br><span class="line">    <span class="comment">// 写入多个缓冲区</span></span><br><span class="line">    fileChannel.read(<span class="keyword">new</span> ByteBuffer[]&#123;buffer1, buffer2, buffer3&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取单个缓冲区</span></span><br><span class="line">    fileChannel.write(buffer1);</span><br><span class="line">    <span class="comment">// 读取多个缓冲区</span></span><br><span class="line">    fileChannel.write(<span class="keyword">new</span> ByteBuffer[]&#123;buffer1, buffer2, buffer3&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>文件通道相互传递数据：[通道借助缓冲区可以交互数据，也可以通道之间直接交互数据，效率更高 -&gt; 用于实现文件拷贝]{.red}</p>
<ul>
<li><p>通道借助缓冲区交互数据</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通道间通信</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">channelTransfer</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ByteBuffer byteBuffer = StandardCharsets.UTF_8.encode(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">    FileChannel fic = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;file.txt&quot;</span>)).getChannel();</span><br><span class="line">    FileChannel foc = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;newfile.txt&quot;</span>)).getChannel();</span><br><span class="line">    <span class="comment">// 借助缓冲区交互数据</span></span><br><span class="line">    fic.read(byteBuffer);</span><br><span class="line">    byteBuffer.flip();</span><br><span class="line">    foc.write(byteBuffer);</span><br><span class="line">    byteBuffer.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>通道之间直接交互数据</p>
<ul>
<li>[每次通道仅能够交互 2G 的数据，超出传输限制后就不能够一次传输完成]{.red}</li>
<li>实际测试每次传输最大为 2079MB 的大小</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通道间通信</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">channelTransfer</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ByteBuffer byteBuffer = StandardCharsets.UTF_8.encode(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">    FileChannel fic = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;file.txt&quot;</span>)).getChannel();</span><br><span class="line">    FileChannel foc = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;newfile.txt&quot;</span>)).getChannel();</span><br><span class="line">    <span class="comment">// 直接交互大量数据: 文件通道超过 2G 后就没有办法一次性交互完成了</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> length = fic.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; length;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// transferTo 会返回写入的字节数量</span></span><br><span class="line">        i = fic.transferTo(i , length - i, foc);</span><br><span class="line">        System.out.println(i + <span class="string">&quot;\t&quot;</span> + ++count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>文件通道：工具类</strong></p>
</blockquote>
<ul>
<li><p>前提：<code>JDK 1.7</code> 之后提供了新的文件工具类 <code>Path &amp; Files</code></p>
</li>
<li><p>Path &amp; Paths</p>
<ul>
<li><p>定义：Path 采用文件路径的表示文件的 [接口]{.red}；Paths 类是用来构建 Path 对象的工具类</p>
</li>
<li><p>归属：<code>package java.nio.file;</code></p>
<p>  注：为什么提到这个呢？因为 <code>package javafx.scene.shape;</code> 包中同样提供了 Path 类</p>
</li>
<li><p>方法：</p>
<ul>
<li><p>Path：提供的方法和 File 文件类相近，不再加以赘述</p>
</li>
<li><p>Paths：创建实现了 Path 接口的对象</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Path 文件对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createPath</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Path path = Paths.get(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>Files</p>
<ul>
<li><p>定义：用于控制 Path 文件路径表示的文件</p>
</li>
<li><p>归属：<code>package java.nio.file;</code></p>
</li>
<li><p>新增目录</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Files 工具类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filesToAdd</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Path path = Paths.get(<span class="string">&quot;first/second/file.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 检验路径表示的文件是否存在</span></span><br><span class="line">    Files.exists(path);</span><br><span class="line">    <span class="comment">// 创建单级目录: 如果创建的是多级目录的话就会报错</span></span><br><span class="line">    Files.createDirectory(path);</span><br><span class="line">    <span class="comment">// 创建多级目录</span></span><br><span class="line">    Files.createDirectories(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>删除文件/目录</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filesToDel</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Path path = Paths.get(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line">    Path directory = Paths.get(<span class="string">&quot;src/main/java/network/&quot;</span>);</span><br><span class="line">    <span class="comment">// 删除文件: 如果文件不存在会报错</span></span><br><span class="line">    Files.delete(path);</span><br><span class="line">    <span class="comment">// 删除目录：如果目录不为空会报错</span></span><br><span class="line">    Files.delete(directory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>拷贝/移动文件</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filesToUpdate</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Path source = Paths.get(<span class="string">&quot;newfile.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 移动的位置的文件可以是不存在的，会自动帮你生成</span></span><br><span class="line">    Path destination = Paths.get(<span class="string">&quot;src/main/java/mynio/newfile.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 将文件复制到新的位置: 如果文件已经存在默认报错，可以设置选项强制覆盖已经存在的文件</span></span><br><span class="line">    Files.copy(source, destination, StandardCopyOption.REPLACE_EXISTING);</span><br><span class="line">    <span class="comment">// 将文件移动到新的位置: 保证文件移动的原子性</span></span><br><span class="line">    Files.move(source, destination, StandardCopyOption.ATOMIC_MOVE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>遍历目录：<code>JDK 1.7</code> 以前遍历文件目录是需要采用递归手动实现的</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用 walktree 方法实现的目录遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filesToList</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Path directory = Paths.get(<span class="string">&quot;D:\\动画\\魔法禁书目录&quot;</span>);</span><br><span class="line">    <span class="comment">// 计算文件数量: 使用原子整型类</span></span><br><span class="line">    <span class="comment">// 因为匿名内部类中所有变量都默认是 final, 所以不可以使用普通变量</span></span><br><span class="line">    AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    Files.walkFileTree(directory, <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line">        <span class="comment">// SimpleFileVisitor 的构造方法是受保护的，所以我们不可以直接构造其对象</span></span><br><span class="line">        <span class="comment">// 这里采用匿名内部类的方式，实际上是创建了继承 SimpleFileVisitor 的类</span></span><br><span class="line">        <span class="comment">// 理所应当地可以创建其子类的对象</span></span><br><span class="line">        <span class="comment">// 第一个重写方法：访问目录前需要完成的事情</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--&gt;&quot;</span>+dir);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二个重写的方法：访问到文件时需要完成的事情</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">            count.getAndIncrement();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.visitFile(file, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第三个需要重写的方法：退出目录时完成的事情</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&lt;--&quot;</span>+dir);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.postVisitDirectory(dir, exc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 输出文件数量</span></span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用 walk 实现方法实现目录遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filesToList</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Path directory = Paths.get(<span class="string">&quot;D:\\动画\\魔法禁书目录&quot;</span>);</span><br><span class="line">    AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">// 指定遍历的深度: 即可以向下遍历多少层级的目录</span></span><br><span class="line">    Files.walk(directory, <span class="number">4</span>).forEach(path -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (Files.isDirectory(path))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;目录: &quot;</span> + path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Files.isRegularFile(path))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件: &quot;</span> + path);</span><br><span class="line">            count.getAndIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>

        <h4 id="SocketChannel"   >
          <a href="#SocketChannel" class="heading-link"><i class="fas fa-link"></i></a><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h4>
      <ul>
<li><p>定义：客户端使用的通道端口</p>
</li>
<li><p>特点：</p>
<ul>
<li>仅能够利用静态方法创建对象（构造方法是受到保护的）</li>
<li>默认提供阻塞式的方法，可以设置为非阻塞式方法：[设置读写方法为非阻塞]{.red}</li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li><p>创建客户端端口对象：[客户端可以在创建端口对象的同时指定连接的服务器端口号]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对象时指定端口号并且连接该端口号：不需要手动连接服务器端口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SocketChannel sc = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">4396</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;客户端:启动成功&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动连接服务器端口号</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> viod <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SocketChannel sc = SocketChannel.open();</span><br><span class="line">    <span class="comment">// 客户端连接服务器: 调用 connect 方法连接不是 bind</span></span><br><span class="line">    sc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">4396</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>注册监听器（涉及到 Selector 类）</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">		</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>客户端实例</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SocketChannel sc = SocketChannel.open();</span><br><span class="line">    <span class="comment">// 客户端连接服务器: 调用 connect 方法连接不是 bind</span></span><br><span class="line">    sc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">4396</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;客户端:启动成功&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>调试技巧</p>
<ul>
<li><p>可以不用代码编写输入流或者写入固定的数据用以测试</p>
</li>
<li><p>可以在客户端最后一行代码旁打上 [断点]{.red}</p>
</li>
<li><p>启动服务器端后以调试（Debug）的方式启动客户端</p>
</li>
<li><p>在客户端的调试界面右击端口对象后，点击 <code>Evaluate Expression</code> 后直接编写代码调试</p>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/20/19c7119a8d00be28477bff5632bc05e4.png" alt="19c7119a8d00be28477bff5632bc05e4.png" style="zoom:80%;" /></li>
<li><p>编写代码调试，这样测试的代码就不用遗留下来</p>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/20/4cb5269b20102ec2c36264e49ea32e44.png" alt="4cb5269b20102ec2c36264e49ea32e44.png" style="zoom:80%;" /></li>
</ul>
</li>
</ul>

        <h4 id="ServerSocketChannel"   >
          <a href="#ServerSocketChannel" class="heading-link"><i class="fas fa-link"></i></a><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h4>
      <ul>
<li><p>定义：服务器端使用的端口</p>
</li>
<li><p>特点：</p>
<ul>
<li>仅能够利用静态方法创建对象（构造方法是受到保护的）</li>
<li>默认提供阻塞式的方法，可以设置为非阻塞式方法：[设置接收请求的方法为非阻塞]{.red}</li>
</ul>
</li>
<li><p>方法：</p>
<ul>
<li><p>创建服务器端口对象</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NIO 提供的端口对象不能够在创建的时候传入端口号：需要手动调用方法绑定</span></span><br><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();</span><br></pre></td></tr></table></div></figure></li>
<li><p>绑定端口号</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IO 提供的端口对象实际上内部就是调用了 bind 方法：只不过现在需要手动调用了</span></span><br><span class="line">ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">4396</span>));</span><br></pre></td></tr></table></div></figure></li>
<li><p>注册监听器（涉及到 Selector 类）</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Selector 类中详细解释：设置当前通道关心哪些事件，只要事件被监听到，服务器就不再阻塞</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>服务器实例</p>
<ul>
<li><p>传统 IO 实现的 BIO 通信模型需要使用多线程来满足多个客户端同时发出的请求</p>
</li>
<li><p>新 IO 实现的 NIO 通信模型只需要使用单线程就可以完全满足多个客户端同时发出请求</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 构造器时受到保护的: 通过静态方法创建对象</span></span><br><span class="line">    ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">    <span class="comment">// 绑定端口号</span></span><br><span class="line">    ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">4396</span>));</span><br><span class="line">    <span class="comment">// 改进: 手动设置为非阻塞 -&gt; accept 方法会非阻塞式调用</span></span><br><span class="line">    ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 创建缓冲区</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">36</span>);</span><br><span class="line">    <span class="comment">// 记录当前在线的客户端</span></span><br><span class="line">    List&lt;SocketChannel&gt; clients = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 服务器长时间运行</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        SocketChannel sc = ssc.accept();</span><br><span class="line">        <span class="keyword">if</span> (sc != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 只要服务器接收到客户端相应的请求就将其添加到集合汇总</span></span><br><span class="line">            clients.add(sc);</span><br><span class="line">            System.out.println(sc);</span><br><span class="line">            <span class="comment">// 改进：从客户端通道读取数据时也设置为非阻塞 -&gt; 读写方法变为非阻塞方法</span></span><br><span class="line">            sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读取客户端发送的消息</span></span><br><span class="line">        <span class="keyword">for</span> (SocketChannel client : clients)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 只有在读取到字节后才可以输出: read 方法没有读取到字节返回 0, 抛出异常返回 -1</span></span><br><span class="line">            <span class="keyword">if</span> (client.read(buffer) &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 输出缓冲区中的内容</span></span><br><span class="line">                readBuffer(buffer);</span><br><span class="line">                System.out.print(<span class="string">&quot;\t&quot;</span> + client + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>问题：思考一下，现在的服务器代码是否存在问题？如果存在问题，那么应该怎样解决？</p>
</li>
</ul>

        <h3 id="Selector"   >
          <a href="#Selector" class="heading-link"><i class="fas fa-link"></i></a><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3>
      <blockquote>
<p><strong>Selector：基础知识</strong></p>
</blockquote>
<ul>
<li><p>前情提要：</p>
<ul>
<li><p>问题：测试过之前的服务器代码就能够发现问题，服务器即使在没有客户端连接的情况下都在运行，非常占用服务器资源</p>
<p>  !!经过自己电脑测试之后发现，每开一个客户端进程，CPU 的资源利用率就会上涨将近 15%!!</p>
</li>
<li><p>目的：</p>
<p>  我们显然不希望在没有客户端请求到来的时候服务器也在不停地运行</p>
<p>  [我们需要的是服务器仅在客户端发来请求的时候才开始处理，其余时候阻塞就行]{.blue}</p>
</li>
<li><p>解决：[Selector 类]{.red}</p>
</li>
</ul>
</li>
<li><p>名称：直译为选择器</p>
</li>
<li><p>定义：Selector 监视 [事件]{.red} 的发生：只要事件发生就通知相应的通道来处理该事件，否则就阻塞服务器</p>
</li>
<li><p>核心：[<strong>将轮询的非阻塞机制优化成复用式的阻塞机制</strong>]{.red}</p>
<p>  注：Selector 并不是将阻塞变成非阻塞，而是对非阻塞机制进行优化，优化的结果就是阻塞机制</p>
</li>
<li><p>事件：[主要分为四种事件]{.red}</p>
<ul>
<li><code>SelectionKey.OP_ACCEPT</code>：服务器接收客户端连接请求时该事件发生</li>
<li><code>SelectionKey.OP_READ</code>：客户端发送数据时该事件发生</li>
<li><code>SelectionKey.OP_WRITE</code>：服务器端发送数据时该事件发生</li>
<li><code>SelectionKey.OP_CONNECT</code>：客户端向服务器发送连接请求时该事件发生</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>[Selector 可以被多个通道共同使用]{.red}</li>
<li>[Selector 可以监视同一个通道关注的多个事件]{.red}</li>
</ul>
</li>
<li><p>创建并注册 Selector</p>
<ul>
<li>创建：Selector 构造方法依然是受到保护的，仅能够通过静态方法创建实例对象</li>
<li>注册：<ul>
<li>概述：[ServerSocketChannel 对象]{.blue} 调用 <code>register</code> 方法</li>
<li>第一个参数：传入通道想要注册的监视器（注：是通道向监视器注册）</li>
<li>第二个参数：传入通道关注的事件（[注：通道可以同时关注多个事件]{.red}）</li>
<li>第三个参数：传入通道独占的缓冲区，主要在服务器发生 [写事件]{.red} 时会使用到</li>
<li>返回值：Selector 会为通道分配相应的管理员，用来管理该通道关注的所有事件</li>
</ul>
</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 服务器端口</span></span><br><span class="line">    ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">    ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">4396</span>));</span><br><span class="line">    ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 创建监视器（选择器）</span></span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    <span class="comment">// 服务器端注册监视器: 指定当前通道关注的事件</span></span><br><span class="line">    <span class="comment">// 返回值为监视器分配的管理员: 用于管理该通道关注的所有事件</span></span><br><span class="line">    SelectionKey key = ssc.register(selector, SelectionKey.OP_ACCEPT, <span class="keyword">null</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>阻塞服务器：Selector 调用 <code>select</code> 方法</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 只要没有事件发生，监视器就会阻塞服务器; 只要事件产生，就让服务器开始处理事件</span></span><br><span class="line">        selector.select();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>获取并且遍历事件集合</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取当前发生的事件集合: 因为可能多个客户端同时触发事件，所以是集合</span></span><br><span class="line">        Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">        <span class="comment">// 采用迭代器遍历集合: 后续涉及到移除事件</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">        <span class="comment">// 管理员判断当前是哪种事件发生了</span></span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 遍历事件集合处理事件</span></span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 获取当前的事件</span></span><br><span class="line">                SelectionKey sk = iterator.next();</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>处理事件</p>
<ul>
<li>处理接收事件</li>
<li>处理读事件</li>
<li>处理写事件</li>
</ul>
</li>
<li><p>移除事件</p>
</li>
</ul>
<blockquote>
<p><strong>Selector：相关问题</strong></p>
</blockquote>
<ul>
<li>处理客户端断开连接问题</li>
<li>处理消息边界问题</li>
<li>处理容量超出问题</li>
</ul>

        <h2 id="实例-多人聊天室"   >
          <a href="#实例-多人聊天室" class="heading-link"><i class="fas fa-link"></i></a><a href="#实例-多人聊天室" class="headerlink" title="实例: 多人聊天室"></a>实例: 多人聊天室</h2>
      <blockquote>
<p><strong>服务器端</strong></p>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.v5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多人聊天室: 采用 NIO + Selector 实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 服务器端口号: 默认使用的端口号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">7777</span>;</span><br><span class="line">    <span class="comment">// 缓冲区固定分配的空间大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">// 退出消息标识符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXIT = <span class="string">&quot;退出&quot;</span>;</span><br><span class="line">    <span class="comment">// 调用者可以根据需要使用其他的端口号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="comment">// 服务器端</span></span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel server;</span><br><span class="line">    <span class="comment">// 监听器</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatServer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_PORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatServer</span><span class="params">(<span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取客户端相关信息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getClientName</span><span class="params">(SocketChannel client)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;客户端[&quot;</span> + client.socket().getPort() + <span class="string">&quot;]:&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理连接事件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">acceptHandler</span><span class="params">(SelectionKey selectionKey)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 通知相应的通道来处理事件: 服务器端开始处理</span></span><br><span class="line">        ServerSocketChannel server = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">        <span class="comment">// 获取客户端连接</span></span><br><span class="line">        SocketChannel client = server.accept();</span><br><span class="line">        <span class="comment">// 打印提示信息</span></span><br><span class="line">        System.out.println(getClientName(client) + <span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">        <span class="comment">// 客户端同样设置为非阻塞</span></span><br><span class="line">        client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 客户端向选择器注册: 每个客户端都有属于自己的专属缓冲区</span></span><br><span class="line">        client.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(BUFFER_SIZE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转发消息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">forward</span><span class="params">(Set&lt;SelectionKey&gt; selectionKeys, SocketChannel client, ByteBuffer buffer)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 开始处理事件: 获取所有注册在监听器上的通道</span></span><br><span class="line">        Set&lt;SelectionKey&gt; keys = selector.keys();</span><br><span class="line">        <span class="comment">// 开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (SelectionKey receiver : keys)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 因为获取的是所有的事件而不是发生的所有事件, 所以这里面包含服务器端要处理的事件</span></span><br><span class="line">            <span class="comment">// 我们只需要向客户端转发消息, 所有只需要处理对应通道为客户端的事件, 而不需要服务器端的</span></span><br><span class="line">            <span class="keyword">if</span> (receiver.channel() <span class="keyword">instanceof</span> SocketChannel)</span><br><span class="line">            &#123;</span><br><span class="line">                SocketChannel channel = (SocketChannel) receiver.channel();</span><br><span class="line">                <span class="keyword">if</span> (channel != client)</span><br><span class="line">                &#123;</span><br><span class="line">                    buffer.rewind();</span><br><span class="line">                    channel.write(buffer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断客户端是否退出</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isExit</span><span class="params">(ByteBuffer buffer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(StandardCharsets.UTF_8.decode(buffer)).contains(EXIT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理读事件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readHandler</span><span class="params">(SelectionKey selectionKey)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 缓冲区</span></span><br><span class="line">        ByteBuffer buffer = (ByteBuffer) selectionKey.attachment();</span><br><span class="line">        <span class="comment">// 从发送消息的客户端中读取数据</span></span><br><span class="line">        SocketChannel client = (SocketChannel) selectionKey.channel();</span><br><span class="line">        buffer.put(getClientName(client).getBytes());</span><br><span class="line">        client.read(buffer);</span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="keyword">if</span> (isExit(buffer))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(getClientName(client) + <span class="string">&quot;断开连接&quot;</span>);</span><br><span class="line">            client.write(StandardCharsets.UTF_8.encode(EXIT));</span><br><span class="line">            <span class="comment">// 取消监听该事件</span></span><br><span class="line">            selectionKey.cancel();</span><br><span class="line">            <span class="comment">// 关闭客户端</span></span><br><span class="line">            client.close();</span><br><span class="line">            <span class="comment">// 结束执行该方法</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写模式切换成读模式</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="comment">// 打印提示信息: decode 方法会将 position 指针移动, 所以使用这个方法之后想要再次读取, 就要使用 clear 或者 rewind 方法</span></span><br><span class="line">        System.out.println(StandardCharsets.UTF_8.decode(buffer));</span><br><span class="line">        <span class="comment">// 转发消息</span></span><br><span class="line">        forward(selector.keys(), client, buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理发生的事件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">selectionKeyHandler</span><span class="params">(Set&lt;SelectionKey&gt; selectionKeys)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 采用迭代器遍历事件集合更好: 因为有可能部分事件发生了但没有处理</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 遍历集合事件</span></span><br><span class="line">            SelectionKey selectionKey = iterator.next();</span><br><span class="line">            <span class="comment">// 根据事件类型分别处理</span></span><br><span class="line">            <span class="keyword">if</span> (selectionKey.isAcceptable())</span><br><span class="line">            &#123;</span><br><span class="line">               acceptHandler(selectionKey);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable())</span><br><span class="line">            &#123;</span><br><span class="line">                readHandler(selectionKey);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isWritable())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// TODO 服务器端向客户端发送消息, 一次没有发送完成才会触发写事件</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 事件处理完成后移除</span></span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable close)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (close != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            close.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            server = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">// 服务器端设置为非阻塞</span></span><br><span class="line">            server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 绑定端口号</span></span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            <span class="comment">// 创建选择器</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">// 服务器端注册: 仅需要关注客户端连接的事件</span></span><br><span class="line">            server.register(selector, SelectionKey.OP_ACCEPT, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 打印提示信息</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;服务器[%d]:%s\n&quot;</span>, port, <span class="string">&quot;启动成功&quot;</span>);</span><br><span class="line">            <span class="comment">// 服务器开始等待客户端连接并且处理事件</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 阻塞服务器: 防止服务器空转</span></span><br><span class="line">                selector.select();</span><br><span class="line">                <span class="comment">// 获取此时所有发生的事件并处理</span></span><br><span class="line">                selectionKeyHandler(selector.selectedKeys());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ChatServer().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>



<blockquote>
<p><strong>客户端</strong></p>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.v5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectableChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_LOCALHOST = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">7777</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXIT = <span class="string">&quot;退出&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> String localhost;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel client;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClient</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_PORT, DEFAULT_LOCALHOST);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClient</span><span class="params">(<span class="keyword">int</span> port, String localhost)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.localhost = localhost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取客户端相关信息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getClientName</span><span class="params">(SocketChannel client)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        InetSocketAddress address = (InetSocketAddress) client.getLocalAddress();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;客户端[&quot;</span> + address.getPort() + <span class="string">&quot;]:&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理连接事件</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectHandler</span><span class="params">(SelectionKey selectionKey)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 获取处理事件的通道</span></span><br><span class="line">        SocketChannel channel = (SocketChannel) selectionKey.channel();</span><br><span class="line">        <span class="comment">// 连接正在建立时返回 true</span></span><br><span class="line">        <span class="keyword">if</span> (channel.isConnectionPending())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 手动确认连接建立完成</span></span><br><span class="line">            channel.finishConnect();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理读取事件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readHandler</span><span class="params">(SelectionKey selectionKey)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 获取事件对应的通道</span></span><br><span class="line">        SocketChannel client = (SocketChannel) selectionKey.channel();</span><br><span class="line">        <span class="comment">// 获取事件对应的附件(缓冲区)</span></span><br><span class="line">        ByteBuffer buffer = (ByteBuffer) selectionKey.attachment();</span><br><span class="line">        client.read(buffer);</span><br><span class="line">        <span class="comment">// 写模式切换成读模式</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        String msg = String.valueOf(StandardCharsets.UTF_8.decode(buffer));</span><br><span class="line">        <span class="keyword">if</span> (EXIT.equals(msg))</span><br><span class="line">        &#123;</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印提示信息</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// 读模式切换成写模式</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理事件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">selectionKeysHandler</span><span class="params">(Set&lt;SelectionKey&gt; selectionKeys)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历事件集合</span></span><br><span class="line">        <span class="keyword">for</span> (SelectionKey selectionKey : selectionKeys)</span><br><span class="line">        &#123;</span><br><span class="line">             readHandler(selectionKey);</span><br><span class="line">        &#125;</span><br><span class="line">        selectionKeys.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 创建客户端</span></span><br><span class="line">            client = SocketChannel.open();</span><br><span class="line">            <span class="comment">// 客户端绑定端口号</span></span><br><span class="line">            client.connect(<span class="keyword">new</span> InetSocketAddress(localhost, port));</span><br><span class="line">            <span class="comment">// 客户端设置为非阻塞</span></span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 开启输入线程</span></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ChatClientInputThread(client)).start();</span><br><span class="line">            <span class="comment">// 打印提示信息</span></span><br><span class="line">            System.out.println(getClientName(client) + <span class="string">&quot;启动成功&quot;</span>);</span><br><span class="line">            <span class="comment">// 监听器</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">// 注册监听事件</span></span><br><span class="line">            client.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ,</span><br><span class="line">                    ByteBuffer.allocate(BUFFER_SIZE));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 阻塞客户端</span></span><br><span class="line">                selector.select();</span><br><span class="line">                <span class="comment">// 获取发生的事件集合</span></span><br><span class="line">                selectionKeysHandler(selector.selectedKeys());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ChatClient().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.v5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClientInputThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXIT = <span class="string">&quot;退出&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BufferedReader READER = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">            <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                    System.in));</span><br><span class="line">    <span class="keyword">private</span> SocketChannel client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClientInputThread</span><span class="params">(SocketChannel client)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">while</span> ((msg = READER.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ByteBuffer buffer = StandardCharsets.UTF_8.encode(msg);</span><br><span class="line">                client.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>



</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/08/16/java/generic/%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6/">泛型编程</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-08-16</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-08-16</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="泛型编程"   >
          <a href="#泛型编程" class="heading-link"><i class="fas fa-link"></i></a><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h1>
      <blockquote>
<p>参考博客</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/briblue/article/details/76736356" >Java 泛型，你了解类型擦除吗？</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/s10461/article/details/53941091?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161942846716780366533091%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161942846716780366533091&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-53941091.pc_search_result_cache&utm_term=Java+%E6%B3%9B%E5%9E%8B" >java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.zhihu.com/question/20928981" >java为什么不支持泛型数组？</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h2 id="基本内容"   >
          <a href="#基本内容" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h2>
      <ul>
<li><p>泛型问题：</p>
<ul>
<li>什么是泛型？</li>
<li>为什么要引入泛型？</li>
<li>泛型的优点在哪里？</li>
</ul>
</li>
<li><p>推导过程</p>
<ul>
<li><p>初始阶段</p>
<ol>
<li>我们在学习数据结构的时候通常会自己手动实现栈，队列，哈希表等数据结构</li>
<li>我们通常为了方便起见，都是将数据类型默认设置成为的 <code>Integer</code> 类型</li>
<li>那么你是否思考过，如果下次需要将 <code>String</code> 类型的元素存入你写的数据结构要怎么办</li>
<li>显然，我们最笨的办法就是再写一个存储 <code>String</code> 类型的数据结构类</li>
</ol>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储 Integer 元素的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackOfInteger</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] stack;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储 String 元素的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackOfString</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] stack;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></div></figure>

<ol start="5">
<li>那么现在我们再提出一个要求，需要存储 <code>Double</code> 类型的元素的数据结构</li>
<li>很无奈，我们只能再次重复一遍数据结构的代码，仅仅只为了改动一个数据类型</li>
</ol>
<p>  <a style="color:red;">每次都为不同的数据类型重写一个类显然是非常不合理的 -&gt; 代码量会陡然增大</a></p>
</li>
<li><p>中级阶段</p>
<ul>
<li>方式：<ol>
<li>相对于每次都重写类的方式，利用 Java 多态的特性显然更加符合常理</li>
<li>每次都可以任意传入自己想要的类型 -&gt; 所有类都是 <code>Object</code> 子类 -&gt; 所有类型都可以被==向上转型==</li>
<li>采用 <code>Object</code> 的方式显然避免了代码量过大的问题</li>
</ol>
</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] stack;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top;</span><br><span class="line">    </span><br><span class="line">    ...<span class="comment">// 省略构造方法...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈已满！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack[++top] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object val = stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<ul>
<li>问题：<ol>
<li>每次取出元素时都需要主动进行==强制类型转换==</li>
<li>每个数据结构中都存储同一类型元素（Integer）的时候 -&gt; 将另一类型的元素（String）存储进去也不会报错 -&gt; 强制转换读取元素使才会报错</li>
</ol>
</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Stack stack = <span class="keyword">new</span> Stack(...);</span><br><span class="line">        stack.push(<span class="string">&quot;String&quot;</span>);</span><br><span class="line">        <span class="comment">// 显然在这个位置想要使用字符串的特性是需要强制转换的</span></span><br><span class="line">        String string = (String) stack.pop();</span><br><span class="line">        stack.push(<span class="number">114514</span>);</span><br><span class="line">        Integer integer = (Integer) stack.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(stack.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">            1. 显然如果栈中有其他类型的数据被强制转换成 Integer 类型是显然报错的</span></span><br><span class="line"><span class="comment">            2. 我们无法在编译阶段就知道会出现类型转换错误，有时甚至难以得知栈中到底存储的是什么元素</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            Integer integer = (Integer) stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>最终阶段</p>
<ol>
<li>我们不需要提前指定任何==具体类型== -&gt; 使用==类型参数==来表示我们并不知道现在需要使用哪种具体类型</li>
<li>我们只需要在使用数据结构的时候指定具体类型就可以</li>
<li>采用这种方式就能够避免 Object 方式中的强制转换造成的错误</li>
</ol>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] stack;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       	...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 后面菱形中不用再填入具体类型 -&gt; 前面已经填入可以自动推导</span></span><br><span class="line">        Stack&lt;String&gt; strStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        strStack.push(<span class="string">&quot;shinobu&quot;</span>);</span><br><span class="line">        strStack.push(<span class="string">&quot;fuyusakaiori&quot;</span>);</span><br><span class="line">        <span class="comment">// 采用 Object 的方式中是不会在编译阶段报错的 -&gt; 采用泛型编程是会在此处直接报错</span></span><br><span class="line">        strStack.push(<span class="number">1234</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>类型参数：</p>
<ul>
<li><p>引入：既然具体变量可以作为实际参数传入，那么是否具体的类型是否也可以作为实际参数传入呢？ -&gt; 答案显然是可以的</p>
</li>
<li><p>概念：将类型由原来的==具体的类型参数化==，类似于方法中的变量参数</p>
</li>
<li><p>表现形式：使用&lt;&gt;表示类型参数</p>
<ul>
<li>T：表示任何类型</li>
<li>E（Element）：表示集合中的元素类型</li>
<li>K（Key）：表示映射中键的类型</li>
<li>V（Value）：表示映射值的类型</li>
<li>S（SubType）：</li>
</ul>
<p>  <a style="color:red;">注：5 种表示方式没有任何实质区别 -&gt; 仅仅只是为了增强代码可读性</a></p>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li><p>最初采用==重写不同类==适应不同类型的需要</p>
</li>
<li><p>改进采用 ==Object 方式（多态）== 适应不同类型的需要</p>
<p>  <a style="color:red;">注：Java 5 之前全部都是采用这种多态的方式实现“泛型”</a></p>
</li>
<li><p>最后采用==泛型==非常容易就适应不同类型的需要</p>
<ul>
<li>概念：泛型的本质是为了==参数化类型== -&gt; 不创建新的类型的情况下，通过泛型指定具体类型来控制形参的具体类型</li>
<li>优点：<ul>
<li>泛型提供一种==扩展能力==，使得数据类别可以像参数一样由外部传递进来，更符合面向抽象开发的软件编程宗旨</li>
<li>泛型又提供了一种==类型检测==的机制，只有相匹配的数据才能正常的赋值，否则编译器就不通过</li>
<li>泛型提高了程序代码的==可读性==，能够一目了然猜测出代码要操作的数据类型</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>思考：Java 中是否真的实现了泛型机制呢？ -&gt; 答案是否定的</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. Java 虚拟机中并没有真正的实现泛型 -&gt; 采用了类型擦除机制 -&gt; 之后解释</span></span><br><span class="line"><span class="comment">2. C# C++ 都是彻底实现了泛型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;String&gt; l1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    List&lt;Integer&gt; l2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    System.out.println(l1.getClass() == l2.getClass()); <span class="comment">// 得到的答案是 true 而不是 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h2 id="进阶内容"   >
          <a href="#进阶内容" class="heading-link"><i class="fas fa-link"></i></a><a href="#进阶内容" class="headerlink" title="进阶内容"></a>进阶内容</h2>
      
        <h3 id="泛型使用"   >
          <a href="#泛型使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#泛型使用" class="headerlink" title="泛型使用"></a>泛型使用</h3>
      
        <h4 id="泛型类"   >
          <a href="#泛型类" class="heading-link"><i class="fas fa-link"></i></a><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4>
      <ul>
<li><p>概念：集合框架中对于泛型类的使用非常常见（<code>ArrayList&lt;T&gt;</code>，<code>HashMap&lt;K,V&gt;</code>…）</p>
</li>
<li><p>表现形式：使用<T> 类型参数==声明==当前类是泛型类</p>
</li>
<li><p>特点：</p>
<ul>
<li><p>泛型类中的构造方法不需要声明泛型</p>
</li>
<li><p>泛型类中的所有方法和属性都可以使用 <T> 类型参数 -&gt; 不能够使用未被声明的类型参数，诸如<E>，<S>…</p>
</li>
<li><p>泛型类并不强制要求所有方法和属性都使用 <T> 类型参数</p>
</li>
<li><p>泛型类的具体类型的指定</p>
<ol>
<li>可以显示的指定具体的类型</li>
<li>也可以不指定具体的类型 -&gt; 这样就可以存放任何类型的元素，不会编译错误 -&gt; 实际上相当于 Object 的方式</li>
</ol>
<p>  <a style="color:red;">注：传入的参数只能够是类型，不能够是基本数据类型（int，double，float）</a></p>
</li>
</ul>
</li>
<li><p>总结：==泛型类就相当于普通类的工厂== -&gt; 想要什么样的类就可以生产什么样的类</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">不可以使用通配符声明泛型类</span></span><br><span class="line"><span class="comment">class Generic&lt;?&gt;</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	这是错误的</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不能够写成 public Generic&lt;T&gt;() 这种形式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;泛型类启动...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        System.out.println(<span class="string">&quot;泛型类启动...&quot;</span> + <span class="keyword">this</span>.key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 可以显示的指定具体的类型</span></span><br><span class="line">        Generic&lt;String&gt; generic = <span class="keyword">new</span> Generic&lt;&gt;(<span class="string">&quot;shinobu&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 也可以不指定具体的类型 -&gt; 这样就可以存放任何类型的元素，不会编译错误 -&gt; 实际上相当于 Object 的方式</span></span><br><span class="line">        Generic generic = <span class="keyword">new</span> Generic(<span class="string">&quot;shinobu&quot;</span>);</span><br><span class="line">        Generic generic = <span class="keyword">new</span> Generic(<span class="number">1234</span>);</span><br><span class="line">        <span class="comment">// 3. 可以使用通配符 -&gt; 之后会提到</span></span><br><span class="line">        Generic&lt;?&gt; generic = <span class="keyword">new</span> Generic&lt;&gt;(<span class="string">&quot;shinobu&quot;</span>);</span><br><span class="line">        <span class="comment">// 注意：这样声明是完全可以的，但是调用方法时会受到很大的限制，具体原因在统配符处解释</span></span><br><span class="line">        <span class="comment">// 简单解释：? 虽然可以代表任何类型，但是它不能够去匹配各种类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="泛型接口"   >
          <a href="#泛型接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4>
      <ul>
<li>概念：<ul>
<li>集合框架中对于泛型接口的使用也非常常见（<code>List&lt;T&gt;</code>，<code>Map&lt;K,V&gt;</code>…）</li>
<li>泛型接口通常搭配泛型类或者普通类使用</li>
</ul>
</li>
<li>表现形式：使用<T> 类型参数==声明==当前接口是泛型接口</li>
<li>特点<ul>
<li>泛型接口的具体类型指定<ol>
<li>我们可以现在明确指定泛型接口的类型参数</li>
<li>我们也可以使用泛型类的类型参数，而不是具体指定一个</li>
<li>不能够使用通配符作为类型参数 -&gt; 直接编译报错</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">getGenerator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 普通类实现泛型接口 -&gt; 我们需要明确指定泛型接口的类型参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// IDEA 会自动将类型参数转换为实际类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGenerator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">null</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这种实现方式：接口的类型参数就会依赖泛型类的类型参数 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="泛型方法"   >
          <a href="#泛型方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4>
      <ul>
<li><p>概念：方法前必须使用类型参数 <code>&lt;T&gt;</code> 进行声明才是泛型方法</p>
<p>  <a style="color:red;">仅仅只是使用泛型类的类型参数的方法并不是泛型方法</a></p>
</li>
<li><p>表现形式：定义方法时，在返回值之前声明类型参数</p>
</li>
<li><p>特点</p>
<ul>
<li><p>普通泛型方法</p>
<ul>
<li>泛型方法可以将返回值定义为 <code>void</code> 也可以使用 <code>&lt;T&gt;</code></li>
<li>泛型方法需要定义自己的类型参数 <code>&lt;T&gt;</code><ol>
<li>泛型方法自己的类型参数和泛型类的类型参数==完全不同== -&gt; 即使都使用 <code>&lt;T&gt;</code> 作为类型参数</li>
<li>泛型方法中的形参可以使用自己定义的类型参数 <code>&lt;E&gt;</code> 也可以使用泛型类定义的类型参数 <code>&lt;T&gt;</code></li>
</ol>
</li>
</ul>
</li>
<li><p>静态泛型方法</p>
<ul>
<li>静态方法不能够使用泛型类定义的类型参数，只能够使用自己的</li>
</ul>
<p>  <a style="color:red;">注：静态字段是不可以使用类型参数声明类型的</a></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T filed; <span class="comment">// 注意：这是错误的</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 注意：这个并不是泛型方法，这个只是一个使用了泛型类的类型参数的普通方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMethod</span><span class="params">(T method)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"> 	<span class="comment">// 1. 泛型方法采用了&lt;T&gt;类型参数，泛型类也采用了&lt;T&gt;，但是这两个类型参数是完全不同的</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">genericMethod</span><span class="params">(T method)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 注意：这种使用方式是可以的，但是静态方法不行，无论是否是泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">genericMethod</span><span class="params">(E method1,T method2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 注意：这种使用方式是错误的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">E <span class="title">genericMethod</span><span class="params">(T method)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 注意：自己定义的是 E 就只能够使用的 E，而不能够使用 T</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">genericMethod</span><span class="params">(E method)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="泛型限定"   >
          <a href="#泛型限定" class="heading-link"><i class="fas fa-link"></i></a><a href="#泛型限定" class="headerlink" title="泛型限定"></a>泛型限定</h3>
      <ul>
<li><p>概念：对传入类型参数中的具体类型做出限制 -&gt; 不能够传入任意的具体类型</p>
</li>
<li><p>方式</p>
<ul>
<li><p>上界</p>
<ul>
<li><p>概念：</p>
<ol>
<li>如果限制条件是实体类 -&gt; 传入的具体类型==必须是限制类的子类==</li>
<li>如果限制条件是接口 -&gt; 传入的具体类型==必须实现限制接口==</li>
</ol>
</li>
<li><p>特点：</p>
<ul>
<li>无论限制条件是实体类还是接口 -&gt; 都使用 <code>extends</code> 关键字</li>
<li><a style="color:red;">注：限定条件可以有多个，使用 &amp; 连接；限定类必须写在第一个</a></li>
</ul>
</li>
<li><p>测试</p>
<ul>
<li>限定条件是实体类</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显然只能够是 Person 的子类才能够作为具体类型传入</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Person&gt; <span class="function"><span class="keyword">void</span> <span class="title">genericMethod</span><span class="params">(T person)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;泛型测试...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> statci <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    genericMethod(<span class="keyword">new</span> Student());<span class="comment">// 合法</span></span><br><span class="line">    genericMethod(<span class="keyword">new</span> String()); <span class="comment">// 不合法 -&gt; 编译阶段就会报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<ul>
<li>限定条件是接口</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PlayGame</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span> <span class="keyword">implements</span> <span class="title">PlayGame</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 接口是普通的接口 -&gt; 显然传入的具体类型必须实现这个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends PlayGame&gt; <span class="function"><span class="keyword">void</span> <span class="title">genericMethod</span><span class="params">(T person)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;泛型测试...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">2. 接口是泛型接口</span></span><br><span class="line"><span class="comment">	2.1 泛型接口使用类型参数 -&gt; 传入的具体类型只要实现了 Comparator 接口就可以了 -&gt; 从原来的任意范围缩小到有限的范围</span></span><br><span class="line"><span class="comment">	2.2 泛型接口使用具体类型 -&gt; 这样写实际上限制死了传入的具体类型 -&gt; 从原来的任意范围缩小的一个点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparator&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">genericMethod</span><span class="params">(T person)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;泛型测试...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样传入的类型就只能够是 String 类型了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparator&lt;String&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">genericMethod</span><span class="params">(T person)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;泛型测试...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>上界：类型参数不能够使用 <code>super</code> 关键字作为上界进行限制</p>
<p>  <a style="color:red;">注：泛型通配符中却是可以 super 关键字进行限定的</a></p>
</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种声明式错误的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">super</span> Student&gt; <span class="function"><span class="keyword">void</span> <span class="title">genericMethod</span><span class="params">(T student)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	原因分析：</span></span><br><span class="line"><span class="comment">	1. 类型擦除导致的</span></span><br><span class="line"><span class="comment">	2. 虚拟机执行类型擦除之后会导致 &lt;&gt; 中存放 T 类型而不是 Student 类型</span></span><br><span class="line"><span class="comment">	3. 而 T 类型也会被擦除称为 Object 类型</span></span><br><span class="line"><span class="comment">	4. 导致无论任何具体类型都可以传入，那么 super 的限制就没有任何实际意义了</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h3 id="泛型继承规则"   >
          <a href="#泛型继承规则" class="heading-link"><i class="fas fa-link"></i></a><a href="#泛型继承规则" class="headerlink" title="泛型继承规则"></a>泛型继承规则</h3>
      <ul>
<li><p>普通泛型继承规则</p>
<ul>
<li>图示</li>
</ul>
  <img src="D:\博客\hexo\source\_posts\Java\泛型机制.assets\image-20210427224737542.png" alt="image-20210427224737542" style="zoom:80%;" />

<ul>
<li><p>代码：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;Person&gt; people)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;People&gt; people = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> 	List&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    method(people); <span class="comment">// 编译通过</span></span><br><span class="line">    method(students); <span class="comment">// 编译无法通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>通配符泛型继承规则</p>
<ul>
<li><p>下界限制继承</p>
  <img src="D:\博客\hexo\source\_posts\Java\泛型机制.assets\image-20210428213751390.png" alt="image-20210428213751390" style="zoom:80%;" /></li>
<li><p>上界限制继承</p>
  <img src="D:\博客\hexo\source\_posts\Java\泛型机制.assets\image-20210428213829294.png" alt="image-20210428213829294" style="zoom:80%;" /></li>
</ul>
</li>
</ul>

        <h3 id="泛型通配符"   >
          <a href="#泛型通配符" class="heading-link"><i class="fas fa-link"></i></a><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3>
      <ul>
<li><p>概念：在我们根本不知道要传入何种具体类型时，将通配符作为==具体类型==传入</p>
</li>
<li><p>表现形式：<code>&lt;?&gt;</code></p>
</li>
<li><p>特点：</p>
<ul>
<li><a style="color:red;">通配符不是类型参数，不能够用于声明泛型类，泛型接口，泛型方法</a></li>
<li><a style="color:red;">通配符并不是一种具体类型</a></li>
<li>通配符可以使用上界（<code>super</code>）和 下界（<code>extends</code>）</li>
</ul>
</li>
<li><p>类型</p>
<ul>
<li><p>无限定通配符</p>
<ol>
<li><p>通配符不可以用于声明变量</p>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 通配符声明是直接报错的 -&gt; 因为通配符不是任何具体的类型，并不等价于 Object </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ? element = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>通配符可以用于局部变量的声明中 -&gt; 并非没有实际意义</p>
<p> 注：</p>
<ul>
<li>表示对于这个泛型类我们不关心存储的元素类型，只关心和元素类型无关的方法 -&gt; 诸如获取集合长度，判断集合是否为空…</li>
<li>用于方法的形参中可以解除泛型的严格限制</li>
<li>提高了代码的可阅读性</li>
</ul>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 正如之前所提到的可以使用通配符作为具体参数类型传入 </span></span><br><span class="line"><span class="comment">2. 因为几乎无法调用泛型类中的任何方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;?&gt; people = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 根据上面的声明传入通配符</span></span><br><span class="line">List&lt;?&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 显然我们不可能声明一个 ? 类型的变量去接收</span></span><br><span class="line">    ? getElement();</span><br><span class="line">    <span class="comment">// 显然根据第一条规则赋值方法是根本不可能使用的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setElement</span><span class="params">(? element)</span></span>;</span><br><span class="line">    <span class="comment">// 但是我们只要类中存在不涉及 ? 类型的方法，仍然是可以调用的</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 这种不需要涉及到使用 ? 类型的方法都是可以调用的</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>通配符用于方法中</p>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. List&lt;String&gt;，List&lt;Integer&gt; 所有类型的集合都可以作为参数传入</span></span><br><span class="line"><span class="comment">2. 而不是传入某个特定的泛型类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;?&gt; list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ol>
</li>
<li><p>通配符子类型限定</p>
<ol>
<li><p>限定通配符声明局部变量</p>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 不同于无限定通配符几乎丧失了所有读写的能力</span></span><br><span class="line"><span class="comment">2. 子类型限定通配符仍然具有读取的能力</span></span><br><span class="line"><span class="comment">3. 原因我也不知道</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;? extends Person&gt; people = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">people.get();<span class="comment">// 编译通过</span></span><br><span class="line">people.add();<span class="comment">// 编译不通过</span></span><br></pre></td></tr></table></div></figure></li>
<li><p>限定通配符用于方法中</p>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 限定了作为形参传入的类型 -&gt;  List&lt;String&gt;，List&lt;Integer&gt; 都不可以传入，只有 List&lt;Student&gt; 可以传入</span></span><br><span class="line"><span class="comment">2. List&lt;?&gt; 是不可以被捕获的，但是 List 可以</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;? extends Person&gt; list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

</li>
</ol>
</li>
<li><p>通配符超类型限定</p>
<ol>
<li><p>限定通配符声明局部变量</p>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 不同于无限定通配符几乎丧失了所有读写的能力</span></span><br><span class="line"><span class="comment">2. 超类型限定通配符仍然具有存储的能力</span></span><br><span class="line"><span class="comment">3. 但是存储的类型只可以是 Student 类型 -&gt; 其父类都是不可以存储的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;? <span class="keyword">super</span> Student&gt; student = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">student.add(<span class="keyword">new</span> Student()); <span class="comment">// 编译通过</span></span><br><span class="line">student.get(); <span class="comment">// 编译不通过</span></span><br></pre></td></tr></table></div></figure></li>
<li><p>限定通配符用于方法中</p>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 限定了作为形参传入的类型 -&gt;  List&lt;String&gt;，List&lt;Integer&gt; 都不可以传入，只有 List&lt;Student&gt;  List&lt;Person&gt; List&lt;Object&gt; 可以传入</span></span><br><span class="line"><span class="comment">2.  List&lt;?&gt; 是不可以被捕获的，但是 List 可以</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;? <span class="keyword">super</span> Student&gt; list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ol>
</li>
</ul>
<p>  <a style="color:red;">注：如果局部变量中使用无限定通配符，那么形参中也必须使用无限定通配符才能够捕获，只要形参有限定都是不可以捕获无限定通配符到的</a></p>
</li>
</ul>

        <h3 id="类型擦除"   >
          <a href="#类型擦除" class="heading-link"><i class="fas fa-link"></i></a><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3>
      <ul>
<li><p>引入</p>
<ul>
<li><p>问题：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; integers = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 这两个集合类的类型相同吗？因为传入的具体类型不同所以反射得到的类型也不同？还是说是相同的</span></span><br><span class="line"><span class="comment">2. 答案是相同的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.out.println(strings.getClass() == integers.getClass());</span><br></pre></td></tr></table></div></figure></li>
<li><p>历史背景</p>
<ul>
<li><p>Java 与 C#</p>
<ol>
<li><p>底层层面：</p>
<ul>
<li>Java 并没有实现真正的泛型化 -&gt; 采用==类型擦除式泛型==；</li>
<li>C# 实现了真正的泛型 -&gt; 采用==具现化泛型==</li>
</ul>
</li>
<li><p>源码层面：</p>
<ul>
<li><p>Java 采用的是在原有的集合类中的直接进行泛型化</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 原有的不带泛型的集合类(ArrayList，List...)可以声明，但是在源码中已经不存在了</span></span><br><span class="line"><span class="comment">2. 只提供了带有泛型的集合类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ArrayList&lt;T&gt; List&lt;T&gt;... </span><br></pre></td></tr></table></div></figure></li>
<li><p>C# 采用的是增加带有泛型的集合类，和原有的不带有泛型的集合类进行区分 </p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>Java 采取如此策略的原因</p>
<ol>
<li><p>底层原因：</p>
<ul>
<li>采用具现化泛型则意味着需要对字节码文件，虚拟机的规范做出修改</li>
<li>Java 语言规范中保证老版本的源文件在新版本的 JDK 中同样能够正常编译</li>
<li>既然字节码文件的格式，以及虚拟机的规范都发生了变化，那么老版本的源文件显然是不可能新版本的 JDK 上编译的</li>
</ul>
<p> <a style="color:red;">注：这就导致 Java 仅仅只是在源码层面实现了泛型</a></p>
</li>
<li><p>原码原因：</p>
<ul>
<li>既然不用在字节码和虚拟机的层面去实现泛型，那么源码层面的泛型怎么实现呢？</li>
<li>Java 采用在原有的集合类的基础上直接进行泛型化，而不是新增加泛型类</li>
<li>Java 在需要增加泛型机制时已经经过了数十年的发展，许多方法中已经使用原有的集合类作为返回值</li>
<li>如果此时再添加新的泛型集合类显然会将集合类库变得更加庞大（骂的人更多）</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>遗留问题：原有的集合类如何新版本的泛型集合类交互呢？-&gt; 让原有的集合类作为原始类成为所有泛型集合类的父类</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">arrayList = strings; <span class="comment">// 编译可以通过</span></span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>概念：源代码在进入虚拟机之前所有的类型参数都会被==抹去==</p>
</li>
<li><p>规则：</p>
<ul>
<li><p>无限定类型参数：</p>
<ol>
<li>所有==类型参数==全部被替换成为 <code>Object</code></li>
<li>==泛型类==会转换成为==原始类==</li>
</ol>
<p>  <a style="color:red;">任何需要使用泛型的地方都会采用强制转换</a></p>
<p>  <a style="color:red;">从最简单的泛型擦除规则可以看出来，泛型在 Java 中仅仅是相当于一种语法糖，底层仍然采用的是多态去实现泛型</a></p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">进入虚拟机之前的源代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	T genericFiled;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">method</span><span class="params">(T first, T second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">进入虚拟机之后的源代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	Object genericFiled;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">method</span><span class="params">(Object first, Object second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main*(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//源码层面： 类型参数将会被抹去生成原类型</span></span><br><span class="line">    Generic&lt;String&gt; generic = <span class="keyword">new</span> Generic&lt;String&gt;(); </span><br><span class="line">    <span class="comment">// 虚拟机层面：</span></span><br><span class="line">    Generic generic = <span class="keyword">new</span> Generic();</span><br><span class="line">    <span class="comment">// 虚拟机中：使用带有泛型的变量时是需要进行强制转换的</span></span><br><span class="line">    String str = (String)generci.method(<span class="string">&quot;123&quot;</span>,<span class="string">&quot;456&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>有限定类型参数</p>
<ul>
<li><p>限定类</p>
<ol>
<li>所有类型参数都会转换为==限定的类==</li>
<li>泛型类会==继承==当前这个限定类</li>
</ol>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">进入虚拟机之前的源代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Person</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	T genericFiled;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">method</span><span class="params">(T first, T second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">进入虚拟机之后的源代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	Person genericFiled;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">method</span><span class="params">(Person first, Person second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//源码层面： 类型参数将会被抹去生成原类型</span></span><br><span class="line">    Generic&lt;Student&gt; generic = <span class="keyword">new</span> Generic&lt;Student&gt;(); </span><br><span class="line">    <span class="comment">// 虚拟机层面：</span></span><br><span class="line">    Generic generic = <span class="keyword">new</span> Generic();</span><br><span class="line">    <span class="comment">// 虚拟机中：使用带有泛型的变量时是需要进行强制转换的</span></span><br><span class="line">    Person str = (Person)generci.method(<span class="keyword">new</span> Student(),<span class="keyword">new</span> Student());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>限定接口</p>
<ul>
<li><p>规则</p>
<ol>
<li>所有类型参数都会转换为==限定的接口==</li>
<li>泛型类会==实现==当前这个限定接口</li>
</ol>
</li>
<li><p>问题：如果限定条件中有多个接口？虚拟机如何选择？</p>
<p>  解决方式：虚拟机会选择==第一个接口==作为限定的接口</p>
<p>  影响：所以限定接口的顺序会导致虚拟机选择的接口不一样，导致强转的类型不一样</p>
</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">进入虚拟机之前的源代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span> &amp; <span class="title">Serializable</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	T genericFiled;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">method</span><span class="params">(T first, T second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">进入虚拟机之后的源代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 选择第一个限定接口作为具体的类型</span></span><br><span class="line">	Comparable genericFiled;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Comparable <span class="title">method</span><span class="params">(Comparable first, Comparable second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>类型擦除产生的问题：</p>
<ul>
<li><p>重载问题</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. List&lt;String&gt; List&lt;Integer&gt; 根据类型擦除机制 -&gt; 显然这两个参数的类型是一致的都是 List </span></span><br><span class="line"><span class="comment">2. 重载必须保证相同方法名中的参数类型必须不一致，这里的参数类型一致所以显然重载失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(List&lt;String&gt; strings)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(List&lt;Integer&gt; integers)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 重载必须保证方法签名不同，但是返回类型并不属于方法名中的一部分，所以编译是根本无法通过的</span></span><br><span class="line"><span class="comment">2. 但是在虚拟机中的重载并不是这样的</span></span><br><span class="line"><span class="comment">3. 虚拟机中只要保证 返回类型 + 方法签名 是不同的就可以证明两个方法不同 -&gt; 是可以共存的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method1</span><span class="params">(List&lt;String&gt; strings)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method1</span><span class="params">(List&lt;Integer&gt; integers)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure></li>
<li><p>继承问题</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    T first;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T first)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span>&lt;<span class="title">String</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 子类重写父类的方法所以理所应当调用的应该是子类的的方法</span></span><br><span class="line"><span class="comment">    2. 但是由于类型擦除导致父类新增了两个方法 </span></span><br><span class="line"><span class="comment">    public void setFirst(Object first)</span></span><br><span class="line"><span class="comment">    public Object getFirst()</span></span><br><span class="line"><span class="comment">    3. 显然这两个新增的方法也会被子类继承，但是这样就达不到重写的效果，虚拟机可能根本不知道到底调用哪个方法</span></span><br><span class="line"><span class="comment">    4. 桥方法诞生用于解决这个问题：</span></span><br><span class="line"><span class="comment">    虚拟机中采用 方法嵌套调用的方式解决</span></span><br><span class="line"><span class="comment">    public void setFirst(Object first)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">    	this.setFirst((String) first) 强制转换调用子类的方法</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(String first)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.first = first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>自动拆装箱问题</p>
<ul>
<li>回顾：前面提到类型参数不能够接收基本数据类型（<code>int</code> <code>double</code>…）</li>
<li>原因：类型擦除后，显然需要在 <code>int</code> 和 <code>Object</code> 之间进行强制转换，这显然是不可以的 -&gt; 只能够允许传入 <code>int</code> 的包装类 <code>Integer</code></li>
<li>影响：调用方法时会进行很多次的无意义的自动拆装箱，导致 Java 泛型的效率非常低</li>
</ul>
</li>
<li><p>数组问题：不能够声明泛型数组</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">以下代码都是不可以运行的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 源码层面</span></span><br><span class="line">    ArrayList&lt;String&gt;[] strings = <span class="keyword">new</span> ArrayList&lt;&gt;[<span class="number">20</span>];</span><br><span class="line">    <span class="comment">// 虚拟机中</span></span><br><span class="line">    Object[] strings = <span class="keyword">new</span> Object[<span class="number">20</span>];</span><br><span class="line">    <span class="comment">// 显然此时任何类型都可以作为元素加入数组中 -&gt; 在编译阶段并不会报错</span></span><br><span class="line">    strings[<span class="number">0</span>] = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 但是虚拟机执行这行代码时，会检查存储类型是否正确，最后会抛出存储类型异常</span></span><br><span class="line">    <span class="comment">// 有个问题，虚拟机怎么知道原有的存储类型是什么？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>

        <h3 id="泛型与反射"   >
          <a href="#泛型与反射" class="heading-link"><i class="fas fa-link"></i></a><a href="#泛型与反射" class="headerlink" title="泛型与反射"></a>泛型与反射</h3>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/08/16/os/process/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">进程概述</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-08-16</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-28</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="进程概述"   >
          <a href="#进程概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h1>
      
        <h2 id="进程概念"   >
          <a href="#进程概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2>
      
        <h3 id="进程定义"   >
          <a href="#进程定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程定义" class="headerlink" title="进程定义"></a>进程定义</h3>
      <ul>
<li><p>定义：</p>
<ul>
<li><p>处于 ==并发== 状态下</p>
<p>  <a style="color:red;">注：非并发情况下的程序不可以称之为进程</a></p>
</li>
<li><p>具有某种功能的程序在某个数据集上执行的 ==过程==</p>
<p>  <a style="color:red;">注：进程不是静态的实体而是活动的过程</a></p>
</li>
<li><p>是 ==进程调度== 和 ==资源分配== 的 ==独立== 单位</p>
<p>  <a style="color:red;">注：这里说的是独立单位不是最小单位；进程调度的最小单位是线程；资源分配的最小单位是进程</a></p>
</li>
</ul>
</li>
<li><p>进程 &amp; 程序</p>
<ul>
<li><p>进程是 ==活动== 的实体：进程 = 程序段 + 数据段 + <a href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97">进程控制块</a></p>
<p>  <a style="color:red;">注：每个进程都拥有自己独立的逻辑程序计数器，但是物理程序计数器只有一个</a></p>
</li>
<li><p>程序是 ==被动== 的实体：只是存放在硬盘中的代码段</p>
</li>
</ul>
</li>
<li><p>分类：</p>
<ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6">CPU 密集型进程 &amp; I/O 密集型进程</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E5%8D%8F%E4%BD%9C">独立进程 &amp; 协作进程</a></li>
<li>前端进程 &amp; 后端进程</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E5%AE%9E%E7%8E%B0">父进程 &amp; 子进程</a></li>
<li>孤儿进程 &amp; 僵尸进程 &amp; 守护进程</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li><p>处理器频繁切换进程实现并行；采用跟踪正在运行的进程集（主存）而不是跟踪处理器如何切换的</p>
</li>
<li><p>并行 &amp; 伪并行</p>
<ul>
<li><p>并行：多个进程 ==同时== 运行</p>
</li>
<li><p>伪并行：处理器通过频繁 ==切换== 进程执行</p>
<p>  解释：制造了多个进程同时进行的错觉</p>
</li>
</ul>
<p>  <a style="color:red;">1. 单处理器系统每个瞬间只能够运行一个进程 -&gt;  单处理器系统并没有实现真正意义上的并行（伪并行）</a></p>
<p>  <a style="color:red;">2. 多处理器系统具有多个处理器芯片每个瞬间可以运行多个进程 -&gt; 多处理器系统实现了真正意义上的并行</a></p>
<p>  <a style="color:red;">3. 多个进程可以共享同一个程序</a></p>
<p>  解释：同一个程序可以被执行多次，每执行一次都算作一个进程，但是程序只有一个</p>
</li>
</ul>
</li>
</ul>
<p>​        <img src="https://i1.xpic.jp/file/xpicjp/2021/05/18/a084f67f611ec916e89c3757bcf14667.png" alt="a084f67f611ec916e89c3757bcf14667.png"></p>

        <h3 id="进程状态"   >
          <a href="#进程状态" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3>
      <ul>
<li><p>五种状态</p>
<ul>
<li><p>初始态(<code>new</code>)：进程刚被创建时的状态</p>
<ul>
<li>创建的情况：(1)系统初始化；(2)正在执行进程创建另一个进程；(3)用户请求创建新的进程</li>
</ul>
<p>  <a style="color:red;">注：进程刚被创建时进入作业队列，等待获取相应的资源后，进入就绪队列</a></p>
</li>
<li><p>就绪态(<code>ready</code>)：进程已经获取到所需所有资源；等待处理器的调度后即可执行</p>
<p>  <a style="color:red;">1. 运行态 -&gt; 就绪态：代表进程是被动放弃 CPU 的；处理器因为中断需要执行其他的进程</a></p>
<p>  <a style="color:red;">2. 这个状态下的进程已经可以执行了</a></p>
</li>
<li><p>运行态(<code>running</code>)：处理器中正在执行的进程</p>
</li>
<li><p>阻塞态（等待态）(<code>wating</code>)：进程等待某些资源的获取</p>
<p>  <a style="color:red;">1. 运行态 -&gt; 阻塞态：代表进程值主动放弃 CPU 的；因为进程需要获取资源后才可以执行</a></p>
<p>  <a style="color:red;">2. 阻塞态是不可以在获取到相应资源后直接返回运行态，必须进入就绪态等待</a></p>
</li>
<li><p>终止态(<code>terminated</code>)：进程执行完成</p>
<ul>
<li>终止的情况：(1) 正常退出；(2) 出错退出；(3)被其他进程杀死</li>
</ul>
</li>
</ul>
</li>
<li><p>状态转换图：</p>
<p>  <a style="color:red;">中断处理，启动进程，结束进程都是由调度程序处理的（调度程序是一段非常短小的程序）</a></p>
</li>
</ul>
<p><img src="https://i1.xpic.jp/file/xpicjp/2021/05/18/51238e9c1e1bcddf61d990aa90246f49.png" alt="51238e9c1e1bcddf61d990aa90246f49.png"></p>

        <h3 id="进程控制块"   >
          <a href="#进程控制块" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h3>
      <ul>
<li><p>定义：每个进程都维护的一个结构数组，用于保存进程所有的相关信息</p>
<p>  <a style="color:red;">处理器 <strong>只会通过进程控制块</strong> 找到进程在内存中的所有相关信息</a></p>
</li>
<li><p>相关信息：(进程相关的所有信息都存放在进程控制块中：可能是具体的数据也可能是指针)</p>
<div class="table-container"><table>
<thead>
<tr>
<th>进程描述信息</th>
<th>进程控制信息和管理信息</th>
<th>资源分配信息</th>
<th>处理器相关信息</th>
</tr>
</thead>
<tbody><tr>
<td>进程唯一标识符</td>
<td>进程状态</td>
<td>代码段指针</td>
<td>程序状态字寄存器</td>
</tr>
<tr>
<td>用户唯一标识符</td>
<td>进程优先级</td>
<td>数据段指针</td>
<td>地址寄存器</td>
</tr>
<tr>
<td>子进程 &amp; 父进程唯一标识符</td>
<td>代码段入口地址</td>
<td>堆栈段指针</td>
<td>程序计数器</td>
</tr>
<tr>
<td></td>
<td>程序磁盘地址</td>
<td>文件描述符</td>
<td>通用寄存器</td>
</tr>
<tr>
<td></td>
<td>进入内存时间 &amp; 处理器使用时间</td>
<td>外接设备</td>
<td></td>
</tr>
<tr>
<td></td>
<td>信号量</td>
<td></td>
<td></td>
</tr>
</tbody></table></div>
</li>
<li><p>上下文：当前进程的物理实体(PCB)和进程的运行环境(处理器各个寄存器值)被统称为上下文</p>
<ul>
<li>上下文切换：<a style="color:red;">保存当前正在执行的进程状态(运行环境)然后载入另一个进程的状态(运行环境)</a></li>
<li>具体过程<ol>
<li>保存当前 <strong>处理器的各个寄存器的值</strong> 并且 <strong>更新</strong> 进程相应的 <strong>进程控制块信息</strong></li>
<li><strong>载入</strong> 将要运行的进程的 <strong>进程控制块</strong> 并且 <strong>更新处理器各个寄存器的值</strong></li>
</ol>
</li>
</ul>
</li>
<li><p>细节：<a style="color:red;">进程控制块采用两种方式进行组织：<strong>链表 / 索引表</strong></a></p>
</li>
</ul>
<p><img src="https://i1.xpic.jp/file/xpicjp/2021/05/18/31a2d2f8d0e97ef1834e0c09f62c532a.png" alt="31a2d2f8d0e97ef1834e0c09f62c532a.png"></p>

        <h2 id="进程调度"   >
          <a href="#进程调度" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2>
      <ul>
<li><p>定义：多个进程需要处理器执行，调度程序采用一定的 ==策略== 选择其中一个进程分派给处理器执行</p>
</li>
<li><p>调度队列：</p>
<ul>
<li><p>作业队列：包含操作系统中的所有初始态的进程（未分配到相应资源的进程）</p>
<p>  <a style="color:red;">注：作业队列也就是输入队列，都是等待被调度到内存中执行的进程；作业队列的进程都是存放在磁盘上</a></p>
</li>
<li><p>就绪队列：已经加载到内存中等待执行的进程</p>
<p>  <a style="color:red;">1. 就绪队列中的所有进程都处于内存中，且都处于就绪态</a></p>
<p>  <a style="color:red;">2. 就绪队列仅仅只是内存的一部分，代表已经可以执行的进程，部分没有准备的好的进程仍然可以在内存中等待</a></p>
</li>
<li><p>设备队列：包含所有需要相应 I/O 资源的进程</p>
</li>
</ul>
<p>  <a style="color:red;">调度队列采用具有尾指针的链表队列实现</a></p>
</li>
<li><p>调度程序：</p>
<ul>
<li><p>定义：将处理器的 ==控制权== 交付 给由调度算法确定的 ==进程==</p>
</li>
<li><p>功能：</p>
<ul>
<li>上下文切换(<a style="color:red;">保存当前进程时会从用户态进入内核态；恢复新进程时会从内核态进入用户态</a>)</li>
<li>获取 PCB 中程序计数器的值跳转到合适的位置 -&gt; 重新执行进程</li>
</ul>
</li>
<li><p>CPU 密集型进程 &amp; I/O 密集型进程</p>
<ul>
<li><p>CPU 密集型进程：需要花费更多时间在执行计算上</p>
</li>
<li><p>I/O 密集型进程：需要花费更多时间在提交 I/O 请求上</p>
<p>  <a style="color:red;">进程两个执行区间：CPU 执行区间 + I/O 执行区间</a></p>
</li>
</ul>
</li>
<li><p>调度延迟：调度程序保存一个进程并恢复另一个进程的过程（上下文切换）所花费的时间</p>
</li>
<li><p>调度程序分类</p>
<ul>
<li><p>长期调度程序：从硬盘等二级存储中调度 ==程序== 到 ==内存== 中等待执行</p>
<p>  <a style="color:red;">1. 长期调度程序执行的频率相对较低</a></p>
<p>  <a style="color:red;">2. 长期调度程序可以控制多道程序系统的度</a></p>
</li>
<li><p>短期调度程序：从内存中调度 ==进程== 到 处理器中执行 (这只是一种抽象的说法：实际上是处理器获取到进程的入口地址和寄存器信息开始执行进程)</p>
<p>  <a style="color:red;">短期调度程序执行的频率相对较高</a></p>
</li>
<li><p>中期调度程序：将 ==进程== 从内存中 ==暂时交换== 到备份存储的 ==交换空间== 中，从而降低多道程序系统的度，在合适的时候再将进程调入内存中继续执行</p>
<ul>
<li><p>交换方式：</p>
<ul>
<li><p>标准交换：将进程再次调度进入内存时分配进程 ==可能需要== 的内存大小</p>
</li>
<li><p>“变体”交换：将进程再次调度进入内存时分配进程 ==真正需要== 的内存大小(<a style="color:red;">进程可以利用系统调用告知操作系统</a>)</p>
<p>  <a style="color:red;">现代操作系统通常采用的方式是在空闲内存低于一定的阈值时才会采用交换来改善内存状况；否则禁止采用交换</a></p>
</li>
</ul>
</li>
<li><p>备份存储：<a style="color:red;">通常是大容量的存储设备（磁盘）</a></p>
</li>
<li><p>原因：长期调度程序在调度进程时很可能对于进程的组合不够得当，导致 CPU 或 I/O 的效率很低 -&gt; 借助中期调度程序进行改善</p>
</li>
<li><p>优点 &amp; 缺点：</p>
<ul>
<li>优点：(1) <a style="color:red;">改善进程组合</a> (2) <a style="color:red;">降低多道程序的度</a></li>
<li>缺点：==标准交换== 上下文的切换时间 ==相当高==</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li><p>中期调度程序在 ==换出进程== 时应该确保进程中的那个进程是 ==完全空闲== 的</p>
<p>  解释：如果进程处于设备等待队列，那么就是不能够立即换出的</p>
</li>
<li><p><a style="color:red;">移动设备不支持任何形式的交换</a></p>
<p>  解释：Android &amp; iOS 在空闲内存低于阈值时都是要求进程 ==主动放弃== 占用的内存以达到释放内存的目的</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>调度队列图</p>
<p>  <img src="https://i1.xpic.jp/file/xpicjp/2021/05/18/44debe8ff8f28bb1b969b68ed489cb15.png" alt="44debe8ff8f28bb1b969b68ed489cb15.png"></p>
</li>
<li><p><a href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">调度算法</a></p>
</li>
<li><p>进程调度 &amp; 上下文切换的区别</p>
<ul>
<li>进程调度仅仅只是 <strong>决定将要分配</strong> 给进程何种资源何种环境 (决策行为)</li>
<li>上下文切换是 <strong>真正意义</strong> 上将资源和环境分配给进程 (执行行为)</li>
</ul>
</li>
</ul>

        <h2 id="进程实现"   >
          <a href="#进程实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程实现" class="headerlink" title="进程实现"></a>进程实现</h2>
      <p><a style="color:red;">实现进程的所有函数实际上都是系统调用且都在内核态下运行</a></p>
<ul>
<li><p>前提：按照 UNIX 标准实现进程；Windows 实现类似</p>
</li>
<li><p>进程层次结构：</p>
<ul>
<li><p>父进程 &amp; 子进程：</p>
<ul>
<li>父进程：创建子进程的进程</li>
<li>子进程：由父进程调用 <code>fork()</code> 函数创建的进程</li>
</ul>
</li>
<li><p>进程组：父进程和其派生的 ==所有== 子进程共同组成进程组</p>
</li>
<li><p>进程标识符（PID）：每个进程由操作系统分配的 ==唯一== 编号</p>
</li>
<li><p>资源共享：</p>
<ul>
<li>父进程允许子进程共享 ==全部== 资源</li>
<li>父进程不允许子进程共享资源 -&gt; 子进程只可以从 ==操作系统== 处获取资源</li>
<li>父进程允许子进程共享 ==部分== 资源</li>
</ul>
</li>
<li><p>运行顺序：</p>
<ul>
<li><p>父进程可以和子进程并发运行；<a style="color:red;">父进程和子进程此时都进入就绪队列 -&gt; 处于就绪态</a></p>
</li>
<li><p>父进程等待子进程执行结束后再执行；<a style="color:red;">只有子进程进入就绪队列，处于就绪态；父进程直到子进程结束之前都处于阻塞态</a></p>
<p>  <a style="color:red;">注：无论是并发运行还是等待运行，子进程都会优先于父进程执行</a></p>
</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li><p><a style="color:red;">父进程可以拥有多个子进程；每个子进程只可以拥有一个父进程</a></p>
</li>
<li><p>UNIX Solaris 中进程都是采用 ==树形== 层次结构；Windows 中并没有进程层次的概念，所有进程都是平等的</p>
</li>
<li><p>每个子进程可以继续创建自己的子进程</p>
</li>
<li><p><a style="color:red;">父进程和子进程的 <strong>逻辑地址</strong> 和 <strong>物理地址</strong> 都是相同的</a>(在调用 <code>exec</code> 指令或者进行写操作之前)</p>
<p>  解释：需要使用写时复制进行解释</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>进程实现方式</p>
<ul>
<li><p>进程创建：<code>fork()</code> </p>
<ul>
<li><p>创建过程：</p>
<ol>
<li><p>父进程调用 <code>fork()</code> 函数创建自身的 ==副本进程==（子进程） -&gt; <code>fork()</code> 函数返回子进程的进程标识符</p>
</li>
<li><p>操作系统创建 <strong>空白进程控制块</strong> (如果进程控制块创建失败则会直接导致 <strong>进程创建失败</strong>)</p>
</li>
<li><p>操作系统为进程分配内存空间 (如果内存空间不足以容纳新的进程则会导致 <strong>进程处于阻塞态</strong>)</p>
</li>
<li><p>操作系统 <strong>初始化进程控制块信息</strong></p>
</li>
<li><p>调度程序将子进程调度进入就绪队列等待执行</p>
</li>
<li><p>子进程可以调用 <code>exec()</code> 函数载入新的程序运行</p>
</li>
</ol>
<pre><code>解释：子进程不再是父进程的副本，调用 `fork()` 也可以创建子进程了
</code></pre>
</li>
<li><p>写时复制：</p>
<ul>
<li><p>引入：</p>
<p>  父进程在调用 <code>fork()</code> 函数时会创建副本子进程；显然需要将父进程的所有内容全部复制一遍</p>
<p>  但是大多数的子进程在被创建后都会立刻执行 <code>exec()</code> 函数去执行另一个程序；这样就显得此前复制操作非常没有必要</p>
</li>
<li><p>概念：</p>
<ul>
<li><p>子进程在被创建后和父进程共享同一块内存空间</p>
</li>
<li><p>等待子进程需要对内存空间进行 ==写操作== 时才单独为子进程分配单独的内存空间并复制父进程的内容</p>
</li>
</ul>
</li>
<li><p>细节：</p>
<ol>
<li><p><a style="color:red;">父进程和子进程共享内存空间时是不可以对其进行写操作的</a></p>
</li>
<li><p>子进程写操作</p>
<ul>
<li>子进程不使用 <code>exec()</code> 进行写操作：操作系统仍然会让子进程和父进程共享代码段；其余内容重新分配</li>
<li>子进程使用 <code>exrc()</code> 进行写操作：操作系统会对子进程的所有内容重新分配</li>
</ul>
</li>
</ol>
</li>
</ul>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32131499/article/details/94561780" >写时复制</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</li>
</ul>
<p>  <img src="https://i1.xpic.jp/file/xpicjp/2021/05/19/4bf1c3e2265801cf9eeb03aa08a9ac57.png" alt="4bf1c3e2265801cf9eeb03aa08a9ac57.png"></p>
</li>
<li><p>进程等待：<code>wait()</code></p>
<ul>
<li>父进程创建子进程之后选择等待子进程执行结束后再执行就会使用 <code>wait()</code> 指令</li>
</ul>
</li>
<li><p>进程删除：<code>exit()</code>  &amp; <code>kill()</code></p>
<ul>
<li><p>正常退出：进程使用 <code>exit()</code> 指令即可退出；子进程退出后 <code>exit()</code> 指令返回 ==退出状态== </p>
</li>
<li><p>异常退出：进程出现访问越界，使用非法指令，运行超时，运算出错等都会造成进程异常结束 (子进程使用了不该使用的资源)</p>
</li>
<li><p>外界干预：父进程被终止或者程序员手动干预</p>
</li>
<li><p>终止过程：</p>
<ol>
<li>操作系统根据 <strong>进程唯一标识符</strong> 查找其 <strong>进程控制块</strong> (进程控制块最后删除)</li>
<li>操作系统 <strong>终止</strong> 该进程的 <strong>所有子进程</strong> 并且将其拥有的资源全部 <strong>还给父进程或操作系统</strong></li>
<li>操作系统在在 <strong>链表</strong> 中 <strong>删除</strong> 该进程的 <strong>进程控制块</strong></li>
</ol>
<p>  <a style="color:red;">级联终止：如果一个父进程被终止，其派生的所有子进程一并终止</a></p>
</li>
</ul>
</li>
<li><p>细节：</p>
<ol>
<li><p><a style="color:red;">父进程调用 fork() 函数会得到子进程的进程标识符；子进程如果仍然是副本的话调用 fork() 函数只会得到 0</a></p>
<p> 解释：因为子进程也是从 <code>fork()</code> 函数开始执行的，如果子进程也正常调用 <code>fork()</code> 函数创建子进程，那就成死循环了</p>
</li>
<li><p><code>fork()</code> 函数时 UNIX 中 ==唯一== 可以创建进程的函数</p>
</li>
<li><p><code>exec()</code> 并不是一个具体的函数而是包含了 <code>execl</code> <code>execv</code>  <code>execle</code> <code>execve</code> <code>execlp</code> <code>execvp</code> 六种具体函数</p>
</li>
<li><p>Windows 进程相关函数：</p>
<ul>
<li>CreateProcess = fork + exec</li>
<li>ExitProcess = exit；TerminateProcess = kill</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  childPid; <span class="comment">// 子进程的进程标识符</span></span><br><span class="line">    childPid = fork(); <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) <span class="comment">// 进程创建失败 </span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Fork Failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>); <span class="comment">// 异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (childPid == <span class="number">0</span>) <span class="comment">// 子进程开始执行时也是从第一行开始执行的，毕竟是父进程的副本</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 子进程进入这个分支，载入其他的程序</span></span><br><span class="line">        execlp(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 父进程创建子进程之后进入的分支 </span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 父进程进行等待</span></span><br><span class="line">        wait (<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Child Complete&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h2 id="进程协作-amp-通信"   >
          <a href="#进程协作-amp-通信" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程协作-amp-通信" class="headerlink" title="进程协作 &amp; 通信"></a>进程协作 &amp; 通信</h2>
      <ul>
<li><p>协作进程 &amp; 独立进程</p>
<ul>
<li><p>协作进程：能够 ==影响== 其他进程或者 ==受== 其他进程 ==影响== 的进程</p>
<p>  注：提供相应的环境保证多个进程之间可以协作通信显然更有利于用户</p>
</li>
<li><p>独立进程：不能够影响其他进程也不受其他啊进程影响的进程</p>
</li>
</ul>
</li>
<li><p>进程通信机制（IPC）</p>
<ul>
<li><p>共享内存：</p>
<ul>
<li><p>定义：允许两个或多个通信进程访问同一块物理内存</p>
</li>
<li><p>优点：共享内存的通信方式 ==效率更高== </p>
<p>  解释：<a style="color:red;">只有在创建共享内存区域的时候需要使用系统调用</a>，进程访问共享区域都是 ==直接访问== 的，不需要使用系统调用</p>
</li>
<li><p>缺点：<a style="color:red;">共享内存没有提供进程同步机制</a> -&gt; <a href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5">同步机制</a></p>
<p>  解释：共享区域有进程正在使用时，其他进程不需要等待当前进程结束就可以使用共享区域，即共享区域没有上锁</p>
</li>
</ul>
<p>  <a style="color:red;">注：共享内存不代表进程之间可以相互访问对方的内存空间，本质上访问的是共享区域</a></p>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/ypt523/article/details/79958188" >共享内存通信</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>  <img src="https://i1.xpic.jp/file/xpicjp/2021/05/19/ee5fa8257ee9d585f9237842c1c0baca.png" alt="ee5fa8257ee9d585f9237842c1c0baca.png"></p>
</li>
<li><p>消息传递</p>
<ul>
<li><p>定义：两个或多个进程之间通过发送规定格式的消息进行通信</p>
</li>
<li><p>优点：<a style="color:red;">分布式系统/多核处理器中中采用消息传递的方式效率相对更高且容易实现</a></p>
<p>  注：共享内存在这种情况下会出现高速缓存不一致的情况</p>
</li>
<li><p>缺点：消息传递的通信方式 ==效率更低==</p>
<p>  解释：<a style="color:red;">进程每次发送消息都需要执行系统调用</a>，需要和内核交互，导致执行效率较低</p>
</li>
</ul>
<p>  <img src="https://i1.xpic.jp/file/xpicjp/2021/05/19/47671e747f498844ea2d896a70bd38e1.png" alt="47671e747f498844ea2d896a70bd38e1.png"></p>
</li>
<li><p>优点：(1) 信息共享；(2)计算加速；(3)模块化；(4) 更加便利</p>
</li>
</ul>
</li>
<li><p><a href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5">进程通信问题</a></p>
</li>
<li><p>生产者-消费者</p>
<ul>
<li><p>生产者 &amp; 缓冲区 &amp; 消费者 </p>
<ul>
<li><p>生产者：生成数据信息的进程</p>
</li>
<li><p>消费者：使用数据信息的进程</p>
</li>
<li><p>缓冲区：用于存储生产者生成的数据信息，并且提供给消费者使用数据信息的区域</p>
<p>  <a style="color:red;">缓冲区分为两类：无界缓冲区：没有实际大小的缓冲区；有界缓冲区：拥有实际大小的缓冲区</a></p>
</li>
</ul>
</li>
<li><p>过程：</p>
<ol>
<li><p>生产者进程生成数据信息提交至缓冲区中</p>
<p> <a style="color:red;">注：如果缓冲区位有界缓冲区且已经被数据填满，生产者进程必须停止产生数据</a></p>
</li>
<li><p>消费者进程从缓冲区中获取数据信息</p>
<p> <a style="color:red;">注：如果缓冲区中没有任何数据，消费者进程不可以从中获取数据</a></p>
</li>
</ol>
</li>
<li><p>细节</p>
<ol>
<li>生产者-消费者模式不是 23 种设计模式中的；23 种设计模式都是基于面向对象的，该模式是基于面向过程的</li>
<li><a style="color:red;">生产者-消费者模式时采用共享内存实现的；缓冲区就是两者共享的内存</a></li>
</ol>
</li>
<li><p>实现（循环队列）</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/luego/p/12048857.html" >生产者-消费者模式</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/10/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/随机图库/1641882498931.3kditdl6ds40.webp" alt="avatar"></div><p class="sidebar-ov-author__text">什么都不会的废物</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/fuyusakaiori" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://weibo.com/Sakiless/home?topnav=1&amp;wvr=6" target="_blank" rel="noopener" data-popover="微博" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weibo"></i></span></a><a class="sidebar-ov-social-item" href="670232228" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">108</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">33</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-nd.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020~2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>小忍的甜甜圈</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1.0.1/dist/canvas-nest.min.js" color="0,0,0" opacity="0.6" count="99" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>