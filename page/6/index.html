<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="啥也不会的大三狗">
<meta property="og:type" content="website">
<meta property="og:title" content="天鹅绒房间">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="天鹅绒房间">
<meta property="og:description" content="啥也不会的大三狗">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Fuyusakaiori">
<meta name="twitter:card" content="summary"><title>天鹅绒房间</title><link ref="canonical" href="http://example.com/page/6/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">天鹅绒房间</div><div class="header-banner-info__subtitle">Velvet Room</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/24/jvm/runtime/%E6%A6%82%E8%BF%B0/">概述</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-24</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h1>
      <blockquote>
<p><strong>什么是 Java 虚拟机运行时数据区？</strong></p>
</blockquote>
<ul>
<li><p>第一个问题：什么是 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://fuyusakaiori.github.io/OperatingSystem/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" >虚拟机</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>？</p>
<ul>
<li><p>定义：[运行在操作系统上的具有物理机拥有的全部硬件功能的软件]{.red}</p>
</li>
<li><p>核心：[虚拟机采用软件对真实计算机进行模拟]{.red}</p>
<p>  :::info</p>
<p>  注：既然是对真实计算机的模拟，那么虚拟机中的很多组件显然会对应真实计算机中的硬件</p>
<p>  :::</p>
</li>
</ul>
</li>
<li><p>第二个问题：什么是 Java 虚拟机？</p>
<ul>
<li><p>定义：简单来说就是运行 Java 进程的虚拟机</p>
<p>  :::info</p>
<p>  [① 这种说法并不严谨，只要能够通过编译生成字节码的程序都是可以在虚拟机中运行的]{.green}</p>
<p>  [② 诸如 Kotlin、Clojure 等语言也都是运行在 Java 虚拟机上的]{.green}</p>
<p>  :::</p>
</li>
<li><p>核心：Java 为了实现跨平台的特性而特意开发的虚拟机，使其能够不受硬件的制约</p>
</li>
<li><p>细节：[每个 Java 进程都运行在相应的 JVM 实例上]{.red}</p>
<p>  :::info</p>
<p>  注：翻译一下就是说每个 Java 进程都对应一个 JVM 实例，多个 Java 进程就会存在多个 JVM 实例</p>
<p>  :::</p>
</li>
</ul>
</li>
<li><p>第三个问题：什么是运行时数据区？</p>
<ul>
<li>定义：简单来说就是虚拟机中 [存放 Java 进程各种各样数据的空间]{.red}</li>
<li>细节：真实计算机中进程必须加载到内存中才能够执行，同样在 JVM 中进程也需要加载到运行时数据区中才能够执行</li>
</ul>
</li>
<li><p>第四个问题：运行时数据区由哪些部分组成呢？</p>
<ul>
<li><a href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8">程序计数寄存器</a>：<ul>
<li>别称：PC 寄存器、程序计数器、程序钩子</li>
<li>[真实计算机中的程序计数寄存器是由 <strong>物理硬件寄存器</strong> 实现的，JVM 的程序计数寄存器只是块 <strong>内存区域</strong>]{.blue}</li>
</ul>
</li>
<li>栈空间（<a href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">虚拟机栈</a> + <a href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88">本地方法栈</a>） + <a href="#%E5%A0%86%E7%A9%BA%E9%97%B4">堆空间</a><ul>
<li>在 C/C++ 这样的操作系统级别的语言来说，内存空间基本是由这两部分组成的</li>
<li>无论是 Java 或者 C/C++，栈空间和堆空间都是非常重要的两个部分</li>
</ul>
</li>
<li><a href="#%E6%96%B9%E6%B3%95%E5%8C%BA">方法区</a>：<ul>
<li>[方法区中还包含 <strong>运行时常量池</strong>]{.red}</li>
<li>[JDK 8 之后采用 <strong>元空间</strong> 替代]{.red}</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>运行时数据区总结图示</strong></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/个人博客搭建/运行时数据区.4yae49h3vr00.jpg" alt="运行时数据区" style="zoom:80%;" />

<blockquote>
<p><strong>内存模型简化图示</strong></p>
</blockquote>
<p>:::warning</p>
<p>运行时数据区并不包含执行引擎部分，这里只是为了能够展示整个虚拟机全貌而画出来的</p>
<p>:::</p>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/个人博客搭建/内存模型.1oezjqm5y51c.png" alt="内存模型" style="zoom:80%;" />

<blockquote>
<p><strong>内存模型完全图示</strong></p>
</blockquote>

        <h1 id="线程"   >
          <a href="#线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程" class="headerlink" title="线程"></a>线程</h1>
      <p>:::warning</p>
<p>① 本部分不会介绍 Java 线程的基础知识，更加不会介绍 Java 线程并发的知识，放在另外的博客介绍</p>
<p>② 本部分也不会像操作系统那样详细介绍线程的来龙去脉，这部分已经在操作系统的博客中介绍过了</p>
<p>③ 本部分主要从操作系统线程的角度来看待 Java 线程</p>
<p>参考书籍：《深入理解 Java 虚拟机》</p>
<p>建议阅读：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://fuyusakaiori.github.io/OperatingSystem/%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0/" >线程概述</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<ul>
<li>前提：具备操作系统层面的相关知识之后再阅读如下部分</li>
</ul>

        <h2 id="Java-线程实现"   >
          <a href="#Java-线程实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java-线程实现" class="headerlink" title="Java 线程实现"></a>Java 线程实现</h2>
      
        <h3 id="Java-线程历史"   >
          <a href="#Java-线程历史" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java-线程历史" class="headerlink" title="Java 线程历史"></a>Java 线程历史</h3>
      <ul>
<li>Java 在 JDK 1.2 时期的 Classic 虚拟机上采用线程实现方案是 [用户级线程实现]{.blue}：称为绿色线程（Green Threads）</li>
<li>Java 在 JDK 1.3 时期时，所有主流的商用虚拟机全部采用 [内核级线程实现]{.blue}</li>
<li>Java ME 的 CLDC-HI 虚拟机采用的是两种实现方案： [用户级线程实现 + 混合级线程实现]{.blue}</li>
<li>Solaris 的 HotSpot 虚拟机采用的也是两种实现方案：[内核级线程实现 + 混合级线程实现]{.blue}</li>
</ul>
<p>:::info</p>
<p>① Java 早期采用用户级线程的目的应该是比较明确的：为了实现更好的跨平台；改用内核级线程估计还是处于性能上的考虑</p>
<p>② Java 之后采用内核级线程就导致了各个操作系统上的虚拟机的具体实现根本不一样，Solaris、Windows、Linux等等，都有自己的实现方案</p>
<p>:::</p>

        <h3 id="Java-线程调度"   >
          <a href="#Java-线程调度" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java-线程调度" class="headerlink" title="Java 线程调度"></a>Java 线程调度</h3>
      <p>:::warning</p>
<p>建议阅读：<a href="">调度算法</a></p>
<p>:::</p>
<ul>
<li><p>前提：最好具备一定的操作系统的调度算法知识再继续阅读</p>
</li>
<li><p>引入：多线程并发执行时，如何安排这些线程执行呢？这就是调度算法要完成的工作</p>
</li>
<li><p>分类：</p>
<ul>
<li>协同式调度（Cooperative Threads-Scheduling）<ul>
<li>名称：协同式调度也可以称为非抢占式调度</li>
<li>定义：线程只有执行完成自己的所有任务后主动放弃处理器的使用权</li>
<li>优点：调度算法实现简单</li>
<li>缺点：当前线程执行时间过长会导致后续所有线程长时间等待，即使后续线程执行时间很短</li>
</ul>
</li>
<li>抢占式调度（Preemptive Threads-Scheduling）<ul>
<li>定义：其他线程可以抢占当前线程处理的使用权，无论当前线程是否执行结束</li>
<li>优点：避免线程长时间等待，线程执行效率高</li>
<li>缺点：调度算法实现复杂</li>
</ul>
</li>
</ul>
</li>
<li><p>[Java 采用抢占式类型的调度算法]{.red}</p>
<ul>
<li>此前提到 Java 采用的线程实现方案是内核级线程实现，所有线程的控制权都在操作系统手上，JVM 没有管理的权利</li>
<li>这里又提到 Java 采用的调度算法是抢占式的，不同的线程在交替执行</li>
<li>这就出现了多线程编程中的常见现象<ul>
<li>每次启动多个线程，执行的先后结果都是不一样的：每次抢占的情况都不一样</li>
<li>设定线程优先级后，依然没有按照预想的情况执行：JVM 仅能给操作系统建议，而无法控制</li>
</ul>
</li>
</ul>
</li>
<li><p>Java 优先级：</p>
<ul>
<li><p>Java 提供了 10 种优先级（1~10）：主线程默认优先级为 5</p>
</li>
<li><p>Windows 操作系统也提供了 7 种优先级</p>
</li>
<li><p>Solaris 操作系统提供了 2^31 种优先级</p>
<p>  +++danger 问题来了，Java 和操作系统的优先级数量不一样，那么是怎么对应上的呢？</p>
<p>  实际很简单，如果操作系统的优先级数量少，那么 Java 中多个优先级就对应一个就行了，如 Windows</p>
<p>  所以得到结果就是，Java 中1和2、3和4、6和7、8和9的效果是完全相同</p>
<p>  +++</p>
</li>
</ul>
</li>
</ul>

        <h3 id="Java-线程状态转换"   >
          <a href="#Java-线程状态转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java-线程状态转换" class="headerlink" title="Java 线程状态转换"></a>Java 线程状态转换</h3>
      <ul>
<li><p>Java 线程状态：</p>
<ul>
<li><p>初始态（New）：线程对象被创建但是没有启动时的状态</p>
</li>
<li><p>可运行态（Runnable）：包含 [线程准备运行和线程正在运行]{.red} 两种状态，即对应操作系统中两种状态</p>
</li>
<li><p>等待态：线程正在等待</p>
<ul>
<li><p>无限等待（Waiting）：线程必须被 [其他线程唤醒]{.red}，否则该线程永远不会执行</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下方法会导致线程进入无限等待</span></span><br><span class="line">wait()</span><br><span class="line"><span class="comment">// 唤醒方法</span></span><br><span class="line">notify()/notifyAll()</span><br></pre></td></tr></table></div></figure></li>
<li><p>有限等待（Timed Waiting）：线程睡眠一段时间后 [自动唤醒]{.red}，不需要其他线程帮助</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下方法会导致线程进入有限等待</span></span><br><span class="line">sleep()</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>阻塞态（Blocked）:线程等待其他线程释放同步锁</p>
</li>
<li><p>终止态（Terminated）：线程执行结束或者意外终止</p>
</li>
</ul>
<p>  :::info</p>
<p>  ① Java 定义线程运行状态和操作系统层面定义的有些细微差距，要注意区分</p>
<p>  ② Java 线程的状态是可以测试得到的，之后在其他博客中说明</p>
<p>  :::</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/个人博客搭建/Java 线程状态.547rhq1vqz40.png" alt="Java 线程状态" style="zoom:80%;" />


        <h2 id="Java-与协程"   >
          <a href="#Java-与协程" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java-与协程" class="headerlink" title="Java 与协程"></a>Java 与协程</h2>
      <ul>
<li>前提：[目前 Java 并没有提供协程技术]{.blue}</li>
</ul>

        <h2 id="Java-守护线程"   >
          <a href="#Java-守护线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java-守护线程" class="headerlink" title="Java 守护线程"></a>Java 守护线程</h2>
      <ul>
<li>虚拟线程</li>
<li>周期任务线程</li>
<li>垃圾回收线程（GC线程）</li>
<li>编译线程</li>
<li>信号调度线程</li>
</ul>

        <h1 id="字节码解析"   >
          <a href="#字节码解析" class="heading-link"><i class="fas fa-link"></i></a><a href="#字节码解析" class="headerlink" title="字节码解析"></a>字节码解析</h1>
      <ul>
<li><p>前提：后续的学习中会涉及到字节码的分析，而字节码的解析途径有多种，在此提前解释下</p>
</li>
<li><p>反编译：定义：将字节码文件解析成 Java 源代码</p>
</li>
<li><p>IDAE：本身就可以直接反编译字节码文件</p>
<ul>
<li><p>点击进入 out/production/ 目录下（存放所有字节码文件的目录）</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/个人博客搭建/IDEA 查看字节码文件.6k9fo19k10g0.png" alt="IDEA 查看字节码文件" style="zoom:80%;" /></li>
<li><p>[实际上源代码并不是我们想要查看的信息，我们需要把字节码解析成另外的形式才能得到更多的信息]{.green}</p>
<p>  :::warning</p>
<p>  注：毕竟我们自己编写的源代码，再去查看一遍确实没有什么意义</p>
<p>  :::</p>
</li>
</ul>
</li>
<li><p>反编译命令</p>
<ul>
<li><p>选择命令行终端</p>
<p>  :::info</p>
<p>  IDEA 或者 Windows 中使用都是可以的，笔者这里使用 IDEA 里的终端</p>
<p>  :::</p>
</li>
<li><p>点击 IDEA 中的终端后切换当前所在目录</p>
  <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 后面接上你自己的字节码所在的目录</span></span><br><span class="line"><span class="built_in">cd</span> out/production/yourdirectoryname</span><br></pre></td></tr></table></div></figure></li>
<li><p>使用反编译命令解析字节码文件：</p>
  <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Java 自身提供的反编译指令：接上你想要反编译的类的名称</span></span><br><span class="line">javap -v ClassName.class</span><br></pre></td></tr></table></div></figure></li>
<li><p>反编译解析结果：可以先简单了解下</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/个人博客搭建/解析字节码文件.25f1fgg3dgn4.png" alt="解析字节码文件" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>反编译插件：</p>
<ul>
<li>IDEA 中安装 Jclasslib 插件</li>
<li>选中想要解析的字节码文件后点击 View 选中 Show ByteCode With Jclasslib </li>
<li>就可以非常方便的查看字节码文件解析后的结果</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/个人博客搭建/IDEA 插件查看字节码文件.17xxsmn7pfkw.png" alt="IDEA 插件查看字节码文件" style="zoom:80%;" /></li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/24/jvm/execution-engine/%E6%A6%82%E8%BF%B0/">执行引擎-概述</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-25</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h1>
      <blockquote>
<p><strong>什么是执行引擎?</strong></p>
</blockquote>
<ul>
<li><p>定义：[采用 <strong>软件模拟</strong> 的物理机处理器就是执行引擎]{.red}</p>
<ul>
<li>物理机中的计算核心是处理器（CPU）</li>
<li>虚拟机作为对物理机的模拟，执行引擎显然就是对计算核心的模拟，也就是处理器</li>
</ul>
</li>
<li><p>作用：[将（前端）编译器生成的字节码 <strong>翻译/编译</strong> 成本地机器指令]{.red}</p>
<ul>
<li>执行引擎每次都取出一条字节码指令并执行</li>
<li>但是无论执行任何指令，最终都要依靠物理机，所以需要向物理机解释</li>
<li>执行引擎需要将字节码指令翻译/编译成处理器能够识别的机器指令</li>
</ul>
<p>:::info</p>
<p>① 前端编译器是什么之后将会提到，可以暂时先认为前端编译器就是 Javac</p>
<p>② 前端编译器并不是执行引擎的其中一部分，特别注意</p>
<p>:::</p>
</li>
<li><p>特点：</p>
<ul>
<li><p>[执行引擎作为对于处理的模拟：具有相应的指令集和缓存结构]{.red}</p>
<ul>
<li>执行引擎的指令集：[字节码指令]{.blue}</li>
<li>执行引擎的缓存结构：[即时编译器产生的本地代码就缓存再方法区中]{.blue}</li>
</ul>
</li>
<li><p>执行引擎处理指令集的方式：</p>
<ul>
<li>解释执行：初代 Java 虚拟机——Classic 虚拟机就只拥有解释器，仅能够解释执行</li>
<li>即时编译：BEA 开发的 JRockit 虚拟机就仅具有即时编译器，只能够编译执行</li>
<li>[解释执行 + 即时编译：HotSpot 虚拟机既具有即时编译器和解释器，两者可以协调合作]{.red}</li>
</ul>
<p>  :::info</p>
<p>  注：什么是解释执行，什么是即时编译之后会详细提到</p>
<p>  :::</p>
</li>
<li><p>[Java 虚拟机执行引擎是基于栈执行的，现代计算机基本都是基于寄存器执行的]{.red}</p>
<p>  :::primary</p>
<p>  想要了解什么是基于栈执行的执行引擎，参考 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://fuyusakaiori.github.io/JVM/Runtime/StackSpace/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/" >运行时数据区-栈空间-操作数栈</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 部分</p>
<p>  :::</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>执行引擎是由哪些部分组成的?</strong></p>
</blockquote>
<p>:::warning</p>
<p>① 仅针对 HotSpot 虚拟机的执行引擎，而不针对其他虚拟机的执行引擎</p>
<p>② 下面的图示是将执行引擎的大多数细节都填充进去了，目前你只需要知道个大致组成就行，之后会详细介绍</p>
<p>:::</p>
<ul>
<li><p>图示</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/执行引擎.2jibqu41fte0.png" alt="执行引擎" style="zoom:80%;" /></li>
<li><p>组成：[解释器 + 即时编译器 + 垃圾回收器]{.red}</p>
</li>
</ul>
<blockquote>
<p><strong>解释器(解释执行)与编译器(编译执行)到底是什么?</strong></p>
</blockquote>
<p>:::warning</p>
<p>① 如果想要详细了解编译器，建议阅读《编译原理》（俗称龙书）</p>
<p>② 如果想要了解机器指令和汇编语言，建议阅读《深入理解计算机系统》和《数字设计和计算机体系结构》</p>
<p>:::</p>
<ul>
<li><p>编译器（编译执行）：</p>
<ul>
<li><p>定义：[编译器将高级语言编译成处理器能够识别的机器指令]{.red}</p>
</li>
<li><p>主要语言：C、C++ 都是编译执行的语言</p>
</li>
<li><p>流程（任何类型的编译器基本都遵照以下流程）：</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/编译器流程.1fexxdsd40gw.png" alt="编译器流程" style="zoom:80%;" /></li>
<li><p>分类（仅限于 Java）：</p>
<ul>
<li><p>前端编译器：</p>
<ul>
<li>定义：[负责将源代码编译成 <strong>字节码指令</strong>]{.red}</li>
<li>常见编译器：JDK 自带的 Javac 编译器，Eclipse JDT 提供的 ECJ（增量式编译器）<ul>
<li>[Javac 编译器完全采用 Java 实现]{.blue}</li>
<li>Eclipse 编辑器中使用的就是 ECJ 编译器</li>
</ul>
</li>
</ul>
</li>
<li><p>即时编译器（后端编译器）</p>
<ul>
<li><p>定义：[负责在进程运行时将经常调用的方法编译成 <strong>机器指令</strong>]{.red}</p>
<ul>
<li>[编译生成的本地代码将会被缓存再方法区中（JIT 代码缓存）]{.red}</li>
</ul>
</li>
<li><p>常见编译器：HotSpot 提供的C1（客户端编译器）、C2（服务器端编译器），Graal 虚拟机提供的 Graal 编译器</p>
<p>  Graal 目前还只是实验性质的虚拟机，并没有发布正式的版本</p>
</li>
</ul>
</li>
<li><p>提前编译器（后端编译器）</p>
<ul>
<li>定义：[<strong>直接</strong> 将源代码编译成机器指令]{.red}<ul>
<li>类似于 C/C++ 使用的 GCC 编译器</li>
</ul>
</li>
<li>常见编译器：JDK 自带的 Jaotc 编译器，GNU 计划中的 GCJ 编译器，Excelsior JET 编译器</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>解释器（解释执行）：</p>
<ul>
<li><p>定义：[解释器每次都会向处理器解释源代码的含义]{.red}</p>
</li>
<li><p>主要语言：Python、JavaScript、PHP 都是解释执行的语言</p>
</li>
<li><p>流程</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/解释器.k8qxml3ekz4.png" alt="解释器" style="zoom:80%;" />
  </li>
<li><p>分类（仅限于 Java）：</p>
<ul>
<li>[字节码解释器：采用纯软件模拟的方式执行字节码 -&gt; 效率非常低下]{.red}</li>
<li>[模板解释器：每条字节码都和一个模板函数关联，模板函数能够直接生成字节码对应的本地代码 -&gt; 效率相对较高]{.red}</li>
</ul>
</li>
</ul>
</li>
<li><p>区别：</p>
<ul>
<li>[编译器对源代码进行编译之后会生成可执行文件，解释器不会生成任何可执行文件]{.red}</li>
<li>[编译器在编译过程中会对源代码采用各种优化技术进行优化（诸如逃逸分析），解释器不会对源代码进行任何优化]{.red}</li>
<li>源代码再次执行时：<ul>
<li>编译器生成的可执行文件就可以直接使用不需要再编译，[所以编译执行效率非常高]{.blue}</li>
<li>解释器则需要再次向处理器解释源代码的含义，[所以解释执行的效率就低]{.blue}</li>
</ul>
</li>
<li>[编译器需要对源代码进行编译：程序的启动速度慢；解释器不需要任何编译过程直接向处理器解释：启动速度快]{.red}</li>
</ul>
</li>
</ul>
<p>+++danger Java 到底是解释执行还是编译执行的语言呢？</p>
<p>① 远古时代的 Java 确实是纯解释执行的语言，就和 Python 一样</p>
<p>② 如今的 Java 既不是纯解释执行也不是纯编译执行的语言，而是半解释半编译的语言</p>
<p>③ 如今的 Java 程序在运行过程会交替使用解释器和编译器，使得运行效率大幅提升（至于如何交替使用，会在后端编译器部分中详细介绍） </p>
<p>+++</p>
<blockquote>
<p><strong>执行引擎如何使用解释器和即时编译器呢?</strong></p>
</blockquote>
<ul>
<li><p>[前端编译器将源代码编译成字节码]{.red}</p>
<ul>
<li>提前编译器通常会给即时编译器作为缓存加速，改善程序的启动时间</li>
</ul>
</li>
<li><p>执行引擎获取程序计数器提供的指令地址</p>
</li>
<li><p>执行引擎从方法区中获取相应的字节码指令</p>
</li>
<li><p>[执行引擎开始协调解释器和即时编译器执行：]{.red}</p>
<ul>
<li><p>[使用 <strong>热点探测技术</strong> 判断字节码指令是否要编译成本地代码]{.blue}</p>
<ul>
<li><p>如果执行引擎决定将其编译为本地代码，那么即时编译器将开始执行编译过程</p>
<p>  编译期间，[解释器会和即时编译器 <strong>异步执行</strong>]{.blue}，避免浪费用户线程的执行时间</p>
</li>
<li><p>如果执行引擎不认为要将其编译为本地代码，那么就采用解释执行</p>
</li>
</ul>
</li>
<li><p>查看调用的方法是否存在编译好的本地代码</p>
<ul>
<li>如果被调用的方法没有被编译成本地代码，那么将会解释执行</li>
<li>如果被调用的方法已经有相应的本地代码，那么将会直接执行本地代码</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/执行引擎执行大致流程.2cwfqncr4dwk.png" alt="执行引擎执行大致流程" style="zoom:80%;" />

<p>+++danger 最后抛出一个问题，为什么要使用字节码文件呢？明明虚拟机已经实现跨平台了啊？</p>
<p>+++</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/24/jvm/execution-engine/%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E5%99%A8/">执行引擎-后端编译器</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-25</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="后端编译器"   >
          <a href="#后端编译器" class="heading-link"><i class="fas fa-link"></i></a><a href="#后端编译器" class="headerlink" title="后端编译器"></a>后端编译器</h1>
      
        <h2 id="即时编译器"   >
          <a href="#即时编译器" class="heading-link"><i class="fas fa-link"></i></a><a href="#即时编译器" class="headerlink" title="即时编译器"></a>即时编译器</h2>
      <blockquote>
<p><strong>什么是即时编译器?</strong></p>
</blockquote>
<ul>
<li><p>前提：</p>
<ul>
<li>虚拟机规范中并没有强制要求必须实现即时编译器，虚拟机可以采用纯解释执行</li>
<li>但是 [即时编译器性能的好坏、对于代码优化质量的高低]{.blue} 却是衡量虚拟机是否优秀的关键标准</li>
</ul>
</li>
<li><p>名称：即时编译器（Just In Time 编译器）</p>
</li>
<li><p>定义：[负责在 <strong>进程运行期间</strong> 将 <strong>热点探测</strong> 决定的字节码指令 <strong>编译并且优化</strong> 成本地机器指令]{.red}</p>
</li>
<li><p>分类：</p>
<ul>
<li><p>客户端编译器：</p>
<ul>
<li>名称：Client Compiler（C1 编译器）</li>
<li>特点：[采用的代码优化策略相对简单可靠，确保客户端的编译速度]{.red}</li>
</ul>
</li>
<li><p>服务器端编译器：</p>
<ul>
<li>名称：Server Compiler（C2 编译器）</li>
<li>特点：[采用的代码优化策略更加的激进，全局性的优化，服务器端的执行速度也更快]{.red}</li>
</ul>
<p>  :::info</p>
<p>  ① 采用的优化策略更多，显然编译器执行的编译过程就更长，显然编译速度就会更慢</p>
<p>  ② 只要编译期间采用的优化策略越多，代码质量就会越好，执行速度就会越快</p>
<p>  :::</p>
</li>
<li><p>Graal 编译器：JDK 10 之后提供的编译器，目的是替代服务器端编译器</p>
</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li>[虚拟机预热：]{.red}<ul>
<li>虚拟机刚启动时只采用解释执行，热点探测本质就是统计方法的调用次数，即时编译器无法立刻生效</li>
<li>[虚拟机在等待即时编译器生效的这段时间称为虚拟机预热]{.blue}</li>
</ul>
</li>
<li>[虚拟机假死：]{.red}<ul>
<li>虚拟机预热完成之前都称为冷机状态，虚拟机长时间运行之后称为热机状态</li>
<li>[虚拟机的热机状态所能够承受的负载显然要大于虚拟机的冷机状态]{.blue}</li>
<li>[如果将处于热机状态的虚拟机的部分任务分配给处于冷机状态的虚拟机，就会导致其无法承受过大的流量而假死；毕竟虚拟机刚开始只采用解释执行，突然将大流量的任务交给处于冷机状态的虚拟机，肯定难以承受]{.green}</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>解释器和即时编译器如何配合执行?</strong></p>
</blockquote>
<p>:::primary</p>
<p>参考博客：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000009371813" >jvm分层编译级别</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<ul>
<li><p>解释模式：</p>
<ul>
<li><p>定义：仅使用解释器执行代码的模式</p>
</li>
<li><p>设置解释模式命令：[-Xint]{.blue}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/解释模式.7j3rnjsbqio0.png" alt="解释模式" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>编译模式</p>
<ul>
<li><p>定义：仅使用即时编译器执行的模式</p>
</li>
<li><p>设置编译模式命令：[-Xcomp]{.blue}</p>
</li>
<li><p>细节：[在即时编译器无法执行的情况下，解释器会强制介入]{.red}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/编译模式.5x9nc8v7cno0.png" alt="编译模式" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>混合模式</p>
<ul>
<li><p>定义：解释器和即时编译器混合执行的模式</p>
</li>
<li><p>设置混合模式命令：[-Xmixed]{.blue}</p>
<ul>
<li>[HotSpot 虚拟机默认采用混合模式]{.red}</li>
</ul>
</li>
<li><p>常规混合模式：[解释器配合任意一个即时编译器进行工作]{.red}</p>
</li>
<li><p>分层编译模式：</p>
<ul>
<li><p>前提：即时编译器想要完成更好的优化，就可能需要解释器的介入，替他监控并收集相关信息</p>
</li>
<li><p>开启分层编译策略：</p>
<ul>
<li>命令：[-XX:+TieredCompilation 开启分层策略 / -XX:-TieredCompilation 关闭分层策略]{.blue}</li>
<li>JDK 6 分层编译策略被初步实现，JDK 7 之后分层编译才作为默认策略被开启</li>
</ul>
</li>
<li><p>分层：</p>
<ul>
<li><p>第 0 层（解释执行）：程序纯解释执行，并且不开启性能监控功能</p>
</li>
<li><p>第 1 层（简单 C1 编译）：开启客户端编译器进行代码优化，解释器仍然不开启性能监控功能</p>
<p>  !!不开启性能监控怎么知道哪些代码是热点代码啊？!!{.bulr}</p>
</li>
<li><p>第 2 层（受限 C1 编译）：继续使用客户端编译器进行代码优化，解释器开启 [部分性能监控功能]{.red}</p>
<ul>
<li>方法调用计数器和回边计数器等少量性能监控功能</li>
</ul>
</li>
<li><p>第 3 层（完全 C1 编译）：继续使用客户端编译器进行代码优化，解释器开启 [全部性能监控功能]{.red}</p>
<ul>
<li>新增分支跳转、虚方法调用版本等信息的收集</li>
<li>[大多数方法第一次被编译就是采用第 3 层级别的编译]{.red}</li>
</ul>
</li>
<li><p>第 4 层（C2 编译）：开启服务器端编译器进行代码优化，将会采取更加激进的优化策略</p>
<ul>
<li>[服务器端编译器较忙的情况下会将方法下放到第 2 层级别的编译]{.red}</li>
<li>[等到服务器端编译器不太忙的时候，再对此前下放的方法重新编译]{.red}</li>
</ul>
</li>
</ul>
</li>
<li><p>核心：</p>
<ul>
<li>执行频率较高的代码优先被C1编译器编译</li>
<li>随着时间的推移再采用C2编译器做进一步优化编译，此前的本地代码被抛弃</li>
</ul>
</li>
<li><p>细节：启用分层编译之后，不再是单独使用任何一个即时编译器，而是交替使用，同时使用</p>
</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/混合模式.g4usdv50h9k.png" alt="混合模式" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>速率测试：</p>
<ul>
<li><p>测试代码</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    testMethod(<span class="number">10000000</span>);</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(end - start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算质数的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;开始执行...&quot;</span>);</span><br><span class="line">    <span class="comment">// 没有经过任何优化的算法采用纯解释执行实在是太他妈的慢了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; count; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; Math.sqrt(i); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行结束...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>测试结果</p>
<ul>
<li>纯解释执行的效率显然是非常低下的，尤其是在算法没有优化且计算量大的情况下，非常糟糕</li>
<li>纯编译执行效果显然是非常好的，即使算法写的不好，虚拟机也会采用相应的优化策略，提高效率</li>
<li>混合执行效果也不错，但是相比于纯编译似乎没有多大的提升，甚至有点下降</li>
<li>这是你可能产生了一个疑问，既然纯编译效果这么好，那为什么还要留着解释器呢？接下来就会提到这个问题</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解释器和编译器配合模式测试</span></span><br><span class="line"><span class="comment">// 纯解释执行 36980</span></span><br><span class="line"><span class="comment">// 纯编译执行 4902</span></span><br><span class="line"><span class="comment">// 混合执行 5031</span></span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>运行模式</p>
<ul>
<li>服务器端：[没有分层编译的混合模式中默认使用服务器端即时编译器]{.red}<ul>
<li>设置命令：[-server]{.blue}</li>
</ul>
</li>
<li>客户端：[没有分层编译的混合模式默认使用客户端即时编译器]{.red}<ul>
<li>设置命令：[client]{.blue}</li>
</ul>
</li>
<li>细节：虚拟机根据宿主机器选择运行模式，不过在 [64位的虚拟机]{.blue} 中默认采用服务器端运行</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>为什么要采用解释器和即时编译器并存的架构呢?</strong></p>
</blockquote>
<ul>
<li><p>回顾：</p>
<ul>
<li>主流的 HotSpot、OpenJ9 虚拟机都采用解释器和即时编译并存的架构</li>
<li>远古时代的 Classsic 虚拟机仅采用解释执行的架构</li>
<li>BEA 开发的 JRockit 虚拟机仅采用编译执行的架构</li>
</ul>
</li>
<li><p>原因：</p>
<ul>
<li>Java 程序不仅需要运行在服务器端也需要运行在客户端</li>
<li>[客户端程序更加关心程序的启动速度，对运行速率没有太高要求，过长的编译期会严重影响客户端的启动]{.red}<ul>
<li>[解释器不需要对源码执行编译过程所以启动速度非常快，也不需要和具体的硬件产生关系]{.blue}</li>
</ul>
</li>
<li>[服务器端则更加关心其运行速度，因为需要频繁处理客户端的请求，所以需要更加全局性的代码优化策略]{.red}<ul>
<li>但是解释器每次都需要向处理器解释源码的含义，对于长时间运行的服务器来说效率非常差</li>
<li>所以即时编译器就用来解决运行时的执行效率问题</li>
<li>[即时编译器会采用热点探测，对频繁执行的代码进行编译，再次执行该代码时就会提高其运行效率]{.blue}</li>
</ul>
</li>
</ul>
</li>
<li><p>核心：[虚拟机能够同时兼具启动速度和执行速度两种优势，能够适应不同进程情况]{.red}</p>
</li>
<li><p>细节：</p>
<ul>
<li>[即时编译器和解释器是异步执行：代码在编译的过程中，同时进入解释器执行，等到再次调用时再编译执行]{.red}</li>
<li>[解释器还可以作为即时编译器激进优化的逃生门]{.red}</li>
</ul>
<p>  :::info</p>
<p>  ① 即时编译器有时候会采用非常激进的优化策略，这些优化策略并不是一定都能够成功的，是由一定概率的</p>
<p>  ② 如果优化策略没有成功，那么代码就会从编译执行退回到解释执行</p>
<p>  :::</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/解释器和编译器.7ammm6bwlz00.png" alt="解释器和编译器" style="zoom:80%;" />

<blockquote>
<p><strong>如何触发即时编译?</strong></p>
</blockquote>
<ul>
<li><p>热点代码（HotSpot Code）</p>
<ul>
<li>定义：[被多次调用的 <strong>方法</strong> 或者被多次执行的 <strong>循环体</strong>]{.red}<ul>
<li>多次调用？多次执行？到底是多少次呢？有没有一个定量呢？</li>
</ul>
</li>
<li>替换方式：<ul>
<li>普通方式：<ul>
<li>内容：方法下次调用时再使用编译好的本地代码</li>
<li>特点：适用于方法调用计数器</li>
</ul>
</li>
<li>栈上替换（On Stack Replacement: OSR）：<ul>
<li>内容：[循环体代码将在解释执行的过程中被编译生成的本地代码替换]{.red}</li>
<li>特点：适用于回边计数器</li>
</ul>
</li>
</ul>
</li>
<li>细节：[无论是多次调用的方法还是循环体，编译的对象都是整个方法]{.red}</li>
</ul>
</li>
<li><p>热点探测（HotSpot Code Detection）</p>
<ul>
<li><p>定义：探测执行的代码是否为热点代码</p>
</li>
<li><p>方式：</p>
<ul>
<li>基于采样的热点探测<ul>
<li>内容：[虚拟机将会 <strong>周期性</strong> 的检查各个线程的调用栈顶，频繁出现在栈顶的方法被认为是热点代码]{.red}</li>
<li>特点：<ul>
<li>[实现简单且高效，可以得知方法之间的调用关系]{.red}（不太理解后面这个优点）</li>
<li>[难以精确确定方法的热度，而且由于是周期性的，容易受到线程阻塞的影响]{.green}</li>
</ul>
</li>
</ul>
</li>
<li>基于计数器的热点探测<ul>
<li>内容：[虚拟机将会为每个方法建立 <strong>计数器</strong>，统计执行的次数，超过阈值的方法就认为是热点代码]{.red}</li>
<li>分类：[方法调用计数器、回边计数器]{.red}</li>
<li>特点：<ul>
<li>[能够精确测定方法的热度，并且可以使用热度衰减技术]{.red}</li>
<li>[为每个方法都维护计数器显然比较麻烦，并且无法得知方法之间的调用关系]{.green}</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>计数器：</p>
<ul>
<li><p>方法调用计数器</p>
<ul>
<li><p>作用：统计一个方法被执行的次数，[方法调用计数器和回边计数器之和]{.red} 超过阈值之后发起编译请求</p>
</li>
<li><p>阈值：</p>
<ul>
<li>默认阈值：客户端默认值为 1500 次，服务器端默认值为 10000 次</li>
<li>设置阈值的命令：[-XX:CompileThreshold=threshold]{.blue}</li>
</ul>
</li>
<li><p>过程</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/方法调用计数器.54qypk5j6b40.png" alt="方法调用计数器" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>回边计数器</p>
<ul>
<li><p>作用：统计一个方法中循环体被执行的次数</p>
<p>  [方法调用计数器和回边计数器之和]{.red} 超过阈值之后发起 [OSR 编译请求]{.red}</p>
</li>
<li><p>阈值：</p>
<ul>
<li>客户端默认阈值：[方法调用计数器默认值 x OSR 默认比率 / 100]{.blue} 默认值 13995<ul>
<li>[方法调用计数器的值（-XX:CompileThreshold）：默认值 1500]{.blue}</li>
<li>[OSR 比率（-XX:OnStackReplacePercengtage）：默认值 933]{.blue}</li>
</ul>
</li>
<li>服务器端默认值：[方法调用计数器默认值 x (OSR 比率 - 解释器监控比率) / 100]{.blue} 默认值 10700<ul>
<li>[OSR 比率（-XX:OnStackReplacePercengtage）：默认值 140]{.blue}</li>
<li>[解释器监控比率（-XX:InterperterProfilePercentage）: 默认值 33]{.blue}</li>
</ul>
</li>
</ul>
</li>
<li><p>过程：</p>
</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/回边计数器.2ree7t6c62s0.png" alt="回边计数器" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>细节：J9 曾采用基于采样的热点探测，HotSpot 采用基于计数器的热点探测</p>
</li>
</ul>
</li>
<li><p>热度衰减（Counter Decay）</p>
<ul>
<li>前提：仅有基于计数器的热点探测中的方法计数器可以使用热端衰减，回边计数器无法使用</li>
<li>定义：[周期时间内某个方法始终没有达到方法调用计数器的阈值，那么该方法的方法调用计数器的值减半]{.red}</li>
<li>周期时间：《深入理解虚拟机》中没有明确指明默认时间到底是多久，只说了这段时间又称为半衰周期</li>
<li>命令：<ul>
<li>[-XX:+UseCounterDecay 开启热度衰减 / -XX:-UseCounterDecay 关闭热度衰减]{.blue}</li>
<li>[-XX:CounterHalfLifeTime=time 设置半衰周期的时间，单位是秒]{.blue}</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>即时编译如何进行的?</strong></p>
</blockquote>
<blockquote>
<p><strong>即时编译会采用哪些优化策略呢?</strong></p>
</blockquote>
<ul>
<li>核心：[不同的即时编译器采用的优化策略也不尽相同]{.red}</li>
<li>C1 编译器：<ul>
<li>方法内联</li>
<li>去虚拟化</li>
<li>冗余访问消除</li>
<li>复写传播</li>
</ul>
</li>
<li>C2 编译器：[逃逸分析是 C2 编译器进行优化的前提]{.red}<ul>
<li>栈上分配</li>
<li>标量替换</li>
<li>同步消除</li>
</ul>
</li>
</ul>

        <h2 id="提前编译器"   >
          <a href="#提前编译器" class="heading-link"><i class="fas fa-link"></i></a><a href="#提前编译器" class="headerlink" title="提前编译器"></a>提前编译器</h2>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/24/jvm/execution-engine/%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%99%A8/">执行引擎-前端编译器</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-24</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="前端编译器"   >
          <a href="#前端编译器" class="heading-link"><i class="fas fa-link"></i></a><a href="#前端编译器" class="headerlink" title="前端编译器"></a>前端编译器</h1>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/23/jvm/runtime/stackspace/%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/">栈空间-本地方法栈</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-23</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h3 id="本地方法栈"   >
          <a href="#本地方法栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3>
      <p>:::primary</p>
<p>参考博客：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/w1992wishes/article/details/80283403" >java调用本地方法–jni简介</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<blockquote>
<p><strong>什么是本地方法？</strong></p>
</blockquote>
<ul>
<li><p>定义：[采用非 Java 代码实现的“接口”]{.red}</p>
<ul>
<li><p>本地方法并不需要采用 Java 实现，[类似于]{.blue} 接口和抽象类中的方法</p>
</li>
<li><p>但是本地方法依然会采用其他语言具体实现，所以也只是类似于接口和抽象类</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地方法是没有方法体的，也就没有具体的实现，类似于接口和抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeMethod</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li>Java 本地方法大多数采用 C/C++ 实现</li>
<li>Java 本地方法可以通过本地方法接口（JNI）访问 Java 运行时数据区</li>
<li>Java 线程调用本地方法后就不再受到虚拟机限制，可以访问操作系统的寄存器、内存等硬件设备</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>为什么需要使用本地方法?</strong></p>
</blockquote>
<p>+++danger 核心：Java 需要和操作系统级别的软件进行交互]</p>
<p>① Java 采用虚拟机隔离了操作系统，所以才能够实现跨平台</p>
<p>② 正是因为虚拟机隔离了操作系统，所以 Java 难以直接和操作系统建立联系，本地方法就提供了访问操作系统的接口</p>
<p>+++</p>
<p>+++ Java 需要使用某些采用其他语言实现的功能</p>
<p>① 虚拟机内部的解释器就是采用 C 实现的</p>
<p>② Java 想要使用虚拟机提供的某些方法就不得不提供链接其他语言的接口</p>
<p>+++</p>
<blockquote>
<p><strong>如何编写本地方法?</strong>!!草，网上查到的全是在 Linux 下编写的，就离谱，大致过程还是记录下!!{.bulr}</p>
</blockquote>
<ul>
<li><p>方式：[JNI（Java Native Interface）]{.blue}</p>
<p>  :::info</p>
<p>  ① Java 借助本地调用接口使用存放在库文件中的本地方法，从而使用操作系统提供的功能</p>
<p>  ② Windows 库文件是采用 DLL 格式存方法的，Linux 库文件是采用 SO 格式存放的</p>
<p>  :::</p>
</li>
<li><p>编写过程：</p>
<p>  (1) 编写 Java 代码</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NativeMethod</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 调用静态链接库</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.loadLibrary(<span class="string">&quot;nativeMethod&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;fail...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;success...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 调用本地方法</span></span><br><span class="line">        <span class="keyword">new</span> NativeMethod().nativeMethod(<span class="string">&quot;Fuyusakaiori&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明本地方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeMethod</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  (2) 利用 javah 程序生成相应的 jni 文件</p>
<p>  :::primary</p>
<p>  ① IDEA 中配置 javah 程序：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/u011781521/article/details/106956827/?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.no_search_link&spm=1001.2101.3001.4242" >配置并使用 JNI</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>  ② 直接在命令行中使用 javah 指令可能无法被识别，即使你配置了环境变量</p>
<p>  :::</p>
<p>  (3) 采用 C/C++ 编写方法的具体实现</p>
  <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="comment">// 头文件记得换成你自己 JNI 生成的文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;chapter06_NativeMethod.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数名</span></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">chapter06_NativeMethod_nativeMethod</span></span></span><br><span class="line"><span class="function"><span class="params">(JNIEnv* env, jclass jc, jstring name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 返回传入的名称</span></span><br><span class="line">	<span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  (4) 编译 C/C++ 源文件</p>
  <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -D_REENTRANT -fPIC -l $Java_HOME$\include -l $Java_HOME$\include\win32 -c nativeMethod.c</span><br></pre></td></tr></table></div></figure>

<p>  (5) 后续暂时不记录了，因为有问题</p>
</li>
<li><p>特点：JNI 调用本地方法会导致开发的程序跨平台性能变差</p>
</li>
</ul>
<blockquote>
<p><strong>什么是本地方法栈?</strong></p>
</blockquote>
<ul>
<li><p>核心：基本内容和虚拟机栈完全相同</p>
</li>
<li><p>定义：存储被调用的本地方法拥有的信息</p>
</li>
<li><p>特点：</p>
<ul>
<li>[本地方法栈完全采用 C 语言实现]{.red}</li>
<li>[本地方法栈也不存在垃圾回收机制，但是能够抛出 StackOverFlowError 异常和 OutOfMemoryError 异常]{.blue}</li>
<li>[本地方法栈也是线程私有空间]{.blue}</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li>Java 虚拟机规范没有明确说明虚拟机必须实现本地方法栈，所以本地方法栈是可以没有的</li>
<li>HotSpot 虚拟机中直接将虚拟机栈和本地方法栈合二为一</li>
</ul>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/23/jvm/runtime/stackspace/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/">栈空间-虚拟机栈</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-23</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="虚拟机栈"   >
          <a href="#虚拟机栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1>
      
        <h2 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h2>
      <blockquote>
<p><strong>虚拟机栈基本概念</strong></p>
</blockquote>
<ul>
<li><p>定义：虚拟机栈依然是一块内存区域</p>
</li>
<li><p>作用：[临时存储所有 <strong>已经被调用</strong> 的方法拥有的数据]{.red}</p>
</li>
<li><p>组成：[栈帧是虚拟机栈中最小的存储单位]{.red}</p>
<ul>
<li>每个栈帧对应保存每个被调用的方法，没有被调用的方法是不会产生相应的栈帧进行保存的</li>
<li>每个方法执行结束后，栈帧就会出栈（销毁）</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li><p>[虚拟机栈是线程私有空间：每个线程都会占用虚拟机栈的中的 <strong>固定空间</strong>，每个固定空间都是私有的]{.red}</p>
<ul>
<li><p>虚拟机栈总容量：[操作系统分配给虚拟机的内存 - 堆区内存 - 方法区内存 - 本地方法栈内存]{.red}</p>
<ul>
<li>虚拟机栈的总容量我们是无法直接使用参数来控制的，取决于虚拟机获得的内存大小</li>
</ul>
</li>
<li><p>[虚拟机栈的大小可以是固定的也可以是动态扩展的]{.red}</p>
<ul>
<li><p>解释：[这里指的虚拟机栈大小是每个线程被分配的大小而不是虚拟机栈的总容量]{.red}</p>
</li>
<li><p>固定容量：</p>
<ul>
<li><p>+++info 各个操作系统的默认的固定容量不同</p>
<ul>
<li><p>Linux：默认每个线程分配的虚拟机栈区域大小 1MB</p>
</li>
<li><p>macOS：默认每个线程分配的虚拟机栈区域大小 1MB</p>
</li>
<li><p>Solaris：默认每个线程分配的虚拟栈区域大小为 1MB</p>
</li>
<li><p>Windows：[取决于操作系统设置的虚拟内存大小]{.red}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/虚拟机栈大小.2613fyb77r0g.png" alt="虚拟机栈大小" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>固定容量设置得太小也会导致虚拟机无法运行</p>
<blockquote>
<p>《深入理解虚拟机》上写的原话，但是我将其设置为1k之后依然能够运行，很奇怪</p>
</blockquote>
</li>
</ul>
</li>
<li><p>动态扩展容量：</p>
<ul>
<li>定义：虚拟机栈的容量不足时可以使用虚拟机内存中剩余空闲的内存作为扩展</li>
<li>现状：HotSpot 虚拟机并没有选择支持动态扩展技术，以前的 Classic 虚拟机支持动态扩展</li>
</ul>
</li>
<li><p>设置线程分配的栈大小：[-Xss Size]{.blue}</p>
  <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意命令和大小之间是没有空格的</span></span><br><span class="line">-Xss1k</span><br><span class="line">-Xss1m</span><br><span class="line">-Xss1g</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>[虚拟机栈不存在垃圾回收机制，但是存在 OutOfMemoryError 异常和 StackOverFlowError 异常]{.red}</p>
<ul>
<li><p>[线程获取的虚拟机栈深度不够无法容纳太多的栈帧，就会抛出StackOverFlowError 异常]{.red}</p>
<p>  测试代码：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个栈帧并不大，但是栈帧数量太多</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 静态变量 count: 记录递归的次数</span></span><br><span class="line">    System.out.println(++count);</span><br><span class="line">    <span class="comment">// 无限递归</span></span><br><span class="line">    main(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 大小不够：栈帧数量不多，但是每个栈帧的大小太大（测试见《深入理解JVM》）</span></span><br></pre></td></tr></table></div></figure>

<p>  测试结果：</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/虚拟机栈溢出.voivx0vevz4.png" alt="虚拟机栈溢出" style="zoom:80%;" />

<p>  :::warning</p>
<p>  ① 单线程情况下，无论是栈帧的数量太多还是栈帧太大，都会因为栈帧的深度不够而抛出的 StackOverFlowError 异常</p>
<p>  ② 单线程情况下，如果线程创建时申请的空间超过了虚拟机栈总容量大小，会抛出 OutOfMemoryError 异常</p>
<p>  （把虚拟机栈空间设置为10g也没有出现这种情况）</p>
<p>  :::</p>
</li>
<li><p>[虚拟机栈在动态扩展线程的栈空间时， 无法申请到足够的内存就会抛出 OutOfMemoryError 异常]{.red}</p>
<p>  :::warning</p>
<p>  ① Java 大多数虚拟机都支持动态扩展技术（存疑），不过 HotSpot 并不支持动态扩展技术，远古的 Classic 支持</p>
<p>  （可以使用早期的 JDK 版本进行测试）</p>
<p>  ② 多线程情况下，创建的线程太多就会导致虚拟机栈的总容量不够，从而抛出 OutOfMemoryError 异常</p>
<p>  ③ 多线程情况下测试 OOM 异常容易导致操作系统假死，因为Java 中每个线程都是映射一个内核级线程</p>
<p>  :::</p>
<p>  测试代码</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个线程分配的栈空间设置为 1g</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 无限创建线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;被创建&quot;</span>);</span><br><span class="line">            <span class="comment">// 保证线程无限运行</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  测试结果：在创建了 1000+ 左右的线程之后，IDEA 直接卡死，被强制结束了（不过之前确实测试出了 OutOfMemoryError 异常）</p>
</li>
</ul>
</li>
<li><p>[每个线程和其拥有的虚拟机栈空间生命周期一致：线程结束后拥有虚拟机栈空间也相应释放]{.blue}</p>
</li>
<li><p>栈空间主要涉及 [进程运行的管理]{.red}，所以存储被调用的方法相关信息</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>虚拟机栈内部结构图示</strong></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/个人博客搭建/虚拟机栈结构.4dq1hkdejyu0.png" alt="虚拟机栈结构" style="zoom:80%;" />


        <h2 id="栈帧"   >
          <a href="#栈帧" class="heading-link"><i class="fas fa-link"></i></a><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2>
      <ul>
<li><p>定义：虚拟机栈中存储方法的最小单位</p>
</li>
<li><p>特点：</p>
<ul>
<li>每个栈帧都对应存储一个方法</li>
<li>虚拟机栈顶的栈帧也被称作[当前栈帧]{.red}</li>
</ul>
</li>
<li><p>组成：</p>
<ul>
<li><a href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8">局部变量表</a>（Local Variables）</li>
<li><a href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88">操作数栈</a>（Operand Stack）</li>
<li><a href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5">动态链接</a>（Dynamic Linking）</li>
<li><a href="#%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80">返回地址</a>（Return Address）</li>
<li>附加信息：这个组成部分是可有可无的</li>
</ul>
</li>
<li><p>入栈/出栈过程：</p>
<ul>
<li><p>虚拟机在每个方法被调用时都会创建相应的栈帧并将其入栈</p>
</li>
<li><p>虚拟机在每个方法执行结束时会将该方法出栈（两种结束/出栈方式）</p>
<ul>
<li><p>[方法正常结束：return 返回]{.blue}</p>
</li>
<li><p>[方法异常结束：throw 返回]{.blue}</p>
<blockquote>
<p>注：方法异常结束就是说方法的执行过程中出现了异常，但是这个异常并没有被正常处理，所以导致方法结束</p>
</blockquote>
</li>
</ul>
</li>
<li><p>[恢复上层方法的局部变量表和操作数栈，并将方法的返回值压入操作数栈]{.red}</p>
</li>
<li><p>[根据返回地址调整程序计数器的值，继续执行此前没有执行完的方法]{.red}</p>
</li>
</ul>
</li>
</ul>

        <h3 id="局部变量表"   >
          <a href="#局部变量表" class="heading-link"><i class="fas fa-link"></i></a><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3>
      <ul>
<li><p>定义：栈帧中 [存储局部变量和方法参数]{.red} 的内存区域</p>
<ul>
<li>局部变量和成员变量：<ul>
<li>定义：方法中声明的变量都是局部变量，类中声明的变量都是成员变量</li>
<li>区别：<ul>
<li>两种变量的[作用域不同]{.blue}：前者出了方法就不可以被调用，后者可以在类中随意调用</li>
<li>两种变量的[赋值情况不同]{.blue}：<ul>
<li>前者必须赋值才能够使用</li>
<li>后者 [类变量会在链接准备阶段]{.red}赋默认值，[实例变量会在对象创建时分配默认值]{.red}，所以不赋值也可以使用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>基本数据类型和引用类型：<ul>
<li>基本数据类型就是 int、short、byte、boolean、double、long、char、float 8 种</li>
<li>引用类型：各种类（String、自定义类等等）</li>
<li>变量类型：无论是局部变量还是成员变量都有相应的数据类型</li>
</ul>
</li>
</ul>
<p>  :::info</p>
<p>  ① 局部变量表存储的引用类型局部变量，实际上存储的是该对象的引用，对象的实际数据分配在堆中</p>
<p>  ② 局部变量的类型还可以是返回地址（returnAddress 类型）!!我不太清楚这是个什么，反编译过程没见过!!{.bulr}</p>
<p>  :::</p>
</li>
<li><p>组成：[最小存储单位是变量槽]{.red}</p>
</li>
<li><p>变量槽特点：</p>
<ul>
<li><p>每个变量槽都具有对应索引，执行引擎通过索引访问变量槽存储的变量</p>
</li>
<li><p>[非静态方法会默认拥有 this 变量，始终占用索引为 0 的变量槽]{.red}</p>
<blockquote>
<p>注：正因为默认在非静态方法中添加了 this 变量，所以你才能够使用 this 关键字</p>
</blockquote>
</li>
<li><p>不同类型的局部变量占用的变量槽数量不同</p>
<ul>
<li>[long 和 double 型占用两个变量槽（64位）]{.red}</li>
<li>其余类型仅占用一个变量槽（32位）</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/个人博客搭建/变量槽.41qyru13ed80.png" alt="变量槽" style="zoom:80%;" /></li>
<li><p>[变量槽存储的局部变量如果在方法未结束前就不再使用，那么该变量槽会被其他变量复用（变量槽复用）]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">10</span>;</span><br><span class="line">    &#123;	<span class="comment">// second 变量只在这个代码块中有效，出了代码块就无效了</span></span><br><span class="line">        <span class="keyword">double</span> second = first + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// second 占用的变量槽将会被 third 变量占据</span></span><br><span class="line">    <span class="comment">// second 变量占据两个变量槽，third 只占据一个，所以最后会有一个变量槽空着</span></span><br><span class="line">    <span class="keyword">int</span> third = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  +++info 反编译解析之前可以先想想局部变量表的大小是多少？到底有几个局部变量？</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/个人博客搭建/变量槽复用.2kf44qleuco0.png" alt="变量槽复用" style="zoom:80%;" />

<p>  +++</p>
</li>
<li><p>[变量槽会将 short、byte、boolean、char类型转换为 int 类型存储]{.blue}</p>
<p>  :::warning</p>
<p>  这个点我暂时不太明白</p>
<p>  :::</p>
</li>
</ul>
</li>
<li><p>局部变量表特点：</p>
<ul>
<li><p>局部变量表中的参数和局部变量越多，局部变量表越大</p>
</li>
<li><p>[局部变量表的大小在编译期间就已经确定]{.red}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/个人博客搭建/局部变量表大小.6dcbkdq2n7w0.png" alt="局部变量表大小" style="zoom:80%;" />

</li>
</ul>
</li>
</ul>

        <h3 id="操作数栈"   >
          <a href="#操作数栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3>
      <p>:::info</p>
<p>前提：如果熟悉数据结构的读者，尤其是利用栈结构写过计算器的读者，将会很容易理解操作数栈这个区域</p>
<p>建议阅读：<a href="">栈</a></p>
<p>:::</p>
<ul>
<li><p>定义：临时存储 [将要进行运算的局部变量和计算结果]{.red} 的内存区域</p>
</li>
<li><p>基于栈的字节码执行引擎</p>
<ul>
<li><p>执行引擎：</p>
<ul>
<li>物理机的执行引擎是建立在具体硬件之上：[处理器、缓存、指令集（x86）、操作系统]{.blue}</li>
<li>虚拟机的执行引擎是建立在软件之上：[解释器、即时编译器、指令集（字节码）、垃圾回收]{.blue}</li>
</ul>
</li>
<li><p>基于栈和基于寄存器</p>
<ul>
<li><p>基于寄存器：</p>
<ul>
<li><p>定义：[变量临时存放在处理器的寄存器中]{.red}，执行引擎每次根据寄存器地址获取变量进行计算</p>
</li>
<li><p>操作：每个寄存器都有相应的地址，每次使用指令调用寄存器都需要按照寄存器地址选用</p>
</li>
<li><p>特点：</p>
<ul>
<li><p>[每个指令依赖于具体寄存器地址就会导致指令集的设计非常复杂]{.green}</p>
</li>
<li><p>[指令集的设计依赖于寄存器这种硬件就会导致其移植性差]{.green}</p>
</li>
<li><p>[指令集的设计复杂带来的好处就是每条指令的功能强大，完成一个方法需要的指令数量少，执行效率高，寄存器执行效率高也是其中一个原因]{.red}</p>
  <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 完成加法计算 a = b + 4</span></span><br><span class="line"><span class="comment"># 取寄存器 $s1 中的值加上常数 4 然后赋值给 $s0</span></span><br><span class="line"><span class="comment"># 这个指令不是 x86 指令集中的而是 MIPS 指令集中的</span></span><br><span class="line">addi <span class="variable">$s0</span>, <span class="variable">$s1</span>, 4</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>基于栈</p>
<ul>
<li><p>定义：[变量临时存储在操作数栈中]{.red}，执行引擎每次执行出栈和入栈操作进行计算</p>
</li>
<li><p>操作：操作数栈仅存在出栈和入栈的操作，没有地址这种设计</p>
</li>
<li><p>特点：</p>
<ul>
<li><p>[每个指令只涉及出栈入栈操作并不依赖于地址所以指令集的设计相对精简]{.red}</p>
</li>
<li><p>[指令集的设计不依赖于物理硬件的好处就是其可移植性高]{.red}</p>
</li>
<li><p>[指令集的设计精简的缺点就是指令的数量非常多，完成一个方法可能需要大量的指令，从而导致效率低下]{.green}</p>
  <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 完成加法计算: a = b + 10</span></span><br><span class="line">0: bipush        10</span><br><span class="line">2: istore_1</span><br><span class="line">3: iload_1</span><br><span class="line">4: bipush        10</span><br><span class="line">6: iadd</span><br><span class="line">7: istore_2</span><br><span class="line">8: <span class="built_in">return</span></span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>目的：[采用基于栈结构的执行引擎就是为了能够不依赖于硬件从而实现 <strong>跨平台</strong>，并且编译器容易实现]{.red}</p>
</li>
<li><p>执行过程：</p>
<ul>
<li><p>测试代码：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行两数求和的计算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> second = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> result = first + second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>字节码指令</p>
  <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0: bipush        10</span><br><span class="line">2: istore_1</span><br><span class="line">3: bipush        20</span><br><span class="line">5: istore_2</span><br><span class="line">6: iload_1</span><br><span class="line">7: iload_2</span><br><span class="line">8: iadd</span><br><span class="line">9: istore_3</span><br><span class="line">10: <span class="built_in">return</span></span><br></pre></td></tr></table></div></figure></li>
<li><p>图解：（参考《深入理解虚拟机》）</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/基于栈的执行引擎.6xdgz9b1xh00.png" alt="基于栈的执行引擎" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
</li>
<li><p>栈顶缓存技术</p>
<ul>
<li>引入：<ul>
<li>因为虚拟机的内存实际使用的是物理机的内存，频繁的出栈入栈实际上是在频繁读写内存</li>
<li>又因为虚拟机采用的是基于栈式的体系结构，所以指令的读写更加频繁</li>
<li>频繁的读写内存会降低操作系统的效率，也就会导致虚拟机的性能降低</li>
</ul>
</li>
<li>解决方式：[将栈顶元素全部缓存到处理器的寄存器中，防止多次使用造成的频繁读写操作]{.red}</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>[操作数栈的深度也在编译期间就已经确定]{.red}</li>
<li>[操作数栈的深度和局部变量表的大小没有直接的关系：局部变量的数量会 <strong>间接影响</strong> 到操作数栈开辟的深度]{.red}</li>
</ul>
</li>
</ul>

        <h3 id="动态链接"   >
          <a href="#动态链接" class="heading-link"><i class="fas fa-link"></i></a><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3>
      <blockquote>
<p><strong>什么是动态链接？</strong></p>
</blockquote>
<ul>
<li><p>定义：[将字节码指令使用的符号引用解析成运行时常量池保存的直接引用]{.red}</p>
</li>
<li><p>特点</p>
<ul>
<li>[动态链接是在方法执行期间发生的，静态解析是在连接解析阶段发生的]{.red}</li>
<li>并不是所有方法调用都会触发动态链接，部分方法调用可能在解析阶段发生的</li>
</ul>
</li>
<li><p>解析过程</p>
<p>  测试代码：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> DynamicLink().methodA();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></div></figure>

<p>  字节码指令：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #数字 就是符号引用</span></span><br><span class="line"><span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  </span><br><span class="line"><span class="number">3</span>: dup</span><br><span class="line"><span class="comment">// 方法调用会使用符号引用，动态链接会进行解析</span></span><br><span class="line"><span class="comment">// 构造方法调用</span></span><br><span class="line"><span class="number">4</span>: invokespecial #<span class="number">3</span></span><br><span class="line"><span class="comment">// methodA() 方法调用</span></span><br><span class="line"><span class="number">7</span>: invokevirtual #<span class="number">4</span>                  </span><br><span class="line"><span class="number">10</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></div></figure>

<p>  常量池保存符号引用和直接引用的关系</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中间不重要的常量省略了</span></span><br><span class="line">Constant pool:</span><br><span class="line">   <span class="comment">// ① #4 符号引用要求我们再去查找 #2 #22 两个符号引用</span></span><br><span class="line">   #<span class="number">4</span> = Methodref          #<span class="number">2.</span>#<span class="number">22</span>         <span class="comment">// chapter05/DynamicLink.methodA:()V</span></span><br><span class="line">   <span class="comment">// ② #2 符号引用要求我们继续查找 #21 符号引用</span></span><br><span class="line">   #<span class="number">2</span> = Class              #<span class="number">21</span>            <span class="comment">// chapter05/DynamicLink</span></span><br><span class="line">   <span class="comment">// ③ #22 是方法签名，要求继续查找 #17 #7 两个符号引用</span></span><br><span class="line">   #<span class="number">22</span> = NameAndType        #<span class="number">17</span>:#<span class="number">7</span>         <span class="comment">// methodA:()V</span></span><br><span class="line">   <span class="comment">// ④ 调用方法的对象的符号引用就被解析完成了</span></span><br><span class="line">   #<span class="number">21</span> = Utf8               chapter05/DynamicLink</span><br><span class="line">   <span class="comment">// ⑤ 被调用方法的返回值和方法名就被解析成功了</span></span><br><span class="line">   #<span class="number">7</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">17</span> = Utf8               methodA</span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h3 id="返回地址"   >
          <a href="#返回地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h3>
      <blockquote>
<p><strong>什么是返回地址？</strong></p>
</blockquote>
<ul>
<li>定义：方法执行结束后回到的最初被调用的位置称为返回地址</li>
</ul>
<blockquote>
<p><strong>为什么需要返回地址？</strong></p>
</blockquote>
<ul>
<li>原因：<ul>
<li>程序计数器保存的是当前执行的指令地址，而此前的指令地址是不知道的</li>
<li>如果没有此前的指令地址，执行引擎就不知道此前的栈帧执行到哪里了</li>
<li>被调用的方法执行结束之后，执行引擎在没有返回地址的情况下就回不去了</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>如何保证能够返回？</strong></p>
</blockquote>
<ul>
<li><p>方式：[方法被调用时栈帧就会记录当前程序计数器的值作为返回地址]{.red}</p>
</li>
<li><p>特点</p>
<ul>
<li>方法正常退出：执行引擎使用 [栈帧中保存的返回地址]{.red} 回到此前执行的位置</li>
<li>方法异常退出：执行引擎使用 [异常表中的信息确定返回地址，栈帧几乎不会保存这种信息]{.red}.</li>
</ul>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/23/jvm/runtime/heapspace/TLAB/">堆空间-TLAB</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-23</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h3 id="TLAB"   >
          <a href="#TLAB" class="heading-link"><i class="fas fa-link"></i></a><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h3>
      <p>:::primary</p>
<p>参考博客：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qiang_zi_/article/details/98504710" >JVM - TLAB</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.zhihu.com/question/56538259" >在TLAB中创建的对象，如何被其他线程共享？</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.jianshu.com/p/8be816cbb5ed" >浅析java中的TLAB</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<blockquote>
<p><strong>什么是 TLAB?</strong></p>
</blockquote>
<ul>
<li><p>名称：</p>
<ul>
<li>全称：TLAB（Thread Local Allocation Buffer）</li>
<li>译名：线程本地缓存</li>
</ul>
</li>
<li><p>定义：[堆中的 <strong>伊甸园区</strong> 分配给线程的一块较小的“私有”空间]{.red}</p>
<ul>
<li>在伊甸园区中划分 TLAB 采用的也是指针碰撞的方式</li>
<li>TLAB 内部分配对象时采用的依然是指针碰撞的方式 </li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li><p>TLAB 空间非常小，仅占用伊甸园区的 1% 大小</p>
</li>
<li><p>[线程每次创建对象优先在 TLAB 区域创建]{.red}</p>
</li>
<li><p>[线程每次在 TLAB 中创建对象时，其余线程是无法抢占 TLAB 执行的]{.red}</p>
</li>
<li><p>TLAB 无法分配足够的空间给新对象时：</p>
<ul>
<li><p>[TLAB 剩余的空间大于设定的最大浪费空间（阈值）：新对象直接在伊甸园区的公共部分进行创建]{.red}</p>
</li>
<li><p>[TLAB 剩余的空间小于设定的最大浪费空间（阈值）：重新提供给线程一块 TLAB 让其创建对象]{.red}</p>
<p>  :::info</p>
<p>  ① 如果新分配的 TLAB 依然无法容纳新对象，那么该对象就需要在伊甸园公共区域创建</p>
<p>  ② 如果在伊甸园的公共区域创建对象，那就意味着需要其他的方式确保分配过程的安全（诸如CAS加锁）</p>
<p>  :::</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>命令：</p>
<ul>
<li></li>
<li>[-XX:TLABWasteTargetPercent 设置 TLAB 区域所占空间的百分比]{.blue}</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>为什么要使用 TLAB?</strong></p>
</blockquote>
<ul>
<li>引入：<ul>
<li>多线程情况下，如何确保创建对象时的线程安全，不会被其余线程抢占执行？</li>
<li>当前线程刚为对象分配好空间，还没来得及将引用指向内存，其余线程抢占执行，覆盖了刚才创建的对象</li>
<li>这种情况是非常有可能发生的</li>
</ul>
</li>
<li>方式：<ul>
<li>[给每个线程为对象分配内存的动作做同步处理]{.red}，确保其余线程不会访问<ul>
<li>[线程分配动作同步带来的缺陷显然就是程序性能的下降]{.green}</li>
</ul>
</li>
<li>[给每个线程分配“私有”的堆空间，每次线程都在这个“私有”的空间中创建对象]{.red}，确保其余线程不会访问<ul>
<li>[“私有”空间并不是真正的线程私有，<strong>线程仅在分配对象空间时独占这块区域</strong>，其余时候所有线程都可以访问这块区域]{.green}</li>
<li>[线程在 TLAB 上分配对象时并不会将这块区域上锁，所以不会因为同步造成性能下降]{.red}</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>TLAB 原理是什么?</strong></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/23/jvm/runtime/heapspace/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/">堆空间-逃逸分析</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-23</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="逃逸分析"   >
          <a href="#逃逸分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h1>
      <p>:::warning</p>
<p>前提：逃逸分析目前是 Java 虚拟机中比较前沿的技术，并且还很不成熟，需要时间优化</p>
<p>参考博客：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/chenxuegui1234/article/details/96726988" >JVM对象逃逸</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<blockquote>
<p><strong>什么是逃逸分析？</strong></p>
</blockquote>
<ul>
<li><p>定义：编译器根据字节码信息分析对象是否发生逃逸的 [分析技术]{.red}</p>
<p>  :::info</p>
<p>  ① 逃逸分析只是 [代码分析技术]{.red} 而不是 [代码优化技术]{.red}</p>
<p>  ② 逃逸分析是后续代码优化技术的前提，栈上分配、标量替换、同步消除都依赖于逃逸分析</p>
<p>  :::</p>
</li>
</ul>
<blockquote>
<p><strong>为什么要使用逃逸分析?</strong></p>
</blockquote>
<ul>
<li><p>核心：[有效减少堆空间的内存分配压力，避免频繁的垃圾回收对用户线程造成的影响]{.red}</p>
</li>
<li><p>解释：</p>
<ul>
<li>定义中提到逃逸分析只是分析技术，所以严谨来说逃逸分析是没有什么好处的，有好处的只是优化技术</li>
<li>但是因为逃逸分析是优化技术的前提，所以这里用逃逸分析指代优化技术</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>如何判断对象是否发生逃逸？</strong></p>
</blockquote>
<ul>
<li><p>定义：</p>
<ul>
<li>[<strong>本方法创建的对象在外部被使用</strong> 或者 <strong>本方法使用外部方法传递的对象</strong> 都被视为对象发生逃逸]{.red}<ul>
<li>本方法创建的对象在外部被使用：[内部对象逃逸出本方法]{.blue}</li>
<li>本方法使用外部方法传递的对象：[外部对象逃逸进本方法]{.blue}</li>
</ul>
</li>
<li>只有本方法创建的对象不会被外部使用才认为没有发生逃逸</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逃逸分析举例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">returnStringBuilder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 其他方法可以引用本方法创建的对象了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(<span class="string">&quot;对象逃逸了!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防止对象逃逸</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">returnStringBuilder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 思考：为什么这个就不算做逃逸了呢？明明返回了对象</span></span><br><span class="line">    <span class="comment">// 回答1：创建的 StringBuilder 对象无法被其他方法引用了，所以这个对象是没有逃逸的</span></span><br><span class="line">    <span class="comment">// 回答2：但是 toString 方法又会创建 String 对象，String 对象是可以被其他方法引用的，所以还是逃逸了</span></span><br><span class="line">    <span class="comment">// 回答3：真正防止逃逸的方法只有不提供外界可引用的对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(<span class="string">&quot;对象逃逸了!&quot;</span>).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>三种逃逸状态</p>
<ul>
<li><p>线程级逃逸（全局逃逸）：类的 [成员变量]{.red} 引用方法的返回的对象</p>
<ul>
<li>[成员变量意味着无论变量是静态的还是非静态的，都认为是逃逸对象]{.blue}</li>
<li>[成员变量可以被多个线程访问，所以称为线程级逃逸]{.blue}</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysis</span></span>&#123;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> StringBuilder sb;</span><br><span class="line">    <span class="comment">// 线程逃逸</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadEscape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 多个线程都可以在这个方法中引用到这个对象:：对象逃逸出线程</span></span><br><span class="line">        <span class="comment">// 问题：如果给对象加锁，那么还算做逃逸吗？</span></span><br><span class="line">        <span class="comment">// 个人观点：应该还是算的, 即使上锁也依然可以访问</span></span><br><span class="line">        <span class="keyword">this</span>.sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;对象逃出线程了!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>方法级逃逸（参数逃逸）：</p>
<ul>
<li>[本方法将对象作为返回值返回，其余方法可以直接调用]{.blue}</li>
<li>[本方法将对象作为参数传递到其他方法中，供其他方法使用]{.blue}</li>
<li>细节：每个线程引用的对象都是不可能一样的，因为每次都是新建对象，所以对于线程是不可见的，没有逃出线程</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法逃逸</span></span><br><span class="line"><span class="comment">// 情况1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">createStringBuilder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(<span class="string">&quot;对象逃出方法了!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 情况2</span></span><br><span class="line"><span class="comment">// 这个对象显然并不属于该方法，而是属于其他方法的</span></span><br><span class="line"><span class="comment">// 对象逃逸进这个方法了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useStringBuilder</span><span class="params">(StringBuilder sb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对象逃逸出本方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createStringBuilder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 传递参数</span></span><br><span class="line">    useStringBuilder(<span class="keyword">new</span> StringBuilder(<span class="string">&quot;对象逃逸出方法了!&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>不逃逸：[只要确保对象不会被其他方法或者线程引用，那么就是没有逃逸的]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noEscapeAnalysis</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="string">&quot;我是对象!&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;我没有逃逸!&quot;</span>);</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>结论：[尽可能多使用局部变量而不是成员变量，减少堆分配的压力]{.green}</p>
</li>
</ul>
<blockquote>
<p><strong>没有逃逸的对象应该怎么处理?</strong></p>
</blockquote>
<ul>
<li><p>核心：</p>
<ul>
<li>[<strong>没有发生逃逸</strong> 的对象就 <strong>可能</strong> 会被分配在栈空间上]{.red}</li>
<li>[存放在栈帧中的对象随着栈帧的结束而被销毁]{.red}</li>
</ul>
</li>
<li><p>方式：</p>
<ul>
<li><p>栈上分配（Stack Allocation）</p>
<ul>
<li>定义：[方法逃逸和没有逃逸的对象]{.red} 将会被分配在栈上而不是堆中</li>
<li>优点：[避免堆空间垃圾回收造成的性能消耗（诸如筛选回收对象、整理内存等），对象会随着栈帧的出栈而被销毁]{.red}</li>
<li>细节：[栈上分配并没有明确指明对象在栈中如何存储]{.blue}</li>
</ul>
</li>
<li><p>标量替换（Scalar Replacement）</p>
<ul>
<li><p>概念：</p>
<ul>
<li><p>标量：无法进一步分解的数据类型都称为标量</p>
<p>  int、double、float、引用类型等等都是无法继续分解的标量</p>
</li>
<li><p>聚合量：可以继续分解的数据类型称为聚合量</p>
<p>  对象就是非常典型的聚合量</p>
</li>
</ul>
</li>
<li><p>定义：[<strong>没有逃逸的对象</strong> 会被直接拆解为若干的成员变量存储在栈帧的局部变量表中]{.red}</p>
<ul>
<li>[采用标量替换后就不会创建对象了，而是改为创建各个成员变量]{.blue}</li>
<li>如果对象的拥有聚合量的成员变量，那么继续拆解就行</li>
</ul>
</li>
<li><p>细节：[标量替换可以看做是栈上分配的一种具体实现]{.red}</p>
</li>
<li><p>实例：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="comment">// 标量替换：不会直接创建对象了，而是创建局部变量</span></span><br><span class="line">    user.id;</span><br><span class="line">    user.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>测试代码</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化方案: 标量替换</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于对象没有逃逸,所以会采用标量替换的方式创建对象,所以创建消耗的时间也会较少</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createUser</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.id = <span class="number">1</span>;</span><br><span class="line">    user.name = <span class="string">&quot;Fuyusakaiori&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟机参数设置</span></span><br><span class="line"><span class="comment">// 第一次测试：关闭标量替换</span></span><br><span class="line"><span class="comment">// 第一次参数设置：-Xms100m -Xmx100m -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+PrintGC</span></span><br><span class="line"><span class="comment">// 第二次测试：开启标量替换</span></span><br><span class="line"><span class="comment">// 第二次参数设置：-Xms100m -Xmx100m -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+PrintGC</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 开始创建对象的起始时间</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        createUser();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;耗费时间: &quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>测试结果</p>
<ul>
<li>第一次测试：[没有开启标量替换的情况下创建对象消耗的时间 4228ms，并且会不断进行垃圾回收]{.green}</li>
<li>第二次测试：[开启标量替换的情况下创建对象仅消耗 8ms，并且不会进行垃圾回收]{.red}</li>
<li>测试结论：标量替换没有真正创建对象，因为根本就没有打印垃圾回收的信息</li>
</ul>
</li>
</ul>
</li>
<li><p>同步消除（Synchronization Elimination）</p>
<ul>
<li><p>定义：[<strong>方法逃逸和没有逃逸的对象</strong> 采用的同步措施会被 <strong>即时编译器</strong> 直接消除掉]{.red}</p>
</li>
<li><p>实例：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化方案: 同步消除</span></span><br><span class="line"><span class="comment">// 原始代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SynchronizationElimination</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 每个线程进入该方法都会创建一个新的对象</span></span><br><span class="line">    <span class="comment">// 所有线程根本不会访问到同一个对象，那本身就没有上锁的意义啊</span></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="keyword">synchronized</span> (user)</span><br><span class="line">    &#123;</span><br><span class="line">        user.id = <span class="number">1</span>;</span><br><span class="line">        user.name = <span class="string">&quot;Fuyusakaiori&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化方案：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SynchronizationElimination</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 消除同步机制</span></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.id = <span class="number">1</span>;</span><br><span class="line">    user.name = <span class="string">&quot;Fuyusakaiori&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
<p>  :::warning</p>
<p>  ① 同步消除策略非常不好测试，所以不在此进行测试</p>
<p>  ② 而且感觉同步消除存在一定的问题，既然其余线程都无法访问这个对象，那为什么要上锁呢？根本就不会这么写，那优化什么</p>
<p>  :::</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>逃逸分析是由谁来完成的呢?</strong></p>
</blockquote>
<ul>
<li>宽泛地讲逃逸分析显然是由 [执行引擎]{.red} 完成的</li>
<li>具体地来讲执行引擎中细分为解释器和即时编译器，逃逸分析实际是由 [C2 即时编译器（服务器端）]{.red} 执行的</li>
</ul>
<blockquote>
<p><strong>不成熟的逃逸分析带来的缺陷</strong></p>
</blockquote>
<ul>
<li><p>缺陷</p>
<ul>
<li><p>[逃逸分析的成本非常高]{.red}</p>
</li>
<li><p>[无法保证经过逃逸分析后的优化效果能够高于逃逸分析的成本]{.red}</p>
<blockquote>
<p>极端情况：经过逃逸分析之后发现几乎所有对象都发生了逃逸，那么就浪费了这次分析</p>
</blockquote>
</li>
</ul>
</li>
<li><p>细节：[逃逸分析在 JDK 6 以前都是默认不开启的，直到 JDK 7 之后才默认开启]{.blue}</p>
</li>
</ul>
<blockquote>
<p><strong>逃逸分析相关参数</strong></p>
</blockquote>
<ul>
<li>[-XX:+DoEscapeAnalysis：开启逃逸分析 / -XX:-DoEscapeAnalysis：关闭逃逸分析]{.blue}</li>
<li>[-XX:+EliminateAllocations：开启标量替换 / -XX:-EliminateAllocations：关闭标量替换]{.blue}</li>
<li>[-XX:+EliminateLocks：开启同步消除 / -XX:-EliminateLocks：关闭同步消除]{.blue}</li>
</ul>
<p>:::warning</p>
<p>① 两条无法使用的命令：-XX:+PrintEliminateAllocations（打印标量替换结果），-XX:+PrintEscapeAnalysis（查看逃逸分析结果）</p>
<p>② 这两条命令在《深入理解虚拟机》中提到了，但是实际没有办法使用，只可以在调试版本的虚拟机中可以使用</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚拟机创建错误</span></span><br><span class="line">VM option <span class="string">&#x27;PrintEliminateAllocations&#x27;</span> is notproduct and is available only in debug version of VM.</span><br></pre></td></tr></table></div></figure>

<p>:::</p>
<blockquote>
<p><strong>回到之前那个问题：对象只能够在堆中分配吗?</strong></p>
</blockquote>
<ul>
<li>先回答这个答案吧，[Java 对象目前只能够在堆中分配]{.red}</li>
<li>你可能想说，哎，不是有栈上分配技术和标量替换技术吗？为什么还是只能够在堆中分配呢？</li>
<li>[原因①：Java 虚拟机目前并没有实现栈上分配的技术，而是采用了诸如标量替换这种替代方案]{.green}</li>
<li>[原因②：标量替换并没有去创建对象，而是创建了对象包含的成员变量，这些成员变量又都是标量，所有压根就没有创建对象]{.green}</li>
<li>结论：所以最终依然认为 Java 对象目前仅能够在堆中分配，但是随着 Valhalla 项目的进行，说不定以后就可以真的在栈上分配了</li>
</ul>
<blockquote>
<p><strong>尾声</strong>（摘自《深入理解虚拟机》）</p>
</blockquote>
<ul>
<li><p>Java 对于栈上分配的技术有着明显的弱势</p>
</li>
<li><p>[但是 C/C++ 天生就支持栈上分配，只要不使用 new 关键字创建对象就好了]{.green}</p>
</li>
<li><p>[对于 Java 的竞争者 C# 来说也是支持栈上分配的]{.green}</p>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/23/jvm/runtime/heapspace/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/">堆空间-内存分配</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-23</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="内存分配"   >
          <a href="#内存分配" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1>
      <p>:::info</p>
<p>前提：这里对象的分配策略是建立在堆空间中的，不考虑逃逸分析这种例外情况</p>
<p>核心：解决对象如何在堆空间分配的问题</p>
<p>:::</p>

        <h2 id="分区概述"   >
          <a href="#分区概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#分区概述" class="headerlink" title="分区概述"></a>分区概述</h2>
      <ul>
<li><p>伊甸园区：</p>
<ul>
<li>[几乎所有对象都是在伊甸园区中被创建的，并且在伊甸园区中被销毁]{.red}</li>
<li>[伊甸园区无法存放对象时将会触发 Minor GC]{.red}</li>
</ul>
</li>
<li><p>幸存者0区/幸存者1区：</p>
<ul>
<li><p>开始：[每次仅使用一个分区存放对象，另外一个分区暂时为空]{.red}</p>
<p>  :::info</p>
<p>  ① 存放对象的分区也称为 From 区，不存放对象的分区也称为 To 区</p>
<p>  ② 第一次触发 Minor GC 时将会任意选择一个幸存者分区存放对象</p>
<p>  :::</p>
</li>
<li><p>过程：</p>
<ul>
<li>[幸存者区无法触发 Minor GC，只有伊甸园区可以触发]{.red}</li>
<li>[幸存者区虽然无法触发 Minor GC，但是 Minor GC  依然会回收幸存者区的对象]{.red}</li>
<li>[触发垃圾回收机制后，存放对象的分区将会把所有对象复制到空的分区中，并且清除自己拥有的对象]{.red}</li>
</ul>
</li>
<li><p>特点：[幸存者区中的每个对象都拥有年龄计数器，用于判断是否进入老年代]{.red}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/幸存者区.f89homjxw00.png" alt="幸存者区" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>老年代：[老年代中的对象很少被垃圾回收机制回收]{.red}</p>
</li>
</ul>

        <h2 id="分配策略"   >
          <a href="#分配策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h2>
      <ul>
<li>对象优先在伊甸园区中分配</li>
<li>大对象直接进入老年代<ul>
<li>内容：超过对象大小阈值的对象将会直接进入老年代</li>
<li>设置阈值命令：[-XX:PretenureSizeThreshold=Size]</li>
</ul>
</li>
<li>长期存活的对象进入老年代<ul>
<li>内容<ul>
<li>每个幸存者区中的对象都具有年龄计数器</li>
<li>每次从一个幸存者区移动到另一个幸存者区时，对象的年龄计数器就会加1</li>
<li>对象的年龄计数器达到阈值之后，对象就会从幸存者区进入老年代区</li>
</ul>
</li>
<li>细节：<ul>
<li>默认阈值为 15</li>
<li>设置阈值命令：[-XX:MaxTenuringThreshold=age]{.blue}</li>
</ul>
</li>
</ul>
</li>
<li>动态对象年龄判断进入老年代<ul>
<li>内容：<ul>
<li>只要保证幸存者区中具有 [小于等于某年龄的对象的总大小]{.red} 超过幸存者区大小的一半</li>
<li>那么 [大于等于该年龄的对象]{.red} 将会直接进入老年代，不需要等待年龄超过阈值</li>
</ul>
</li>
<li>细节：这个策略基本不怎么使用</li>
</ul>
</li>
<li>空间分配担保<ul>
<li>核心：[确保老年代能够容纳在幸存者区无法容纳的对象]{.red}</li>
<li>内容：<ul>
<li>[判断老年代最大连续可用空间是否大于新生代所有对象的总和]{.red}<ul>
<li>如果满足条件，那么这次 Minor GC 就是安全的</li>
<li>如果不满足条件，那么将会继续执行另一个判断</li>
</ul>
</li>
<li>[再次判断老年代最大可用空间是否大于历次晋升到老年代对象的平均大小]{.red}<ul>
<li>如果满足条件，仍然可以 Minor GC，但是是有风险的</li>
<li>如果不满足条件，将会执行 Full GC，用户线程停止时间将会变长</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h2 id="分配过程"   >
          <a href="#分配过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#分配过程" class="headerlink" title="分配过程"></a>分配过程</h2>
      <blockquote>
<p><strong>对象分配示意图</strong></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/分配过程.y6pu32gjvdc.png" alt="分配过程" style="zoom:80%;" />

<blockquote>
<p><strong>对象分配过程</strong></p>
</blockquote>
<ul>
<li><p>开始创建对象</p>
</li>
<li><p>[采用大对象直接进入老年代的策略]{.red}</p>
<ul>
<li>[如果超过对象的阈值：对象将直接进入老年代]{.blue}</li>
<li>如果没有超过对象的阈值：接着采用其他策略分配</li>
</ul>
</li>
<li><p>[判断伊甸园是否具有足够的空间容纳新对象]{.red}</p>
<ul>
<li><p>[如果伊甸园没有足够的空间容纳新对象：触发 Minor GC / YGC]{.blue}</p>
<p>  :::info</p>
<p>  注：触发 Minor GC 之前需要执行空间分配担保</p>
<p>  :::</p>
</li>
<li><p>如果伊甸园区可以容纳新对象：直接分配内存即可</p>
</li>
</ul>
</li>
<li><p>[Minor GC / YGC 开始回收伊甸园区和幸存者区中的对象]{.red}</p>
<ul>
<li><p>被垃圾回收机制回收的对象将会被销毁</p>
</li>
<li><p>[判断幸存者区中对象的年龄是否达到阈值]{.blue}</p>
<ul>
<li>[如果幸存者区中的对象达到阈值：晋升到老年代中]{.blue}</li>
<li>[如果幸存者区中的对象没有达到阈值：进入另一个空幸存者区]{.blue}</li>
</ul>
</li>
<li><p>[判断幸存者区是否还有足够空间容纳从伊甸园区进入幸存者区的对象]{.red}</p>
<ul>
<li>[如果幸存者区没有足够的空间容纳进入的对象：无法被容纳的对象直接晋升为老年代]{.blue}</li>
<li>[如果空幸存者区有足够的空间容纳所有对象：伊甸园和存放对象的幸存者区中没有被回收的对象将进入空幸存者区]{.blue}</li>
</ul>
<p>  :::info</p>
<p>  ① 因为此前执行了空间分配担保，所以可以直接进入老年代，没有必要判断</p>
<p>  ② 伊甸园区无法被幸存者区容纳的对象进入老年代，幸存者区本身的对象是根据阈值来决定的</p>
<p>  ③ 判断阈值和年龄关系的同时也会采用 [动态对象年龄]{.red} 的策略进行优化</p>
<p>  :::</p>
</li>
<li><p>[进入空幸存者区的对象的年龄计数器增加1]{.red}</p>
<p>  :::info</p>
<p>  ① 第一次触发 Minor GC时，两个幸存者区都是空的，虚拟机自行选择一个即可</p>
<p>  ② 对象移动之后年龄计数器达到阈值的话，需要等待下一次移动才会进入老年代</p>
<p>  ③ 年龄计数器的默认阈值是 15</p>
<p>  :::</p>
</li>
</ul>
</li>
<li><p>再次判断伊甸园区是否具有足够的空间容纳新对象</p>
<ul>
<li>如果伊甸园区可以容纳新对象：直接分配内存即可</li>
<li>如果伊甸园没有足够的空间容纳新对象：判断是否可以直接进入老年代</li>
</ul>
</li>
<li><p>[判断老年代是否具有足够的空间容纳新对象]{.red}</p>
<ul>
<li>[如果老年代没有足够的空间容纳新对象：触发 Major GC]{.blue}</li>
<li>[如果老年代有足够的空间容纳新对象：对象直接晋升到老年代]{.blue}</li>
</ul>
</li>
<li><p>Major GC 开始回收老年代中的对象</p>
</li>
<li><p>再次判断老年代是否具有足够的空间容纳新对象</p>
<ul>
<li>如果伊甸园区可以容纳新对象：直接分配内存即可</li>
<li>[如果伊甸园没有足够的空间容纳新对象：抛出 OutOfMemoryError 异常]{.blue}</li>
</ul>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/23/jvm/runtime/heapspace/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/">堆空间-对象创建</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-23</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="对象创建"   >
          <a href="#对象创建" class="heading-link"><i class="fas fa-link"></i></a><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h1>
      
        <h2 id="对象的组成部分"   >
          <a href="#对象的组成部分" class="heading-link"><i class="fas fa-link"></i></a><a href="#对象的组成部分" class="headerlink" title="对象的组成部分"></a>对象的组成部分</h2>
      <ul>
<li><p>对象头（Header）</p>
</li>
<li><p>实例数据（Instance Data）</p>
</li>
<li><p>对齐填充（Padding）</p>
</li>
</ul>

        <h3 id="对象头"   >
          <a href="#对象头" class="heading-link"><i class="fas fa-link"></i></a><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3>
      <blockquote>
<p><strong>对象头图示</strong></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/对象组成.3wxv6lvcr740.png" alt="对象组成" style="zoom:80%;" />

<blockquote>
<p><strong>对象头详解</strong></p>
</blockquote>
<ul>
<li><p>[Mark Word]{.red}：</p>
<ul>
<li><p>定义：采用 32位/64位 的 Bitmap 数据结构存储对象的运行时相关信息</p>
<p>  :::info</p>
<p>  32位虚拟机的 Bitmap 数据结构就是32位的，64位的虚拟机的 Bitmap 就是64位的</p>
<p>  :::</p>
</li>
<li><p>组成：</p>
<ul>
<li>问题：对象的运行时相关信息数据量特别多，超过了 Bitmap 数据结构所能承载的容量，那要怎么解决这个问题呢？</li>
<li>方式：[Mark Word 被设计成为动态的数据结构：根据对象不同的锁状态确定 Mark Word 存储的具体内容]{.red}</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li>[未锁定状态和偏向锁状态的标志位是一样的，所以这两个锁还需要使用 1bit 来进行区分]{.blue}</li>
<li>各个不同的锁不在此细讲，因为涉及到并发编程</li>
</ul>
</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/Mark-Word.39jpbualpio0.png" alt="Mark-Word" style="zoom:80%;" /></li>
<li><p>[类型指针]{.red}</p>
<ul>
<li><p>定义：[指向该对象所属的类型元数据（Klass 对象）的指针]{.red}</p>
</li>
<li><p>细节：</p>
<ul>
<li><p>[对象可以通过类型元数据指针找到其所属的类，但是并不是所有对象都必须保存该指针]{.red}</p>
<p>  比如在使用反射中，你可以使用对象获取 Class 对象也可以使用类或者方法获取 Class 对象</p>
</li>
<li><p>[首先明确 Klass 对象不是 Class 对象]{.red}</p>
<p>  详细了解：[OOP-Klass模型](#OOP-Klass 模型)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数组长度：用于记录数组长度的部分（[只有数组才有这部分内容]{.red}）</p>
</li>
</ul>

        <h3 id="实例数据"   >
          <a href="#实例数据" class="heading-link"><i class="fas fa-link"></i></a><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3>
      <ul>
<li><p>定义：存储对象中所有的有效信息</p>
</li>
<li><p>组成：我们在程序中 [定义各种类型的 <strong>实例变量</strong> 以及从父类继承的 <strong>实例变量</strong> ]{.red}</p>
<p>  +++warning 对象的实例数据仅包含各种各样的实例变量，并不包含方法信息</p>
<p>  ① 每个类都可以拥有非常多的对象，每个对象仅有数据字段不同，使用的方法肯定是完全相同的</p>
<p>  ② 所以让每个堆中的对象都记录虚方法表显然是不合适的，浪费堆内存空间</p>
<p>  ③ 既然对象中并不保存方法信息，那么到底哪里保存方法相关的信息呢？这个就涉及到 OOP-Klass 模型了</p>
<p>  +++</p>
</li>
<li><p>存储顺序：[长度相同的变量总是优先分配在一起]{.red}</p>
<ul>
<li>虚拟机默认分配策略：<ul>
<li>double &amp; long 一起分配（8B）</li>
<li>int &amp; float 一起分配（4B）</li>
<li>char &amp; short 一起分配（2B）</li>
<li>byte &amp; boolean 一起分配（1B）</li>
<li>referrence 最后分配（4B）</li>
</ul>
</li>
<li>虚拟机的分配策略还会受到  [变量的定义顺序]{.blue} 和 [分配策略参数]{.blue} 的影响</li>
</ul>
</li>
</ul>

        <h3 id="对其填充"   >
          <a href="#对其填充" class="heading-link"><i class="fas fa-link"></i></a><a href="#对其填充" class="headerlink" title="对其填充"></a>对其填充</h3>
      <ul>
<li>前提：<ul>
<li>Java 虚拟机要求对象的大小必须是 8字节 的整数倍</li>
<li>对象大小不是 8字节 整数倍时就会采用对其填充的方式变为 8 字节整数倍</li>
</ul>
</li>
<li>定义：为对象填充某些数据使得其大小为 8字节 的整数倍</li>
<li>细节：[对其填充本身没有什么含义，但是会引发一系列的问题]{.blue}</li>
</ul>
<blockquote>
<p><strong>对象头组成代码演示</strong></p>
</blockquote>
<p>:::info</p>
<p>① 使用 jol 工具类就可以查看对象在内存中的布局</p>
<p>② 使用 lombok 插件可以简化对象类的编写</p>
<p>:::</p>
<blockquote>
<p>对象代码</p>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter08;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Integer age;</span><br><span class="line">    String name;</span><br><span class="line">    Boolean gender;</span><br><span class="line">    String work;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<blockquote>
<p><strong>测试代码</strong></p>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="number">16</span>, <span class="string">&quot;冬坂五百里&quot;</span>, <span class="keyword">true</span>, <span class="string">&quot;开机兵&quot;</span>);</span><br><span class="line">    <span class="comment">// 貌似只有使用到了哈希码才会生成, 否则在 MarkWord 中是看不到的</span></span><br><span class="line">    printfObject(person);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工具方法: 输出对象的内存布局</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printfObject</span><span class="params">(Person person)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 输出对象头</span></span><br><span class="line">    System.out.println(ClassLayout.parseInstance(person).toPrintable());</span><br><span class="line">    System.out.println(GraphLayout.parseInstance(person).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p><strong>测试结果</strong></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/对象组成演示.4scx77d5pr00.png" alt="对象组成演示" style="zoom:80%;" />




        <h2 id="OOP-Klass-模型"   >
          <a href="#OOP-Klass-模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#OOP-Klass-模型" class="headerlink" title="OOP-Klass 模型"></a>OOP-Klass 模型</h2>
      <p>:::primary</p>
<p>参考博客：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/linxdcn/article/details/73287490" >【理解HotSpot虚拟机】对象在jvm中的表示：OOP-Klass模型</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26000415/article/details/88061403" >oop-klass内存模型</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<blockquote>
<p><strong>什么是 OOP-Klass 模型</strong></p>
</blockquote>
<ul>
<li><p>定义：OOP 模型 + Klass 模型</p>
</li>
<li><p>OOP 模型（Ordinary Object Pointer）：</p>
<ul>
<li>定义：[存储 Java 对象所有实例数据的模型]{.red}</li>
<li>创建时间：创建对象时（<a href="#%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96">对象实例化</a>）就会相应的创建 OOP 对象</li>
<li>组成：对象头 + 实例数据 + 数组长度</li>
<li>存储位置：[堆空间]{.red}</li>
</ul>
<p>  :::info</p>
<p>  说白了，OOP 就是我们创建对象后，堆空间存储对象相关数据的模型</p>
<p>  :::</p>
</li>
<li><p>Klass 模型：</p>
<ul>
<li>定义：[存储 Java 类的所有元数据信息]{.red}</li>
<li>创建时间：类加载阶段</li>
<li>组成：运行时常量池、成员变量、方法信息（vtable 虚方法表 + itable 类实现的接口的函数表）</li>
<li>存储位置：[方法区]{.red}</li>
<li>细节：[反射机制中的 Class 对象是依靠 Klass 对象生成的：Class 对象相当于是 Klass 对象的镜像文件]{.red}</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>为什么要使用 OOP-Klass 模型</strong></p>
</blockquote>
<ul>
<li><p>问题：</p>
<ul>
<li>HotSpot 是采用 C++ 编写的运行 Java 程序的虚拟机</li>
<li>[那么 Java 的类如何才能够被 C++ 编写的虚拟机解析呢？]{.blue}</li>
</ul>
</li>
<li><p>方式：</p>
<ul>
<li><p>最简单的方式：为了每个 Java 类都生成对应的 C++ 类，[这意味着每个 Java 对象中也必须包含虚方法表]{.blue}</p>
<p>  :::info</p>
<p>  ① Java 中默认所有的方法都是虚方法，而 C++ 中必须使用关键字 virtual 声明方法才行</p>
<p>  ② Java 的虚方法的数量显然会比 C++ 中的虚方法使用更加频繁，数量更多，为每个对象都保存虚方法表显然是不明智的</p>
<p>  :::</p>
</li>
<li><p>采用的方式：利用 OOP-Klass 模型</p>
<ul>
<li><p>OOP 模型只用于存储对象的相关数据</p>
</li>
<li><p>[Klass 模型用于存储类的元数据信息，用于被 C++ 解析，]{.blue}</p>
<p>  [所以可以认为 Klass 对象是 C++ 中类的表现形式，和 Java 中的类相对应]{.blue}</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>原因：[为了 Java 编写的类能够被虚拟机解析，同时也为了压缩堆空间中对象的大小]{.red}</p>
</li>
</ul>

        <h2 id="对象大小计算"   >
          <a href="#对象大小计算" class="heading-link"><i class="fas fa-link"></i></a><a href="#对象大小计算" class="headerlink" title="对象大小计算"></a>对象大小计算</h2>
      <p>:::primary</p>
<p>参考博客：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/149678226" >jvm压缩指针原理以及32g内存压缩指针失效详解</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<ul>
<li>不同位数的虚拟机<ul>
<li>32 位虚拟机：<ul>
<li>对象头：[类元数据指针 4B + Mark Word 4B]{.blue}</li>
<li>实例数据：[引用类型大小占据 4B，基本类型不变]{.blue}</li>
<li>对其填充：确保对象大小为8的整数倍</li>
</ul>
</li>
<li>64 位虚拟机：<ul>
<li>对象头：[类元数据指针 8B + Mark Word 8B]{.blue}</li>
<li>实例数据：[引用类型大小占据 8B，基本类型不变]{.blue}</li>
<li>对其填充：确保对象大小为8的整数倍</li>
</ul>
</li>
<li>问题：<ul>
<li>64位虚拟机下的对象大小是32位虚拟机的对象的2倍，由于对齐填充，实际是1.5倍</li>
<li>[对象增大导致对象占用的堆内存更多，触发垃圾回收机制更加频繁]{.red}</li>
<li>[对象增大同时导致处理器能够缓存的对象变少，处理器缓存的命中率降低]{.red}</li>
</ul>
</li>
</ul>
</li>
<li>指针压缩<ul>
<li>定义：[压缩 OOP 对象的大小]{.red}<ul>
<li>压缩对象头信息：对象头从 16B 压缩到 12B（主要就是压缩了类型指针）</li>
<li>压缩对象引用：对象引用（不是类型指针）从 8B 压缩到 4B</li>
<li>压缩数组类型：数组从 24B 压缩到 16B</li>
</ul>
</li>
<li>作用：[减轻堆内存的分配对象的压力]{.red}</li>
<li>细节：JDK 6 之后默认开启指针压缩</li>
</ul>
</li>
</ul>
<p>+++danger 为什么不推荐让虚拟机内存超过 32G？</p>
<p>+++</p>

        <h2 id="对象的实例化"   >
          <a href="#对象的实例化" class="heading-link"><i class="fas fa-link"></i></a><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h2>
      <p>:::warning</p>
<p>前提：需要对反射机制、克隆机制、序列化机制有所了解，才能够明白这些机制是如何创建对象的</p>
<p>:::</p>
<blockquote>
<p><strong>对象的实例化方式图示</strong></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/对象实例化方式.5iqes5rp0540.png" alt="对象实例化方式" style="zoom:80%;" />

<blockquote>
<p><strong>对象实例化方式具体实现</strong></p>
</blockquote>
<ul>
<li><p>[关键字 new 创建对象]{.red}</p>
<ul>
<li><p>使用方式：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Object object = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>变形：（设计模式的运用）</p>
<ul>
<li><a href="">单例模式</a>：使用静态方法创建对象</li>
<li><a href="">工厂模式/建造者模式</a>：使用普通方法创建对象</li>
</ul>
</li>
<li><p>细节：[最常见的创建对象的方式]{.blue}</p>
</li>
</ul>
</li>
<li><p>[反射机制创建对象]{.red}</p>
<ul>
<li><p>[直接利用反射类对象创建类对象]{.blue}</p>
<ul>
<li><p>使用方式：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateObject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> </span></span><br><span class="line"><span class="function">        IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 获得 Student 类对应的反射类对象</span></span><br><span class="line">        Class&lt;Student&gt; studentClass = Student.class;</span><br><span class="line">        <span class="comment">// 利用反射类对象创建 Student 类对象</span></span><br><span class="line">        Student student = studentClass.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>细节：</p>
<ul>
<li>[直接利用反射类创建对象仅能够调用 <strong>公共的空参构造器创建</strong>]{.red}</li>
<li>[JDK 9 之后该方式被标记为已过时]{.green}</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/反射创建对象API(1).2tr9r2dz4ts0.png" alt="反射创建对象API(1)" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>[利用反射类对象获取类的构造器创建对象]{.blue}</p>
<ul>
<li><p>使用方式：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateObject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> </span></span><br><span class="line"><span class="function">        IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 获得 Student 类对应的反射类对象</span></span><br><span class="line">        Class&lt;Student&gt; studentClass = Student.class;</span><br><span class="line">        <span class="comment">// 利用反射类对象获取构造器后创建 Student 类对象</span></span><br><span class="line">        Student student = studentClass.getConstructor().newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="comment">// 显示声明空参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>细节：[利用构造器类创建对象可以使用有参或者无参的构造器，并且构造器的权限时任意的]{.red}</p>
</li>
</ul>
</li>
</ul>
<p>  +++ 对比这两种方法，想想为什么直接利用反射类创建对象被废弃了?</p>
<p>  +++</p>
</li>
<li><p>[克隆创建对象]{.red}</p>
<ul>
<li><p>使用方式</p>
<ul>
<li><p>[浅克隆]{.blue}：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateObject</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throw CloneNotSupportedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        Student student_clone = (Student)student.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ① 一定要实现 Cloneable 接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="comment">// ② 一定要重写 clone 方法：因为 Student 不是 Object 的子类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>[深克隆：本质实现还是采用的反序列化机制，就不在这里演示了]{.blue}</p>
</li>
</ul>
</li>
<li><p>细节：</p>
</li>
</ul>
</li>
<li><p>[反序列化创建对象]{.red}</p>
<ul>
<li><p>使用方式：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反序列化创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateObject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="comment">// 1.创建对象输出流</span></span><br><span class="line">        ObjectOutputStream  oos = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedOutputStream(baos));</span><br><span class="line">        <span class="comment">// 2.序列化对象</span></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> Student(<span class="number">10</span>));</span><br><span class="line">        <span class="comment">// 3.刷新缓存，否则你是无法将对象写入流中的（血的教训）</span></span><br><span class="line">        oos.flush();</span><br><span class="line">        <span class="comment">// 4.创建对象输入流：对象输入流必须在序列化对象之后创建，否则对象输入流会创建失败（血的教训）</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">            <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                <span class="keyword">new</span> ByteArrayInputStream(</span><br><span class="line">                    baos.toByteArray())));</span><br><span class="line">        <span class="comment">// 5. 反序列化对象</span></span><br><span class="line">        Student student = (Student) ois.readObject();</span><br><span class="line">        <span class="comment">// 6.测试是否创建成功</span></span><br><span class="line">        System.out.println(student.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0.序列化类必须实现序列化接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>细节：[网络编程中接收传输数据创建对象最常使用的方式]{.blue}</p>
</li>
</ul>
</li>
</ul>

        <h2 id="对象的创建过程"   >
          <a href="#对象的创建过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h2>
      <p>:::primary</p>
<p>参考博客：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40634846/article/details/106300702" >Java的指针碰撞简介</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<blockquote>
<p><strong>对象创建过程图示</strong></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/对象创建过程.ctt8ofhx6gg.png" alt="对象创建过程" style="zoom:80%;" />

<blockquote>
<p><strong>具体的对象创建过程</strong></p>
</blockquote>
<ul>
<li><p>[对象对应的类是否已经被加载进入虚拟机内存]{.red}</p>
<ul>
<li><p>[虚拟机定位到类在元空间运行时常量池中的符号引用]{.blue}</p>
</li>
<li><p>[虚拟机再判断类是否已经经历加载、连接、初始化三个过程]{.blue}</p>
<ul>
<li>如果类已经被类加载器加载，接着创建对象就行</li>
<li>如果类没有被类加载器加载，那么虚拟机就会查找类对应的字节码文件<ul>
<li>如果查找到相应的字节码文件，就加载该类并且创建对应的 Class 对象即可</li>
<li>如果没有查找到对应的字节码文件，那么就会抛出异常</li>
</ul>
</li>
</ul>
<p>  :::info</p>
<p>  ① 动态链接是将符号引用转化成直接引用的过程，实际上就是虚拟机查找类在内存中地址的过程</p>
<p>  ② 虚拟机能找到类的内存地址那就是加载了，找不到那就是没有加载</p>
<p>  :::</p>
</li>
</ul>
</li>
<li><p>[为对象分配内存空间]{.red}</p>
<ul>
<li><p>堆内存规整</p>
<ul>
<li>定义：所有被对象使用过的内存存放在一边，没有被使用的内存存放在另一边</li>
<li>分配算法：指针碰撞（Bump The Pointer）</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/指针碰撞.2ghfaw61x39c.png" alt="指针碰撞" style="zoom:80%;" />

<ul>
<li><p>几个问题：</p>
<p>  +++ 为什么要叫做指针碰撞呢？指针是有了，碰撞在哪里呢？</p>
<p>  +++</p>
<p>  +++danger 如果对象超过或者小于固定的内存块大小呢?</p>
<p>  +++</p>
</li>
</ul>
</li>
<li><p>堆内存不规整</p>
<ul>
<li>定义：被对象使用的过内存和没有使用的内存交错分布</li>
<li>分配算法：空闲列表（Free List）（类似于操作系统中的非连续分配方式）<ul>
<li>维护一个用于记录空闲内存块的列表</li>
<li>每次都从列表中查找一个足够大的内存块分配给对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>  :::info</p>
<p>  ① [对象的大小在类加载的过程就已经被确定好了]{.red}：每个对象都是类的实例嘛，类的大小也就基本等同于对象的大小</p>
<p>  ② [对象的分配方式取决于堆内存是否规整，堆内存是否规整取决于垃圾回收器是否具有压缩整理功能]{.red}</p>
<p>  ③ [对象中拥有引用类型的实例变量，那么仅分配引用的空间（4字节）]{.red}</p>
<p>  :::</p>
</li>
<li><p>[确保分配内存安全]{.red}</p>
<ul>
<li>问题：[多个线程同时创建对象造成的并发问题]{.blue}<ul>
<li>前一个线程刚创建对象完毕，但是还没有来得及将引用指向对象，就切换成另外一个线程</li>
<li>另一个线程也要创建对象，刚好和前一个线程使用同一块区域，导致其创建对象覆盖掉前一个线程创建的对象</li>
</ul>
</li>
<li>方式<ul>
<li>[对分配内存空间的行为采用同步机制处理]{.blue}：虚拟机实际采用 CAS 配上失败重试的方式保证分配操作的原子性</li>
<li>[不同线程在互不干扰的区域中分配对象]{.blue}：虚拟机实际采用 TLAB 来实现分配过程的安全性</li>
</ul>
</li>
</ul>
</li>
<li><p>[初始化对象的 <strong>实例变量</strong>]{.red}：实例变量会被设置成类型 [默认值]{.red}</p>
<p>  :::info</p>
<p>  类中的类变量早在类加载阶段就已经初始化完成了，所以这里只涉及实例变量</p>
<p>  :::</p>
</li>
<li><p>[初始化对象的对象头]{.red}</p>
</li>
<li><p>[执行对象的构造函数]{.red}</p>
</li>
</ul>

        <h2 id="对象的访问定位"   >
          <a href="#对象的访问定位" class="heading-link"><i class="fas fa-link"></i></a><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2>
      <ul>
<li><p>访问定位：虚拟机栈中的对象引用寻找到对象在堆空间中的实例数据的过程</p>
</li>
<li><p>方式</p>
<ul>
<li><p>句柄访问</p>
<ul>
<li>句柄：[对象实例数据指针 + 对象类元数据信息指针]{.red}</li>
<li>存储：堆空间中划分一块区域用于存储所有对象的句柄</li>
<li>引用：[指向句柄在堆空间中的地址]{.red}</li>
<li>访问过程：引用需要先找到句柄在堆空间中的位置后，再根据句柄确定对象的实例数据或者类元信息</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/句柄访问.6xtbodd7hao0.png" alt="句柄访问" style="zoom:80%;" /></li>
<li><p>直接指针访问</p>
<ul>
<li>引用：[直接指向对象在堆空间中的地址]{.red}</li>
<li>访问过程：引用直接就可以根据地址找到对象</li>
<li>细节：[HotSpot 虚拟机实际采用的就是直接指针访问的方式定位对象]{.blue}</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/直接指针访问.4eqkkn6unpm0.png" alt="直接指针访问" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>对比</p>
<ul>
<li>句柄访问<ul>
<li>优点：[对象在堆空间中的位置发生改变，只需要改变句柄的地址就行，对象引用的地址不需要改变]{.red}<ul>
<li>对于程序员来讲这个地址改变就是彻底不可见了，因为引用地址不会随着对象的地址而改变</li>
<li>[适用于对象地址频繁在堆空间中发生变化的情况]{.red}</li>
</ul>
</li>
<li>缺点：[每次访问对象都会增加一次寻址的开销]{.green}</li>
<li>细节：[对象类元数据指针不再存放在对象实例数据中，也就意味着没有存放在对象头中]{.red}</li>
</ul>
</li>
<li>直接指针访问<ul>
<li>优点：[每次访问对象仅花费一次寻址的开销]{.red}</li>
<li>缺点：[对象在堆空间中的位置发生改变，需要直接修改对象引用]{.green}<ul>
<li>对于频繁再堆空间中地址发生变化的对象是非常不利的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/5/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/7/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/随机图库/1641882498931.3kditdl6ds40.webp" alt="avatar"></div><p class="sidebar-ov-author__text">什么都不会的废物</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/fuyusakaiori" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://weibo.com/Sakiless/home?topnav=1&amp;wvr=6" target="_blank" rel="noopener" data-popover="微博" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weibo"></i></span></a><a class="sidebar-ov-social-item" href="670232228" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">108</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">32</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-nd.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020~2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>小忍的甜甜圈</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1.0.1/dist/canvas-nest.min.js" color="0,0,0" opacity="0.6" count="99" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>