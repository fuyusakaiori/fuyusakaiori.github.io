<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="啥也不会的大三狗">
<meta property="og:type" content="website">
<meta property="og:title" content="天鹅绒房间">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="天鹅绒房间">
<meta property="og:description" content="啥也不会的大三狗">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Fuyusakaiori">
<meta name="twitter:card" content="summary"><title>天鹅绒房间</title><link ref="canonical" href="http://example.com/page/6/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">天鹅绒房间</div><div class="header-banner-info__subtitle">Velvet Room</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/24/jvm/execution-engine/%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E5%99%A8/">执行引擎-后端编译器</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-25</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="后端编译器"   >
          <a href="#后端编译器" class="heading-link"><i class="fas fa-link"></i></a><a href="#后端编译器" class="headerlink" title="后端编译器"></a>后端编译器</h1>
      
        <h2 id="即时编译器"   >
          <a href="#即时编译器" class="heading-link"><i class="fas fa-link"></i></a><a href="#即时编译器" class="headerlink" title="即时编译器"></a>即时编译器</h2>
      <blockquote>
<p><strong>什么是即时编译器?</strong></p>
</blockquote>
<ul>
<li><p>前提：</p>
<ul>
<li>虚拟机规范中并没有强制要求必须实现即时编译器，虚拟机可以采用纯解释执行</li>
<li>但是 [即时编译器性能的好坏、对于代码优化质量的高低]{.blue} 却是衡量虚拟机是否优秀的关键标准</li>
</ul>
</li>
<li><p>名称：即时编译器（Just In Time 编译器）</p>
</li>
<li><p>定义：[负责在 <strong>进程运行期间</strong> 将 <strong>热点探测</strong> 决定的字节码指令 <strong>编译并且优化</strong> 成本地机器指令]{.red}</p>
</li>
<li><p>分类：</p>
<ul>
<li><p>客户端编译器：</p>
<ul>
<li>名称：Client Compiler（C1 编译器）</li>
<li>特点：[采用的代码优化策略相对简单可靠，确保客户端的编译速度]{.red}</li>
</ul>
</li>
<li><p>服务器端编译器：</p>
<ul>
<li>名称：Server Compiler（C2 编译器）</li>
<li>特点：[采用的代码优化策略更加的激进，全局性的优化，服务器端的执行速度也更快]{.red}</li>
</ul>
<p>  :::info</p>
<p>  ① 采用的优化策略更多，显然编译器执行的编译过程就更长，显然编译速度就会更慢</p>
<p>  ② 只要编译期间采用的优化策略越多，代码质量就会越好，执行速度就会越快</p>
<p>  :::</p>
</li>
<li><p>Graal 编译器：JDK 10 之后提供的编译器，目的是替代服务器端编译器</p>
</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li>[虚拟机预热：]{.red}<ul>
<li>虚拟机刚启动时只采用解释执行，热点探测本质就是统计方法的调用次数，即时编译器无法立刻生效</li>
<li>[虚拟机在等待即时编译器生效的这段时间称为虚拟机预热]{.blue}</li>
</ul>
</li>
<li>[虚拟机假死：]{.red}<ul>
<li>虚拟机预热完成之前都称为冷机状态，虚拟机长时间运行之后称为热机状态</li>
<li>[虚拟机的热机状态所能够承受的负载显然要大于虚拟机的冷机状态]{.blue}</li>
<li>[如果将处于热机状态的虚拟机的部分任务分配给处于冷机状态的虚拟机，就会导致其无法承受过大的流量而假死；毕竟虚拟机刚开始只采用解释执行，突然将大流量的任务交给处于冷机状态的虚拟机，肯定难以承受]{.green}</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>解释器和即时编译器如何配合执行?</strong></p>
</blockquote>
<p>:::primary</p>
<p>参考博客：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000009371813" >jvm分层编译级别</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<ul>
<li><p>解释模式：</p>
<ul>
<li><p>定义：仅使用解释器执行代码的模式</p>
</li>
<li><p>设置解释模式命令：[-Xint]{.blue}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/解释模式.7j3rnjsbqio0.png" alt="解释模式" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>编译模式</p>
<ul>
<li><p>定义：仅使用即时编译器执行的模式</p>
</li>
<li><p>设置编译模式命令：[-Xcomp]{.blue}</p>
</li>
<li><p>细节：[在即时编译器无法执行的情况下，解释器会强制介入]{.red}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/编译模式.5x9nc8v7cno0.png" alt="编译模式" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>混合模式</p>
<ul>
<li><p>定义：解释器和即时编译器混合执行的模式</p>
</li>
<li><p>设置混合模式命令：[-Xmixed]{.blue}</p>
<ul>
<li>[HotSpot 虚拟机默认采用混合模式]{.red}</li>
</ul>
</li>
<li><p>常规混合模式：[解释器配合任意一个即时编译器进行工作]{.red}</p>
</li>
<li><p>分层编译模式：</p>
<ul>
<li><p>前提：即时编译器想要完成更好的优化，就可能需要解释器的介入，替他监控并收集相关信息</p>
</li>
<li><p>开启分层编译策略：</p>
<ul>
<li>命令：[-XX:+TieredCompilation 开启分层策略 / -XX:-TieredCompilation 关闭分层策略]{.blue}</li>
<li>JDK 6 分层编译策略被初步实现，JDK 7 之后分层编译才作为默认策略被开启</li>
</ul>
</li>
<li><p>分层：</p>
<ul>
<li><p>第 0 层（解释执行）：程序纯解释执行，并且不开启性能监控功能</p>
</li>
<li><p>第 1 层（简单 C1 编译）：开启客户端编译器进行代码优化，解释器仍然不开启性能监控功能</p>
<p>  !!不开启性能监控怎么知道哪些代码是热点代码啊？!!{.bulr}</p>
</li>
<li><p>第 2 层（受限 C1 编译）：继续使用客户端编译器进行代码优化，解释器开启 [部分性能监控功能]{.red}</p>
<ul>
<li>方法调用计数器和回边计数器等少量性能监控功能</li>
</ul>
</li>
<li><p>第 3 层（完全 C1 编译）：继续使用客户端编译器进行代码优化，解释器开启 [全部性能监控功能]{.red}</p>
<ul>
<li>新增分支跳转、虚方法调用版本等信息的收集</li>
<li>[大多数方法第一次被编译就是采用第 3 层级别的编译]{.red}</li>
</ul>
</li>
<li><p>第 4 层（C2 编译）：开启服务器端编译器进行代码优化，将会采取更加激进的优化策略</p>
<ul>
<li>[服务器端编译器较忙的情况下会将方法下放到第 2 层级别的编译]{.red}</li>
<li>[等到服务器端编译器不太忙的时候，再对此前下放的方法重新编译]{.red}</li>
</ul>
</li>
</ul>
</li>
<li><p>核心：</p>
<ul>
<li>执行频率较高的代码优先被C1编译器编译</li>
<li>随着时间的推移再采用C2编译器做进一步优化编译，此前的本地代码被抛弃</li>
</ul>
</li>
<li><p>细节：启用分层编译之后，不再是单独使用任何一个即时编译器，而是交替使用，同时使用</p>
</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/混合模式.g4usdv50h9k.png" alt="混合模式" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>速率测试：</p>
<ul>
<li><p>测试代码</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    testMethod(<span class="number">10000000</span>);</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(end - start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算质数的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;开始执行...&quot;</span>);</span><br><span class="line">    <span class="comment">// 没有经过任何优化的算法采用纯解释执行实在是太他妈的慢了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; count; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; Math.sqrt(i); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行结束...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>测试结果</p>
<ul>
<li>纯解释执行的效率显然是非常低下的，尤其是在算法没有优化且计算量大的情况下，非常糟糕</li>
<li>纯编译执行效果显然是非常好的，即使算法写的不好，虚拟机也会采用相应的优化策略，提高效率</li>
<li>混合执行效果也不错，但是相比于纯编译似乎没有多大的提升，甚至有点下降</li>
<li>这是你可能产生了一个疑问，既然纯编译效果这么好，那为什么还要留着解释器呢？接下来就会提到这个问题</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解释器和编译器配合模式测试</span></span><br><span class="line"><span class="comment">// 纯解释执行 36980</span></span><br><span class="line"><span class="comment">// 纯编译执行 4902</span></span><br><span class="line"><span class="comment">// 混合执行 5031</span></span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>运行模式</p>
<ul>
<li>服务器端：[没有分层编译的混合模式中默认使用服务器端即时编译器]{.red}<ul>
<li>设置命令：[-server]{.blue}</li>
</ul>
</li>
<li>客户端：[没有分层编译的混合模式默认使用客户端即时编译器]{.red}<ul>
<li>设置命令：[client]{.blue}</li>
</ul>
</li>
<li>细节：虚拟机根据宿主机器选择运行模式，不过在 [64位的虚拟机]{.blue} 中默认采用服务器端运行</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>为什么要采用解释器和即时编译器并存的架构呢?</strong></p>
</blockquote>
<ul>
<li><p>回顾：</p>
<ul>
<li>主流的 HotSpot、OpenJ9 虚拟机都采用解释器和即时编译并存的架构</li>
<li>远古时代的 Classsic 虚拟机仅采用解释执行的架构</li>
<li>BEA 开发的 JRockit 虚拟机仅采用编译执行的架构</li>
</ul>
</li>
<li><p>原因：</p>
<ul>
<li>Java 程序不仅需要运行在服务器端也需要运行在客户端</li>
<li>[客户端程序更加关心程序的启动速度，对运行速率没有太高要求，过长的编译期会严重影响客户端的启动]{.red}<ul>
<li>[解释器不需要对源码执行编译过程所以启动速度非常快，也不需要和具体的硬件产生关系]{.blue}</li>
</ul>
</li>
<li>[服务器端则更加关心其运行速度，因为需要频繁处理客户端的请求，所以需要更加全局性的代码优化策略]{.red}<ul>
<li>但是解释器每次都需要向处理器解释源码的含义，对于长时间运行的服务器来说效率非常差</li>
<li>所以即时编译器就用来解决运行时的执行效率问题</li>
<li>[即时编译器会采用热点探测，对频繁执行的代码进行编译，再次执行该代码时就会提高其运行效率]{.blue}</li>
</ul>
</li>
</ul>
</li>
<li><p>核心：[虚拟机能够同时兼具启动速度和执行速度两种优势，能够适应不同进程情况]{.red}</p>
</li>
<li><p>细节：</p>
<ul>
<li>[即时编译器和解释器是异步执行：代码在编译的过程中，同时进入解释器执行，等到再次调用时再编译执行]{.red}</li>
<li>[解释器还可以作为即时编译器激进优化的逃生门]{.red}</li>
</ul>
<p>  :::info</p>
<p>  ① 即时编译器有时候会采用非常激进的优化策略，这些优化策略并不是一定都能够成功的，是由一定概率的</p>
<p>  ② 如果优化策略没有成功，那么代码就会从编译执行退回到解释执行</p>
<p>  :::</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/解释器和编译器.7ammm6bwlz00.png" alt="解释器和编译器" style="zoom:80%;" />

<blockquote>
<p><strong>如何触发即时编译?</strong></p>
</blockquote>
<ul>
<li><p>热点代码（HotSpot Code）</p>
<ul>
<li>定义：[被多次调用的 <strong>方法</strong> 或者被多次执行的 <strong>循环体</strong>]{.red}<ul>
<li>多次调用？多次执行？到底是多少次呢？有没有一个定量呢？</li>
</ul>
</li>
<li>替换方式：<ul>
<li>普通方式：<ul>
<li>内容：方法下次调用时再使用编译好的本地代码</li>
<li>特点：适用于方法调用计数器</li>
</ul>
</li>
<li>栈上替换（On Stack Replacement: OSR）：<ul>
<li>内容：[循环体代码将在解释执行的过程中被编译生成的本地代码替换]{.red}</li>
<li>特点：适用于回边计数器</li>
</ul>
</li>
</ul>
</li>
<li>细节：[无论是多次调用的方法还是循环体，编译的对象都是整个方法]{.red}</li>
</ul>
</li>
<li><p>热点探测（HotSpot Code Detection）</p>
<ul>
<li><p>定义：探测执行的代码是否为热点代码</p>
</li>
<li><p>方式：</p>
<ul>
<li>基于采样的热点探测<ul>
<li>内容：[虚拟机将会 <strong>周期性</strong> 的检查各个线程的调用栈顶，频繁出现在栈顶的方法被认为是热点代码]{.red}</li>
<li>特点：<ul>
<li>[实现简单且高效，可以得知方法之间的调用关系]{.red}（不太理解后面这个优点）</li>
<li>[难以精确确定方法的热度，而且由于是周期性的，容易受到线程阻塞的影响]{.green}</li>
</ul>
</li>
</ul>
</li>
<li>基于计数器的热点探测<ul>
<li>内容：[虚拟机将会为每个方法建立 <strong>计数器</strong>，统计执行的次数，超过阈值的方法就认为是热点代码]{.red}</li>
<li>分类：[方法调用计数器、回边计数器]{.red}</li>
<li>特点：<ul>
<li>[能够精确测定方法的热度，并且可以使用热度衰减技术]{.red}</li>
<li>[为每个方法都维护计数器显然比较麻烦，并且无法得知方法之间的调用关系]{.green}</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>计数器：</p>
<ul>
<li><p>方法调用计数器</p>
<ul>
<li><p>作用：统计一个方法被执行的次数，[方法调用计数器和回边计数器之和]{.red} 超过阈值之后发起编译请求</p>
</li>
<li><p>阈值：</p>
<ul>
<li>默认阈值：客户端默认值为 1500 次，服务器端默认值为 10000 次</li>
<li>设置阈值的命令：[-XX:CompileThreshold=threshold]{.blue}</li>
</ul>
</li>
<li><p>过程</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/方法调用计数器.54qypk5j6b40.png" alt="方法调用计数器" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>回边计数器</p>
<ul>
<li><p>作用：统计一个方法中循环体被执行的次数</p>
<p>  [方法调用计数器和回边计数器之和]{.red} 超过阈值之后发起 [OSR 编译请求]{.red}</p>
</li>
<li><p>阈值：</p>
<ul>
<li>客户端默认阈值：[方法调用计数器默认值 x OSR 默认比率 / 100]{.blue} 默认值 13995<ul>
<li>[方法调用计数器的值（-XX:CompileThreshold）：默认值 1500]{.blue}</li>
<li>[OSR 比率（-XX:OnStackReplacePercengtage）：默认值 933]{.blue}</li>
</ul>
</li>
<li>服务器端默认值：[方法调用计数器默认值 x (OSR 比率 - 解释器监控比率) / 100]{.blue} 默认值 10700<ul>
<li>[OSR 比率（-XX:OnStackReplacePercengtage）：默认值 140]{.blue}</li>
<li>[解释器监控比率（-XX:InterperterProfilePercentage）: 默认值 33]{.blue}</li>
</ul>
</li>
</ul>
</li>
<li><p>过程：</p>
</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/回边计数器.2ree7t6c62s0.png" alt="回边计数器" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>细节：J9 曾采用基于采样的热点探测，HotSpot 采用基于计数器的热点探测</p>
</li>
</ul>
</li>
<li><p>热度衰减（Counter Decay）</p>
<ul>
<li>前提：仅有基于计数器的热点探测中的方法计数器可以使用热端衰减，回边计数器无法使用</li>
<li>定义：[周期时间内某个方法始终没有达到方法调用计数器的阈值，那么该方法的方法调用计数器的值减半]{.red}</li>
<li>周期时间：《深入理解虚拟机》中没有明确指明默认时间到底是多久，只说了这段时间又称为半衰周期</li>
<li>命令：<ul>
<li>[-XX:+UseCounterDecay 开启热度衰减 / -XX:-UseCounterDecay 关闭热度衰减]{.blue}</li>
<li>[-XX:CounterHalfLifeTime=time 设置半衰周期的时间，单位是秒]{.blue}</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>即时编译如何进行的?</strong></p>
</blockquote>
<blockquote>
<p><strong>即时编译会采用哪些优化策略呢?</strong></p>
</blockquote>
<ul>
<li>核心：[不同的即时编译器采用的优化策略也不尽相同]{.red}</li>
<li>C1 编译器：<ul>
<li>方法内联</li>
<li>去虚拟化</li>
<li>冗余访问消除</li>
<li>复写传播</li>
</ul>
</li>
<li>C2 编译器：[逃逸分析是 C2 编译器进行优化的前提]{.red}<ul>
<li>栈上分配</li>
<li>标量替换</li>
<li>同步消除</li>
</ul>
</li>
</ul>

        <h2 id="提前编译器"   >
          <a href="#提前编译器" class="heading-link"><i class="fas fa-link"></i></a><a href="#提前编译器" class="headerlink" title="提前编译器"></a>提前编译器</h2>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/24/jvm/execution-engine/%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%99%A8/">执行引擎-前端编译器</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-24</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="前端编译器"   >
          <a href="#前端编译器" class="heading-link"><i class="fas fa-link"></i></a><a href="#前端编译器" class="headerlink" title="前端编译器"></a>前端编译器</h1>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/23/jvm/runtime/stackspace/%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/">栈空间-本地方法栈</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-23</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h3 id="本地方法栈"   >
          <a href="#本地方法栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3>
      <p>:::primary</p>
<p>参考博客：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/w1992wishes/article/details/80283403" >java调用本地方法–jni简介</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<blockquote>
<p><strong>什么是本地方法？</strong></p>
</blockquote>
<ul>
<li><p>定义：[采用非 Java 代码实现的“接口”]{.red}</p>
<ul>
<li><p>本地方法并不需要采用 Java 实现，[类似于]{.blue} 接口和抽象类中的方法</p>
</li>
<li><p>但是本地方法依然会采用其他语言具体实现，所以也只是类似于接口和抽象类</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地方法是没有方法体的，也就没有具体的实现，类似于接口和抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeMethod</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li>Java 本地方法大多数采用 C/C++ 实现</li>
<li>Java 本地方法可以通过本地方法接口（JNI）访问 Java 运行时数据区</li>
<li>Java 线程调用本地方法后就不再受到虚拟机限制，可以访问操作系统的寄存器、内存等硬件设备</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>为什么需要使用本地方法?</strong></p>
</blockquote>
<p>+++danger 核心：Java 需要和操作系统级别的软件进行交互]</p>
<p>① Java 采用虚拟机隔离了操作系统，所以才能够实现跨平台</p>
<p>② 正是因为虚拟机隔离了操作系统，所以 Java 难以直接和操作系统建立联系，本地方法就提供了访问操作系统的接口</p>
<p>+++</p>
<p>+++ Java 需要使用某些采用其他语言实现的功能</p>
<p>① 虚拟机内部的解释器就是采用 C 实现的</p>
<p>② Java 想要使用虚拟机提供的某些方法就不得不提供链接其他语言的接口</p>
<p>+++</p>
<blockquote>
<p><strong>如何编写本地方法?</strong>!!草，网上查到的全是在 Linux 下编写的，就离谱，大致过程还是记录下!!{.bulr}</p>
</blockquote>
<ul>
<li><p>方式：[JNI（Java Native Interface）]{.blue}</p>
<p>  :::info</p>
<p>  ① Java 借助本地调用接口使用存放在库文件中的本地方法，从而使用操作系统提供的功能</p>
<p>  ② Windows 库文件是采用 DLL 格式存方法的，Linux 库文件是采用 SO 格式存放的</p>
<p>  :::</p>
</li>
<li><p>编写过程：</p>
<p>  (1) 编写 Java 代码</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NativeMethod</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 调用静态链接库</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.loadLibrary(<span class="string">&quot;nativeMethod&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;fail...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;success...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 调用本地方法</span></span><br><span class="line">        <span class="keyword">new</span> NativeMethod().nativeMethod(<span class="string">&quot;Fuyusakaiori&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明本地方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeMethod</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  (2) 利用 javah 程序生成相应的 jni 文件</p>
<p>  :::primary</p>
<p>  ① IDEA 中配置 javah 程序：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/u011781521/article/details/106956827/?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.no_search_link&spm=1001.2101.3001.4242" >配置并使用 JNI</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>  ② 直接在命令行中使用 javah 指令可能无法被识别，即使你配置了环境变量</p>
<p>  :::</p>
<p>  (3) 采用 C/C++ 编写方法的具体实现</p>
  <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="comment">// 头文件记得换成你自己 JNI 生成的文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;chapter06_NativeMethod.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数名</span></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">chapter06_NativeMethod_nativeMethod</span></span></span><br><span class="line"><span class="function"><span class="params">(JNIEnv* env, jclass jc, jstring name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 返回传入的名称</span></span><br><span class="line">	<span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  (4) 编译 C/C++ 源文件</p>
  <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -D_REENTRANT -fPIC -l $Java_HOME$\include -l $Java_HOME$\include\win32 -c nativeMethod.c</span><br></pre></td></tr></table></div></figure>

<p>  (5) 后续暂时不记录了，因为有问题</p>
</li>
<li><p>特点：JNI 调用本地方法会导致开发的程序跨平台性能变差</p>
</li>
</ul>
<blockquote>
<p><strong>什么是本地方法栈?</strong></p>
</blockquote>
<ul>
<li><p>核心：基本内容和虚拟机栈完全相同</p>
</li>
<li><p>定义：存储被调用的本地方法拥有的信息</p>
</li>
<li><p>特点：</p>
<ul>
<li>[本地方法栈完全采用 C 语言实现]{.red}</li>
<li>[本地方法栈也不存在垃圾回收机制，但是能够抛出 StackOverFlowError 异常和 OutOfMemoryError 异常]{.blue}</li>
<li>[本地方法栈也是线程私有空间]{.blue}</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li>Java 虚拟机规范没有明确说明虚拟机必须实现本地方法栈，所以本地方法栈是可以没有的</li>
<li>HotSpot 虚拟机中直接将虚拟机栈和本地方法栈合二为一</li>
</ul>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/23/jvm/runtime/stackspace/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/">栈空间-虚拟机栈</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-23</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="虚拟机栈"   >
          <a href="#虚拟机栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1>
      
        <h2 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h2>
      <blockquote>
<p><strong>虚拟机栈基本概念</strong></p>
</blockquote>
<ul>
<li><p>定义：虚拟机栈依然是一块内存区域</p>
</li>
<li><p>作用：[临时存储所有 <strong>已经被调用</strong> 的方法拥有的数据]{.red}</p>
</li>
<li><p>组成：[栈帧是虚拟机栈中最小的存储单位]{.red}</p>
<ul>
<li>每个栈帧对应保存每个被调用的方法，没有被调用的方法是不会产生相应的栈帧进行保存的</li>
<li>每个方法执行结束后，栈帧就会出栈（销毁）</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li><p>[虚拟机栈是线程私有空间：每个线程都会占用虚拟机栈的中的 <strong>固定空间</strong>，每个固定空间都是私有的]{.red}</p>
<ul>
<li><p>虚拟机栈总容量：[操作系统分配给虚拟机的内存 - 堆区内存 - 方法区内存 - 本地方法栈内存]{.red}</p>
<ul>
<li>虚拟机栈的总容量我们是无法直接使用参数来控制的，取决于虚拟机获得的内存大小</li>
</ul>
</li>
<li><p>[虚拟机栈的大小可以是固定的也可以是动态扩展的]{.red}</p>
<ul>
<li><p>解释：[这里指的虚拟机栈大小是每个线程被分配的大小而不是虚拟机栈的总容量]{.red}</p>
</li>
<li><p>固定容量：</p>
<ul>
<li><p>+++info 各个操作系统的默认的固定容量不同</p>
<ul>
<li><p>Linux：默认每个线程分配的虚拟机栈区域大小 1MB</p>
</li>
<li><p>macOS：默认每个线程分配的虚拟机栈区域大小 1MB</p>
</li>
<li><p>Solaris：默认每个线程分配的虚拟栈区域大小为 1MB</p>
</li>
<li><p>Windows：[取决于操作系统设置的虚拟内存大小]{.red}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/虚拟机栈大小.2613fyb77r0g.png" alt="虚拟机栈大小" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>固定容量设置得太小也会导致虚拟机无法运行</p>
<blockquote>
<p>《深入理解虚拟机》上写的原话，但是我将其设置为1k之后依然能够运行，很奇怪</p>
</blockquote>
</li>
</ul>
</li>
<li><p>动态扩展容量：</p>
<ul>
<li>定义：虚拟机栈的容量不足时可以使用虚拟机内存中剩余空闲的内存作为扩展</li>
<li>现状：HotSpot 虚拟机并没有选择支持动态扩展技术，以前的 Classic 虚拟机支持动态扩展</li>
</ul>
</li>
<li><p>设置线程分配的栈大小：[-Xss Size]{.blue}</p>
  <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意命令和大小之间是没有空格的</span></span><br><span class="line">-Xss1k</span><br><span class="line">-Xss1m</span><br><span class="line">-Xss1g</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>[虚拟机栈不存在垃圾回收机制，但是存在 OutOfMemoryError 异常和 StackOverFlowError 异常]{.red}</p>
<ul>
<li><p>[线程获取的虚拟机栈深度不够无法容纳太多的栈帧，就会抛出StackOverFlowError 异常]{.red}</p>
<p>  测试代码：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个栈帧并不大，但是栈帧数量太多</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 静态变量 count: 记录递归的次数</span></span><br><span class="line">    System.out.println(++count);</span><br><span class="line">    <span class="comment">// 无限递归</span></span><br><span class="line">    main(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 大小不够：栈帧数量不多，但是每个栈帧的大小太大（测试见《深入理解JVM》）</span></span><br></pre></td></tr></table></div></figure>

<p>  测试结果：</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/虚拟机栈溢出.voivx0vevz4.png" alt="虚拟机栈溢出" style="zoom:80%;" />

<p>  :::warning</p>
<p>  ① 单线程情况下，无论是栈帧的数量太多还是栈帧太大，都会因为栈帧的深度不够而抛出的 StackOverFlowError 异常</p>
<p>  ② 单线程情况下，如果线程创建时申请的空间超过了虚拟机栈总容量大小，会抛出 OutOfMemoryError 异常</p>
<p>  （把虚拟机栈空间设置为10g也没有出现这种情况）</p>
<p>  :::</p>
</li>
<li><p>[虚拟机栈在动态扩展线程的栈空间时， 无法申请到足够的内存就会抛出 OutOfMemoryError 异常]{.red}</p>
<p>  :::warning</p>
<p>  ① Java 大多数虚拟机都支持动态扩展技术（存疑），不过 HotSpot 并不支持动态扩展技术，远古的 Classic 支持</p>
<p>  （可以使用早期的 JDK 版本进行测试）</p>
<p>  ② 多线程情况下，创建的线程太多就会导致虚拟机栈的总容量不够，从而抛出 OutOfMemoryError 异常</p>
<p>  ③ 多线程情况下测试 OOM 异常容易导致操作系统假死，因为Java 中每个线程都是映射一个内核级线程</p>
<p>  :::</p>
<p>  测试代码</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个线程分配的栈空间设置为 1g</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 无限创建线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;被创建&quot;</span>);</span><br><span class="line">            <span class="comment">// 保证线程无限运行</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  测试结果：在创建了 1000+ 左右的线程之后，IDEA 直接卡死，被强制结束了（不过之前确实测试出了 OutOfMemoryError 异常）</p>
</li>
</ul>
</li>
<li><p>[每个线程和其拥有的虚拟机栈空间生命周期一致：线程结束后拥有虚拟机栈空间也相应释放]{.blue}</p>
</li>
<li><p>栈空间主要涉及 [进程运行的管理]{.red}，所以存储被调用的方法相关信息</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>虚拟机栈内部结构图示</strong></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/个人博客搭建/虚拟机栈结构.4dq1hkdejyu0.png" alt="虚拟机栈结构" style="zoom:80%;" />


        <h2 id="栈帧"   >
          <a href="#栈帧" class="heading-link"><i class="fas fa-link"></i></a><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2>
      <ul>
<li><p>定义：虚拟机栈中存储方法的最小单位</p>
</li>
<li><p>特点：</p>
<ul>
<li>每个栈帧都对应存储一个方法</li>
<li>虚拟机栈顶的栈帧也被称作[当前栈帧]{.red}</li>
</ul>
</li>
<li><p>组成：</p>
<ul>
<li><a href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8">局部变量表</a>（Local Variables）</li>
<li><a href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88">操作数栈</a>（Operand Stack）</li>
<li><a href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5">动态链接</a>（Dynamic Linking）</li>
<li><a href="#%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80">返回地址</a>（Return Address）</li>
<li>附加信息：这个组成部分是可有可无的</li>
</ul>
</li>
<li><p>入栈/出栈过程：</p>
<ul>
<li><p>虚拟机在每个方法被调用时都会创建相应的栈帧并将其入栈</p>
</li>
<li><p>虚拟机在每个方法执行结束时会将该方法出栈（两种结束/出栈方式）</p>
<ul>
<li><p>[方法正常结束：return 返回]{.blue}</p>
</li>
<li><p>[方法异常结束：throw 返回]{.blue}</p>
<blockquote>
<p>注：方法异常结束就是说方法的执行过程中出现了异常，但是这个异常并没有被正常处理，所以导致方法结束</p>
</blockquote>
</li>
</ul>
</li>
<li><p>[恢复上层方法的局部变量表和操作数栈，并将方法的返回值压入操作数栈]{.red}</p>
</li>
<li><p>[根据返回地址调整程序计数器的值，继续执行此前没有执行完的方法]{.red}</p>
</li>
</ul>
</li>
</ul>

        <h3 id="局部变量表"   >
          <a href="#局部变量表" class="heading-link"><i class="fas fa-link"></i></a><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3>
      <ul>
<li><p>定义：栈帧中 [存储局部变量和方法参数]{.red} 的内存区域</p>
<ul>
<li>局部变量和成员变量：<ul>
<li>定义：方法中声明的变量都是局部变量，类中声明的变量都是成员变量</li>
<li>区别：<ul>
<li>两种变量的[作用域不同]{.blue}：前者出了方法就不可以被调用，后者可以在类中随意调用</li>
<li>两种变量的[赋值情况不同]{.blue}：<ul>
<li>前者必须赋值才能够使用</li>
<li>后者 [类变量会在链接准备阶段]{.red}赋默认值，[实例变量会在对象创建时分配默认值]{.red}，所以不赋值也可以使用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>基本数据类型和引用类型：<ul>
<li>基本数据类型就是 int、short、byte、boolean、double、long、char、float 8 种</li>
<li>引用类型：各种类（String、自定义类等等）</li>
<li>变量类型：无论是局部变量还是成员变量都有相应的数据类型</li>
</ul>
</li>
</ul>
<p>  :::info</p>
<p>  ① 局部变量表存储的引用类型局部变量，实际上存储的是该对象的引用，对象的实际数据分配在堆中</p>
<p>  ② 局部变量的类型还可以是返回地址（returnAddress 类型）!!我不太清楚这是个什么，反编译过程没见过!!{.bulr}</p>
<p>  :::</p>
</li>
<li><p>组成：[最小存储单位是变量槽]{.red}</p>
</li>
<li><p>变量槽特点：</p>
<ul>
<li><p>每个变量槽都具有对应索引，执行引擎通过索引访问变量槽存储的变量</p>
</li>
<li><p>[非静态方法会默认拥有 this 变量，始终占用索引为 0 的变量槽]{.red}</p>
<blockquote>
<p>注：正因为默认在非静态方法中添加了 this 变量，所以你才能够使用 this 关键字</p>
</blockquote>
</li>
<li><p>不同类型的局部变量占用的变量槽数量不同</p>
<ul>
<li>[long 和 double 型占用两个变量槽（64位）]{.red}</li>
<li>其余类型仅占用一个变量槽（32位）</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/个人博客搭建/变量槽.41qyru13ed80.png" alt="变量槽" style="zoom:80%;" /></li>
<li><p>[变量槽存储的局部变量如果在方法未结束前就不再使用，那么该变量槽会被其他变量复用（变量槽复用）]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">10</span>;</span><br><span class="line">    &#123;	<span class="comment">// second 变量只在这个代码块中有效，出了代码块就无效了</span></span><br><span class="line">        <span class="keyword">double</span> second = first + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// second 占用的变量槽将会被 third 变量占据</span></span><br><span class="line">    <span class="comment">// second 变量占据两个变量槽，third 只占据一个，所以最后会有一个变量槽空着</span></span><br><span class="line">    <span class="keyword">int</span> third = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  +++info 反编译解析之前可以先想想局部变量表的大小是多少？到底有几个局部变量？</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/个人博客搭建/变量槽复用.2kf44qleuco0.png" alt="变量槽复用" style="zoom:80%;" />

<p>  +++</p>
</li>
<li><p>[变量槽会将 short、byte、boolean、char类型转换为 int 类型存储]{.blue}</p>
<p>  :::warning</p>
<p>  这个点我暂时不太明白</p>
<p>  :::</p>
</li>
</ul>
</li>
<li><p>局部变量表特点：</p>
<ul>
<li><p>局部变量表中的参数和局部变量越多，局部变量表越大</p>
</li>
<li><p>[局部变量表的大小在编译期间就已经确定]{.red}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/个人博客搭建/局部变量表大小.6dcbkdq2n7w0.png" alt="局部变量表大小" style="zoom:80%;" />

</li>
</ul>
</li>
</ul>

        <h3 id="操作数栈"   >
          <a href="#操作数栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3>
      <p>:::info</p>
<p>前提：如果熟悉数据结构的读者，尤其是利用栈结构写过计算器的读者，将会很容易理解操作数栈这个区域</p>
<p>建议阅读：<a href="">栈</a></p>
<p>:::</p>
<ul>
<li><p>定义：临时存储 [将要进行运算的局部变量和计算结果]{.red} 的内存区域</p>
</li>
<li><p>基于栈的字节码执行引擎</p>
<ul>
<li><p>执行引擎：</p>
<ul>
<li>物理机的执行引擎是建立在具体硬件之上：[处理器、缓存、指令集（x86）、操作系统]{.blue}</li>
<li>虚拟机的执行引擎是建立在软件之上：[解释器、即时编译器、指令集（字节码）、垃圾回收]{.blue}</li>
</ul>
</li>
<li><p>基于栈和基于寄存器</p>
<ul>
<li><p>基于寄存器：</p>
<ul>
<li><p>定义：[变量临时存放在处理器的寄存器中]{.red}，执行引擎每次根据寄存器地址获取变量进行计算</p>
</li>
<li><p>操作：每个寄存器都有相应的地址，每次使用指令调用寄存器都需要按照寄存器地址选用</p>
</li>
<li><p>特点：</p>
<ul>
<li><p>[每个指令依赖于具体寄存器地址就会导致指令集的设计非常复杂]{.green}</p>
</li>
<li><p>[指令集的设计依赖于寄存器这种硬件就会导致其移植性差]{.green}</p>
</li>
<li><p>[指令集的设计复杂带来的好处就是每条指令的功能强大，完成一个方法需要的指令数量少，执行效率高，寄存器执行效率高也是其中一个原因]{.red}</p>
  <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 完成加法计算 a = b + 4</span></span><br><span class="line"><span class="comment"># 取寄存器 $s1 中的值加上常数 4 然后赋值给 $s0</span></span><br><span class="line"><span class="comment"># 这个指令不是 x86 指令集中的而是 MIPS 指令集中的</span></span><br><span class="line">addi <span class="variable">$s0</span>, <span class="variable">$s1</span>, 4</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>基于栈</p>
<ul>
<li><p>定义：[变量临时存储在操作数栈中]{.red}，执行引擎每次执行出栈和入栈操作进行计算</p>
</li>
<li><p>操作：操作数栈仅存在出栈和入栈的操作，没有地址这种设计</p>
</li>
<li><p>特点：</p>
<ul>
<li><p>[每个指令只涉及出栈入栈操作并不依赖于地址所以指令集的设计相对精简]{.red}</p>
</li>
<li><p>[指令集的设计不依赖于物理硬件的好处就是其可移植性高]{.red}</p>
</li>
<li><p>[指令集的设计精简的缺点就是指令的数量非常多，完成一个方法可能需要大量的指令，从而导致效率低下]{.green}</p>
  <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 完成加法计算: a = b + 10</span></span><br><span class="line">0: bipush        10</span><br><span class="line">2: istore_1</span><br><span class="line">3: iload_1</span><br><span class="line">4: bipush        10</span><br><span class="line">6: iadd</span><br><span class="line">7: istore_2</span><br><span class="line">8: <span class="built_in">return</span></span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>目的：[采用基于栈结构的执行引擎就是为了能够不依赖于硬件从而实现 <strong>跨平台</strong>，并且编译器容易实现]{.red}</p>
</li>
<li><p>执行过程：</p>
<ul>
<li><p>测试代码：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行两数求和的计算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> second = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> result = first + second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>字节码指令</p>
  <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0: bipush        10</span><br><span class="line">2: istore_1</span><br><span class="line">3: bipush        20</span><br><span class="line">5: istore_2</span><br><span class="line">6: iload_1</span><br><span class="line">7: iload_2</span><br><span class="line">8: iadd</span><br><span class="line">9: istore_3</span><br><span class="line">10: <span class="built_in">return</span></span><br></pre></td></tr></table></div></figure></li>
<li><p>图解：（参考《深入理解虚拟机》）</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/基于栈的执行引擎.6xdgz9b1xh00.png" alt="基于栈的执行引擎" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
</li>
<li><p>栈顶缓存技术</p>
<ul>
<li>引入：<ul>
<li>因为虚拟机的内存实际使用的是物理机的内存，频繁的出栈入栈实际上是在频繁读写内存</li>
<li>又因为虚拟机采用的是基于栈式的体系结构，所以指令的读写更加频繁</li>
<li>频繁的读写内存会降低操作系统的效率，也就会导致虚拟机的性能降低</li>
</ul>
</li>
<li>解决方式：[将栈顶元素全部缓存到处理器的寄存器中，防止多次使用造成的频繁读写操作]{.red}</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>[操作数栈的深度也在编译期间就已经确定]{.red}</li>
<li>[操作数栈的深度和局部变量表的大小没有直接的关系：局部变量的数量会 <strong>间接影响</strong> 到操作数栈开辟的深度]{.red}</li>
</ul>
</li>
</ul>

        <h3 id="动态链接"   >
          <a href="#动态链接" class="heading-link"><i class="fas fa-link"></i></a><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3>
      <blockquote>
<p><strong>什么是动态链接？</strong></p>
</blockquote>
<ul>
<li><p>定义：[将字节码指令使用的符号引用解析成运行时常量池保存的直接引用]{.red}</p>
</li>
<li><p>特点</p>
<ul>
<li>[动态链接是在方法执行期间发生的，静态解析是在连接解析阶段发生的]{.red}</li>
<li>并不是所有方法调用都会触发动态链接，部分方法调用可能在解析阶段发生的</li>
</ul>
</li>
<li><p>解析过程</p>
<p>  测试代码：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> DynamicLink().methodA();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></div></figure>

<p>  字节码指令：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #数字 就是符号引用</span></span><br><span class="line"><span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  </span><br><span class="line"><span class="number">3</span>: dup</span><br><span class="line"><span class="comment">// 方法调用会使用符号引用，动态链接会进行解析</span></span><br><span class="line"><span class="comment">// 构造方法调用</span></span><br><span class="line"><span class="number">4</span>: invokespecial #<span class="number">3</span></span><br><span class="line"><span class="comment">// methodA() 方法调用</span></span><br><span class="line"><span class="number">7</span>: invokevirtual #<span class="number">4</span>                  </span><br><span class="line"><span class="number">10</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></div></figure>

<p>  常量池保存符号引用和直接引用的关系</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中间不重要的常量省略了</span></span><br><span class="line">Constant pool:</span><br><span class="line">   <span class="comment">// ① #4 符号引用要求我们再去查找 #2 #22 两个符号引用</span></span><br><span class="line">   #<span class="number">4</span> = Methodref          #<span class="number">2.</span>#<span class="number">22</span>         <span class="comment">// chapter05/DynamicLink.methodA:()V</span></span><br><span class="line">   <span class="comment">// ② #2 符号引用要求我们继续查找 #21 符号引用</span></span><br><span class="line">   #<span class="number">2</span> = Class              #<span class="number">21</span>            <span class="comment">// chapter05/DynamicLink</span></span><br><span class="line">   <span class="comment">// ③ #22 是方法签名，要求继续查找 #17 #7 两个符号引用</span></span><br><span class="line">   #<span class="number">22</span> = NameAndType        #<span class="number">17</span>:#<span class="number">7</span>         <span class="comment">// methodA:()V</span></span><br><span class="line">   <span class="comment">// ④ 调用方法的对象的符号引用就被解析完成了</span></span><br><span class="line">   #<span class="number">21</span> = Utf8               chapter05/DynamicLink</span><br><span class="line">   <span class="comment">// ⑤ 被调用方法的返回值和方法名就被解析成功了</span></span><br><span class="line">   #<span class="number">7</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">17</span> = Utf8               methodA</span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h3 id="返回地址"   >
          <a href="#返回地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h3>
      <blockquote>
<p><strong>什么是返回地址？</strong></p>
</blockquote>
<ul>
<li>定义：方法执行结束后回到的最初被调用的位置称为返回地址</li>
</ul>
<blockquote>
<p><strong>为什么需要返回地址？</strong></p>
</blockquote>
<ul>
<li>原因：<ul>
<li>程序计数器保存的是当前执行的指令地址，而此前的指令地址是不知道的</li>
<li>如果没有此前的指令地址，执行引擎就不知道此前的栈帧执行到哪里了</li>
<li>被调用的方法执行结束之后，执行引擎在没有返回地址的情况下就回不去了</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>如何保证能够返回？</strong></p>
</blockquote>
<ul>
<li><p>方式：[方法被调用时栈帧就会记录当前程序计数器的值作为返回地址]{.red}</p>
</li>
<li><p>特点</p>
<ul>
<li>方法正常退出：执行引擎使用 [栈帧中保存的返回地址]{.red} 回到此前执行的位置</li>
<li>方法异常退出：执行引擎使用 [异常表中的信息确定返回地址，栈帧几乎不会保存这种信息]{.red}.</li>
</ul>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/23/jvm/runtime/heapspace/TLAB/">堆空间-TLAB</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-23</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h3 id="TLAB"   >
          <a href="#TLAB" class="heading-link"><i class="fas fa-link"></i></a><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h3>
      <p>:::primary</p>
<p>参考博客：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qiang_zi_/article/details/98504710" >JVM - TLAB</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.zhihu.com/question/56538259" >在TLAB中创建的对象，如何被其他线程共享？</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.jianshu.com/p/8be816cbb5ed" >浅析java中的TLAB</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<blockquote>
<p><strong>什么是 TLAB?</strong></p>
</blockquote>
<ul>
<li><p>名称：</p>
<ul>
<li>全称：TLAB（Thread Local Allocation Buffer）</li>
<li>译名：线程本地缓存</li>
</ul>
</li>
<li><p>定义：[堆中的 <strong>伊甸园区</strong> 分配给线程的一块较小的“私有”空间]{.red}</p>
<ul>
<li>在伊甸园区中划分 TLAB 采用的也是指针碰撞的方式</li>
<li>TLAB 内部分配对象时采用的依然是指针碰撞的方式 </li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li><p>TLAB 空间非常小，仅占用伊甸园区的 1% 大小</p>
</li>
<li><p>[线程每次创建对象优先在 TLAB 区域创建]{.red}</p>
</li>
<li><p>[线程每次在 TLAB 中创建对象时，其余线程是无法抢占 TLAB 执行的]{.red}</p>
</li>
<li><p>TLAB 无法分配足够的空间给新对象时：</p>
<ul>
<li><p>[TLAB 剩余的空间大于设定的最大浪费空间（阈值）：新对象直接在伊甸园区的公共部分进行创建]{.red}</p>
</li>
<li><p>[TLAB 剩余的空间小于设定的最大浪费空间（阈值）：重新提供给线程一块 TLAB 让其创建对象]{.red}</p>
<p>  :::info</p>
<p>  ① 如果新分配的 TLAB 依然无法容纳新对象，那么该对象就需要在伊甸园公共区域创建</p>
<p>  ② 如果在伊甸园的公共区域创建对象，那就意味着需要其他的方式确保分配过程的安全（诸如CAS加锁）</p>
<p>  :::</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>命令：</p>
<ul>
<li></li>
<li>[-XX:TLABWasteTargetPercent 设置 TLAB 区域所占空间的百分比]{.blue}</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>为什么要使用 TLAB?</strong></p>
</blockquote>
<ul>
<li>引入：<ul>
<li>多线程情况下，如何确保创建对象时的线程安全，不会被其余线程抢占执行？</li>
<li>当前线程刚为对象分配好空间，还没来得及将引用指向内存，其余线程抢占执行，覆盖了刚才创建的对象</li>
<li>这种情况是非常有可能发生的</li>
</ul>
</li>
<li>方式：<ul>
<li>[给每个线程为对象分配内存的动作做同步处理]{.red}，确保其余线程不会访问<ul>
<li>[线程分配动作同步带来的缺陷显然就是程序性能的下降]{.green}</li>
</ul>
</li>
<li>[给每个线程分配“私有”的堆空间，每次线程都在这个“私有”的空间中创建对象]{.red}，确保其余线程不会访问<ul>
<li>[“私有”空间并不是真正的线程私有，<strong>线程仅在分配对象空间时独占这块区域</strong>，其余时候所有线程都可以访问这块区域]{.green}</li>
<li>[线程在 TLAB 上分配对象时并不会将这块区域上锁，所以不会因为同步造成性能下降]{.red}</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>TLAB 原理是什么?</strong></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/23/jvm/runtime/heapspace/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/">堆空间-逃逸分析</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-23</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="逃逸分析"   >
          <a href="#逃逸分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h1>
      <p>:::warning</p>
<p>前提：逃逸分析目前是 Java 虚拟机中比较前沿的技术，并且还很不成熟，需要时间优化</p>
<p>参考博客：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/chenxuegui1234/article/details/96726988" >JVM对象逃逸</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<blockquote>
<p><strong>什么是逃逸分析？</strong></p>
</blockquote>
<ul>
<li><p>定义：编译器根据字节码信息分析对象是否发生逃逸的 [分析技术]{.red}</p>
<p>  :::info</p>
<p>  ① 逃逸分析只是 [代码分析技术]{.red} 而不是 [代码优化技术]{.red}</p>
<p>  ② 逃逸分析是后续代码优化技术的前提，栈上分配、标量替换、同步消除都依赖于逃逸分析</p>
<p>  :::</p>
</li>
</ul>
<blockquote>
<p><strong>为什么要使用逃逸分析?</strong></p>
</blockquote>
<ul>
<li><p>核心：[有效减少堆空间的内存分配压力，避免频繁的垃圾回收对用户线程造成的影响]{.red}</p>
</li>
<li><p>解释：</p>
<ul>
<li>定义中提到逃逸分析只是分析技术，所以严谨来说逃逸分析是没有什么好处的，有好处的只是优化技术</li>
<li>但是因为逃逸分析是优化技术的前提，所以这里用逃逸分析指代优化技术</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>如何判断对象是否发生逃逸？</strong></p>
</blockquote>
<ul>
<li><p>定义：</p>
<ul>
<li>[<strong>本方法创建的对象在外部被使用</strong> 或者 <strong>本方法使用外部方法传递的对象</strong> 都被视为对象发生逃逸]{.red}<ul>
<li>本方法创建的对象在外部被使用：[内部对象逃逸出本方法]{.blue}</li>
<li>本方法使用外部方法传递的对象：[外部对象逃逸进本方法]{.blue}</li>
</ul>
</li>
<li>只有本方法创建的对象不会被外部使用才认为没有发生逃逸</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逃逸分析举例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">returnStringBuilder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 其他方法可以引用本方法创建的对象了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(<span class="string">&quot;对象逃逸了!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防止对象逃逸</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">returnStringBuilder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 思考：为什么这个就不算做逃逸了呢？明明返回了对象</span></span><br><span class="line">    <span class="comment">// 回答1：创建的 StringBuilder 对象无法被其他方法引用了，所以这个对象是没有逃逸的</span></span><br><span class="line">    <span class="comment">// 回答2：但是 toString 方法又会创建 String 对象，String 对象是可以被其他方法引用的，所以还是逃逸了</span></span><br><span class="line">    <span class="comment">// 回答3：真正防止逃逸的方法只有不提供外界可引用的对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(<span class="string">&quot;对象逃逸了!&quot;</span>).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>三种逃逸状态</p>
<ul>
<li><p>线程级逃逸（全局逃逸）：类的 [成员变量]{.red} 引用方法的返回的对象</p>
<ul>
<li>[成员变量意味着无论变量是静态的还是非静态的，都认为是逃逸对象]{.blue}</li>
<li>[成员变量可以被多个线程访问，所以称为线程级逃逸]{.blue}</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysis</span></span>&#123;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> StringBuilder sb;</span><br><span class="line">    <span class="comment">// 线程逃逸</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadEscape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 多个线程都可以在这个方法中引用到这个对象:：对象逃逸出线程</span></span><br><span class="line">        <span class="comment">// 问题：如果给对象加锁，那么还算做逃逸吗？</span></span><br><span class="line">        <span class="comment">// 个人观点：应该还是算的, 即使上锁也依然可以访问</span></span><br><span class="line">        <span class="keyword">this</span>.sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;对象逃出线程了!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>方法级逃逸（参数逃逸）：</p>
<ul>
<li>[本方法将对象作为返回值返回，其余方法可以直接调用]{.blue}</li>
<li>[本方法将对象作为参数传递到其他方法中，供其他方法使用]{.blue}</li>
<li>细节：每个线程引用的对象都是不可能一样的，因为每次都是新建对象，所以对于线程是不可见的，没有逃出线程</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法逃逸</span></span><br><span class="line"><span class="comment">// 情况1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">createStringBuilder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(<span class="string">&quot;对象逃出方法了!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 情况2</span></span><br><span class="line"><span class="comment">// 这个对象显然并不属于该方法，而是属于其他方法的</span></span><br><span class="line"><span class="comment">// 对象逃逸进这个方法了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useStringBuilder</span><span class="params">(StringBuilder sb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对象逃逸出本方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createStringBuilder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 传递参数</span></span><br><span class="line">    useStringBuilder(<span class="keyword">new</span> StringBuilder(<span class="string">&quot;对象逃逸出方法了!&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>不逃逸：[只要确保对象不会被其他方法或者线程引用，那么就是没有逃逸的]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noEscapeAnalysis</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="string">&quot;我是对象!&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;我没有逃逸!&quot;</span>);</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>结论：[尽可能多使用局部变量而不是成员变量，减少堆分配的压力]{.green}</p>
</li>
</ul>
<blockquote>
<p><strong>没有逃逸的对象应该怎么处理?</strong></p>
</blockquote>
<ul>
<li><p>核心：</p>
<ul>
<li>[<strong>没有发生逃逸</strong> 的对象就 <strong>可能</strong> 会被分配在栈空间上]{.red}</li>
<li>[存放在栈帧中的对象随着栈帧的结束而被销毁]{.red}</li>
</ul>
</li>
<li><p>方式：</p>
<ul>
<li><p>栈上分配（Stack Allocation）</p>
<ul>
<li>定义：[方法逃逸和没有逃逸的对象]{.red} 将会被分配在栈上而不是堆中</li>
<li>优点：[避免堆空间垃圾回收造成的性能消耗（诸如筛选回收对象、整理内存等），对象会随着栈帧的出栈而被销毁]{.red}</li>
<li>细节：[栈上分配并没有明确指明对象在栈中如何存储]{.blue}</li>
</ul>
</li>
<li><p>标量替换（Scalar Replacement）</p>
<ul>
<li><p>概念：</p>
<ul>
<li><p>标量：无法进一步分解的数据类型都称为标量</p>
<p>  int、double、float、引用类型等等都是无法继续分解的标量</p>
</li>
<li><p>聚合量：可以继续分解的数据类型称为聚合量</p>
<p>  对象就是非常典型的聚合量</p>
</li>
</ul>
</li>
<li><p>定义：[<strong>没有逃逸的对象</strong> 会被直接拆解为若干的成员变量存储在栈帧的局部变量表中]{.red}</p>
<ul>
<li>[采用标量替换后就不会创建对象了，而是改为创建各个成员变量]{.blue}</li>
<li>如果对象的拥有聚合量的成员变量，那么继续拆解就行</li>
</ul>
</li>
<li><p>细节：[标量替换可以看做是栈上分配的一种具体实现]{.red}</p>
</li>
<li><p>实例：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="comment">// 标量替换：不会直接创建对象了，而是创建局部变量</span></span><br><span class="line">    user.id;</span><br><span class="line">    user.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>测试代码</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化方案: 标量替换</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于对象没有逃逸,所以会采用标量替换的方式创建对象,所以创建消耗的时间也会较少</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createUser</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.id = <span class="number">1</span>;</span><br><span class="line">    user.name = <span class="string">&quot;Fuyusakaiori&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟机参数设置</span></span><br><span class="line"><span class="comment">// 第一次测试：关闭标量替换</span></span><br><span class="line"><span class="comment">// 第一次参数设置：-Xms100m -Xmx100m -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+PrintGC</span></span><br><span class="line"><span class="comment">// 第二次测试：开启标量替换</span></span><br><span class="line"><span class="comment">// 第二次参数设置：-Xms100m -Xmx100m -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+PrintGC</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 开始创建对象的起始时间</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        createUser();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;耗费时间: &quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>测试结果</p>
<ul>
<li>第一次测试：[没有开启标量替换的情况下创建对象消耗的时间 4228ms，并且会不断进行垃圾回收]{.green}</li>
<li>第二次测试：[开启标量替换的情况下创建对象仅消耗 8ms，并且不会进行垃圾回收]{.red}</li>
<li>测试结论：标量替换没有真正创建对象，因为根本就没有打印垃圾回收的信息</li>
</ul>
</li>
</ul>
</li>
<li><p>同步消除（Synchronization Elimination）</p>
<ul>
<li><p>定义：[<strong>方法逃逸和没有逃逸的对象</strong> 采用的同步措施会被 <strong>即时编译器</strong> 直接消除掉]{.red}</p>
</li>
<li><p>实例：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化方案: 同步消除</span></span><br><span class="line"><span class="comment">// 原始代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SynchronizationElimination</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 每个线程进入该方法都会创建一个新的对象</span></span><br><span class="line">    <span class="comment">// 所有线程根本不会访问到同一个对象，那本身就没有上锁的意义啊</span></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="keyword">synchronized</span> (user)</span><br><span class="line">    &#123;</span><br><span class="line">        user.id = <span class="number">1</span>;</span><br><span class="line">        user.name = <span class="string">&quot;Fuyusakaiori&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化方案：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SynchronizationElimination</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 消除同步机制</span></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.id = <span class="number">1</span>;</span><br><span class="line">    user.name = <span class="string">&quot;Fuyusakaiori&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
<p>  :::warning</p>
<p>  ① 同步消除策略非常不好测试，所以不在此进行测试</p>
<p>  ② 而且感觉同步消除存在一定的问题，既然其余线程都无法访问这个对象，那为什么要上锁呢？根本就不会这么写，那优化什么</p>
<p>  :::</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>逃逸分析是由谁来完成的呢?</strong></p>
</blockquote>
<ul>
<li>宽泛地讲逃逸分析显然是由 [执行引擎]{.red} 完成的</li>
<li>具体地来讲执行引擎中细分为解释器和即时编译器，逃逸分析实际是由 [C2 即时编译器（服务器端）]{.red} 执行的</li>
</ul>
<blockquote>
<p><strong>不成熟的逃逸分析带来的缺陷</strong></p>
</blockquote>
<ul>
<li><p>缺陷</p>
<ul>
<li><p>[逃逸分析的成本非常高]{.red}</p>
</li>
<li><p>[无法保证经过逃逸分析后的优化效果能够高于逃逸分析的成本]{.red}</p>
<blockquote>
<p>极端情况：经过逃逸分析之后发现几乎所有对象都发生了逃逸，那么就浪费了这次分析</p>
</blockquote>
</li>
</ul>
</li>
<li><p>细节：[逃逸分析在 JDK 6 以前都是默认不开启的，直到 JDK 7 之后才默认开启]{.blue}</p>
</li>
</ul>
<blockquote>
<p><strong>逃逸分析相关参数</strong></p>
</blockquote>
<ul>
<li>[-XX:+DoEscapeAnalysis：开启逃逸分析 / -XX:-DoEscapeAnalysis：关闭逃逸分析]{.blue}</li>
<li>[-XX:+EliminateAllocations：开启标量替换 / -XX:-EliminateAllocations：关闭标量替换]{.blue}</li>
<li>[-XX:+EliminateLocks：开启同步消除 / -XX:-EliminateLocks：关闭同步消除]{.blue}</li>
</ul>
<p>:::warning</p>
<p>① 两条无法使用的命令：-XX:+PrintEliminateAllocations（打印标量替换结果），-XX:+PrintEscapeAnalysis（查看逃逸分析结果）</p>
<p>② 这两条命令在《深入理解虚拟机》中提到了，但是实际没有办法使用，只可以在调试版本的虚拟机中可以使用</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚拟机创建错误</span></span><br><span class="line">VM option <span class="string">&#x27;PrintEliminateAllocations&#x27;</span> is notproduct and is available only in debug version of VM.</span><br></pre></td></tr></table></div></figure>

<p>:::</p>
<blockquote>
<p><strong>回到之前那个问题：对象只能够在堆中分配吗?</strong></p>
</blockquote>
<ul>
<li>先回答这个答案吧，[Java 对象目前只能够在堆中分配]{.red}</li>
<li>你可能想说，哎，不是有栈上分配技术和标量替换技术吗？为什么还是只能够在堆中分配呢？</li>
<li>[原因①：Java 虚拟机目前并没有实现栈上分配的技术，而是采用了诸如标量替换这种替代方案]{.green}</li>
<li>[原因②：标量替换并没有去创建对象，而是创建了对象包含的成员变量，这些成员变量又都是标量，所有压根就没有创建对象]{.green}</li>
<li>结论：所以最终依然认为 Java 对象目前仅能够在堆中分配，但是随着 Valhalla 项目的进行，说不定以后就可以真的在栈上分配了</li>
</ul>
<blockquote>
<p><strong>尾声</strong>（摘自《深入理解虚拟机》）</p>
</blockquote>
<ul>
<li><p>Java 对于栈上分配的技术有着明显的弱势</p>
</li>
<li><p>[但是 C/C++ 天生就支持栈上分配，只要不使用 new 关键字创建对象就好了]{.green}</p>
</li>
<li><p>[对于 Java 的竞争者 C# 来说也是支持栈上分配的]{.green}</p>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/23/jvm/runtime/heapspace/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/">堆空间-内存分配</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-23</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="内存分配"   >
          <a href="#内存分配" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1>
      <p>:::info</p>
<p>前提：这里对象的分配策略是建立在堆空间中的，不考虑逃逸分析这种例外情况</p>
<p>核心：解决对象如何在堆空间分配的问题</p>
<p>:::</p>

        <h2 id="分区概述"   >
          <a href="#分区概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#分区概述" class="headerlink" title="分区概述"></a>分区概述</h2>
      <ul>
<li><p>伊甸园区：</p>
<ul>
<li>[几乎所有对象都是在伊甸园区中被创建的，并且在伊甸园区中被销毁]{.red}</li>
<li>[伊甸园区无法存放对象时将会触发 Minor GC]{.red}</li>
</ul>
</li>
<li><p>幸存者0区/幸存者1区：</p>
<ul>
<li><p>开始：[每次仅使用一个分区存放对象，另外一个分区暂时为空]{.red}</p>
<p>  :::info</p>
<p>  ① 存放对象的分区也称为 From 区，不存放对象的分区也称为 To 区</p>
<p>  ② 第一次触发 Minor GC 时将会任意选择一个幸存者分区存放对象</p>
<p>  :::</p>
</li>
<li><p>过程：</p>
<ul>
<li>[幸存者区无法触发 Minor GC，只有伊甸园区可以触发]{.red}</li>
<li>[幸存者区虽然无法触发 Minor GC，但是 Minor GC  依然会回收幸存者区的对象]{.red}</li>
<li>[触发垃圾回收机制后，存放对象的分区将会把所有对象复制到空的分区中，并且清除自己拥有的对象]{.red}</li>
</ul>
</li>
<li><p>特点：[幸存者区中的每个对象都拥有年龄计数器，用于判断是否进入老年代]{.red}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/幸存者区.f89homjxw00.png" alt="幸存者区" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>老年代：[老年代中的对象很少被垃圾回收机制回收]{.red}</p>
</li>
</ul>

        <h2 id="分配策略"   >
          <a href="#分配策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h2>
      <ul>
<li>对象优先在伊甸园区中分配</li>
<li>大对象直接进入老年代<ul>
<li>内容：超过对象大小阈值的对象将会直接进入老年代</li>
<li>设置阈值命令：[-XX:PretenureSizeThreshold=Size]</li>
</ul>
</li>
<li>长期存活的对象进入老年代<ul>
<li>内容<ul>
<li>每个幸存者区中的对象都具有年龄计数器</li>
<li>每次从一个幸存者区移动到另一个幸存者区时，对象的年龄计数器就会加1</li>
<li>对象的年龄计数器达到阈值之后，对象就会从幸存者区进入老年代区</li>
</ul>
</li>
<li>细节：<ul>
<li>默认阈值为 15</li>
<li>设置阈值命令：[-XX:MaxTenuringThreshold=age]{.blue}</li>
</ul>
</li>
</ul>
</li>
<li>动态对象年龄判断进入老年代<ul>
<li>内容：<ul>
<li>只要保证幸存者区中具有 [小于等于某年龄的对象的总大小]{.red} 超过幸存者区大小的一半</li>
<li>那么 [大于等于该年龄的对象]{.red} 将会直接进入老年代，不需要等待年龄超过阈值</li>
</ul>
</li>
<li>细节：这个策略基本不怎么使用</li>
</ul>
</li>
<li>空间分配担保<ul>
<li>核心：[确保老年代能够容纳在幸存者区无法容纳的对象]{.red}</li>
<li>内容：<ul>
<li>[判断老年代最大连续可用空间是否大于新生代所有对象的总和]{.red}<ul>
<li>如果满足条件，那么这次 Minor GC 就是安全的</li>
<li>如果不满足条件，那么将会继续执行另一个判断</li>
</ul>
</li>
<li>[再次判断老年代最大可用空间是否大于历次晋升到老年代对象的平均大小]{.red}<ul>
<li>如果满足条件，仍然可以 Minor GC，但是是有风险的</li>
<li>如果不满足条件，将会执行 Full GC，用户线程停止时间将会变长</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h2 id="分配过程"   >
          <a href="#分配过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#分配过程" class="headerlink" title="分配过程"></a>分配过程</h2>
      <blockquote>
<p><strong>对象分配示意图</strong></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/分配过程.y6pu32gjvdc.png" alt="分配过程" style="zoom:80%;" />

<blockquote>
<p><strong>对象分配过程</strong></p>
</blockquote>
<ul>
<li><p>开始创建对象</p>
</li>
<li><p>[采用大对象直接进入老年代的策略]{.red}</p>
<ul>
<li>[如果超过对象的阈值：对象将直接进入老年代]{.blue}</li>
<li>如果没有超过对象的阈值：接着采用其他策略分配</li>
</ul>
</li>
<li><p>[判断伊甸园是否具有足够的空间容纳新对象]{.red}</p>
<ul>
<li><p>[如果伊甸园没有足够的空间容纳新对象：触发 Minor GC / YGC]{.blue}</p>
<p>  :::info</p>
<p>  注：触发 Minor GC 之前需要执行空间分配担保</p>
<p>  :::</p>
</li>
<li><p>如果伊甸园区可以容纳新对象：直接分配内存即可</p>
</li>
</ul>
</li>
<li><p>[Minor GC / YGC 开始回收伊甸园区和幸存者区中的对象]{.red}</p>
<ul>
<li><p>被垃圾回收机制回收的对象将会被销毁</p>
</li>
<li><p>[判断幸存者区中对象的年龄是否达到阈值]{.blue}</p>
<ul>
<li>[如果幸存者区中的对象达到阈值：晋升到老年代中]{.blue}</li>
<li>[如果幸存者区中的对象没有达到阈值：进入另一个空幸存者区]{.blue}</li>
</ul>
</li>
<li><p>[判断幸存者区是否还有足够空间容纳从伊甸园区进入幸存者区的对象]{.red}</p>
<ul>
<li>[如果幸存者区没有足够的空间容纳进入的对象：无法被容纳的对象直接晋升为老年代]{.blue}</li>
<li>[如果空幸存者区有足够的空间容纳所有对象：伊甸园和存放对象的幸存者区中没有被回收的对象将进入空幸存者区]{.blue}</li>
</ul>
<p>  :::info</p>
<p>  ① 因为此前执行了空间分配担保，所以可以直接进入老年代，没有必要判断</p>
<p>  ② 伊甸园区无法被幸存者区容纳的对象进入老年代，幸存者区本身的对象是根据阈值来决定的</p>
<p>  ③ 判断阈值和年龄关系的同时也会采用 [动态对象年龄]{.red} 的策略进行优化</p>
<p>  :::</p>
</li>
<li><p>[进入空幸存者区的对象的年龄计数器增加1]{.red}</p>
<p>  :::info</p>
<p>  ① 第一次触发 Minor GC时，两个幸存者区都是空的，虚拟机自行选择一个即可</p>
<p>  ② 对象移动之后年龄计数器达到阈值的话，需要等待下一次移动才会进入老年代</p>
<p>  ③ 年龄计数器的默认阈值是 15</p>
<p>  :::</p>
</li>
</ul>
</li>
<li><p>再次判断伊甸园区是否具有足够的空间容纳新对象</p>
<ul>
<li>如果伊甸园区可以容纳新对象：直接分配内存即可</li>
<li>如果伊甸园没有足够的空间容纳新对象：判断是否可以直接进入老年代</li>
</ul>
</li>
<li><p>[判断老年代是否具有足够的空间容纳新对象]{.red}</p>
<ul>
<li>[如果老年代没有足够的空间容纳新对象：触发 Major GC]{.blue}</li>
<li>[如果老年代有足够的空间容纳新对象：对象直接晋升到老年代]{.blue}</li>
</ul>
</li>
<li><p>Major GC 开始回收老年代中的对象</p>
</li>
<li><p>再次判断老年代是否具有足够的空间容纳新对象</p>
<ul>
<li>如果伊甸园区可以容纳新对象：直接分配内存即可</li>
<li>[如果伊甸园没有足够的空间容纳新对象：抛出 OutOfMemoryError 异常]{.blue}</li>
</ul>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/23/jvm/runtime/heapspace/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/">堆空间-对象创建</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-23</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="对象创建"   >
          <a href="#对象创建" class="heading-link"><i class="fas fa-link"></i></a><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h1>
      
        <h2 id="对象的组成部分"   >
          <a href="#对象的组成部分" class="heading-link"><i class="fas fa-link"></i></a><a href="#对象的组成部分" class="headerlink" title="对象的组成部分"></a>对象的组成部分</h2>
      <ul>
<li><p>对象头（Header）</p>
</li>
<li><p>实例数据（Instance Data）</p>
</li>
<li><p>对齐填充（Padding）</p>
</li>
</ul>

        <h3 id="对象头"   >
          <a href="#对象头" class="heading-link"><i class="fas fa-link"></i></a><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3>
      <blockquote>
<p><strong>对象头图示</strong></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/对象组成.3wxv6lvcr740.png" alt="对象组成" style="zoom:80%;" />

<blockquote>
<p><strong>对象头详解</strong></p>
</blockquote>
<ul>
<li><p>[Mark Word]{.red}：</p>
<ul>
<li><p>定义：采用 32位/64位 的 Bitmap 数据结构存储对象的运行时相关信息</p>
<p>  :::info</p>
<p>  32位虚拟机的 Bitmap 数据结构就是32位的，64位的虚拟机的 Bitmap 就是64位的</p>
<p>  :::</p>
</li>
<li><p>组成：</p>
<ul>
<li>问题：对象的运行时相关信息数据量特别多，超过了 Bitmap 数据结构所能承载的容量，那要怎么解决这个问题呢？</li>
<li>方式：[Mark Word 被设计成为动态的数据结构：根据对象不同的锁状态确定 Mark Word 存储的具体内容]{.red}</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li>[未锁定状态和偏向锁状态的标志位是一样的，所以这两个锁还需要使用 1bit 来进行区分]{.blue}</li>
<li>各个不同的锁不在此细讲，因为涉及到并发编程</li>
</ul>
</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/Mark-Word.39jpbualpio0.png" alt="Mark-Word" style="zoom:80%;" /></li>
<li><p>[类型指针]{.red}</p>
<ul>
<li><p>定义：[指向该对象所属的类型元数据（Klass 对象）的指针]{.red}</p>
</li>
<li><p>细节：</p>
<ul>
<li><p>[对象可以通过类型元数据指针找到其所属的类，但是并不是所有对象都必须保存该指针]{.red}</p>
<p>  比如在使用反射中，你可以使用对象获取 Class 对象也可以使用类或者方法获取 Class 对象</p>
</li>
<li><p>[首先明确 Klass 对象不是 Class 对象]{.red}</p>
<p>  详细了解：[OOP-Klass模型](#OOP-Klass 模型)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数组长度：用于记录数组长度的部分（[只有数组才有这部分内容]{.red}）</p>
</li>
</ul>

        <h3 id="实例数据"   >
          <a href="#实例数据" class="heading-link"><i class="fas fa-link"></i></a><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3>
      <ul>
<li><p>定义：存储对象中所有的有效信息</p>
</li>
<li><p>组成：我们在程序中 [定义各种类型的 <strong>实例变量</strong> 以及从父类继承的 <strong>实例变量</strong> ]{.red}</p>
<p>  +++warning 对象的实例数据仅包含各种各样的实例变量，并不包含方法信息</p>
<p>  ① 每个类都可以拥有非常多的对象，每个对象仅有数据字段不同，使用的方法肯定是完全相同的</p>
<p>  ② 所以让每个堆中的对象都记录虚方法表显然是不合适的，浪费堆内存空间</p>
<p>  ③ 既然对象中并不保存方法信息，那么到底哪里保存方法相关的信息呢？这个就涉及到 OOP-Klass 模型了</p>
<p>  +++</p>
</li>
<li><p>存储顺序：[长度相同的变量总是优先分配在一起]{.red}</p>
<ul>
<li>虚拟机默认分配策略：<ul>
<li>double &amp; long 一起分配（8B）</li>
<li>int &amp; float 一起分配（4B）</li>
<li>char &amp; short 一起分配（2B）</li>
<li>byte &amp; boolean 一起分配（1B）</li>
<li>referrence 最后分配（4B）</li>
</ul>
</li>
<li>虚拟机的分配策略还会受到  [变量的定义顺序]{.blue} 和 [分配策略参数]{.blue} 的影响</li>
</ul>
</li>
</ul>

        <h3 id="对其填充"   >
          <a href="#对其填充" class="heading-link"><i class="fas fa-link"></i></a><a href="#对其填充" class="headerlink" title="对其填充"></a>对其填充</h3>
      <ul>
<li>前提：<ul>
<li>Java 虚拟机要求对象的大小必须是 8字节 的整数倍</li>
<li>对象大小不是 8字节 整数倍时就会采用对其填充的方式变为 8 字节整数倍</li>
</ul>
</li>
<li>定义：为对象填充某些数据使得其大小为 8字节 的整数倍</li>
<li>细节：[对其填充本身没有什么含义，但是会引发一系列的问题]{.blue}</li>
</ul>
<blockquote>
<p><strong>对象头组成代码演示</strong></p>
</blockquote>
<p>:::info</p>
<p>① 使用 jol 工具类就可以查看对象在内存中的布局</p>
<p>② 使用 lombok 插件可以简化对象类的编写</p>
<p>:::</p>
<blockquote>
<p>对象代码</p>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter08;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Integer age;</span><br><span class="line">    String name;</span><br><span class="line">    Boolean gender;</span><br><span class="line">    String work;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<blockquote>
<p><strong>测试代码</strong></p>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="number">16</span>, <span class="string">&quot;冬坂五百里&quot;</span>, <span class="keyword">true</span>, <span class="string">&quot;开机兵&quot;</span>);</span><br><span class="line">    <span class="comment">// 貌似只有使用到了哈希码才会生成, 否则在 MarkWord 中是看不到的</span></span><br><span class="line">    printfObject(person);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工具方法: 输出对象的内存布局</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printfObject</span><span class="params">(Person person)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 输出对象头</span></span><br><span class="line">    System.out.println(ClassLayout.parseInstance(person).toPrintable());</span><br><span class="line">    System.out.println(GraphLayout.parseInstance(person).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p><strong>测试结果</strong></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/对象组成演示.4scx77d5pr00.png" alt="对象组成演示" style="zoom:80%;" />




        <h2 id="OOP-Klass-模型"   >
          <a href="#OOP-Klass-模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#OOP-Klass-模型" class="headerlink" title="OOP-Klass 模型"></a>OOP-Klass 模型</h2>
      <p>:::primary</p>
<p>参考博客：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/linxdcn/article/details/73287490" >【理解HotSpot虚拟机】对象在jvm中的表示：OOP-Klass模型</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26000415/article/details/88061403" >oop-klass内存模型</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<blockquote>
<p><strong>什么是 OOP-Klass 模型</strong></p>
</blockquote>
<ul>
<li><p>定义：OOP 模型 + Klass 模型</p>
</li>
<li><p>OOP 模型（Ordinary Object Pointer）：</p>
<ul>
<li>定义：[存储 Java 对象所有实例数据的模型]{.red}</li>
<li>创建时间：创建对象时（<a href="#%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96">对象实例化</a>）就会相应的创建 OOP 对象</li>
<li>组成：对象头 + 实例数据 + 数组长度</li>
<li>存储位置：[堆空间]{.red}</li>
</ul>
<p>  :::info</p>
<p>  说白了，OOP 就是我们创建对象后，堆空间存储对象相关数据的模型</p>
<p>  :::</p>
</li>
<li><p>Klass 模型：</p>
<ul>
<li>定义：[存储 Java 类的所有元数据信息]{.red}</li>
<li>创建时间：类加载阶段</li>
<li>组成：运行时常量池、成员变量、方法信息（vtable 虚方法表 + itable 类实现的接口的函数表）</li>
<li>存储位置：[方法区]{.red}</li>
<li>细节：[反射机制中的 Class 对象是依靠 Klass 对象生成的：Class 对象相当于是 Klass 对象的镜像文件]{.red}</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>为什么要使用 OOP-Klass 模型</strong></p>
</blockquote>
<ul>
<li><p>问题：</p>
<ul>
<li>HotSpot 是采用 C++ 编写的运行 Java 程序的虚拟机</li>
<li>[那么 Java 的类如何才能够被 C++ 编写的虚拟机解析呢？]{.blue}</li>
</ul>
</li>
<li><p>方式：</p>
<ul>
<li><p>最简单的方式：为了每个 Java 类都生成对应的 C++ 类，[这意味着每个 Java 对象中也必须包含虚方法表]{.blue}</p>
<p>  :::info</p>
<p>  ① Java 中默认所有的方法都是虚方法，而 C++ 中必须使用关键字 virtual 声明方法才行</p>
<p>  ② Java 的虚方法的数量显然会比 C++ 中的虚方法使用更加频繁，数量更多，为每个对象都保存虚方法表显然是不明智的</p>
<p>  :::</p>
</li>
<li><p>采用的方式：利用 OOP-Klass 模型</p>
<ul>
<li><p>OOP 模型只用于存储对象的相关数据</p>
</li>
<li><p>[Klass 模型用于存储类的元数据信息，用于被 C++ 解析，]{.blue}</p>
<p>  [所以可以认为 Klass 对象是 C++ 中类的表现形式，和 Java 中的类相对应]{.blue}</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>原因：[为了 Java 编写的类能够被虚拟机解析，同时也为了压缩堆空间中对象的大小]{.red}</p>
</li>
</ul>

        <h2 id="对象大小计算"   >
          <a href="#对象大小计算" class="heading-link"><i class="fas fa-link"></i></a><a href="#对象大小计算" class="headerlink" title="对象大小计算"></a>对象大小计算</h2>
      <p>:::primary</p>
<p>参考博客：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/149678226" >jvm压缩指针原理以及32g内存压缩指针失效详解</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<ul>
<li>不同位数的虚拟机<ul>
<li>32 位虚拟机：<ul>
<li>对象头：[类元数据指针 4B + Mark Word 4B]{.blue}</li>
<li>实例数据：[引用类型大小占据 4B，基本类型不变]{.blue}</li>
<li>对其填充：确保对象大小为8的整数倍</li>
</ul>
</li>
<li>64 位虚拟机：<ul>
<li>对象头：[类元数据指针 8B + Mark Word 8B]{.blue}</li>
<li>实例数据：[引用类型大小占据 8B，基本类型不变]{.blue}</li>
<li>对其填充：确保对象大小为8的整数倍</li>
</ul>
</li>
<li>问题：<ul>
<li>64位虚拟机下的对象大小是32位虚拟机的对象的2倍，由于对齐填充，实际是1.5倍</li>
<li>[对象增大导致对象占用的堆内存更多，触发垃圾回收机制更加频繁]{.red}</li>
<li>[对象增大同时导致处理器能够缓存的对象变少，处理器缓存的命中率降低]{.red}</li>
</ul>
</li>
</ul>
</li>
<li>指针压缩<ul>
<li>定义：[压缩 OOP 对象的大小]{.red}<ul>
<li>压缩对象头信息：对象头从 16B 压缩到 12B（主要就是压缩了类型指针）</li>
<li>压缩对象引用：对象引用（不是类型指针）从 8B 压缩到 4B</li>
<li>压缩数组类型：数组从 24B 压缩到 16B</li>
</ul>
</li>
<li>作用：[减轻堆内存的分配对象的压力]{.red}</li>
<li>细节：JDK 6 之后默认开启指针压缩</li>
</ul>
</li>
</ul>
<p>+++danger 为什么不推荐让虚拟机内存超过 32G？</p>
<p>+++</p>

        <h2 id="对象的实例化"   >
          <a href="#对象的实例化" class="heading-link"><i class="fas fa-link"></i></a><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h2>
      <p>:::warning</p>
<p>前提：需要对反射机制、克隆机制、序列化机制有所了解，才能够明白这些机制是如何创建对象的</p>
<p>:::</p>
<blockquote>
<p><strong>对象的实例化方式图示</strong></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/对象实例化方式.5iqes5rp0540.png" alt="对象实例化方式" style="zoom:80%;" />

<blockquote>
<p><strong>对象实例化方式具体实现</strong></p>
</blockquote>
<ul>
<li><p>[关键字 new 创建对象]{.red}</p>
<ul>
<li><p>使用方式：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Object object = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>变形：（设计模式的运用）</p>
<ul>
<li><a href="">单例模式</a>：使用静态方法创建对象</li>
<li><a href="">工厂模式/建造者模式</a>：使用普通方法创建对象</li>
</ul>
</li>
<li><p>细节：[最常见的创建对象的方式]{.blue}</p>
</li>
</ul>
</li>
<li><p>[反射机制创建对象]{.red}</p>
<ul>
<li><p>[直接利用反射类对象创建类对象]{.blue}</p>
<ul>
<li><p>使用方式：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateObject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> </span></span><br><span class="line"><span class="function">        IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 获得 Student 类对应的反射类对象</span></span><br><span class="line">        Class&lt;Student&gt; studentClass = Student.class;</span><br><span class="line">        <span class="comment">// 利用反射类对象创建 Student 类对象</span></span><br><span class="line">        Student student = studentClass.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>细节：</p>
<ul>
<li>[直接利用反射类创建对象仅能够调用 <strong>公共的空参构造器创建</strong>]{.red}</li>
<li>[JDK 9 之后该方式被标记为已过时]{.green}</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/反射创建对象API(1).2tr9r2dz4ts0.png" alt="反射创建对象API(1)" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>[利用反射类对象获取类的构造器创建对象]{.blue}</p>
<ul>
<li><p>使用方式：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateObject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> </span></span><br><span class="line"><span class="function">        IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 获得 Student 类对应的反射类对象</span></span><br><span class="line">        Class&lt;Student&gt; studentClass = Student.class;</span><br><span class="line">        <span class="comment">// 利用反射类对象获取构造器后创建 Student 类对象</span></span><br><span class="line">        Student student = studentClass.getConstructor().newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="comment">// 显示声明空参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>细节：[利用构造器类创建对象可以使用有参或者无参的构造器，并且构造器的权限时任意的]{.red}</p>
</li>
</ul>
</li>
</ul>
<p>  +++ 对比这两种方法，想想为什么直接利用反射类创建对象被废弃了?</p>
<p>  +++</p>
</li>
<li><p>[克隆创建对象]{.red}</p>
<ul>
<li><p>使用方式</p>
<ul>
<li><p>[浅克隆]{.blue}：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateObject</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throw CloneNotSupportedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        Student student_clone = (Student)student.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ① 一定要实现 Cloneable 接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="comment">// ② 一定要重写 clone 方法：因为 Student 不是 Object 的子类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>[深克隆：本质实现还是采用的反序列化机制，就不在这里演示了]{.blue}</p>
</li>
</ul>
</li>
<li><p>细节：</p>
</li>
</ul>
</li>
<li><p>[反序列化创建对象]{.red}</p>
<ul>
<li><p>使用方式：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反序列化创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateObject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="comment">// 1.创建对象输出流</span></span><br><span class="line">        ObjectOutputStream  oos = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedOutputStream(baos));</span><br><span class="line">        <span class="comment">// 2.序列化对象</span></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> Student(<span class="number">10</span>));</span><br><span class="line">        <span class="comment">// 3.刷新缓存，否则你是无法将对象写入流中的（血的教训）</span></span><br><span class="line">        oos.flush();</span><br><span class="line">        <span class="comment">// 4.创建对象输入流：对象输入流必须在序列化对象之后创建，否则对象输入流会创建失败（血的教训）</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">            <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                <span class="keyword">new</span> ByteArrayInputStream(</span><br><span class="line">                    baos.toByteArray())));</span><br><span class="line">        <span class="comment">// 5. 反序列化对象</span></span><br><span class="line">        Student student = (Student) ois.readObject();</span><br><span class="line">        <span class="comment">// 6.测试是否创建成功</span></span><br><span class="line">        System.out.println(student.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0.序列化类必须实现序列化接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>细节：[网络编程中接收传输数据创建对象最常使用的方式]{.blue}</p>
</li>
</ul>
</li>
</ul>

        <h2 id="对象的创建过程"   >
          <a href="#对象的创建过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h2>
      <p>:::primary</p>
<p>参考博客：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40634846/article/details/106300702" >Java的指针碰撞简介</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<blockquote>
<p><strong>对象创建过程图示</strong></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/对象创建过程.ctt8ofhx6gg.png" alt="对象创建过程" style="zoom:80%;" />

<blockquote>
<p><strong>具体的对象创建过程</strong></p>
</blockquote>
<ul>
<li><p>[对象对应的类是否已经被加载进入虚拟机内存]{.red}</p>
<ul>
<li><p>[虚拟机定位到类在元空间运行时常量池中的符号引用]{.blue}</p>
</li>
<li><p>[虚拟机再判断类是否已经经历加载、连接、初始化三个过程]{.blue}</p>
<ul>
<li>如果类已经被类加载器加载，接着创建对象就行</li>
<li>如果类没有被类加载器加载，那么虚拟机就会查找类对应的字节码文件<ul>
<li>如果查找到相应的字节码文件，就加载该类并且创建对应的 Class 对象即可</li>
<li>如果没有查找到对应的字节码文件，那么就会抛出异常</li>
</ul>
</li>
</ul>
<p>  :::info</p>
<p>  ① 动态链接是将符号引用转化成直接引用的过程，实际上就是虚拟机查找类在内存中地址的过程</p>
<p>  ② 虚拟机能找到类的内存地址那就是加载了，找不到那就是没有加载</p>
<p>  :::</p>
</li>
</ul>
</li>
<li><p>[为对象分配内存空间]{.red}</p>
<ul>
<li><p>堆内存规整</p>
<ul>
<li>定义：所有被对象使用过的内存存放在一边，没有被使用的内存存放在另一边</li>
<li>分配算法：指针碰撞（Bump The Pointer）</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/指针碰撞.2ghfaw61x39c.png" alt="指针碰撞" style="zoom:80%;" />

<ul>
<li><p>几个问题：</p>
<p>  +++ 为什么要叫做指针碰撞呢？指针是有了，碰撞在哪里呢？</p>
<p>  +++</p>
<p>  +++danger 如果对象超过或者小于固定的内存块大小呢?</p>
<p>  +++</p>
</li>
</ul>
</li>
<li><p>堆内存不规整</p>
<ul>
<li>定义：被对象使用的过内存和没有使用的内存交错分布</li>
<li>分配算法：空闲列表（Free List）（类似于操作系统中的非连续分配方式）<ul>
<li>维护一个用于记录空闲内存块的列表</li>
<li>每次都从列表中查找一个足够大的内存块分配给对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>  :::info</p>
<p>  ① [对象的大小在类加载的过程就已经被确定好了]{.red}：每个对象都是类的实例嘛，类的大小也就基本等同于对象的大小</p>
<p>  ② [对象的分配方式取决于堆内存是否规整，堆内存是否规整取决于垃圾回收器是否具有压缩整理功能]{.red}</p>
<p>  ③ [对象中拥有引用类型的实例变量，那么仅分配引用的空间（4字节）]{.red}</p>
<p>  :::</p>
</li>
<li><p>[确保分配内存安全]{.red}</p>
<ul>
<li>问题：[多个线程同时创建对象造成的并发问题]{.blue}<ul>
<li>前一个线程刚创建对象完毕，但是还没有来得及将引用指向对象，就切换成另外一个线程</li>
<li>另一个线程也要创建对象，刚好和前一个线程使用同一块区域，导致其创建对象覆盖掉前一个线程创建的对象</li>
</ul>
</li>
<li>方式<ul>
<li>[对分配内存空间的行为采用同步机制处理]{.blue}：虚拟机实际采用 CAS 配上失败重试的方式保证分配操作的原子性</li>
<li>[不同线程在互不干扰的区域中分配对象]{.blue}：虚拟机实际采用 TLAB 来实现分配过程的安全性</li>
</ul>
</li>
</ul>
</li>
<li><p>[初始化对象的 <strong>实例变量</strong>]{.red}：实例变量会被设置成类型 [默认值]{.red}</p>
<p>  :::info</p>
<p>  类中的类变量早在类加载阶段就已经初始化完成了，所以这里只涉及实例变量</p>
<p>  :::</p>
</li>
<li><p>[初始化对象的对象头]{.red}</p>
</li>
<li><p>[执行对象的构造函数]{.red}</p>
</li>
</ul>

        <h2 id="对象的访问定位"   >
          <a href="#对象的访问定位" class="heading-link"><i class="fas fa-link"></i></a><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2>
      <ul>
<li><p>访问定位：虚拟机栈中的对象引用寻找到对象在堆空间中的实例数据的过程</p>
</li>
<li><p>方式</p>
<ul>
<li><p>句柄访问</p>
<ul>
<li>句柄：[对象实例数据指针 + 对象类元数据信息指针]{.red}</li>
<li>存储：堆空间中划分一块区域用于存储所有对象的句柄</li>
<li>引用：[指向句柄在堆空间中的地址]{.red}</li>
<li>访问过程：引用需要先找到句柄在堆空间中的位置后，再根据句柄确定对象的实例数据或者类元信息</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/句柄访问.6xtbodd7hao0.png" alt="句柄访问" style="zoom:80%;" /></li>
<li><p>直接指针访问</p>
<ul>
<li>引用：[直接指向对象在堆空间中的地址]{.red}</li>
<li>访问过程：引用直接就可以根据地址找到对象</li>
<li>细节：[HotSpot 虚拟机实际采用的就是直接指针访问的方式定位对象]{.blue}</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/直接指针访问.4eqkkn6unpm0.png" alt="直接指针访问" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>对比</p>
<ul>
<li>句柄访问<ul>
<li>优点：[对象在堆空间中的位置发生改变，只需要改变句柄的地址就行，对象引用的地址不需要改变]{.red}<ul>
<li>对于程序员来讲这个地址改变就是彻底不可见了，因为引用地址不会随着对象的地址而改变</li>
<li>[适用于对象地址频繁在堆空间中发生变化的情况]{.red}</li>
</ul>
</li>
<li>缺点：[每次访问对象都会增加一次寻址的开销]{.green}</li>
<li>细节：[对象类元数据指针不再存放在对象实例数据中，也就意味着没有存放在对象头中]{.red}</li>
</ul>
</li>
<li>直接指针访问<ul>
<li>优点：[每次访问对象仅花费一次寻址的开销]{.red}</li>
<li>缺点：[对象在堆空间中的位置发生改变，需要直接修改对象引用]{.green}<ul>
<li>对于频繁再堆空间中地址发生变化的对象是非常不利的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/23/jvm/runtime/heapspace/%E6%A6%82%E8%BF%B0/">堆空间-概述</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-23</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="堆空间"   >
          <a href="#堆空间" class="heading-link"><i class="fas fa-link"></i></a><a href="#堆空间" class="headerlink" title="堆空间"></a>堆空间</h1>
      
        <h2 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h2>
      <blockquote>
<p><strong>什么是堆空间?</strong></p>
</blockquote>
<ul>
<li><p>定义：虚拟机中 [最大的存储空间]{.red}</p>
</li>
<li><p>作用：[存放所有被创建的对象和数组的空间]{.red}</p>
<p>  +++danger 对象一定被分配在堆空间中吗？</p>
<p>  <a href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90">逃逸分析</a></p>
<p>  +++</p>
</li>
<li><p>特点：</p>
<ul>
<li><p>[堆空间可以处于物理上并不连续的内存空间中]{.red}</p>
<ul>
<li><p>物理上不连续：操作系统采用了虚拟内存技术，所以分配给虚拟机的内存显然是不连续的</p>
</li>
<li><p>逻辑上连续：虚拟机的使用者并不关心实际内存是怎么存储的，从表面上看来就是连续的</p>
</li>
<li><p>[如果创建的是大对象通常会要求使用连续的堆空间]{.red}</p>
<p>  :::info</p>
<p>  大对象：需要占用的堆内存非常大的对象，诸如数组对象 new byte[1024 * 1024 * 1024]</p>
<p>  :::</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/堆空间实际占用内存.69fin0iqv300.png" alt="堆空间实际占用内存" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>[堆空间中的对象的销毁不取决于方法是否结束，而是取决于垃圾回收机制]{.red}</p>
</li>
<li><p>[堆空间既存在垃圾回收机制，也存在 OutOfMemoryError 异常]{.red}</p>
</li>
<li><p>[堆空间是所有线程共享的区域：线程可以互相访问彼此创建的对象和数组]{.red}</p>
</li>
<li><p>[堆空间主要管理数据的存储，所以存储的是对象和数组的实际数据]{.red}</p>
</li>
</ul>
</li>
</ul>

        <h2 id="空间划分"   >
          <a href="#空间划分" class="heading-link"><i class="fas fa-link"></i></a><a href="#空间划分" class="headerlink" title="空间划分"></a>空间划分</h2>
      <ul>
<li><p>核心：[分代思想]{.red}</p>
</li>
<li><p>虚拟机规范划分：新生代 + 老年代</p>
<ul>
<li><p>新生代：</p>
<ul>
<li>伊甸园区：TLAB（Thread Local Allocation Buffer） + 共享区域</li>
<li>幸存者区：幸存者0区 + 幸存者1区</li>
</ul>
</li>
<li><p>老年代</p>
</li>
<li><p>方法区：[逻辑上归属堆区，物理上并不属于堆区，甚至可以称为非堆区]{.red}</p>
<p>  :::info</p>
<p>  ① 类似于中国大陆和中国台湾的关系，逻辑上台湾归属于中国，但是目前中国大陆的政策无法管理台湾</p>
<p>  ② 方法区和堆区实际存储的内容完全不同，所以进行区分也是正常的</p>
<p>  :::</p>
</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/堆空间划分.3mxvqtnctuw0.png" alt="堆空间划分" style="zoom:80%;" /></li>
<li><p>JDK 7：[方法区采用永久代实现：使用内存是虚拟机提供的内存]{.red}</p>
</li>
<li><p>JDK 8：[方法区采用元空间实现：使用的内存是操作系统提供的物理内存]{.red}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/方法区落地实现.1dqvno6ggn8g.png" alt="方法区落地实现" style="zoom:80%;" />

<p>  +++danger 为什么堆空间要采用分代思想进行管理？</p>
<p>  ① 显然堆空间即使不分代也是可以进行垃圾回收的</p>
<p>  ② 但是如果所有的对象都被杂乱无章地放在一起，每次执行垃圾回收的时候就需要挨个查找</p>
<p>  ③ 哪些是短生命周期的，可以回收，哪些是长生命周期的，不能回收，就相当于每次都要问一问老年代需不需要回收</p>
<p>  ④ 这样垃圾回收的性能显然就会下降，执行了太多没有意义的操作</p>
<p>  ⑤ 核心：优化垃圾回收机制的性能</p>
<p>  +++</p>
</li>
</ul>

        <h2 id="空间大小"   >
          <a href="#空间大小" class="heading-link"><i class="fas fa-link"></i></a><a href="#空间大小" class="headerlink" title="空间大小"></a>空间大小</h2>
      <ul>
<li><p>堆空间大小设置</p>
<ul>
<li><p>特点：[堆空间大小可以是固定容量也可以是动态扩展的]{.red}</p>
</li>
<li><p>固定容量：虚拟机默认采用的是动态扩展，固定容量需要自行设置</p>
<p>  +++info 如何将堆空间设置为固定容量？</p>
<p>  ① 只需要将堆空间的的初始容量和最大容量设置为相同的即可</p>
<p>  ② 再继续想想，为什么要将两者设置为相同？或者说为什么要使用固定容量？</p>
<p>  +++</p>
</li>
<li><p>动态扩展</p>
<ul>
<li><p>[默认初始化容量：物理内存 / 64]{.blue}</p>
</li>
<li><p>[默认最大容量：物理内存 / 4]{.blue}</p>
</li>
<li><p>现状：大多数虚拟机都支持堆空间的动态扩展，[但是实际开发中都是采用固定容量]{.blue}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Runtime: 运行时数据区</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始内存：245MB</span></span><br><span class="line">    <span class="keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory(); </span><br><span class="line">    <span class="comment">// 最大内存：3625MB</span></span><br><span class="line">    <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory();</span><br><span class="line">    <span class="comment">// 输出内存提示信息</span></span><br><span class="line">    System.out.println(<span class="string">&quot;堆空间初始化内存: &quot;</span> + initialMemory / <span class="number">1024</span> /<span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;堆空间最大内存: &quot;</span> + maxMemory / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算物理机的实际内存：15680MB 14500MB</span></span><br><span class="line">    System.out.println(<span class="string">&quot;物理机实际内存: &quot;</span> + initialMemory / <span class="number">1024</span> /<span class="number">1024</span> * <span class="number">64</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;物理机实际最大内存: &quot;</span> + maxMemory / <span class="number">1024</span> /<span class="number">1024</span> * <span class="number">4</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>问题：</p>
<p>  +++danger 为什么要将堆空间的初始化大小和最大容量设置为相同的呢？</p>
<p>  ① 核心：避免频繁扩展堆空间的大小，同时也避免在垃圾回收之后重新计算堆空间大小，从而提高虚拟机的执行性能</p>
<p>  ② 此前提到大多数的虚拟机都支持堆的动态扩展，并且需要使用垃圾回收机制</p>
<p>  ③ 如果允许堆采用动态扩展，那么每次垃圾回收之后都会重新计算堆空间大小</p>
<p>  ④ 因为对象被回收了，堆需要的空间就没那么大了，所以需要重新计算，这显然是浪费性能的</p>
<p>  +++</p>
<p>  +++ 为什么计算得到的物理机内存和实际内存不一样呢？</p>
<p>  ① Runtime.getRuntime().totalMemory();  获取的堆内存是只有正在使用的内存</p>
<p>  ② 幸存者区只会将其中一个区用作存放对象，另外一个区空着不放对象，所以获得的内存每次就少了一部分幸存者区的内存</p>
<p>  +++</p>
</li>
</ul>
</li>
<li><p>设置堆空间大小命令</p>
<ul>
<li><p>[-Xms Size 设置堆空间的初始化大小]{.blue} </p>
  <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置堆空间初始化大小</span></span><br><span class="line"><span class="comment"># 等价于 -XX:InitialHeapSize</span></span><br><span class="line"><span class="comment">#（实际上这个参数我并没有使用过，网上也没有提到如何使用，很奇怪，就连官方文档都没有提到）</span></span><br><span class="line">-Xms1m</span><br></pre></td></tr></table></div></figure></li>
<li><p>[-Xmx Size 设置堆空间的最大容量]{.blue}：</p>
  <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置堆空间最大大小</span></span><br><span class="line"><span class="comment"># 等价于 -XX:MaxHeapSize</span></span><br><span class="line">-Xmx1m</span><br></pre></td></tr></table></div></figure></li>
<li><p>[-Xmn Size 设置堆空间中年轻代的大小]{.blue}：堆剩下的空间就是老年代占有的</p>
  <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置堆空间中年轻代的大小</span></span><br><span class="line">-Xmn1m</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>新生代和老年代大小设置</p>
<ul>
<li><p>默认大小比例</p>
<ul>
<li><p>[新生代 : 老年代 = 1 : 2]{.blue}</p>
</li>
<li><p>[伊甸园区 : 幸存者0区 : 幸存者1区 = 8 : 1 : 1]{.blue}</p>
</li>
<li><p>细节：</p>
<ul>
<li><p>实际开发中通常使用默认的比例设置</p>
</li>
<li><p>实际上虚拟机会采用 [自适应策略]{.red}，新生代和老年代的比例是 1:2，但是新生代内部的比例却不是 8:1:1</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/堆空间比例.4vqbtj0dody0.png" alt="堆空间比例" style="zoom: 67%;" /></li>
</ul>
</li>
</ul>
</li>
<li><p>设置大小比例命令</p>
<ul>
<li><p>[-XX:+UseAdaptiveSizePolicy：关闭虚拟机自适应策略]{.blue}</p>
<p>  :::info</p>
<p>  实际上这个命令并不会生效，自适应策略是无法关闭的，想要让比例为默认的8:1:1，直接设置就好</p>
<p>  :::</p>
</li>
<li><p>[-XX:NewRatio=ration：设置新生代和老年代的比例大小]{.blue}</p>
</li>
<li><p>[-XX:SurvivorRation=ratio：设置伊甸园区和幸存者区的比例大小]{.blue}</p>
</li>
</ul>
</li>
</ul>
<p>  +++ 为什么两个幸存者区的比例始终为 1:1 呢？</p>
<p>  涉及到垃圾回收算法：复制标记算法</p>
<p>  +++</p>
</li>
</ul>

        <h2 id="堆空间溢出"   >
          <a href="#堆空间溢出" class="heading-link"><i class="fas fa-link"></i></a><a href="#堆空间溢出" class="headerlink" title="堆空间溢出"></a>堆空间溢出</h2>
      <p>:::primary</p>
<p>参考博客：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/366840983" >来来来，聊聊7种内存泄露场景和13种解决方案</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>警告：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/sunweiye/p/10863985.html" >jvm 内存泄露与内存溢出</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>、<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43689480/article/details/96474346" >jvm内存泄漏</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>这些博客的例子全部都是错的，但凡写的人自己试一试他写的代码就会发现错了</p>
<p>:::</p>
<ul>
<li><p>异常：OutOfMemoryError</p>
</li>
<li><p>原因：[内存泄露或者内存溢出]{.red}</p>
<ul>
<li><p>内存泄露（Memory Leak）</p>
<ul>
<li><p>定义：[应该被垃圾回收机制清除的对象无法被顺利清除，造成空间浪费，最终可能造成 OOM 异常]{.red}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/随机图库/内存泄露.2mbg5mrp49q0.png" alt="内存泄露" style="zoom:80%;" /></li>
<li><p>情况：（这部分笔记暂时存在问题，先了解什么是内存泄露就行）</p>
<p>  +++danger ① 静态集合类变量长期引用短生命周期的对象</p>
<p>  测试代码</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 线程休眠: 便于观察上升曲线</span></span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">// 链表不被销毁就会长期持有这个对象的引用</span></span><br><span class="line">        list.add(object);</span><br><span class="line">        <span class="comment">// 短生命周期引用不再指向对象, 链表依然持有该对象的引用</span></span><br><span class="line">        <span class="comment">// 注意: 这里将引用置为空的目的是代表这个对象我们不想再使用了</span></span><br><span class="line">        object = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建对象数量: &quot;</span> + ++count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程休眠: 便于观察上升曲线</span></span><br><span class="line">    Thread.sleep(<span class="number">10000000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  测试图示</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/随机图库/内存泄露1.i0i0025otcw.png" alt="内存泄露1" style="zoom:80%;" />

<p>  测试堆内存结果</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/随机图库/堆内存分析1.2caocz52qy4g.png" alt="堆内存分析1" style="zoom:80%;" />

<p>  测试结论：</p>
<ul>
<li>每个添加进入链表的对象我们都不想继续使用，但是由于链表是静态变量，生命周期和类加载器一致，所以垃圾回收无法回收</li>
<li>堆内存结果会再创建对象完成之后长时间保持水平线，意味着垃圾回收一直没有生效</li>
</ul>
<p>  :::info</p>
<p>  疑惑：为什么将 static 关键字去掉之后依然没有触发垃圾回收机制？</p>
<p>  :::</p>
<p>  +++</p>
<p>  ② [未关闭不再使用的连接资源]{.red}：创建的数据库连接、流对象等连接资源再使用之后没有合理关闭，就会造成内存泄露</p>
<p>  ③ [未重写相应的 equals 和 hashCode 方法]{.red}</p>
<p>  ④ 外部类引用内部类对象：</p>
<p>  ⑤ 重写 finalize 方法不得当：</p>
</li>
</ul>
</li>
<li><p>内存溢出（Memory OverFlow）</p>
<ul>
<li><p>定义：[堆空间需要使用的内存超过虚拟机分配的内存，造成 OOM 异常]{.red}</p>
</li>
<li><p>测试：</p>
<p>  测试代码</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 虚拟机参数设置: -Xms1m -Xmx1m</span></span><br><span class="line">    ArrayList&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 注意：尽可能将对象数量设置多点，否则不会溢出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 循环创建对象</span></span><br><span class="line">        list.add(<span class="keyword">new</span> Object());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  测试结果</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/内存溢出.689o51k3uf40.png" alt="内存溢出" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/22/java/reflection/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/">反射机制</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-22</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-22</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="反射机制"   >
          <a href="#反射机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h1>
      <p>:::warning</p>
<ul>
<li>反射机制是非常难解释清楚的，主要原因有如下几个<ul>
<li>反射机制概念本身就很抽象，难以理解其概念</li>
<li>反射机制在初学时使用的机会很少，因为初学者甚至都没有类加载的概念</li>
<li>反射机制涉及到虚拟机中类加载的概念，在各个框架中也有很广泛的应用，没有这些的基本了解真的很难理解</li>
</ul>
</li>
<li>我会尽可能将反射最基础的内容和虚拟机联系起来</li>
</ul>
<p>:::</p>
<p>:::primary</p>
<p>参考博客：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/a745233700/article/details/82893076?ops_request_misc=&request_id=&biz_id=102&utm_term=Java%20%E5%8F%8D%E5%B0%84&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-82893076.nonecase&spm=1018.2226.3001.4187" >Java基础篇：反射机制详解</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<blockquote>
<p><strong>什么是类加载机制?</strong></p>
</blockquote>
<p>:::info</p>
<p>详细了解：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://fuyusakaiori.github.io/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" >Java 虚拟机-类加载机制</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<blockquote>
<p><strong>什么是反射?</strong></p>
</blockquote>
<ul>
<li><p>定义：</p>
<ul>
<li>[虚拟机处于 <strong>运行状态</strong> 中]{.red}</li>
<li>[对于任意一个类都能够知道这个类所有的属性和方法]{.blue}</li>
<li>[对于任意一个对象，都能够调用它的任意一个方法]{.blue}</li>
</ul>
</li>
<li><p>核心：[在进程运行期间将类 <strong>动态</strong> 地加载到虚拟机内存中使用]{.red}</p>
</li>
</ul>
<blockquote>
<p><strong>为什么要使用反射?</strong></p>
</blockquote>
<blockquote>
<p><strong>如何使用反射?</strong></p>
</blockquote>
<blockquote>
<p><strong>反射的原理是什么?</strong></p>
</blockquote>

        <h2 id="反射"   >
          <a href="#反射" class="heading-link"><i class="fas fa-link"></i></a><a href="#反射" class="headerlink" title="反射"></a>反射</h2>
      <ul>
<li><p>概念解释    </p>
<ul>
<li>Java 程序处于运行过程中</li>
<li><strong>根据</strong> Java 程序的<strong>需要</strong></li>
<li><strong>动态</strong>加载 .class 文件</li>
<li>图示解释</li>
</ul>
</li>
<li><p>目的解释</p>
<ul>
<li>更加灵活地根据需求加载 .class 文件</li>
</ul>
<p>  例：每个数据库系统都有不同的数据库驱动（MySQL Oracle）；</p>
<p>  如果在编写代码的时候无法确定程序在执行的过程中究竟使用哪一套数据库驱动系统；</p>
<p>  采用反射机制使用 Class.forName（<em>需要加载的类的全限定名</em>）加载需要使用的数据库驱动</p>
</li>
<li><p>Java 成为<strong>准动态</strong>语言</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String name, <span class="keyword">boolean</span> initialize,</span><br><span class="line">                                   ClassLoader loader)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        Class&lt;?&gt; caller = <span class="keyword">null</span>;</span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Reflective call to get caller class is only needed if a security manager</span></span><br><span class="line">            <span class="comment">// is present.  Avoid the overhead of making this call otherwise.</span></span><br><span class="line">            caller = Reflection.getCallerClass();</span><br><span class="line">            <span class="keyword">if</span> (sun.misc.VM.isSystemDomainLoader(loader)) &#123;</span><br><span class="line">                ClassLoader ccl = ClassLoader.getClassLoader(caller);</span><br><span class="line">                <span class="keyword">if</span> (!sun.misc.VM.isSystemDomainLoader(ccl)) &#123;</span><br><span class="line">                    sm.checkPermission(</span><br><span class="line">                        SecurityConstants.GET_CLASSLOADER_PERMISSION);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// forName 方法会自动选择类加载器(ClassLoader)加载.class文件</span></span><br><span class="line">        <span class="keyword">return</span> forName0(name, initialize, loader, caller);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="反射的用途"   >
          <a href="#反射的用途" class="heading-link"><i class="fas fa-link"></i></a><a href="#反射的用途" class="headerlink" title="反射的用途"></a>反射的用途</h3>
      <ul>
<li>创建实例</li>
<li>框架实现的原理</li>
</ul>

        <h3 id="反射主要内容"   >
          <a href="#反射主要内容" class="heading-link"><i class="fas fa-link"></i></a><a href="#反射主要内容" class="headerlink" title="反射主要内容"></a>反射主要内容</h3>
      
        <h4 id="Javac"   >
          <a href="#Javac" class="heading-link"><i class="fas fa-link"></i></a><a href="#Javac" class="headerlink" title="Javac"></a>Javac</h4>
      <ul>
<li><p>基本概念：Javac 全称 Java Compiler </p>
</li>
<li><p>目的</p>
<ul>
<li><p>Java 源代码实是由 Javac.exe 执行的</p>
<p>  也就是说我们执行 Java 程序实际上是在执行 Javac.exe</p>
</li>
<li><p>Javac 将由 <strong>Java 语言编写的源代码</strong> 转换成 机器能够识别的 <strong>字节码文件(.class)</strong></p>
<p>  ![image-20210307172652963](D:\Typora\Typora\文件\Java 反射机制.assets\image-20210307172652963.png)</p>
</li>
</ul>
</li>
<li><p>使用</p>
</li>
</ul>

        <h4 id="类加载器"   >
          <a href="#类加载器" class="heading-link"><i class="fas fa-link"></i></a><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4>
      <ul>
<li><p>概念：将 C++ 和 Java 编写完成的 <strong>“类”</strong> 加载到<strong>堆中的方法区</strong>中生成 <strong>Class 对象</strong></p>
<ul>
<li>类：所有的类（.java）文件都被 Javac 编译成 .class 文件；所以实际类加载器加载的是 .class 文件</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li>BootstrapClassLoader<ul>
<li>功能：负责加载 Java 语言中的最核心的类库（java.lang.*） 和 构造 ExtClassLoader 和 APPClassLoader</li>
<li>特点<ul>
<li>C++编写</li>
<li>涉及到虚拟机的本地实现细节，不能够被直接调用</li>
</ul>
</li>
</ul>
</li>
<li>ExtClassLoader<ul>
<li>功能：负责加载 Java 语言中的扩展类库（javax.*）</li>
<li>特点<ul>
<li>Java 编写</li>
<li>开发者可以实际调用</li>
</ul>
</li>
</ul>
</li>
<li>APPClassLoader<ul>
<li>功能：主要负责加载应用程序的主函数类</li>
</ul>
</li>
</ul>
</li>
<li><p>类加载机制</p>
<ul>
<li><p>图示</p>
<p>  ![preview](D:\Typora\Typora\文件\Java 反射机制.assets\v2-b9d39568c0e3f87a5df6a0cbfe753cda_r.jpg)</p>
</li>
</ul>
</li>
<li><p>双亲委派机制</p>
<ul>
<li><p>图示</p>
<p>  ![image-20210307175110119](D:\Typora\Typora\文件\Java 反射机制.assets\image-20210307175110119.png)</p>
</li>
<li><p>解释</p>
<p>  从 <strong>自定义类加载器</strong> 开始判断当前的类是否加载过；</p>
<p>  如果当前的类已经在任何一个 类加载器中加载过了，那么当前类就不需要加载了</p>
<p>  如果直到 <strong>核心类库加载器</strong> 中还没有加载过，那么开始从 <strong>核心类库加载器</strong> 开始判断当前类是否可以被加载</p>
<p>  如果当前的类加载器无法加载那么依次向下提交，直到 <strong>自定义类加载器</strong></p>
<p>  如果连 <strong>自定义类加载器</strong> 都无法加载，那么证明当前的类是无法被加载的</p>
</li>
<li><p>目的</p>
<ul>
<li>避免类的重复加载</li>
<li>避免基础核心类库被篡改（自行编写的 String 类是无法被加载的）</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/codeyanbao/article/details/82875064" >双亲委派机制1</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/54693308" >双亲委派机制2</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h4 id="实例构建过程"   >
          <a href="#实例构建过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#实例构建过程" class="headerlink" title="实例构建过程"></a>实例构建过程</h4>
      <p>![image-20210307180421814](D:\Typora\Typora\文件\Java 反射机制.assets\image-20210307180421814.png)</p>

        <h4 id="Class-对象"   >
          <a href="#Class-对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#Class-对象" class="headerlink" title="Class 对象"></a>Class 对象</h4>
      <ul>
<li>概念：.class 文件被类加载器载入堆的方法区中生成 Class 对象</li>
<li>内容<ul>
<li>Class 对象具有<strong>被加载类</strong>的所有信息（注解，方法，字段，构造函数等）</li>
<li>Class 对象提供 <strong>Method Field Constructor <strong>等</strong>静态类</strong>存储<strong>方法</strong>，<strong>字段</strong>，<strong>构造器</strong>的所有信息</li>
</ul>
</li>
<li>源代码</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">volatile</span> Field[] declaredFields; <span class="comment">// 字段和方法的信息太多，所以Class对象提供专门的静态类用于存储信息</span></span><br><span class="line">       <span class="keyword">volatile</span> Field[] publicFields;</span><br><span class="line">       <span class="keyword">volatile</span> Method[] declaredMethods;</span><br><span class="line">       <span class="keyword">volatile</span> Method[] publicMethods;</span><br><span class="line">       <span class="keyword">volatile</span> Constructor&lt;T&gt;[] declaredConstructors;</span><br><span class="line">       <span class="keyword">volatile</span> Constructor&lt;T&gt;[] publicConstructors;</span><br><span class="line">       <span class="comment">// Intermediate results for getFields and getMethods</span></span><br><span class="line">       <span class="keyword">volatile</span> Field[] declaredPublicFields;</span><br><span class="line">       <span class="keyword">volatile</span> Method[] declaredPublicMethods;</span><br><span class="line">       <span class="keyword">volatile</span> Class&lt;?&gt;[] interfaces;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Value of classRedefinedCount when we created this ReflectionData instance</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> redefinedCount;</span><br><span class="line"></span><br><span class="line">       ReflectionData(<span class="keyword">int</span> redefinedCount) &#123;</span><br><span class="line">           <span class="keyword">this</span>.redefinedCount = redefinedCount;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="API"   >
          <a href="#API" class="heading-link"><i class="fas fa-link"></i></a><a href="#API" class="headerlink" title="API"></a>API</h4>
      <ul>
<li>获取类的方式</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种方式 -- 任意情况都能够使用</span></span><br><span class="line">Class clz = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"><span class="comment">// 第二种方式 -- 明确知道类的使用方法</span></span><br><span class="line">Class clz = String.class;</span><br><span class="line"><span class="comment">// 第三种方式</span></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">Class clz = str.getClass();</span><br></pre></td></tr></table></div></figure>

<ul>
<li>获得构造器的方式</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Constructor <span class="title">getConstructor</span><span class="params">(Class[] params)</span> -- 获得使用特殊的参数类型的公共构造函数， </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">Constructor[] <span class="title">getConstructors</span><span class="params">()</span> -- 获得类的所有公共构造函数 </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">Constructor <span class="title">getDeclaredConstructor</span><span class="params">(Class[] params)</span> -- 获得使用特定参数类型的构造函数<span class="params">(与接入级别无关)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">Constructor[] <span class="title">getDeclaredConstructors</span><span class="params">()</span> -- 获得类的所有构造函数<span class="params">(与接入级别无关)</span></span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>获得字段的方式</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Field <span class="title">getField</span><span class="params">(String name)</span> -- 获得命名的公共字段 </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">Field[] <span class="title">getFields</span><span class="params">()</span> -- 获得类的所有公共字段 </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">Field <span class="title">getDeclaredField</span><span class="params">(String name)</span> -- 获得类声明的命名的字段 </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">Field[] <span class="title">getDeclaredFields</span><span class="params">()</span> -- 获得类声明的所有字段</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>获得方法的方式</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name, Class[] params)</span> -- 使用特定的参数类型，获得命名的公共方法 </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">Method[] <span class="title">getMethods</span><span class="params">()</span> -- 获得类的所有公共方法 </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class[] params)</span> -- 使用特写的参数类型，获得类声明的命名的方法</span></span><br><span class="line"><span class="function"><span class="comment">/* </span></span></span><br><span class="line"><span class="comment"><span class="function">这里必须要传入 参数的类型 而且只能够是 Class 对象</span></span></span><br><span class="line"><span class="comment"><span class="function">不能够只传入方法的名称，这样是无法找到方法的（JVM实际上是在Class对象中循环遍历找到的）</span></span></span><br><span class="line"><span class="comment"><span class="function">重载的实现过程实际上是 JVM 在执行方法的时候将参数都传入进去了，所以反射获取方法的时候同样需要传递参数</span></span></span><br><span class="line"><span class="comment"><span class="function">*/</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">Method[] <span class="title">getDeclaredMethods</span><span class="params">()</span> -- 获得类声明的所有方法</span></span><br></pre></td></tr></table></div></figure>

<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.zhihu.com/question/24304289?sort=created" >Java 反射机制</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><a href="jianshu.com/p/9be58ee20dee">Java反射 API</a></p>
</blockquote>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/5/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/7/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/随机图库/1641882498931.3kditdl6ds40.webp" alt="avatar"></div><p class="sidebar-ov-author__text">什么都不会的废物</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/fuyusakaiori" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://weibo.com/Sakiless/home?topnav=1&amp;wvr=6" target="_blank" rel="noopener" data-popover="微博" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weibo"></i></span></a><a class="sidebar-ov-social-item" href="670232228" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">106</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">32</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-nd.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020~2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>小忍的甜甜圈</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1.0.1/dist/canvas-nest.min.js" color="0,0,0" opacity="0.6" count="99" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>