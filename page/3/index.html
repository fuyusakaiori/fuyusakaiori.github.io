<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="啥也不会的大三狗">
<meta property="og:type" content="website">
<meta property="og:title" content="天鹅绒房间">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="天鹅绒房间">
<meta property="og:description" content="啥也不会的大三狗">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Fuyusakaiori">
<meta name="twitter:card" content="summary"><title>天鹅绒房间</title><link ref="canonical" href="http://example.com/page/3/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">天鹅绒房间</div><div class="header-banner-info__subtitle">Velvet Room</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/28/juc/juc-concurrent/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-synchronized-%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/">线程同步-synchronized-优化策略</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-29</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="优化策略"   >
          <a href="#优化策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h1>
      
        <h2 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h2>
      <ul>
<li>前言：<ul>
<li>[Java 线程采用的是内核级线程实现的]{.aqua}</li>
<li>[Synchronized 每次造成的线程阻塞都会让线程执行上下文切换，从而导致 OS 从用户态陷入内核态]{.aqua}</li>
<li>[OS 从用户态陷入内核态的开销是非常大的，为了避免因频繁的阻塞造成的上下文切换带来的开销]{.aqua}</li>
<li>[JDK 官方在 JDK 6 之后推出了相应的优化策略]{.aqua}</li>
</ul>
</li>
<li>细节：下列所有优化策略对程序员来说都是透明的，全部都是由虚拟机完成的，你只需要知道它的原理</li>
<li> 必备知识：你需要了解对象的内存布局或者对象的组成才能够明白下面的知识</li>
</ul>
<p>:::primary</p>
<p>参考笔记：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://47.101.45.234/jvm/runtime/heapspace/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/" >堆空间 - 对象创建</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>

        <h2 id="轻量级锁"   >
          <a href="#轻量级锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2>
      <ul>
<li><p>定义：[不采用传统的 <strong>管程</strong> 给对象加锁，而是采用更加轻量的 <strong>锁记录空间</strong> 来给对象加锁]{.red}</p>
</li>
<li><p>目的：[在 <strong>多线程不会相互产生竞争</strong> 的情况下减少传统的重量级锁带来的性能消耗]{.red}</p>
<ul>
<li>没有竞争不代表不需要加锁，线程的调度完全是由操作系统完成的，线程是否会错开访问完全是未知的</li>
<li>所以虚拟机会在多线程不产生的竞争的情况下使用轻量级锁来减少开销</li>
</ul>
</li>
<li><p>锁记录空间：</p>
<ul>
<li>存放位置：[每个锁记录都存放在线程各自的虚拟机栈空间中]{.red}</li>
<li>组成：[锁记录 + 锁对象的引用地址]{.red}<ul>
<li>[锁记录用于存放 Mark Word 的内容，引用地址用于指向锁住的对象]{.pink}</li>
<li>[锁记录空间的地址并没有存放在锁记录中]{.pink}</li>
</ul>
</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/锁记录空间.26fv5ehdw3eo.png" alt="锁记录空间" style="zoom:80%;" /></li>
<li><p>加锁过程：</p>
<ol>
<li><p>[虚拟机会在线程的虚拟机栈空间中建立锁记录空间，用于记录锁对象的相关信息]{.pink}</p>
</li>
<li><p>线程尝试获取对象锁：</p>
<ul>
<li>[线程首先将 <strong>Mark Word 内容复制到 Displaced Mark Word 中</strong>]{.pink}</li>
<li>[线程接着尝试使用 CAS 将 <strong>Mark Word 的内容更新为 锁记录地址</strong>，并将 <strong>锁状态更新为轻量级锁（00）</strong>]{.pink}    * 如果锁对象的锁状态是未上锁状态（00），那线程就会成功获取对象锁    * 如果锁对象的锁状态已经是轻量级锁状态（01），那线程获取就会获取失败</li>
</ul>
 <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/轻量级-2.qlz08akomzk.png" alt="轻量级-2" style="zoom:80%;" /></li>
<li><p>线程成功获取对象锁：[线程将锁定对象的地址指向当前需要获取的对象]{.red}</p>
</li>
<li><p>线程获取对象失败：[检查 Mark Word 保存的地址是否指向当前线程的锁记录空间]{.red}</p>
<ul>
<li><p>如果指向的是当前线程的锁记录空间，那么当前线程已经拥有该轻量级锁了，就会执行可重入操作</p>
<ul>
<li><p> [线程会在栈空间中新增一条锁记录]{.pink}</p>
</li>
<li><p> [该锁记录的不保存 Mark Word 的副本而是置为空]{.pink}</p>
</li>
</ul>
<p>  +++danger 为什么要将重入记录的 Displaced Mark Word 置为空？</p>
<p>  +++</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/轻量级-3.5gqwcldvufc.png" alt="轻量级-3" style="zoom:80%;" /></li>
<li><p>[如果指向的不是当前线程的锁记录空间，那么就存在其他线程获取到该轻量级锁，轻量级锁会发生<strong>锁膨胀</strong>]{.pink}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/轻量级-4.5qwtg5kz3lw0.png" alt="轻量级-4" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>线程释放锁：</p>
<ul>
<li>[如果锁记录的锁记录地址为空，那么这就是重入记录，直接将锁记录数量减少一即可]{.pink}</li>
<li>[如果锁记录的锁记录地址不为空，那么线程会采用 CAS 将 Mark Word 更新为原来的内容]{.pink}    * 如果 CAS 操作能够成功，那么线程就可以正常释放锁    * [如果 CAS 操作不成功，那么就认为发生了锁膨胀，需要采用重量级锁的解锁流程]{.pink}</li>
</ul>
</li>
</ol>
</li>
<li><p>锁膨胀</p>
<ul>
<li><p>定义：[轻量锁转变为重量锁]{.red}</p>
</li>
<li><p>原因：存在某个线程已经持有对象的轻量级锁时，其余线程试图获取该对象的轻量级锁，产生线程竞争</p>
</li>
<li><p>膨胀过程：</p>
<ol>
<li><p>[虚拟机创建管程对象，Mark Word 指向管程对象]{.pink}</p>
</li>
<li><p>[管程对象将其拥有者设置为持有轻量级锁的线程]{.pink}</p>
</li>
<li><p>[持有轻量锁的线程在释放锁时采用 CAS 更新 Mark Word 会失败，因为 Mark Word 不是期望的锁记录地址]{.pink}</p>
</li>
<li><p>[此时线程就会进入重量级锁的释放流程]{.pink}</p>
</li>
</ol>
<pre><code>&lt;img src=&quot;https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/锁膨胀.myitqy1y69s.png&quot; alt=&quot;锁膨胀&quot; style=&quot;zoom:80%;&quot; /&gt;
</code></pre>
</li>
</ul>
</li>
</ul>

        <h2 id="偏向锁"   >
          <a href="#偏向锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2>
      <ul>
<li>历史：<ul>
<li>JDK 6 中引入的新的锁优化措施，默认开启偏向锁机制</li>
<li>[JDK 15 中已经默认不开启偏向锁机制 （+XX:UseBiasedLocking 开启偏向锁机制）]{.blue}</li>
</ul>
</li>
</ul>

        <h3 id="偏向"   >
          <a href="#偏向" class="heading-link"><i class="fas fa-link"></i></a><a href="#偏向" class="headerlink" title="偏向"></a>偏向</h3>
      <ul>
<li><p>定义：</p>
<ul>
<li>[如果在线程获得锁之后 <strong>长期没有其余线程来尝试获取锁对象</strong>，那么该锁将会“偏向”当前线程]{.red}</li>
<li>[线程在此之后 <strong>无论重入还是普通调用</strong> 锁对象都不需要再执行任何同步措施]{.red}</li>
</ul>
</li>
<li><p>目的：</p>
<ul>
<li><p>[在轻量级锁机制中每次线程执行锁重入都需要使用 CAS 去更新 Mark Word，每次更新都是存在消耗的]{.red}</p>
</li>
<li><p>[在偏向锁机制中只要锁对象偏向线程后，该线程就可以避免每次调用或重入锁对象造成的 CAS 开销]{.red}</p>
</li>
</ul>
</li>
<li><p>偏向过程：</p>
<ol>
<li><p>检查锁对象是否为可偏向状态</p>
<ul>
<li><p>[如果锁对象 Mark Word 中已经存储了哈希值，那么就不可以再开启偏向模式了]{.pink}</p>
</li>
<li><p>[如果虚拟机参数中已经配置禁止开启偏向锁机制的参数，那么也不可以再开启偏向模式]{.pink}</p>
<p>  :::info</p>
<p>  至于为什么在存储哈希值后就不可以开启偏向模式了，在偏向撤销时讲述</p>
<p>  :::</p>
</li>
</ul>
</li>
<li><p>[锁对象 <strong>第一次被线程获取</strong> 时会开启偏向模式，Mark Word 中偏向模式变为 1，锁记录状态依旧为 01]{.pink}</p>
</li>
<li><p>线程接着尝试使用 CAS 更新对象头中存储的内容</p>
</li>
</ol>
<ul>
<li>[如果对象头中哈希值仍为默认值 0，那 CAS 就可以将 <strong>哈希值</strong> 更新为 <strong>偏向线程的 ID + 偏向的时间戳</strong>]{.pink}</li>
<li>[如果对象头中的哈希值不是默认值 0，那么 <strong>虚拟机就会将对象重新置为未偏向模式</strong>]{.pink}</li>
</ul>
<ol start="4">
<li>[线程接下来的重入或者普通调用过程就不需要执行任何同步措施，直接访问即可]{.pink}</li>
</ol>
</li>
<li><p>细节：[偏向锁机制是默认开启的，但是偏向锁默认是延迟开启的]{.red}</p>
<ul>
<li>前者意味着所有对象在未上锁的状态下都是开启了偏向模式的</li>
<li>后者意味着你打印对象内存布局时会发现对象的依然不处于偏向模式</li>
</ul>
</li>
<li><p>测试偏向锁延迟开启机制</p>
<ol>
<li><p>导入 JOL 工具包用于查看对象的内存布局，也就是对象的组成内容</p>
 <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注意: 这个工具类有好几个版本, 每个版本打印出来的格式不太一样--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></div></figure></li>
<li><p>编写测试代码用于测试偏向锁的存在</p>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.bias&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadBias</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 内部类: 里面什么都没有都可以</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Bias</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Bias</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.number = number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Bias bias = <span class="keyword">new</span> Bias();</span><br><span class="line">        <span class="comment">// 打印对象的内存布局</span></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(bias).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>测试结果-1：意料之中没有开启偏向锁</p>
 <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/偏向锁-1.7bdpes7gfyc0.png" alt="偏向锁-1" style="zoom:80%;" /></li>
<li><p>两种解决方式</p>
<ul>
<li>[线程睡眠一段时间之后再打印对象的内存布局]{.blue}</li>
<li>[改变偏向锁延迟的时间：-XX:BiasedLockingStartupDelay=0]{.blue}</li>
</ul>
</li>
<li><p>测试结果-2：</p>
 <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/偏向锁-2.6u5kv3mk6c40.png" alt="偏向锁-2" style="zoom:80%;" /></li>
</ol>
</li>
<li><p>测试偏向锁机制：[前提是确保偏向锁能够生效，也就是没有延迟，否则是看不到偏向线程 ID 的]{.red}</p>
<ol>
<li><p>编写测试代码</p>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.bias&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadBias</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 内部类不再重复</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Bias bias = <span class="keyword">new</span> Bias(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 查看未上锁的对象的内存布局</span></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(bias).toPrintable());</span><br><span class="line">        <span class="comment">// 给对象上锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (bias)&#123;</span><br><span class="line">            <span class="comment">// 查看处于上锁的对象内存布局</span></span><br><span class="line">            log.debug(ClassLayout.parseInstance(bias).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看释放锁之后的对象内存布局</span></span><br><span class="line">        log.debug(ClassLayout.parseInstance(bias).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>测试结果：对象在被主线程上锁之后就将哈希值更新为偏向线程 ID + 偏向时间戳了</p>
 <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/偏向锁-3.3ud0j12nlto0.png" alt="偏向锁-3" style="zoom:80%;" /></li>
</ol>
</li>
</ul>

        <h3 id="撤销偏向"   >
          <a href="#撤销偏向" class="heading-link"><i class="fas fa-link"></i></a><a href="#撤销偏向" class="headerlink" title="撤销偏向"></a>撤销偏向</h3>
      <ul>
<li><p>原因：[存在其他线程尝试获取锁对象的时候，偏向锁就会被立刻撤销转变为轻量级锁]{.red}</p>
<ul>
<li>其他线程尝试获取锁对象可能是拥有线程没有使用锁对象的时候，也有可能恰好拥有线程正在使用锁对象</li>
<li>这两种情况的不同会导致虚拟机在撤销偏向时给定对象的锁状态的不同，前者更新为未上锁，后者就是轻量级锁</li>
</ul>
</li>
<li><p>撤销方式：</p>
<ul>
<li><p>[其余线程尝试获取锁对象，无论对象是否被拥有线程使用]{.red}</p>
<ul>
<li>细节：[这种撤销方式会导致偏向锁升级为轻量级锁]{.pink}</li>
</ul>
</li>
<li><p>[拥有线程调用计算哈希值的方法]{.red}</p>
<ul>
<li><p>细节：</p>
<ul>
<li>[这种撤销方式会导致偏向锁直接升级为重量级锁]{.pink}</li>
<li>[这个方法会自动禁用偏向锁，并且再也无法进入偏向锁状态]{.pink}</li>
</ul>
<p>  +++danger 为什么调用计算哈希值的方法会自动禁用偏向锁呢？</p>
<p>  ① 未上锁状态下的哈希值默认为 0，可以被偏向线程 ID + 偏向时间戳所替换</p>
<p>  ② 但是如果对象调用了计算哈希值的方法，为了保证哈希值一致性就必须将其存储在对象头中</p>
<p>  ③ 此时对象头就没有存储偏向线程 ID + 偏向时间戳的空间了，也就意味着无法进入偏向锁状态了</p>
<p>  +++</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>撤销过程：</p>
<ol>
<li>[Mark Word 记录的偏向模式标志位立刻变为 0]{.pink}</li>
<li>[如果锁对象正在被原拥有线程使用，那么等待使用结束之后就会先将锁状态标志位置为 01]{.pink}<ul>
<li>偏向锁状态 -&gt; 未上锁状态 -&gt; 轻量级锁状态 -&gt; 未上锁状态</li>
</ul>
</li>
<li>[如果锁对象没有被原拥有线程使用，那么其他线程可以立刻使用锁对象，并且将锁状态标志位置为 00]{.pink}<ul>
<li>偏向锁状态 -&gt; 轻量级锁状态 -&gt; 未上锁状态</li>
</ul>
</li>
</ol>
</li>
<li><p>测试其余线程访问造成的偏向撤销</p>
<ol>
<li>编写测试代码</li>
<li>测试结果</li>
</ol>
</li>
<li><p>测试哈希值撤销偏向锁</p>
<ol>
<li><p>编写测试代码</p>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.bias&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadBias</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Bias bias = <span class="keyword">new</span> Bias(<span class="number">10</span>);</span><br><span class="line">		<span class="comment">// 计算对象的哈希值</span></span><br><span class="line">        bias.hashCode();</span><br><span class="line">        <span class="comment">// 查看未上锁的对象的内存布局</span></span><br><span class="line">        log.debug(ClassLayout.parseInstance(bias).toPrintable());</span><br><span class="line">        <span class="keyword">synchronized</span> (bias)&#123;</span><br><span class="line">            <span class="comment">// 查看处于上锁的对象内存布局</span></span><br><span class="line">            log.debug(ClassLayout.parseInstance(bias).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看释放锁之后的对象内存布局</span></span><br><span class="line">        log.debug(ClassLayout.parseInstance(bias).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>测试结果</p>
 <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/偏向锁-4.7cae935ilg40.png" alt="偏向锁-4" style="zoom:80%;" /></li>
</ol>
</li>
</ul>

        <h3 id="批量重偏向"   >
          <a href="#批量重偏向" class="heading-link"><i class="fas fa-link"></i></a><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h3>
      <ul>
<li><p>定义：[偏向锁的撤销次数达到阈值之后，虚拟机会考虑重新将之后的对象重新偏向给其余的线程]{.red}</p>
<ul>
<li>[撤销次数达到阈值之前撤销的对象都从偏向锁升级为轻量级]{.pink}</li>
<li>[撤销次数达到阈值之后的对象都是直接偏向另一个线程而不会经历撤销的过程]{.pink}</li>
</ul>
</li>
<li><p>批量重偏向次数：</p>
<ul>
<li>默认阈值：[虚拟机默认批量重偏向的阈值是达到 20 次]{.red}</li>
<li>设置阈值：[-XX:BiasedLockingBulkRebiasThreshold=count]{.blue}</li>
<li>统计方式：[撤销次数不是统计 <strong>每个对象</strong> 发生了多少次撤销而是统计 <strong>整个进程</strong> 中发生了多少次撤销]{.red}</li>
</ul>
</li>
<li><p>测试批量重偏向机制</p>
<ol>
<li><p>编写测试代码</p>
<ul>
<li><p>主线程延迟启动确保能够开启偏向锁</p>
</li>
<li><p>第一个线程开始给对象添加偏向锁，然后将其添加到集合中，以便之后其他线程使用</p>
</li>
<li><p>第二个线程获取集合中的对象，就会造成偏向锁被撤销，在达到阈值之后开始批量重偏向</p>
</li>
</ul>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.rebias&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadReBias</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread t1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread t2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 确保偏向锁开启</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 存放对象的集合</span></span><br><span class="line">        List&lt;Inner&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 线程开始给对象加锁</span></span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 循环添加对象, 也就是添加偏向锁的过程</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">                Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">                <span class="keyword">synchronized</span> (inner) &#123;</span><br><span class="line">                    list.add(inner);</span><br><span class="line">                    <span class="comment">// 打印内存布局</span></span><br><span class="line">                    log.debug(temp + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(inner).toPrintable());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 尽可能使用同步工具确保第二个线程不会先于第一个线程执行, 最好不要使用睡眠方法</span></span><br><span class="line">            LockSupport.unpark(t2);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 等待一个线程执行结束</span></span><br><span class="line">            LockSupport.park();</span><br><span class="line">            log.debug(<span class="string">&quot;==============================开始撤销===================================&quot;</span>);</span><br><span class="line">            <span class="comment">// 循环添加对象, 也就是添加偏向锁的过程</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">                Inner inner = list.get(i - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (inner) &#123;</span><br><span class="line">                    <span class="comment">// 只打印加锁过程中的对象内存布局也是可以看出来的</span></span><br><span class="line">                    log.debug(temp + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(inner).toPrintable());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>测试结果</p>
<ul>
<li><p>[锁对象偏向线程-1]{.grey}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/偏向锁-5.762zbh2pxt40.png" alt="偏向锁-5" style="zoom:80%;" /></li>
<li><p>[虚拟机撤销偏向锁升级为轻量级锁]{.grey}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/偏向锁-6.125vu4fc1f7k.png" alt="偏向锁-6" style="zoom:80%;" /></li>
<li><p>[锁对象重偏向线程-2：]{.grey}</p>
<ul>
<li>[小细节：]{.grey}<ul>
<li>[实际撤销次数在达到 19 次的时候就会在下个对象身上立刻触发批量重偏向机制]{.grey}</li>
<li>[也就说批量重偏向的对象数量是 21 个，撤销的次数仅有 19 次]{.grey}</li>
</ul>
</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/偏向锁-7.5cn89see1xs0.png" alt="偏向锁-7" style="zoom:80%;" /></li>
</ul>
</li>
</ol>
</li>
</ul>

        <h3 id="批量撤销"   >
          <a href="#批量撤销" class="heading-link"><i class="fas fa-link"></i></a><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h3>
      <ul>
<li><p>定义：</p>
<ul>
<li>[偏向锁的撤销达到更大的阈值之后，虚拟机会认为根本就不应该重偏向]{.red}</li>
<li>[就会直接禁止 <strong>该类的实例</strong> 使用偏向锁（不是完全禁用偏向模式）]{.red}</li>
</ul>
</li>
<li><p>批量撤销阈值：</p>
<ul>
<li>默认值：[虚拟机默认批量撤销的阈值时 40 次]{.red}</li>
<li>设置阈值：[-XX:BiasedLockingBulkRevokeThreshold=count]{.blue}</li>
<li>细节：[在规定的时间范围内撤销次数没有达到阈值次时，虚拟机将会把撤销次数清零，重新统计]{.red}<ul>
<li>[-XX:BiasedLockingDecayTime=time：设置间隔时间]{.blue}</li>
</ul>
</li>
</ul>
</li>
<li><p>测试批量撤销机制</p>
<ol>
<li><p>编写测试代码：</p>
<ul>
<li><p>主线程延迟启动确保能够开启偏向锁</p>
</li>
<li><p>第一个线程开始给对象添加偏向锁，然后将其添加到集合中，以便之后其他线程使用</p>
</li>
<li><p>第二个线程获取集合中的对象，就会造成偏向锁被撤销，在达到阈值之后开始批量重偏向</p>
</li>
<li><p>第三个线程再次获取集合中的对象，对于前面已经被撤销偏向锁的对象就会直接使用，不会再次撤销</p>
</li>
<li><p>而对于重偏向到第二个线程的对象就会再次开始撤销</p>
</li>
</ul>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.rebias&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadReBias</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread t1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread t2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread t3;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 确保偏向锁开启</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 存放对象的集合</span></span><br><span class="line">        List&lt;Inner&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 线程开始给对象加锁</span></span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 循环添加对象, 也就是添加偏向锁的过程</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">                Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">                <span class="keyword">synchronized</span> (inner) &#123;</span><br><span class="line">                    list.add(inner);</span><br><span class="line">                    <span class="comment">// 打印内存布局</span></span><br><span class="line">                    log.debug(temp + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(inner).toPrintable());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.unpark(t2);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            log.debug(<span class="string">&quot;===============开始撤销===============&quot;</span>);</span><br><span class="line">            <span class="comment">// 循环添加对象, 也就是添加偏向锁的过程</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">                Inner inner = list.get(i - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (inner) &#123;</span><br><span class="line">                    <span class="comment">// 打印内存布局</span></span><br><span class="line">                    log.debug(temp + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(inner).toPrintable());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.unpark(t3);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        t3 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            <span class="comment">// 注意: 这里读者可以自行更改为39次和40次进行对比</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">20</span>)</span><br><span class="line">                    log.debug(<span class="string">&quot;===============开始撤销===============&quot;</span>);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">                Inner inner = list.get(i - <span class="number">1</span>);</span><br><span class="line">                log.debug(temp + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(inner).toPrintable());</span><br><span class="line">                <span class="keyword">synchronized</span> (inner)&#123;</span><br><span class="line">                    <span class="comment">// 打印内存布局</span></span><br><span class="line">                    log.debug(temp + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(inner).toPrintable());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">        t3.join();</span><br><span class="line">        log.debug(ClassLayout.parseInstance(<span class="keyword">new</span> Inner()).toPrintable());</span><br><span class="line">        log.debug(ClassLayout.parseInstance(<span class="keyword">new</span> Inner()).toPrintable());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>测试结果：前两个线程执行的逻辑和此前完全一样，因此从第三个线程开始分析</p>
<ul>
<li><p>[第三个线程开始从集合中取出对象，发现前 19 个线程已经被撤销偏向锁了，所以不需要再次撤销]{.grey}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/偏向锁-9.52k3eianqfs0.png" alt="偏向锁-9" style="zoom:80%;" /></li>
<li><p>[第三个线程在取出第 20 个元素的时候就会发现此后的对象都重偏向到第二个线程，所以又会开始撤销]{.grey}</p>
<ul>
<li>[其实撤销次数达到 39 次的时候，之后该类的实例就已经无法进入偏向模式了]{.grey}</li>
<li>[此前第二个线程已经撤销了 19 次对象的偏向锁，那第三个线程只要撤销 20 次就可以触发批量撤销]{.grey}</li>
</ul>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/偏向锁-10.6wadqe6p7jw0.png" alt="偏向锁-10" style="zoom:80%;" /></li>
<li><p>[主线程创建对象并打印内存布局，该类的实例对象再也没有偏向模式]{.grey}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/偏向锁-8.1vx9rgct89eo.png" alt="偏向锁-8" style="zoom:80%;" />

</li>
</ul>
</li>
</ol>
</li>
</ul>

        <h2 id="自旋锁"   >
          <a href="#自旋锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2>
      <ul>
<li>历史：<ul>
<li>JDK 4 中就已经引入自旋锁机制，默认关闭自旋锁机制</li>
<li>JDK 6 中为自旋锁添加自适应机制，默认开启自旋锁机制</li>
<li>[-XX:+UseSpinning 开启自旋锁机制 / -XX:UseSpinning 关闭自旋锁机制]{.blue}</li>
</ul>
</li>
<li>定义：[线程尝试获取对象锁时发现已经被其他线程获取，此时 <strong>不进入阻塞队列等待而是不停地询问锁是否被释放</strong>]{.red}<ul>
<li>如果线程在不停询问的期间发现持有锁的线程释放了锁，那么就可以避免阻塞直接获取锁</li>
<li>如果线程直到询问期结束依然没有获取到锁，那么依然会进入阻塞队列中等待获取锁</li>
</ul>
</li>
<li>原因：<ul>
<li>重量级锁的机制会使得无法获取锁的线程进入阻塞队列中等待</li>
<li>[线程进入阻塞队列等待就必须执行上下文切换，内核线程上下文切换必须从用户态切换到内核态，开销很大]{.aqua}</li>
</ul>
</li>
<li>细节：<ul>
<li>[自旋锁机制只能够在线程可以并行的情况下采用，也就是只能够在多核处理下采用]{.red}<ul>
<li>如果是单核处理器，那么无论如何都会发生上下文切换，换上来的线程采用的自旋是毫无意义的，因为持有锁的线程已经被切换下去了，压根不可能在自旋期间获得锁</li>
<li>只有线程在两个处理器上，其中一个持有锁的线程在执行，另一个线程在自旋，这才是有意义的</li>
</ul>
</li>
<li>[自旋锁本质是忙等待，如果忙等待时间短那效果就会非常好，如果忙等待时间长那就会白白浪费处理器性能]{.red}<ul>
<li>[自旋的次数（询问的次数）默认值为十次：-XX:PreBlockSpin 可以自定义自旋的次数]{.pink}</li>
<li>[JDK 6 之后的自旋锁能够根据即时编译监控收集的信息自动调整自旋的次数，即自适应策略]{.pink}</li>
</ul>
</li>
<li>[自旋锁、轻量级锁、偏向锁这几个策略显然是无法一起使用的]{.pink}<ul>
<li>自旋锁的前提就已经是存在线程之间相互竞争锁了</li>
<li>轻量级锁、偏向锁这两个策略都是基于没有线程竞争的优化策略</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h2 id="锁消除"   >
          <a href="#锁消除" class="heading-link"><i class="fas fa-link"></i></a><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2>
      <ul>
<li><p>前言：Java 虚拟机中采用的同步消除优化策略也就是锁消除策略</p>
</li>
<li><p>定义：[如果虚拟机发现对不存在多线程竞争的资源进行了同步，那么虚拟机会直接消除同步代码块提高性能]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下列情况就是可以同步消除的情况</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 显然内部不存在使用共享变量或者引用对象逃逸的情况</span></span><br><span class="line">    <span class="comment">// 也就是不存在线程安全的情况, 虚拟机(即时编译器)会对其进行同步消除</span></span><br><span class="line"> 	<span class="keyword">int</span> first = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> second = <span class="number">20</span>;</span><br><span class="line">    System.out.println(first + second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>细节：[同步消除的目的不是为了消除你编写的同步代码而是为了 <strong>消除调用的方法中存在的同步代码</strong> ]{.red}</p>
<ul>
<li><p>演示案例：字符串拼接（《深入理解虚拟机》上的例子）</p>
<ul>
<li>[StringBuffer 是线程安全的类，而同步消除就会在拼接操作执行的时候消除这种不必要的同步]{.pink}</li>
<li>除此之外还有非常多的方法自身就涉及到了同步代码，即时编译器都会对他们进行消除</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String first, String second)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JDK 5 以前的方式, 字符串拼接操作会转换成 StringBuffer 进行拼接</span></span><br><span class="line"><span class="comment">// JDK 6 之后会采用 StringBuilder 进行拼接</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String first, String second)</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffe();</span><br><span class="line">    sb.append(first);</span><br><span class="line">    sb.append(second);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>锁消除证明测试</p>
<ol>
<li><p>引入 JMH 工具包</p>
 <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基准测试使用的包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></div></figure></li>
<li><p>编写测试代码</p>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试同步消除</span></span><br><span class="line"><span class="meta">@Fork(1)</span></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line"><span class="meta">@Warmup(iterations = 3)</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 5)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynElimination</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noSynchronizedMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">synchronizedMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            number++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>将项目模块打包后执行</p>
</li>
</ol>
</li>
</ul>

        <h2 id="锁粗化"   >
          <a href="#锁粗化" class="heading-link"><i class="fas fa-link"></i></a><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/28/juc/juc-concurrent/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-synchronized-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">线程同步-synchronized-底层原理</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-29</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="Synchronized-底层原理"   >
          <a href="#Synchronized-底层原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#Synchronized-底层原理" class="headerlink" title="Synchronized-底层原理"></a>Synchronized-底层原理</h1>
      <p>:::primary</p>
<p>① Synchronized 等价于操作系统中的管程，所以首先理解操作系统中的管程是非常重要的</p>
<p>② Java 中提供的所有锁机制几乎都是基于管程的概念实现的</p>
<p>③ 想要知道 Synchronized 是如何实现管程的，需要了解以下的知识</p>
<p>参考笔记：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://47.101.45.234/jvm/runtime/heapspace/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/" >堆空间 - 对象创建</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><a href="">进程同步-信号量</a></p>
<p>:::</p>

        <h2 id="什么是管程？"   >
          <a href="#什么是管程？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是管程？" class="headerlink" title="什么是管程？"></a>什么是管程？</h2>
      <p>:::primary</p>
<p>先来了解下管程的基本机制和基本概念，不涉及具体的过程细节，具体细节放在之后再讲述</p>
<p>参考书籍：《现代操作系统》</p>
<p>参考博客：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38998213/article/details/87899231" >管程的理解</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<ul>
<li><p>名称：Monitor</p>
<ul>
<li>被翻译成管程或者监视器（<del>Java 中还有个概念叫监听器，不过这玩意不重要</del>）</li>
</ul>
</li>
<li><p>定义：[管理共享变量和共享变量的函数实现的一种用于实现同步的高级 <strong>抽象数据结构</strong> ]{.red}</p>
<ul>
<li>[管程中主要包含线程需要使用的共享变量，以及操作共享变量的函数]{.pink}</li>
<li>[抽象数据结构就意味着它不是具体的实现，所以不同语言可以实现自己的管程，是编译器层面的同步方式]{.pink}</li>
</ul>
</li>
<li><p>组成：[共享变量 + 函数 + 信号量 + 条件变量]{.red}</p>
<ul>
<li>[管程作为高级抽象数据结构，其底层通常采用信号量实现同步]{.pink}</li>
<li>[编译器通常确保操作系统能够识别到管程，进而使用信号量进行同步]{.pink}</li>
</ul>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这样的抽象数据结构就称为管程*/</span></span><br><span class="line">monitor monitor_name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*共享变量*/</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">/*信号量: 实现互斥使用的(由编译器负责,程序员不用管)*/</span></span><br><span class="line">    Semaphor semaphor;</span><br><span class="line">    <span class="comment">/*条件变量: 实现线程阻塞和唤醒使用的*/</span></span><br><span class="line">    Condition condition;</span><br><span class="line">    <span class="comment">/*共享变量的函数实现*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="comment">/*初始化代码*/</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>机制：</p>
<ul>
<li>互斥：[管程机制本质采用<strong>信号量等同步机制</strong>确保线程在管程中的互斥，即管程中仅存在唯一活跃的线程]{.red}<ul>
<li>[信号量是由编译器在生成编译文件的时候自动添加而不是由程序员添加，也就是管程是由编译器实现的]{.pink}</li>
<li>[所以管程可以认为是 <strong>软件层面</strong> 实现的同步方式，而此前的信号量通常都是 <strong>硬件层面</strong> 实现的]{.pink}</li>
</ul>
</li>
<li>条件变量：[管程机制允许活跃线程条件不足主动放弃管程的使用权，等待条件满足后重新获取管程的使用权]{.red}<ul>
<li>为何引入条件变量？<ul>
<li>条件不足可能是因为线程需要的某种资源没有获取到，诸如 IO 读取的数据、缓冲区数据不足等等</li>
<li>线程无法得到资源就无法向下执行，就会无限期持有锁，导致其余线程永远获取不到锁</li>
</ul>
</li>
<li>如何使用条件变量？<ul>
<li>核心：线程放弃使用管程时就会自行调用 wait、其余线程唤醒这些等待线程时就会使用 signal</li>
<li>wait 方法会从条件变量中减少一个信号，同时将线程添加到等待队列中</li>
<li>signal 方法会向条件变量发送一个信号，唤醒等待队列中的线程</li>
</ul>
</li>
<li>本质：[条件变量类似于二元信号量 + 指针]{.red}<ul>
<li>[每个条件变量仅能够存储一个信号]{.pink}<ul>
<li>多次调用 signal 方法而不调用 wait 方法会导致信号无法存储而丢失，导致唤醒失去意义</li>
<li>也就是说 wait 方法必须在 signal 方法前使用，毕竟没有等待的线程再怎么唤醒也是没有意义的</li>
</ul>
</li>
<li>[每个条件变量还指向一个等待队列，用于记录当前正在等待的线程]{.pink}</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>[Pascal、C 语言都是不支持管程这种高级同步原语的，Java、C++ 是支持的]{.red}<ul>
<li>Java 管程不同于 OS 定义的经典管程<ul>
<li>[OS 管程默认可以定义包含多个不同的条件变量（定义）]{.pink}</li>
<li>[Java 管程默认仅包含一个条件变量，Java ReentrantLock 管程可以创建多个条件变量（实现）]{.pink}</li>
</ul>
</li>
</ul>
</li>
<li>[进程或者线程不可以直接访问管程中包含的共享变量，只能够借助管程中的函数访问]{.red}</li>
</ul>
</li>
</ul>

        <h2 id="为什么要使用管程？"   >
          <a href="#为什么要使用管程？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么要使用管程？" class="headerlink" title="为什么要使用管程？"></a>为什么要使用管程？</h2>
      <p>:::primary</p>
<p>参考书籍：《操作系统概念》</p>
<p>:::</p>
<ul>
<li><p>核心：[采用信号量实现同步可能存在许多难以避免的问题]{.red}</p>
</li>
<li><p>示例：（采用 C 语言描述）</p>
<ul>
<li><p>[同时执行两次减少信号量的操作显然会导致死锁的发生，这完全可能由程序员自己造成]{.aqua}</p>
  <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">wait(mutex);</span><br><span class="line">	<span class="comment">// 临界区</span></span><br><span class="line">wait(mutex);</span><br></pre></td></tr></table></div></figure></li>
<li><p>[先执行增加信号量的操作，后执行减少信号量的操作，会导致临界区中多于一个活跃线程]{.aqua}</p>
  <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">signal(mutex);</span><br><span class="line">	<span class="comment">// 临界区</span></span><br><span class="line">wait(mutex);</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>
<ul>
<li>总结：<ul>
<li>程序员需要自己确定 wait、signal 操作放置在何处，容易不小心放错位置</li>
<li>管程通常借由编译器保证这些 PV 操作到底添加在何处，比程序员自己添加要安全得多</li>
<li>[<del>Java 采用管程的另一个原因是因为管程比较方便实现（为啥？）</del>]{.grey}</li>
</ul>
</li>
</ul>
<p>​    </p>

        <h2 id="管程如何实现？"   >
          <a href="#管程如何实现？" class="heading-link"><i class="fas fa-link"></i></a><a href="#管程如何实现？" class="headerlink" title="管程如何实现？"></a>管程如何实现？</h2>
      <p>:::info</p>
<p>① 上述内容先简单讲述了 OS 中定义的管程概念，因为管程是一种抽象的概念，所以没有在刚才的内容讲述更加具体的内容</p>
<p>② 接下来就会讲述 Java 如何实现管程这一概念，但是需要优先了解对象是如何组成的</p>
<p>参考笔记：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://47.101.45.234/jvm/runtime/heapspace/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/" >对象是如何组成的？</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<ul>
<li><p>前提：</p>
<ul>
<li>对象头的组成<ul>
<li>Mark Word：包含哈希码、年龄计数器、锁记录等相关信息</li>
<li>类型指针（指向 Klass 对象）</li>
<li>数组长度（只有数组才有的部分）</li>
</ul>
</li>
<li>[阻塞队列：等待当前线程释放锁的线程会进入阻塞队列]{.red}</li>
<li>[等待队列：调用 wait 方法后等待被唤醒的线程进入等待队列]{.red}</li>
</ul>
</li>
<li><p>图解 synchronized 原理</p>
<ul>
<li><p>整体过程</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/管程.3kwq144bgzc0.png" alt="管程" style="zoom:80%;" /></li>
<li><p>线程获取锁：</p>
<ol>
<li>线程判断管程当前是否存在使用者</li>
</ol>
<ul>
<li><p>如果管程当前不存在使用者，那么还要考虑阻塞队列中是否存在等待线程</p>
<ul>
<li><p>[如果不存在等待线程，那么当前线程就可以直接获取管程的使用权]{.pink}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/获取管程的使用权（1）.19slk7btdups.png" alt="获取管程的使用权（1）" style="zoom:80%;" /></li>
<li><p>[如果存在等待线程，线程就需要和阻塞队列中的线程竞争获取对象锁]{.pink}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/获取管程的使用权（2）.1d7ofw1x2cyo.png" alt="获取管程的使用权（2）" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>[如果管程当前存在使用者，那么线程就需要进入阻塞队列等待]{.pink}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/获取管程的使用权（3）.7ffj485ern40.png" alt="获取管程的使用权（3）" style="zoom:80%;" /></li>
</ul>
<ol start="2">
<li><p>[<strong>对象头</strong> 的 Mark Word 的锁记录会从未上锁改为重量级锁状态，同时重量级锁指针指向当前的管程]{.pink}</p>
</li>
<li><p>[<strong>管程</strong> 在线程获取到使用权之后将内部的 Owner 属性设置为当前线程]{.pink}</p>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 虚拟机内部的管程源码</span></span><br><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">//记录个数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL; <span class="comment">// 持有锁的当前线程	</span></span><br><span class="line">    _WaitSet      = NULL; <span class="comment">// 调用 wait 方法后等待被唤醒的线程进入等待队列</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ; <span class="comment">// 等待当前线程释放锁的线程会进入阻塞队列</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

 <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/更新-Mark-Word.5902q4pwfec0.png" alt="更新-Mark-Word" style="zoom:80%;" /></li>
</ol>
</li>
<li><p>线程退出管程（锁）的过程</p>
<ol>
<li>[对象头的 Mark Word 又从重量级锁的状态变为未上锁状态，重量级指针指向空（null）]{.pink}</li>
<li>[管程会将内部的 Owner 属性重新置为空（null），即现在没有线程使用管程]{.pink}</li>
</ol>
</li>
<li><p>线程进入和退出等待队列</p>
<ul>
<li>[线程自行调用 wait 方法放弃管程的使用权，从而进入等待队列中等待被唤醒]{.pink}</li>
<li>[其余线程才可以调用 notify / notifyAll 方法唤醒等待队列中的线程，让等待的线程退出等待队列]{.pink}</li>
</ul>
</li>
</ul>
</li>
<li><p>字节码解释 synchronized 原理</p>
<ul>
<li><p>synchronized 锁对象</p>
<ul>
<li>[编译器会在进入临界区和退出临界区之前添加两条字节码指令：monitorenter、monitorexit]{.aqua}<ul>
<li>这两条指令就实现了管程中始终只存在唯一的活跃线程，实现了线程的互斥</li>
</ul>
</li>
<li>[monitorenter 指令会尝试获取对象锁，如果获取成功就会进入临界区，获取失败就会进入等待队列]{.aqua}</li>
<li>[monitorexit 指令会确保对象锁能够正常被释放，确保其他线程能够获取对象锁]{.aqua}</li>
<li>[额外的 monitorexit：确保临界区中发生异常后依然能够正确释放对象锁]{.pink}</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">   descriptor: ([Ljava/lang/String;)V</span><br><span class="line">   flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field LOCK:Ljava/lang/Object;</span></span><br><span class="line">        <span class="number">3</span>: dup</span><br><span class="line">        <span class="number">4</span>: astore_1</span><br><span class="line">        <span class="number">5</span>: monitorenter	 <span class="comment">// 编译器在字节码文件中插入 monitor 原语确保实现同步						</span></span><br><span class="line">        <span class="number">6</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// 临界区：操作共享变量</span></span><br><span class="line">        <span class="number">9</span>: iconst_1</span><br><span class="line">       <span class="number">10</span>: iadd</span><br><span class="line">       <span class="number">11</span>: putstatic     #<span class="number">3</span>                  </span><br><span class="line">       <span class="number">14</span>: aload_1                           <span class="comment">// 临界区</span></span><br><span class="line">       <span class="number">15</span>: monitorexit     <span class="comment">// 编译器在字节码问题进中插入 monitor 原语确保退出同步块</span></span><br><span class="line">       <span class="number">16</span>: goto          <span class="number">24</span></span><br><span class="line">       <span class="number">19</span>: astore_2</span><br><span class="line">       <span class="number">20</span>: aload_1</span><br><span class="line">       <span class="number">21</span>: monitorexit     <span class="comment">// 编译器确保代码抛出异常时依然能够释放锁的使用权, 从而确保不会死锁</span></span><br><span class="line">       <span class="number">22</span>: aload_2</span><br><span class="line">       <span class="number">23</span>: athrow</span><br><span class="line">       <span class="number">24</span>: <span class="keyword">return</span></span><br><span class="line">		</span><br></pre></td></tr></table></div></figure></li>
<li><p>synchronized 锁方法</p>
<ul>
<li>[方法锁不再添加字节码来确保线程间的互斥而是通过设置访问权限让虚拟机意识到需要进行同步]{.aqua}</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>;</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   <span class="comment">// 锁方法就不会再字节码文件中添加字节码指令来确保同步而是设置访问权限</span></span><br><span class="line">   <span class="comment">// 设置 ACC_SYNCHRONIZED 同步的权限</span></span><br><span class="line">   flags: (<span class="number">0x0029</span>) ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field count:I</span></span><br><span class="line">        <span class="number">3</span>: iconst_1</span><br><span class="line">        <span class="number">4</span>: iadd</span><br><span class="line">        <span class="number">5</span>: putstatic     #<span class="number">2</span>                  <span class="comment">// Field count:I</span></span><br><span class="line">        <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">       line <span class="number">13</span>: <span class="number">8</span></span><br><span class="line">		</span><br></pre></td></tr></table></div></figure>

</li>
</ul>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/28/juc/juc-concurrent/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-synchronized-%E5%9F%BA%E7%A1%80/">线程同步-synchronized-基础</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-11-12</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="Synchronized-基础"   >
          <a href="#Synchronized-基础" class="heading-link"><i class="fas fa-link"></i></a><a href="#Synchronized-基础" class="headerlink" title="Synchronized-基础"></a>Synchronized-基础</h1>
      
        <h2 id="基本概念"   >
          <a href="#基本概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2>
      <p>:::primary</p>
<p>基本概念是对 synchronized 的所有内容的总结，如果发现存在难以理解的地方可以先查看后面的笔记</p>
<p>:::</p>
<p>[基本内容]{.label .info}</p>
<ul>
<li><p>synchronized 定义：[采用的 <strong>悲观锁</strong> 的思想，是一种独占锁或者说排他锁]{.red}</p>
</li>
<li><p>synchronized 作用：[给共享变量添加排他锁从而确保 <strong>每次仅有一个线程</strong> 可以访问该共享变量，确保线程安全]{.red}</p>
</li>
<li><p>synchronized 过程分析：</p>
<ul>
<li><p>[存在线程成功获取共享变量的锁之后，其余线程就会 <strong>发生上下文切换进入阻塞队列等待</strong>]{.red}</p>
<ul>
<li>[持有锁的线程被 <strong>分配的时间片可能不足</strong> 以支撑执行完临界区中所有代码]{.pink}</li>
<li>[此时线程会发生上下文切换 <strong>但是依然持有锁</strong>，其余线程依然处于阻塞队列中无法获取锁]{.pink}</li>
<li>[持有锁的线程需要等待处理器再次分配给自己时间片，从而执行完临界区中所有代码，才能够释放锁]{.pink}</li>
</ul>
</li>
<li><p>[持有锁的线程释放锁之后，阻塞队列中的线程 <strong>再次发生上下文切换开始竞争锁的所有权</strong>]{.red}</p>
</li>
<li><p>竞争成功的线程可以获取到共享变量的锁，其余线程再次进入阻塞队列等待</p>
</li>
</ul>
</li>
<li><p>wait 作用：[持有锁的线程执行所需的条件没有得到的满足时，主动释放锁进入等待队列等待，让其余线程执行]{.red}</p>
</li>
<li><p>notify / notifyAll 作用：[等待队列中的线程执行所需的条件得到满足，从而被唤醒去竞争锁的使用权]{.red}</p>
</li>
</ul>
<p>[底层原理]{.label .danger}</p>
<ul>
<li>实现原理：<ul>
<li>[synchronized + wait + notify 机制就是基于操作系统提出的 <strong>管程</strong> 这个概念实现的]{.red}</li>
<li>[synchronized + wait + notify 都是抽象数据结构管程的组成部分]{.red}</li>
</ul>
</li>
<li>编译器实现：<ul>
<li>[编译器在编译生成字节码的时候会将 synchronized 转换成 monitorenter、monitorexit 两条字节码指令]{.red}</li>
<li>[这两条字节码指令确保共享变量是线程独占的，并且在修改之后对其他线程是可见的]{.red}</li>
<li>[这两条字节码指令的底层实现是由 HotSpot 虚拟机中的 ObjectMonitor 对象实现的]{.red}<ul>
<li>[这个对象负责管理锁、锁的拥有者、等待队列、阻塞队列等信息]{.pink}</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>:::info</p>
<p>这里只是简单讲述 synchronized 关键字的底层实现，详细内容查看<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://47.101.45.234/juc/juc-concurrent/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-synchronized-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" >Synchronized 底层原理</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<p>[性能分析]{.label .success}</p>
<ul>
<li><p>核心：[synchronized 锁]{.red}</p>
</li>
<li><p>[<strong>每次没能成功获取锁的线程需要执行上下文切换进入阻塞队列，而上下文切换会陷入内核态造成很大的开销</strong>]{.red}</p>
</li>
<li><p>[没有竞争的情况下线程依然需要获取锁，也就是会修改监视器对象的信息，这种开销显然是没有必要的]{.red}</p>
<ul>
<li>[没有竞争的情况下产生的获取监视器对象的开销已经在 JDK 6 之后被相应的优化措施解决了]{.pink}</li>
</ul>
</li>
</ul>
<p>[优化措施]{.label .primary}</p>
<ul>
<li>前提：所有的优化措施都是基于没有线程竞争的情况，从而减少没有竞争的情况下同步的开销</li>
<li>[轻量级锁 + 偏向锁（批量重偏向、批量撤销）]{.pink}</li>
<li>[自旋锁 + 锁消除 + 锁粗化]{.pink}</li>
</ul>
<p>[其余细节]{.label .warning}</p>
<ul>
<li><p>[synchronized 锁完美解决了所有并发问题：原子性问题、可见性问题、有序性问题]{.red}</p>
<ul>
<li>不过 synchronized 只是采用内存屏障禁止同步代码块外的代码和同步代码块内的代码进行指令重排</li>
<li>而同步代码内部的代码依然是可以随意进行指令重排的，因为在单线程下指令重排的结果依然是正确的</li>
</ul>
</li>
<li><p>[synchronized 锁是非公平锁，并且不可以被中断，不可以设置超时等待]{.red}</p>
</li>
<li><p>[synchronized 锁可以对共享变量添加，也可以对方法添加]{.red}</p>
<ul>
<li>[synchronized 锁给实例方法添加的本质是给对象实例 this 添加锁]{.pink}</li>
<li>[synchronized 锁给静态方法添加的本质是给 Class 对象添加锁]{.pink}</li>
</ul>
</li>
<li><p>[synchronized 只能给引用类型的变量上锁，基本数据类型是不可以上锁的，并且锁住的引用类型不能为空]{.red}</p>
</li>
<li><p>[不同线程中 synchronized 锁住对象必须相同，才能够确保共享变量是线程独占的]{.red}</p>
</li>
</ul>

        <h2 id="基本使用"   >
          <a href="#基本使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2>
      
        <h3 id="synchronized"   >
          <a href="#synchronized" class="heading-link"><i class="fas fa-link"></i></a><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3>
      <ul>
<li><p>synchronized</p>
<ol>
<li><p>使用方式：给共享变量添加排他锁：<code>synchronized(object)</code></p>
<ul>
<li><p>演示代码</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object object;</span><br><span class="line"><span class="comment">// 给共享变量上锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 其余代码</span></span><br><span class="line">    <span class="keyword">synchronized</span>(object)&#123;</span><br><span class="line">        <span class="comment">// 临界区: 对共享变量进行操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其余代码</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></div></figure></li>
<li><p>细节：</p>
<ul>
<li><p>[给共享变量上锁可以避免给不需要同步的代码块上锁，从而提高加锁的效率]{.pink}</p>
</li>
<li><p>[只有引用类型的共享变量可以上锁，基本数据类型可以借助引用类型变量保护自身]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于上锁的变量</span></span><br><span class="line"><span class="keyword">private</span> Object lock;</span><br><span class="line"><span class="comment">// 共享变量: 不可以直接上锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 其余代码</span></span><br><span class="line">    <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">        <span class="comment">// 保护基本数据类型的变量</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其余代码</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>使用方式：给方法添加排他锁</p>
<ul>
<li><p>演示代码（两种添加方式）</p>
<ul>
<li><p>[给虚方法（实例方法）上锁的实质是对类对象上锁]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronized</span></span>&#123;</span><br><span class="line">    <span class="comment">// 给实例方法上锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等价于锁住类相应的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>[给静态方法上锁的实质是对类的 Class 对象上锁]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronized</span></span>&#123;</span><br><span class="line">    <span class="comment">// 给静态方法上锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等价于锁住类对应的 Class对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(ThreadSynchronized.class)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>细节：[给整个方法上锁会导致锁住不需要同步的代码块从而降低线程的效率]{.pink}</p>
</li>
</ul>
</li>
<li><p>解决线程安全问题：原子性问题</p>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程同步方案: synchronized 关键字</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronized</span></span>&#123;</span><br><span class="line">    <span class="comment">// 共享变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本数据类型无法上锁, 所以可以给方法上锁或者直接给 this 上锁</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        ThreadSynchronized obj = <span class="keyword">new</span> ThreadSynchronized();</span><br><span class="line">		<span class="comment">// 执行递增操作的线程</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">                obj.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">		<span class="comment">// 执行递减操作的线程</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">                obj.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">		<span class="comment">// 启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 无论这个测试代码执行多少次, 最后得到结果一定是固定且正确的</span></span><br><span class="line">        log.debug(<span class="string">&quot;count = &#123;&#125;&quot;</span>, obj.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ol>
</li>
</ul>

        <h3 id="wait"   >
          <a href="#wait" class="heading-link"><i class="fas fa-link"></i></a><a href="#wait" class="headerlink" title="wait"></a>wait</h3>
      <ul>
<li><p>作用：[调用该方法的线程会 <strong>主动放弃共享变量</strong> 的锁，进入等待队列等待被唤醒]{.red}</p>
</li>
<li><p>应用场景：线程发现自己正在执行的任务缺少相应的资源，无法继续正常执行下去，所以会先挂起自己等待条件满足</p>
</li>
<li><p>特点：</p>
<ul>
<li>[线程会从 RUNNABLE 状态变为 WAIT 或者 TIMED_WAITING 状态]{.red}</li>
<li>[线程调用 wait 方法之后会主动释放锁，以便其他线程能够获取]{.red}</li>
<li>[wait 方法被调用之前必须先对共享变量上锁，否则会抛出 IllegalMonitorStateException]{.pink}</li>
<li>[Object 类中提供了该方法，所以引用类型的共享变量都具有 wait 方法]{.blue}</li>
<li>[notify \ notify、interrupt 方法可以打断线程的等待过程，并且抛出 InterruptedException 异常]{.pink}</li>
</ul>
</li>
<li><p>使用方式：</p>
<ol>
<li><p><code>wait()</code>：[线程会无限期等待其余线程唤醒自己]{.aqua}</p>
</li>
<li><p><code>wait(long timeout)</code> ：[线程会在有限的时间内等待其余线程唤醒自己，超过时间之后就不会继续等待]{.aqua}</p>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object object;</span><br><span class="line"><span class="comment">// 给共享变量上锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      	<span class="comment">// 其余代码</span></span><br><span class="line">    	<span class="keyword">synchronized</span>(object)&#123;</span><br><span class="line">        	<span class="comment">// 线程发现正在执行的任务缺少相应资源, 挂起自己</span></span><br><span class="line">        	<span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 线程会持续等待直到有人唤醒自己</span></span><br><span class="line">         		object.wait()   </span><br><span class="line">        	&#125;<span class="keyword">catch</span> (Exception e)&#123;&#125;</span><br><span class="line">    	&#125;  </span><br><span class="line">   	&#125;).start();</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></div></figure></li>
</ol>
</li>
</ul>

        <h3 id="notify-notifyAll"   >
          <a href="#notify-notifyAll" class="heading-link"><i class="fas fa-link"></i></a><a href="#notify-notifyAll" class="headerlink" title="notify / notifyAll"></a>notify / notifyAll</h3>
      <ul>
<li><p>作用：[正在运行的线程唤醒等待队列中等待的线程]{.red}</p>
</li>
<li><p>应用场景：正在运行的线程提供了等待队列中的线程需要的资源，所以将这些等待线程唤醒</p>
</li>
<li><p>特点：</p>
<ul>
<li>[线程调用 notify / notifyAll 方法 <strong>不会主动释放锁</strong>]{.red}<ul>
<li>[这也就意味着线程只能够在即将释放锁的时候调用 notify / notifyAll 方法]{.pink}</li>
<li>[否则在没有释放锁的情况下唤醒等待线程，被唤醒的线程也只能陷入阻塞]{.pink}</li>
</ul>
</li>
<li>[没有任何方法可以指定唤醒某个线程]{.red}<ul>
<li>Java 采用的是内核级线程 + 抢占式调度的算法，所有线程的调度都由 OS 管理</li>
<li>C# 等采用协程的语言才是可以控制线程的</li>
</ul>
</li>
<li>[被唤醒的线程是从此前释放锁的位置开始执行而不是从头开始]{.pink}</li>
<li>[Object 类中提供了该方法，所以引用类型的共享变量都具有 notify / notifyAll 方法]{.blue}</li>
</ul>
</li>
<li><p>使用方式：</p>
<ol>
<li><p><code>notify</code>：[线程调用 notify 方法将会 <strong>随机唤醒</strong> 一个线程]{.aqua}</p>
</li>
<li><p><code>notifyAll</code>：[线程调用 notifyAll 将会 <strong>唤醒所有</strong> 等待线程]{.aqua}</p>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object object;</span><br><span class="line"><span class="comment">// 给共享变量上锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      	<span class="comment">// 其余代码</span></span><br><span class="line">    	<span class="keyword">synchronized</span>(object)&#123;</span><br><span class="line">        	<span class="comment">// 线程发现正在执行的任务缺少相应资源, 挂起自己</span></span><br><span class="line">        	<span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 线程会持续等待直到有人唤醒自己</span></span><br><span class="line">         		object.wait()   </span><br><span class="line">        	&#125;<span class="keyword">catch</span> (Exception e)&#123;&#125;</span><br><span class="line">    	&#125;  </span><br><span class="line">   	&#125;).start();</span><br><span class="line">    </span><br><span class="line">    Time.Unit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 主线程获取锁之后唤醒等待队列中的线程</span></span><br><span class="line">    <span class="keyword">synchronized</span> (LOCK)&#123;</span><br><span class="line">        <span class="comment">// 唤醒所有线程</span></span><br><span class="line">        LOCK.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></div></figure></li>
</ol>
</li>
</ul>

        <h3 id="虚假唤醒"   >
          <a href="#虚假唤醒" class="heading-link"><i class="fas fa-link"></i></a><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h3>
      <ul>
<li><p>问题描述：[线程没有其他任何线程 <strong>唤醒或者被中断或者超时</strong>，该线程从 WAIT 状态变为 RUNNABLE 状态]{.blue}</p>
<ul>
<li>这里的唤醒应该指的是其余线程想要唤醒的不是这个线程，所以说该线程没有被唤醒</li>
</ul>
</li>
<li><p>问题演示：</p>
<ol>
<li>Thread-1、Thread-2 需要 flag、status 变量为 true 时才可正常执行任务</li>
<li>两个线程在获取到对象锁之后分别检查变量是否满足，不满足的情况下就会进入等待队列中等待</li>
<li>主线程在子线程释放锁之后获取对象锁，并且在即将离开之前唤醒所有线程</li>
</ol>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚假唤醒问题</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.fake&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadFakeNotify</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// 第一个线程正常执行需要满足的条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 第二个线程正常执行需要满足的条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> status= <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">// 为了节省篇幅将去除异常的代码块</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK)&#123;</span><br><span class="line">                <span class="comment">// 先检查运行所需的条件是否满足</span></span><br><span class="line">                <span class="keyword">if</span> (!flag)&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;线程未能够获得执行所需的条件, 进入等待队列...&quot;</span>);</span><br><span class="line">                    LOCK.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 唤醒之后检查是否满足条件</span></span><br><span class="line">                <span class="keyword">if</span> (flag)</span><br><span class="line">                    log.debug(<span class="string">&quot;执行任务...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK)&#123;</span><br><span class="line">                <span class="comment">// 先检查运行所需的条件是否满足</span></span><br><span class="line">                <span class="keyword">if</span> (!status)&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;线程未能够获得执行所需的条件, 进入等待队列...&quot;</span>);</span><br><span class="line">                    LOCK.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (status)</span><br><span class="line">                    log.debug(<span class="string">&quot;执行任务...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK)&#123;</span><br><span class="line">                <span class="comment">// 由于资源限制仅满足一个条件</span></span><br><span class="line">                status = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒所有线程</span></span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>核心原因：[每个锁对象仅存在唯一的条件变量，也就是只有一个等待队列]{.red}</p>
<ol>
<li>[所有持有该锁对象的线程在调用 wait 方法之后都会进入相同的等待队列]{.pink}</li>
<li>[其余线程调用 notifyAll 方法会唤醒所有线程，无论线程需要的条件是否满足]{.pink}</li>
<li>[被唤醒的线程不会检查条件变量是否满足，而是直接从此前等待的位置继续执行]{.pink}</li>
<li>[从而导致线程在条件没有满足的情况下，什么都无法完成就结束了]{.pink}</li>
</ol>
</li>
<li><p>正确使用方式：[采用循环判断的方式而不是条件判断]{.aqua}</p>
<ul>
<li>每次线程被唤醒都会检查自己的条件是否满足<ul>
<li>如果条件不满足就会继续调用 wait 方法进行等待</li>
<li>如果条件满足就执行正常任务</li>
</ul>
</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (LOCK)&#123;</span><br><span class="line">        <span class="comment">// 先检查运行所需的条件是否满足</span></span><br><span class="line">        <span class="keyword">while</span> (!flag)&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;线程未能够获得执行所需的条件, 进入等待队列...&quot;</span>);</span><br><span class="line">            LOCK.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 唤醒之后检查是否满足条件</span></span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            log.debug(<span class="string">&quot;执行任务...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></div></figure></li>
</ul>
<p>:::primary</p>
<p>① 在 if 块中使用 wait 方法是非常危险的，因为一旦线程被唤醒并得到锁，就不会再判断if条件而是执行if语句块外的代码</p>
<p>② 在 while 块中则是会在唤醒之后继续判断条件是否成立，这样就避免被虚假唤醒的危险</p>
<p>:::</p>

        <h2 id="八锁问题"   >
          <a href="#八锁问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#八锁问题" class="headerlink" title="八锁问题"></a>八锁问题</h2>
      <p>:::info</p>
<p>如果你认为自己对 Synchronized 关键的使用掌握的很好的话，其实这八个问题都很简单，没有必要看</p>
<p>:::</p>
<ul>
<li><p>前言：[线程八锁问题其实非常简单，考察的是你是否能够清楚分辨锁住的到底是那个对象和线程执行的先后顺序]{.aqua}</p>
</li>
<li><p>问题</p>
<p>  +++warning 观察下列情况，分析两个线程锁住的对象是否相同，线程之间是否会因为锁而互斥</p>
<p>  两个线程锁住都是 this 引用，而 this 指向的是相同的对象，既然锁住的对象相同那么必然就会产生互斥</p>
<p>  +++</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronizedTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法一...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法二...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ThreadSynchronizedTest test = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method1, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method2, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  +++warning 在第一题的基础上让其中一个线程睡眠固定时间，试分析会出现的情况</p>
<p>  ① sleep 方法不会释放线程持有的锁</p>
<p>  ② 其中一个线程需要等待另一个线程固定时间+运行时间才可以获取锁]</p>
<p>  +++</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronizedTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 省略捕获异常的代码...</span></span><br><span class="line">        TimeUnit.sleep(<span class="number">1</span>)</span><br><span class="line">        log.debug(<span class="string">&quot;方法一...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法二...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ThreadSynchronizedTest test = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method1, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method2, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  +++warning 观察下列情况，试分析线程的执行的先后顺序</p>
<p>  ① 线程-1和线程-2之间的执行顺序取决于谁先抢到锁，先抢到的先执行</p>
<p>  ② 线程-3执行的方法没有上锁，执行的时机依靠虚拟机的调度</p>
<p>  ③ 线程1和线程-3：线程-3会先于线程-1执行结束，无论线程-1是否抢到锁，因为线程-1需要睡眠1秒，而线程的调度时间是纳 秒级别的，线程-1执行结束前线程-3早就被调度执行</p>
<p>  ④ 线程-2和线程-3：如果线程-2没有先抢到锁，那么就会晚于线程-3执行，因为线程-1需要睡眠1秒；如果线程-2先抢到锁，那么线程-2和线程-3的执行顺序就是随机的</p>
<p>  ⑤ 结果：3 1 2，3 2 1，2 3 1</p>
<p>  +++</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程八锁问题: 明确到底锁住的是哪个对象</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronizedTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 省略捕获异常的代码...</span></span><br><span class="line">        TimeUnit.sleep(<span class="number">1</span>)</span><br><span class="line">        log.debug(<span class="string">&quot;方法一...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法二...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 没有上锁的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ThreadSynchronizedTest test = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method1, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method2, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method3, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  +++warning 观察下面的代码，试分析两个线程锁住的是否为同一个对象，是否产生互斥</p>
<p>  ① 两者锁住的不是相同的对象，虽然 synchronized 锁住的都是 this 引用，但是两个 this 指向的却是不同的对象</p>
<p>  ② 锁住既然不是相同的对象，那么也就不会产生互斥，两个线程可以并发或者并行输出</p>
<p>  +++</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronizedTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法一...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法二...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       	<span class="comment">// 两个不同的对象</span></span><br><span class="line">        ThreadSynchronizedTest test1 = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        ThreadSynchronizedTest test2 = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(test1::method1, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(test2::method2, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  +++warning 观察下面的代码，试分析两个线程锁住的是否为同一个对象，是否产生互斥</p>
<p>  前者锁住的是静态方法，锁住的是类对应的 Class 对象；后者锁住的是实例方法，锁住的是类对应的实例对象</p>
<p>  +++</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronizedTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法一...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法二...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       	<span class="comment">// 两个不同的对象</span></span><br><span class="line">        ThreadSynchronizedTest test = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        <span class="comment">// 对象调用静态方法是可以的, 只不过不推荐</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;test.method1();&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method2, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  +++warning 观察下面的代码，试分析两个线程锁住的是否为同一个对象，是否产生互斥</p>
<p>  两者锁住都是类对应的 Class 对象</p>
<p>  +++</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronizedTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法一...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法二...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 两个不同的对象</span></span><br><span class="line">        ThreadSynchronizedTest test = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        <span class="comment">// 对象调用静态方法是可以的, 只不过不推荐</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;test.method1();&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;test.method2();&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  +++warning 观察下面的代码，试分析两个线程锁住的是否为同一个对象，是否产生互斥</p>
<p>  前者锁住的依然是 Class 对象，后者锁住的依然是实例对象，只不过实例是 test2 而不是 test 1</p>
<p>  +++</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronizedTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法一...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法二...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 两个不同的对象</span></span><br><span class="line">        ThreadSynchronizedTest test1 = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        ThreadSynchronizedTest test2 = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        <span class="comment">// 对象调用静态方法是可以的, 只不过不推荐</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;test1.method1();&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;test2.method2();&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  +++warning 观察下面的代码，试分析两个线程锁住的是否为同一个对象，是否产生互斥</p>
<p>  虚拟机会为每个类都维护唯一的 Class 对象，两者锁住的都是相同的 Class 对象，尽管实例对象是不同</p>
<p>  +++</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronizedTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法一...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法二...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 两个不同的对象</span></span><br><span class="line">        ThreadSynchronizedTest test1 = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        ThreadSynchronizedTest test2 = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        <span class="comment">// 对象调用静态方法是可以的, 只不过不推荐</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;test1.method1();&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;test2.method2();&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>总结：帮助初学者熟悉 synchronized 机制使用的题目，个人觉得意义不是很大</p>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/28/juc/juc-concurrent/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-volatile/">线程同步-volatile</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-28</span></span></div></header><div class="post-body"><div class="post-excerpt"></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/28/juc/juc-concurrent/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-%E9%94%81%E7%B1%BB%E5%9E%8B/">线程同步-锁类型</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-28</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="锁类型"   >
          <a href="#锁类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h1>
      <p>:::primary</p>
<p>这里只会简单讲述每种锁的概念是什么，具体到锁的每种实现则会放到后面的部分再讲</p>
<p>:::</p>

        <h2 id="悲观锁和乐观锁"   >
          <a href="#悲观锁和乐观锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h2>
      <ul>
<li><p>前言：悲观锁和乐观锁都是数据库并发控制中引入的概念，但并不仅限于数据库系统中使用</p>
</li>
<li><p>悲观锁</p>
<ul>
<li>定义：<ol>
<li>[每次对共享变量的修改过程持悲观态度，认为其他线程访问会 <strong>频繁写入</strong> 共享变量]{.pink}</li>
<li>[所以每次线程访问共享变量之前都会对其上锁，<strong>阻止其他线程访问</strong> 共享变量]{.pink}</li>
</ol>
</li>
<li>核心：[共享变量每次都只能被一个线程访问，其余线程必须阻塞等待直到当前线程释放锁]{.red}</li>
<li>实现：[synchronized、ReentrantLock、ReentrantReadWriteLock（Java）]{.aqua}<ul>
<li>synchronized 底层是采用管程实现的，本质上就符合乐观锁的思想</li>
<li>ReentrantLock 底层采用 CAS 机制实现，本质上是乐观锁，但是其思想符合的是悲观锁的思想</li>
</ul>
</li>
<li>优点：[多数线程都对共享变量执行写操作时，能够通过阻塞线程避免线程无意义的空转，造成资源浪费]{.red}</li>
<li>缺点：<ul>
<li>[每个线程在执行结束之前都不会释放锁从而可能导致死锁问题的发生]{.green}</li>
<li>[每个线程获取锁和释放锁的过程的过程会增加额外的开销]{.green}</li>
</ul>
</li>
<li>细节：</li>
</ul>
</li>
<li><p>乐观锁</p>
<ul>
<li><p>定义：</p>
<ol>
<li>[每次对共享变量的修改过程持乐观态度，认为其他线程不会 <strong>频繁写入而只是读取</strong> 共享变量]{.pink}</li>
<li>[所以每次线程访问共享变量时是不会上锁的，<strong>多个线程可以同时访问</strong> 共享变量]{.pink}</li>
<li>[只有在多个线程同时写入共享变量时才会 <strong>检测是否发生数据冲突</strong>，如果发生冲突就会重新尝试更新数据，直到数据更新成功]{.pink}</li>
</ol>
</li>
<li><p>核心：[多线程可以同时访问共享变量，如果线程行为发生冲突，那么就会不停重试直到成功为止]{.red}</p>
</li>
<li><p>实现：[CAS]{.aqua}</p>
</li>
<li><p>优点：</p>
<ul>
<li>[线程访问共享变量的过程不需要获取锁从而减少获取锁的开销，以及避免死锁问题]{.red}</li>
<li>[底层借助硬件实现（指令集）而不是软件实现的，执行的效率也非常高]{.red}</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><p>[乐观锁会造成 ABA 问题]{.green}</p>
</li>
<li><p>[线程冲突情况特别多时，每个线程重试的次数增多就会大幅增加开销，甚至超过上下文切换带来的开销]{.green}</p>
<p>  :::warning</p>
<p>  乐观锁的 ABA 问题带来的影响远不悲观锁带来的死锁问题影响大，不过确实是个缺点就是了</p>
<p>  :::</p>
</li>
</ul>
</li>
<li><p>细节：乐观锁机制是不会共享变量添加排他锁的，无论线程是读取还是写入变量，而是采用自旋的概念替代排他锁</p>
</li>
</ul>
</li>
</ul>
<p>:::info</p>
<p>① 悲观锁一定是独占锁吗？乐观锁是共享锁吗？</p>
<p>② 乐观锁会对共享变量上锁吗？</p>
<p>:::</p>

        <h2 id="公平锁和非公平锁"   >
          <a href="#公平锁和非公平锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2>
      <ul>
<li><p>前提：公平或者非公平锁都是基于悲观锁而言的，乐观锁根本不存在锁机制也就无从谈起公不公平了</p>
</li>
<li><p>公平锁：</p>
<ul>
<li><p>定义：</p>
<ol>
<li>[想要获取的锁的线程会先检查共享变量的锁是否被其他线程占用]{.pink}</li>
<li>[如果锁没有被其他线程占用，那么线程获取该锁，如果锁已经被占用，那么直接进入阻塞队列等待]{.pink}</li>
</ol>
</li>
<li><p>优点：[避免线程出现饥饿的现象：每个线程都能够在有限的时间内获取到锁的所有权]{.red}</p>
</li>
<li><p>缺点：[正在运行的线程释放锁之后，每次都需要从阻塞队列中唤醒线程，也就是执行上下文切换，增大开销]{.green}</p>
</li>
<li><p>图示</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/公平锁.4305ski22y00.png" alt="公平锁" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>非公平锁</p>
<ul>
<li><p>定义：</p>
<ol>
<li>[想要获取锁的线程会和 <strong>阻塞队列</strong> 中的队首线程竞争获取共享变量的锁]{.pink}</li>
<li>[如果竞争锁成功，那么该线程就会直接获得锁，如果竞争失败，那么该线程就会进入阻塞队列等待]{.pink}</li>
</ol>
</li>
<li><p>实现：synchronized 是非公平锁，ReentrantLock 默认是非公平锁，可以设置为非公平锁</p>
</li>
<li><p>优点：[非公平锁避免频繁唤醒阻塞的线程，减少线程上下文切换造成的开销，增大系统的吞吐量]{.red}</p>
</li>
<li><p>缺点：[容易造成 <strong>饥饿</strong> 现象：阻塞队列中的线程长时间获取不到锁的所有权]{.green}</p>
</li>
<li><p>图示</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/非公平锁.434laznbfc80.png" alt="非公平锁" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li>[无论是公平锁还是非公平锁，阻塞队列中线程都是遵循先进先出的规则来获取锁的]{.red}</li>
<li>[如果没有特别的要求，通常都会采用非公平锁以提升系统整体的性能]{.red}</li>
</ul>
</li>
</ul>

        <h2 id="独占锁和共享锁"   >
          <a href="#独占锁和共享锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#独占锁和共享锁" class="headerlink" title="独占锁和共享锁"></a>独占锁和共享锁</h2>
      <ul>
<li>独占锁：<ul>
<li>定义：[共享变量的锁每次只能够由一个线程获取，其余线程只能够阻塞等待]{.pink}</li>
<li>实现：synchronized、ReetrantLock、ReentrantReadWriteLock.WriteLock</li>
</ul>
</li>
<li>共享锁：<ul>
<li>定义：[共享变量的锁每次可以由多个线程获取，但是多个线程只能够同时进行读操作]{.pink}</li>
<li>实现：ReentrantReadWriteLock.ReadLock</li>
</ul>
</li>
</ul>

        <h2 id="重入锁和不可重入锁"   >
          <a href="#重入锁和不可重入锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#重入锁和不可重入锁" class="headerlink" title="重入锁和不可重入锁"></a>重入锁和不可重入锁</h2>
      <ul>
<li><p>不可重入锁</p>
<ul>
<li>定义：<ol>
<li>[如果线程已经获取到特定共享变量的锁后，想要再次获取该共享变量的锁]{.pink}</li>
<li>[那么该线程将会因为自己持有锁而被阻塞，这样的锁就是不可重入的]{.pink}</li>
</ol>
</li>
<li>细节：Java 默认提供的锁都是可重入的锁，可以采用 AQS 编写不可重入的锁</li>
</ul>
</li>
<li><p>可重入锁：</p>
<ul>
<li><p>定义：</p>
<ol>
<li>[如果线程已经获取到特定共享变量的锁后，想要再次获取该共享变量的锁]{.pink}</li>
<li>[该线程可以继续获取该共享变量的锁而不是被自己阻塞，这样的锁称为可重入的]{.pink}</li>
</ol>
</li>
<li><p>实现：synchronized、ReentrantLock</p>
</li>
<li><p>测试代码</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    log.debug(<span class="string">&quot;第一次获取锁...&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用方法第二次获取锁</span></span><br><span class="line">    method2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二次获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    log.debug(<span class="string">&quot;第二次获取锁...&quot;</span>);</span><br><span class="line">    method3();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第三次获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    log.debug(<span class="string">&quot;第三次获取锁...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

</li>
</ul>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/28/juc/juc-concurrent/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-%E6%A6%82%E8%BF%B0/">线程同步-概述</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-28</span></span></div></header><div class="post-body"><div class="post-excerpt"></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/23/design/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/">模板方法</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-23</span></span></div></header><div class="post-body"><div class="post-excerpt"></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/23/design/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">策略模式</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-11-03</span></span></div></header><div class="post-body"><div class="post-excerpt"></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/23/design/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/">享元模式</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-23</span></span></div></header><div class="post-body"><div class="post-excerpt"></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/21/os/process/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/">进程通信</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-21</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-21</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="进程间通信"   >
          <a href="#进程间通信" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1>
      
        <h2 id="基本概念"   >
          <a href="#基本概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2>
      
        <h2 id="通信方式"   >
          <a href="#通信方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2>
      
        <h3 id="本地进程通信"   >
          <a href="#本地进程通信" class="heading-link"><i class="fas fa-link"></i></a><a href="#本地进程通信" class="headerlink" title="本地进程通信"></a>本地进程通信</h3>
      
        <h4 id="管道"   >
          <a href="#管道" class="heading-link"><i class="fas fa-link"></i></a><a href="#管道" class="headerlink" title="管道"></a>管道</h4>
      
        <h5 id="匿名管道"   >
          <a href="#匿名管道" class="heading-link"><i class="fas fa-link"></i></a><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h5>
      
        <h5 id="命名管道"   >
          <a href="#命名管道" class="heading-link"><i class="fas fa-link"></i></a><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h5>
      
        <h4 id="共享内存"   >
          <a href="#共享内存" class="heading-link"><i class="fas fa-link"></i></a><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4>
      
        <h3 id="分布式进程通信"   >
          <a href="#分布式进程通信" class="heading-link"><i class="fas fa-link"></i></a><a href="#分布式进程通信" class="headerlink" title="分布式进程通信"></a>分布式进程通信</h3>
      
        <h4 id="Socket"   >
          <a href="#Socket" class="heading-link"><i class="fas fa-link"></i></a><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4>
      
        <h4 id="RPC"   >
          <a href="#RPC" class="heading-link"><i class="fas fa-link"></i></a><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4>
      
        <h4 id="MQ"   >
          <a href="#MQ" class="heading-link"><i class="fas fa-link"></i></a><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h4>
      
        <h4 id="Stream"   >
          <a href="#Stream" class="heading-link"><i class="fas fa-link"></i></a><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4>
      
        <h3 id="信号"   >
          <a href="#信号" class="heading-link"><i class="fas fa-link"></i></a><a href="#信号" class="headerlink" title="信号"></a>信号</h3>
      </div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/2/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/4/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/随机图库/1641882498931.3kditdl6ds40.webp" alt="avatar"></div><p class="sidebar-ov-author__text">什么都不会的废物</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/fuyusakaiori" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://weibo.com/Sakiless/home?topnav=1&amp;wvr=6" target="_blank" rel="noopener" data-popover="微博" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weibo"></i></span></a><a class="sidebar-ov-social-item" href="670232228" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">108</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">33</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-nd.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020~2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>小忍的甜甜圈</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1.0.1/dist/canvas-nest.min.js" color="0,0,0" opacity="0.6" count="99" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>