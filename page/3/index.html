<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="啥也不会的大三狗">
<meta property="og:type" content="website">
<meta property="og:title" content="天鹅绒房间">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="天鹅绒房间">
<meta property="og:description" content="啥也不会的大三狗">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Fuyusakaiori">
<meta name="twitter:card" content="summary"><title>天鹅绒房间</title><link ref="canonical" href="http://example.com/page/3/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">天鹅绒房间</div><div class="header-banner-info__subtitle">Velvet Room</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/28/juc/juc-concurrent/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-synchronized-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">线程同步-synchronized-底层原理</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-29</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="Synchronized-底层原理"   >
          <a href="#Synchronized-底层原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#Synchronized-底层原理" class="headerlink" title="Synchronized-底层原理"></a>Synchronized-底层原理</h1>
      <p>:::primary</p>
<p>① Synchronized 等价于操作系统中的管程，所以首先理解操作系统中的管程是非常重要的</p>
<p>② Java 中提供的所有锁机制几乎都是基于管程的概念实现的</p>
<p>③ 想要知道 Synchronized 是如何实现管程的，需要了解以下的知识</p>
<p>参考笔记：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://47.101.45.234/jvm/runtime/heapspace/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/" >堆空间 - 对象创建</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><a href="">进程同步-信号量</a></p>
<p>:::</p>

        <h2 id="什么是管程？"   >
          <a href="#什么是管程？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是管程？" class="headerlink" title="什么是管程？"></a>什么是管程？</h2>
      <p>:::primary</p>
<p>先来了解下管程的基本机制和基本概念，不涉及具体的过程细节，具体细节放在之后再讲述</p>
<p>参考书籍：《现代操作系统》</p>
<p>参考博客：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38998213/article/details/87899231" >管程的理解</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<ul>
<li><p>名称：Monitor</p>
<ul>
<li>被翻译成管程或者监视器（<del>Java 中还有个概念叫监听器，不过这玩意不重要</del>）</li>
</ul>
</li>
<li><p>定义：[管理共享变量和共享变量的函数实现的一种用于实现同步的高级 <strong>抽象数据结构</strong> ]{.red}</p>
<ul>
<li>[管程中主要包含线程需要使用的共享变量，以及操作共享变量的函数]{.pink}</li>
<li>[抽象数据结构就意味着它不是具体的实现，所以不同语言可以实现自己的管程，是编译器层面的同步方式]{.pink}</li>
</ul>
</li>
<li><p>组成：[共享变量 + 函数 + 信号量 + 条件变量]{.red}</p>
<ul>
<li>[管程作为高级抽象数据结构，其底层通常采用信号量实现同步]{.pink}</li>
<li>[编译器通常确保操作系统能够识别到管程，进而使用信号量进行同步]{.pink}</li>
</ul>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这样的抽象数据结构就称为管程*/</span></span><br><span class="line">monitor monitor_name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*共享变量*/</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">/*信号量: 实现互斥使用的(由编译器负责,程序员不用管)*/</span></span><br><span class="line">    Semaphor semaphor;</span><br><span class="line">    <span class="comment">/*条件变量: 实现线程阻塞和唤醒使用的*/</span></span><br><span class="line">    Condition condition;</span><br><span class="line">    <span class="comment">/*共享变量的函数实现*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="comment">/*初始化代码*/</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>机制：</p>
<ul>
<li>互斥：[管程机制本质采用<strong>信号量等同步机制</strong>确保线程在管程中的互斥，即管程中仅存在唯一活跃的线程]{.red}<ul>
<li>[信号量是由编译器在生成编译文件的时候自动添加而不是由程序员添加，也就是管程是由编译器实现的]{.pink}</li>
<li>[所以管程可以认为是 <strong>软件层面</strong> 实现的同步方式，而此前的信号量通常都是 <strong>硬件层面</strong> 实现的]{.pink}</li>
</ul>
</li>
<li>条件变量：[管程机制允许活跃线程条件不足主动放弃管程的使用权，等待条件满足后重新获取管程的使用权]{.red}<ul>
<li>为何引入条件变量？<ul>
<li>条件不足可能是因为线程需要的某种资源没有获取到，诸如 IO 读取的数据、缓冲区数据不足等等</li>
<li>线程无法得到资源就无法向下执行，就会无限期持有锁，导致其余线程永远获取不到锁</li>
</ul>
</li>
<li>如何使用条件变量？<ul>
<li>核心：线程放弃使用管程时就会自行调用 wait、其余线程唤醒这些等待线程时就会使用 signal</li>
<li>wait 方法会从条件变量中减少一个信号，同时将线程添加到等待队列中</li>
<li>signal 方法会向条件变量发送一个信号，唤醒等待队列中的线程</li>
</ul>
</li>
<li>本质：[条件变量类似于二元信号量 + 指针]{.red}<ul>
<li>[每个条件变量仅能够存储一个信号]{.pink}<ul>
<li>多次调用 signal 方法而不调用 wait 方法会导致信号无法存储而丢失，导致唤醒失去意义</li>
<li>也就是说 wait 方法必须在 signal 方法前使用，毕竟没有等待的线程再怎么唤醒也是没有意义的</li>
</ul>
</li>
<li>[每个条件变量还指向一个等待队列，用于记录当前正在等待的线程]{.pink}</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>[Pascal、C 语言都是不支持管程这种高级同步原语的，Java、C++ 是支持的]{.red}<ul>
<li>Java 管程不同于 OS 定义的经典管程<ul>
<li>[OS 管程默认可以定义包含多个不同的条件变量（定义）]{.pink}</li>
<li>[Java 管程默认仅包含一个条件变量，Java ReentrantLock 管程可以创建多个条件变量（实现）]{.pink}</li>
</ul>
</li>
</ul>
</li>
<li>[进程或者线程不可以直接访问管程中包含的共享变量，只能够借助管程中的函数访问]{.red}</li>
</ul>
</li>
</ul>

        <h2 id="为什么要使用管程？"   >
          <a href="#为什么要使用管程？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么要使用管程？" class="headerlink" title="为什么要使用管程？"></a>为什么要使用管程？</h2>
      <p>:::primary</p>
<p>参考书籍：《操作系统概念》</p>
<p>:::</p>
<ul>
<li><p>核心：[采用信号量实现同步可能存在许多难以避免的问题]{.red}</p>
</li>
<li><p>示例：（采用 C 语言描述）</p>
<ul>
<li><p>[同时执行两次减少信号量的操作显然会导致死锁的发生，这完全可能由程序员自己造成]{.aqua}</p>
  <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">wait(mutex);</span><br><span class="line">	<span class="comment">// 临界区</span></span><br><span class="line">wait(mutex);</span><br></pre></td></tr></table></div></figure></li>
<li><p>[先执行增加信号量的操作，后执行减少信号量的操作，会导致临界区中多于一个活跃线程]{.aqua}</p>
  <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">signal(mutex);</span><br><span class="line">	<span class="comment">// 临界区</span></span><br><span class="line">wait(mutex);</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>
<ul>
<li>总结：<ul>
<li>程序员需要自己确定 wait、signal 操作放置在何处，容易不小心放错位置</li>
<li>管程通常借由编译器保证这些 PV 操作到底添加在何处，比程序员自己添加要安全得多</li>
<li>[<del>Java 采用管程的另一个原因是因为管程比较方便实现（为啥？）</del>]{.grey}</li>
</ul>
</li>
</ul>
<p>​    </p>

        <h2 id="管程如何实现？"   >
          <a href="#管程如何实现？" class="heading-link"><i class="fas fa-link"></i></a><a href="#管程如何实现？" class="headerlink" title="管程如何实现？"></a>管程如何实现？</h2>
      <p>:::info</p>
<p>① 上述内容先简单讲述了 OS 中定义的管程概念，因为管程是一种抽象的概念，所以没有在刚才的内容讲述更加具体的内容</p>
<p>② 接下来就会讲述 Java 如何实现管程这一概念，但是需要优先了解对象是如何组成的</p>
<p>参考笔记：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://47.101.45.234/jvm/runtime/heapspace/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/" >对象是如何组成的？</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<ul>
<li><p>前提：</p>
<ul>
<li>对象头的组成<ul>
<li>Mark Word：包含哈希码、年龄计数器、锁记录等相关信息</li>
<li>类型指针（指向 Klass 对象）</li>
<li>数组长度（只有数组才有的部分）</li>
</ul>
</li>
<li>[阻塞队列：等待当前线程释放锁的线程会进入阻塞队列]{.red}</li>
<li>[等待队列：调用 wait 方法后等待被唤醒的线程进入等待队列]{.red}</li>
</ul>
</li>
<li><p>图解 synchronized 原理</p>
<ul>
<li><p>整体过程</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/管程.3kwq144bgzc0.png" alt="管程" style="zoom:80%;" /></li>
<li><p>线程获取锁：</p>
<ol>
<li>线程判断管程当前是否存在使用者</li>
</ol>
<ul>
<li><p>如果管程当前不存在使用者，那么还要考虑阻塞队列中是否存在等待线程</p>
<ul>
<li><p>[如果不存在等待线程，那么当前线程就可以直接获取管程的使用权]{.pink}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/获取管程的使用权（1）.19slk7btdups.png" alt="获取管程的使用权（1）" style="zoom:80%;" /></li>
<li><p>[如果存在等待线程，线程就需要和阻塞队列中的线程竞争获取对象锁]{.pink}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/获取管程的使用权（2）.1d7ofw1x2cyo.png" alt="获取管程的使用权（2）" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>[如果管程当前存在使用者，那么线程就需要进入阻塞队列等待]{.pink}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/获取管程的使用权（3）.7ffj485ern40.png" alt="获取管程的使用权（3）" style="zoom:80%;" /></li>
</ul>
<ol start="2">
<li><p>[<strong>对象头</strong> 的 Mark Word 的锁记录会从未上锁改为重量级锁状态，同时重量级锁指针指向当前的管程]{.pink}</p>
</li>
<li><p>[<strong>管程</strong> 在线程获取到使用权之后将内部的 Owner 属性设置为当前线程]{.pink}</p>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 虚拟机内部的管程源码</span></span><br><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">//记录个数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL; <span class="comment">// 持有锁的当前线程	</span></span><br><span class="line">    _WaitSet      = NULL; <span class="comment">// 调用 wait 方法后等待被唤醒的线程进入等待队列</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ; <span class="comment">// 等待当前线程释放锁的线程会进入阻塞队列</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

 <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/更新-Mark-Word.5902q4pwfec0.png" alt="更新-Mark-Word" style="zoom:80%;" /></li>
</ol>
</li>
<li><p>线程退出管程（锁）的过程</p>
<ol>
<li>[对象头的 Mark Word 又从重量级锁的状态变为未上锁状态，重量级指针指向空（null）]{.pink}</li>
<li>[管程会将内部的 Owner 属性重新置为空（null），即现在没有线程使用管程]{.pink}</li>
</ol>
</li>
<li><p>线程进入和退出等待队列</p>
<ul>
<li>[线程自行调用 wait 方法放弃管程的使用权，从而进入等待队列中等待被唤醒]{.pink}</li>
<li>[其余线程才可以调用 notify / notifyAll 方法唤醒等待队列中的线程，让等待的线程退出等待队列]{.pink}</li>
</ul>
</li>
</ul>
</li>
<li><p>字节码解释 synchronized 原理</p>
<ul>
<li><p>synchronized 锁对象</p>
<ul>
<li>[编译器会在进入临界区和退出临界区之前添加两条字节码指令：monitorenter、monitorexit]{.aqua}<ul>
<li>这两条指令就实现了管程中始终只存在唯一的活跃线程，实现了线程的互斥</li>
</ul>
</li>
<li>[monitorenter 指令会尝试获取对象锁，如果获取成功就会进入临界区，获取失败就会进入等待队列]{.aqua}</li>
<li>[monitorexit 指令会确保对象锁能够正常被释放，确保其他线程能够获取对象锁]{.aqua}</li>
<li>[额外的 monitorexit：确保临界区中发生异常后依然能够正确释放对象锁]{.pink}</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">   descriptor: ([Ljava/lang/String;)V</span><br><span class="line">   flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field LOCK:Ljava/lang/Object;</span></span><br><span class="line">        <span class="number">3</span>: dup</span><br><span class="line">        <span class="number">4</span>: astore_1</span><br><span class="line">        <span class="number">5</span>: monitorenter	 <span class="comment">// 编译器在字节码文件中插入 monitor 原语确保实现同步						</span></span><br><span class="line">        <span class="number">6</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// 临界区：操作共享变量</span></span><br><span class="line">        <span class="number">9</span>: iconst_1</span><br><span class="line">       <span class="number">10</span>: iadd</span><br><span class="line">       <span class="number">11</span>: putstatic     #<span class="number">3</span>                  </span><br><span class="line">       <span class="number">14</span>: aload_1                           <span class="comment">// 临界区</span></span><br><span class="line">       <span class="number">15</span>: monitorexit     <span class="comment">// 编译器在字节码问题进中插入 monitor 原语确保退出同步块</span></span><br><span class="line">       <span class="number">16</span>: goto          <span class="number">24</span></span><br><span class="line">       <span class="number">19</span>: astore_2</span><br><span class="line">       <span class="number">20</span>: aload_1</span><br><span class="line">       <span class="number">21</span>: monitorexit     <span class="comment">// 编译器确保代码抛出异常时依然能够释放锁的使用权, 从而确保不会死锁</span></span><br><span class="line">       <span class="number">22</span>: aload_2</span><br><span class="line">       <span class="number">23</span>: athrow</span><br><span class="line">       <span class="number">24</span>: <span class="keyword">return</span></span><br><span class="line">		</span><br></pre></td></tr></table></div></figure></li>
<li><p>synchronized 锁方法</p>
<ul>
<li>[方法锁不再添加字节码来确保线程间的互斥而是通过设置访问权限让虚拟机意识到需要进行同步]{.aqua}</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>;</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   <span class="comment">// 锁方法就不会再字节码文件中添加字节码指令来确保同步而是设置访问权限</span></span><br><span class="line">   <span class="comment">// 设置 ACC_SYNCHRONIZED 同步的权限</span></span><br><span class="line">   flags: (<span class="number">0x0029</span>) ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field count:I</span></span><br><span class="line">        <span class="number">3</span>: iconst_1</span><br><span class="line">        <span class="number">4</span>: iadd</span><br><span class="line">        <span class="number">5</span>: putstatic     #<span class="number">2</span>                  <span class="comment">// Field count:I</span></span><br><span class="line">        <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">       line <span class="number">13</span>: <span class="number">8</span></span><br><span class="line">		</span><br></pre></td></tr></table></div></figure>

</li>
</ul>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/28/juc/juc-concurrent/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-synchronized-%E5%9F%BA%E7%A1%80/">线程同步-synchronized-基础</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-11-12</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="Synchronized-基础"   >
          <a href="#Synchronized-基础" class="heading-link"><i class="fas fa-link"></i></a><a href="#Synchronized-基础" class="headerlink" title="Synchronized-基础"></a>Synchronized-基础</h1>
      
        <h2 id="基本概念"   >
          <a href="#基本概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2>
      <p>:::primary</p>
<p>基本概念是对 synchronized 的所有内容的总结，如果发现存在难以理解的地方可以先查看后面的笔记</p>
<p>:::</p>
<p>[基本内容]{.label .info}</p>
<ul>
<li><p>synchronized 定义：[采用的 <strong>悲观锁</strong> 的思想，是一种独占锁或者说排他锁]{.red}</p>
</li>
<li><p>synchronized 作用：[给共享变量添加排他锁从而确保 <strong>每次仅有一个线程</strong> 可以访问该共享变量，确保线程安全]{.red}</p>
</li>
<li><p>synchronized 过程分析：</p>
<ul>
<li><p>[存在线程成功获取共享变量的锁之后，其余线程就会 <strong>发生上下文切换进入阻塞队列等待</strong>]{.red}</p>
<ul>
<li>[持有锁的线程被 <strong>分配的时间片可能不足</strong> 以支撑执行完临界区中所有代码]{.pink}</li>
<li>[此时线程会发生上下文切换 <strong>但是依然持有锁</strong>，其余线程依然处于阻塞队列中无法获取锁]{.pink}</li>
<li>[持有锁的线程需要等待处理器再次分配给自己时间片，从而执行完临界区中所有代码，才能够释放锁]{.pink}</li>
</ul>
</li>
<li><p>[持有锁的线程释放锁之后，阻塞队列中的线程 <strong>再次发生上下文切换开始竞争锁的所有权</strong>]{.red}</p>
</li>
<li><p>竞争成功的线程可以获取到共享变量的锁，其余线程再次进入阻塞队列等待</p>
</li>
</ul>
</li>
<li><p>wait 作用：[持有锁的线程执行所需的条件没有得到的满足时，主动释放锁进入等待队列等待，让其余线程执行]{.red}</p>
</li>
<li><p>notify / notifyAll 作用：[等待队列中的线程执行所需的条件得到满足，从而被唤醒去竞争锁的使用权]{.red}</p>
</li>
</ul>
<p>[底层原理]{.label .danger}</p>
<ul>
<li>实现原理：<ul>
<li>[synchronized + wait + notify 机制就是基于操作系统提出的 <strong>管程</strong> 这个概念实现的]{.red}</li>
<li>[synchronized + wait + notify 都是抽象数据结构管程的组成部分]{.red}</li>
</ul>
</li>
<li>编译器实现：<ul>
<li>[编译器在编译生成字节码的时候会将 synchronized 转换成 monitorenter、monitorexit 两条字节码指令]{.red}</li>
<li>[这两条字节码指令确保共享变量是线程独占的，并且在修改之后对其他线程是可见的]{.red}</li>
<li>[这两条字节码指令的底层实现是由 HotSpot 虚拟机中的 ObjectMonitor 对象实现的]{.red}<ul>
<li>[这个对象负责管理锁、锁的拥有者、等待队列、阻塞队列等信息]{.pink}</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>:::info</p>
<p>这里只是简单讲述 synchronized 关键字的底层实现，详细内容查看<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://47.101.45.234/juc/juc-concurrent/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-synchronized-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" >Synchronized 底层原理</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>:::</p>
<p>[性能分析]{.label .success}</p>
<ul>
<li><p>核心：[synchronized 锁]{.red}</p>
</li>
<li><p>[<strong>每次没能成功获取锁的线程需要执行上下文切换进入阻塞队列，而上下文切换会陷入内核态造成很大的开销</strong>]{.red}</p>
</li>
<li><p>[没有竞争的情况下线程依然需要获取锁，也就是会修改监视器对象的信息，这种开销显然是没有必要的]{.red}</p>
<ul>
<li>[没有竞争的情况下产生的获取监视器对象的开销已经在 JDK 6 之后被相应的优化措施解决了]{.pink}</li>
</ul>
</li>
</ul>
<p>[优化措施]{.label .primary}</p>
<ul>
<li>前提：所有的优化措施都是基于没有线程竞争的情况，从而减少没有竞争的情况下同步的开销</li>
<li>[轻量级锁 + 偏向锁（批量重偏向、批量撤销）]{.pink}</li>
<li>[自旋锁 + 锁消除 + 锁粗化]{.pink}</li>
</ul>
<p>[其余细节]{.label .warning}</p>
<ul>
<li><p>[synchronized 锁完美解决了所有并发问题：原子性问题、可见性问题、有序性问题]{.red}</p>
<ul>
<li>不过 synchronized 只是采用内存屏障禁止同步代码块外的代码和同步代码块内的代码进行指令重排</li>
<li>而同步代码内部的代码依然是可以随意进行指令重排的，因为在单线程下指令重排的结果依然是正确的</li>
</ul>
</li>
<li><p>[synchronized 锁是非公平锁，并且不可以被中断，不可以设置超时等待]{.red}</p>
</li>
<li><p>[synchronized 锁可以对共享变量添加，也可以对方法添加]{.red}</p>
<ul>
<li>[synchronized 锁给实例方法添加的本质是给对象实例 this 添加锁]{.pink}</li>
<li>[synchronized 锁给静态方法添加的本质是给 Class 对象添加锁]{.pink}</li>
</ul>
</li>
<li><p>[synchronized 只能给引用类型的变量上锁，基本数据类型是不可以上锁的，并且锁住的引用类型不能为空]{.red}</p>
</li>
<li><p>[不同线程中 synchronized 锁住对象必须相同，才能够确保共享变量是线程独占的]{.red}</p>
</li>
</ul>

        <h2 id="基本使用"   >
          <a href="#基本使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2>
      
        <h3 id="synchronized"   >
          <a href="#synchronized" class="heading-link"><i class="fas fa-link"></i></a><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3>
      <ul>
<li><p>synchronized</p>
<ol>
<li><p>使用方式：给共享变量添加排他锁：<code>synchronized(object)</code></p>
<ul>
<li><p>演示代码</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object object;</span><br><span class="line"><span class="comment">// 给共享变量上锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 其余代码</span></span><br><span class="line">    <span class="keyword">synchronized</span>(object)&#123;</span><br><span class="line">        <span class="comment">// 临界区: 对共享变量进行操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其余代码</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></div></figure></li>
<li><p>细节：</p>
<ul>
<li><p>[给共享变量上锁可以避免给不需要同步的代码块上锁，从而提高加锁的效率]{.pink}</p>
</li>
<li><p>[只有引用类型的共享变量可以上锁，基本数据类型可以借助引用类型变量保护自身]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于上锁的变量</span></span><br><span class="line"><span class="keyword">private</span> Object lock;</span><br><span class="line"><span class="comment">// 共享变量: 不可以直接上锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 其余代码</span></span><br><span class="line">    <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">        <span class="comment">// 保护基本数据类型的变量</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其余代码</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>使用方式：给方法添加排他锁</p>
<ul>
<li><p>演示代码（两种添加方式）</p>
<ul>
<li><p>[给虚方法（实例方法）上锁的实质是对类对象上锁]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronized</span></span>&#123;</span><br><span class="line">    <span class="comment">// 给实例方法上锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等价于锁住类相应的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>[给静态方法上锁的实质是对类的 Class 对象上锁]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronized</span></span>&#123;</span><br><span class="line">    <span class="comment">// 给静态方法上锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等价于锁住类对应的 Class对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(ThreadSynchronized.class)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>细节：[给整个方法上锁会导致锁住不需要同步的代码块从而降低线程的效率]{.pink}</p>
</li>
</ul>
</li>
<li><p>解决线程安全问题：原子性问题</p>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程同步方案: synchronized 关键字</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronized</span></span>&#123;</span><br><span class="line">    <span class="comment">// 共享变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本数据类型无法上锁, 所以可以给方法上锁或者直接给 this 上锁</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        ThreadSynchronized obj = <span class="keyword">new</span> ThreadSynchronized();</span><br><span class="line">		<span class="comment">// 执行递增操作的线程</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">                obj.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">		<span class="comment">// 执行递减操作的线程</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">                obj.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">		<span class="comment">// 启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 无论这个测试代码执行多少次, 最后得到结果一定是固定且正确的</span></span><br><span class="line">        log.debug(<span class="string">&quot;count = &#123;&#125;&quot;</span>, obj.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ol>
</li>
</ul>

        <h3 id="wait"   >
          <a href="#wait" class="heading-link"><i class="fas fa-link"></i></a><a href="#wait" class="headerlink" title="wait"></a>wait</h3>
      <ul>
<li><p>作用：[调用该方法的线程会 <strong>主动放弃共享变量</strong> 的锁，进入等待队列等待被唤醒]{.red}</p>
</li>
<li><p>应用场景：线程发现自己正在执行的任务缺少相应的资源，无法继续正常执行下去，所以会先挂起自己等待条件满足</p>
</li>
<li><p>特点：</p>
<ul>
<li>[线程会从 RUNNABLE 状态变为 WAIT 或者 TIMED_WAITING 状态]{.red}</li>
<li>[线程调用 wait 方法之后会主动释放锁，以便其他线程能够获取]{.red}</li>
<li>[wait 方法被调用之前必须先对共享变量上锁，否则会抛出 IllegalMonitorStateException]{.pink}</li>
<li>[Object 类中提供了该方法，所以引用类型的共享变量都具有 wait 方法]{.blue}</li>
<li>[notify \ notify、interrupt 方法可以打断线程的等待过程，并且抛出 InterruptedException 异常]{.pink}</li>
</ul>
</li>
<li><p>使用方式：</p>
<ol>
<li><p><code>wait()</code>：[线程会无限期等待其余线程唤醒自己]{.aqua}</p>
</li>
<li><p><code>wait(long timeout)</code> ：[线程会在有限的时间内等待其余线程唤醒自己，超过时间之后就不会继续等待]{.aqua}</p>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object object;</span><br><span class="line"><span class="comment">// 给共享变量上锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      	<span class="comment">// 其余代码</span></span><br><span class="line">    	<span class="keyword">synchronized</span>(object)&#123;</span><br><span class="line">        	<span class="comment">// 线程发现正在执行的任务缺少相应资源, 挂起自己</span></span><br><span class="line">        	<span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 线程会持续等待直到有人唤醒自己</span></span><br><span class="line">         		object.wait()   </span><br><span class="line">        	&#125;<span class="keyword">catch</span> (Exception e)&#123;&#125;</span><br><span class="line">    	&#125;  </span><br><span class="line">   	&#125;).start();</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></div></figure></li>
</ol>
</li>
</ul>

        <h3 id="notify-notifyAll"   >
          <a href="#notify-notifyAll" class="heading-link"><i class="fas fa-link"></i></a><a href="#notify-notifyAll" class="headerlink" title="notify / notifyAll"></a>notify / notifyAll</h3>
      <ul>
<li><p>作用：[正在运行的线程唤醒等待队列中等待的线程]{.red}</p>
</li>
<li><p>应用场景：正在运行的线程提供了等待队列中的线程需要的资源，所以将这些等待线程唤醒</p>
</li>
<li><p>特点：</p>
<ul>
<li>[线程调用 notify / notifyAll 方法 <strong>不会主动释放锁</strong>]{.red}<ul>
<li>[这也就意味着线程只能够在即将释放锁的时候调用 notify / notifyAll 方法]{.pink}</li>
<li>[否则在没有释放锁的情况下唤醒等待线程，被唤醒的线程也只能陷入阻塞]{.pink}</li>
</ul>
</li>
<li>[没有任何方法可以指定唤醒某个线程]{.red}<ul>
<li>Java 采用的是内核级线程 + 抢占式调度的算法，所有线程的调度都由 OS 管理</li>
<li>C# 等采用协程的语言才是可以控制线程的</li>
</ul>
</li>
<li>[被唤醒的线程是从此前释放锁的位置开始执行而不是从头开始]{.pink}</li>
<li>[Object 类中提供了该方法，所以引用类型的共享变量都具有 notify / notifyAll 方法]{.blue}</li>
</ul>
</li>
<li><p>使用方式：</p>
<ol>
<li><p><code>notify</code>：[线程调用 notify 方法将会 <strong>随机唤醒</strong> 一个线程]{.aqua}</p>
</li>
<li><p><code>notifyAll</code>：[线程调用 notifyAll 将会 <strong>唤醒所有</strong> 等待线程]{.aqua}</p>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object object;</span><br><span class="line"><span class="comment">// 给共享变量上锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      	<span class="comment">// 其余代码</span></span><br><span class="line">    	<span class="keyword">synchronized</span>(object)&#123;</span><br><span class="line">        	<span class="comment">// 线程发现正在执行的任务缺少相应资源, 挂起自己</span></span><br><span class="line">        	<span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 线程会持续等待直到有人唤醒自己</span></span><br><span class="line">         		object.wait()   </span><br><span class="line">        	&#125;<span class="keyword">catch</span> (Exception e)&#123;&#125;</span><br><span class="line">    	&#125;  </span><br><span class="line">   	&#125;).start();</span><br><span class="line">    </span><br><span class="line">    Time.Unit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 主线程获取锁之后唤醒等待队列中的线程</span></span><br><span class="line">    <span class="keyword">synchronized</span> (LOCK)&#123;</span><br><span class="line">        <span class="comment">// 唤醒所有线程</span></span><br><span class="line">        LOCK.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></div></figure></li>
</ol>
</li>
</ul>

        <h3 id="虚假唤醒"   >
          <a href="#虚假唤醒" class="heading-link"><i class="fas fa-link"></i></a><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h3>
      <ul>
<li><p>问题描述：[线程没有其他任何线程 <strong>唤醒或者被中断或者超时</strong>，该线程从 WAIT 状态变为 RUNNABLE 状态]{.blue}</p>
<ul>
<li>这里的唤醒应该指的是其余线程想要唤醒的不是这个线程，所以说该线程没有被唤醒</li>
</ul>
</li>
<li><p>问题演示：</p>
<ol>
<li>Thread-1、Thread-2 需要 flag、status 变量为 true 时才可正常执行任务</li>
<li>两个线程在获取到对象锁之后分别检查变量是否满足，不满足的情况下就会进入等待队列中等待</li>
<li>主线程在子线程释放锁之后获取对象锁，并且在即将离开之前唤醒所有线程</li>
</ol>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚假唤醒问题</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.fake&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadFakeNotify</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// 第一个线程正常执行需要满足的条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 第二个线程正常执行需要满足的条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> status= <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">// 为了节省篇幅将去除异常的代码块</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK)&#123;</span><br><span class="line">                <span class="comment">// 先检查运行所需的条件是否满足</span></span><br><span class="line">                <span class="keyword">if</span> (!flag)&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;线程未能够获得执行所需的条件, 进入等待队列...&quot;</span>);</span><br><span class="line">                    LOCK.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 唤醒之后检查是否满足条件</span></span><br><span class="line">                <span class="keyword">if</span> (flag)</span><br><span class="line">                    log.debug(<span class="string">&quot;执行任务...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK)&#123;</span><br><span class="line">                <span class="comment">// 先检查运行所需的条件是否满足</span></span><br><span class="line">                <span class="keyword">if</span> (!status)&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;线程未能够获得执行所需的条件, 进入等待队列...&quot;</span>);</span><br><span class="line">                    LOCK.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (status)</span><br><span class="line">                    log.debug(<span class="string">&quot;执行任务...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK)&#123;</span><br><span class="line">                <span class="comment">// 由于资源限制仅满足一个条件</span></span><br><span class="line">                status = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒所有线程</span></span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>核心原因：[每个锁对象仅存在唯一的条件变量，也就是只有一个等待队列]{.red}</p>
<ol>
<li>[所有持有该锁对象的线程在调用 wait 方法之后都会进入相同的等待队列]{.pink}</li>
<li>[其余线程调用 notifyAll 方法会唤醒所有线程，无论线程需要的条件是否满足]{.pink}</li>
<li>[被唤醒的线程不会检查条件变量是否满足，而是直接从此前等待的位置继续执行]{.pink}</li>
<li>[从而导致线程在条件没有满足的情况下，什么都无法完成就结束了]{.pink}</li>
</ol>
</li>
<li><p>正确使用方式：[采用循环判断的方式而不是条件判断]{.aqua}</p>
<ul>
<li>每次线程被唤醒都会检查自己的条件是否满足<ul>
<li>如果条件不满足就会继续调用 wait 方法进行等待</li>
<li>如果条件满足就执行正常任务</li>
</ul>
</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (LOCK)&#123;</span><br><span class="line">        <span class="comment">// 先检查运行所需的条件是否满足</span></span><br><span class="line">        <span class="keyword">while</span> (!flag)&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;线程未能够获得执行所需的条件, 进入等待队列...&quot;</span>);</span><br><span class="line">            LOCK.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 唤醒之后检查是否满足条件</span></span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            log.debug(<span class="string">&quot;执行任务...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></div></figure></li>
</ul>
<p>:::primary</p>
<p>① 在 if 块中使用 wait 方法是非常危险的，因为一旦线程被唤醒并得到锁，就不会再判断if条件而是执行if语句块外的代码</p>
<p>② 在 while 块中则是会在唤醒之后继续判断条件是否成立，这样就避免被虚假唤醒的危险</p>
<p>:::</p>

        <h2 id="八锁问题"   >
          <a href="#八锁问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#八锁问题" class="headerlink" title="八锁问题"></a>八锁问题</h2>
      <p>:::info</p>
<p>如果你认为自己对 Synchronized 关键的使用掌握的很好的话，其实这八个问题都很简单，没有必要看</p>
<p>:::</p>
<ul>
<li><p>前言：[线程八锁问题其实非常简单，考察的是你是否能够清楚分辨锁住的到底是那个对象和线程执行的先后顺序]{.aqua}</p>
</li>
<li><p>问题</p>
<p>  +++warning 观察下列情况，分析两个线程锁住的对象是否相同，线程之间是否会因为锁而互斥</p>
<p>  两个线程锁住都是 this 引用，而 this 指向的是相同的对象，既然锁住的对象相同那么必然就会产生互斥</p>
<p>  +++</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronizedTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法一...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法二...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ThreadSynchronizedTest test = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method1, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method2, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  +++warning 在第一题的基础上让其中一个线程睡眠固定时间，试分析会出现的情况</p>
<p>  ① sleep 方法不会释放线程持有的锁</p>
<p>  ② 其中一个线程需要等待另一个线程固定时间+运行时间才可以获取锁]</p>
<p>  +++</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronizedTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 省略捕获异常的代码...</span></span><br><span class="line">        TimeUnit.sleep(<span class="number">1</span>)</span><br><span class="line">        log.debug(<span class="string">&quot;方法一...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法二...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ThreadSynchronizedTest test = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method1, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method2, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  +++warning 观察下列情况，试分析线程的执行的先后顺序</p>
<p>  ① 线程-1和线程-2之间的执行顺序取决于谁先抢到锁，先抢到的先执行</p>
<p>  ② 线程-3执行的方法没有上锁，执行的时机依靠虚拟机的调度</p>
<p>  ③ 线程1和线程-3：线程-3会先于线程-1执行结束，无论线程-1是否抢到锁，因为线程-1需要睡眠1秒，而线程的调度时间是纳 秒级别的，线程-1执行结束前线程-3早就被调度执行</p>
<p>  ④ 线程-2和线程-3：如果线程-2没有先抢到锁，那么就会晚于线程-3执行，因为线程-1需要睡眠1秒；如果线程-2先抢到锁，那么线程-2和线程-3的执行顺序就是随机的</p>
<p>  ⑤ 结果：3 1 2，3 2 1，2 3 1</p>
<p>  +++</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程八锁问题: 明确到底锁住的是哪个对象</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronizedTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 省略捕获异常的代码...</span></span><br><span class="line">        TimeUnit.sleep(<span class="number">1</span>)</span><br><span class="line">        log.debug(<span class="string">&quot;方法一...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法二...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 没有上锁的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ThreadSynchronizedTest test = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method1, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method2, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method3, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  +++warning 观察下面的代码，试分析两个线程锁住的是否为同一个对象，是否产生互斥</p>
<p>  ① 两者锁住的不是相同的对象，虽然 synchronized 锁住的都是 this 引用，但是两个 this 指向的却是不同的对象</p>
<p>  ② 锁住既然不是相同的对象，那么也就不会产生互斥，两个线程可以并发或者并行输出</p>
<p>  +++</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronizedTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法一...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法二...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       	<span class="comment">// 两个不同的对象</span></span><br><span class="line">        ThreadSynchronizedTest test1 = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        ThreadSynchronizedTest test2 = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(test1::method1, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(test2::method2, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  +++warning 观察下面的代码，试分析两个线程锁住的是否为同一个对象，是否产生互斥</p>
<p>  前者锁住的是静态方法，锁住的是类对应的 Class 对象；后者锁住的是实例方法，锁住的是类对应的实例对象</p>
<p>  +++</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronizedTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法一...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法二...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       	<span class="comment">// 两个不同的对象</span></span><br><span class="line">        ThreadSynchronizedTest test = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        <span class="comment">// 对象调用静态方法是可以的, 只不过不推荐</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;test.method1();&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method2, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  +++warning 观察下面的代码，试分析两个线程锁住的是否为同一个对象，是否产生互斥</p>
<p>  两者锁住都是类对应的 Class 对象</p>
<p>  +++</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronizedTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法一...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法二...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 两个不同的对象</span></span><br><span class="line">        ThreadSynchronizedTest test = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        <span class="comment">// 对象调用静态方法是可以的, 只不过不推荐</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;test.method1();&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;test.method2();&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  +++warning 观察下面的代码，试分析两个线程锁住的是否为同一个对象，是否产生互斥</p>
<p>  前者锁住的依然是 Class 对象，后者锁住的依然是实例对象，只不过实例是 test2 而不是 test 1</p>
<p>  +++</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronizedTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法一...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法二...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 两个不同的对象</span></span><br><span class="line">        ThreadSynchronizedTest test1 = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        ThreadSynchronizedTest test2 = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        <span class="comment">// 对象调用静态方法是可以的, 只不过不推荐</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;test1.method1();&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;test2.method2();&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  +++warning 观察下面的代码，试分析两个线程锁住的是否为同一个对象，是否产生互斥</p>
<p>  虚拟机会为每个类都维护唯一的 Class 对象，两者锁住的都是相同的 Class 对象，尽管实例对象是不同</p>
<p>  +++</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.syn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronizedTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法一...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方法二...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 两个不同的对象</span></span><br><span class="line">        ThreadSynchronizedTest test1 = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        ThreadSynchronizedTest test2 = <span class="keyword">new</span> ThreadSynchronizedTest();</span><br><span class="line">        <span class="comment">// 对象调用静态方法是可以的, 只不过不推荐</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;test1.method1();&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;test2.method2();&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>总结：帮助初学者熟悉 synchronized 机制使用的题目，个人觉得意义不是很大</p>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/28/juc/juc-concurrent/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-volatile/">线程同步-volatile</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-28</span></span></div></header><div class="post-body"><div class="post-excerpt"></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/28/juc/juc-concurrent/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-%E9%94%81%E7%B1%BB%E5%9E%8B/">线程同步-锁类型</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-28</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="锁类型"   >
          <a href="#锁类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h1>
      <p>:::primary</p>
<p>这里只会简单讲述每种锁的概念是什么，具体到锁的每种实现则会放到后面的部分再讲</p>
<p>:::</p>

        <h2 id="悲观锁和乐观锁"   >
          <a href="#悲观锁和乐观锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h2>
      <ul>
<li><p>前言：悲观锁和乐观锁都是数据库并发控制中引入的概念，但并不仅限于数据库系统中使用</p>
</li>
<li><p>悲观锁</p>
<ul>
<li>定义：<ol>
<li>[每次对共享变量的修改过程持悲观态度，认为其他线程访问会 <strong>频繁写入</strong> 共享变量]{.pink}</li>
<li>[所以每次线程访问共享变量之前都会对其上锁，<strong>阻止其他线程访问</strong> 共享变量]{.pink}</li>
</ol>
</li>
<li>核心：[共享变量每次都只能被一个线程访问，其余线程必须阻塞等待直到当前线程释放锁]{.red}</li>
<li>实现：[synchronized、ReentrantLock、ReentrantReadWriteLock（Java）]{.aqua}<ul>
<li>synchronized 底层是采用管程实现的，本质上就符合乐观锁的思想</li>
<li>ReentrantLock 底层采用 CAS 机制实现，本质上是乐观锁，但是其思想符合的是悲观锁的思想</li>
</ul>
</li>
<li>优点：[多数线程都对共享变量执行写操作时，能够通过阻塞线程避免线程无意义的空转，造成资源浪费]{.red}</li>
<li>缺点：<ul>
<li>[每个线程在执行结束之前都不会释放锁从而可能导致死锁问题的发生]{.green}</li>
<li>[每个线程获取锁和释放锁的过程的过程会增加额外的开销]{.green}</li>
</ul>
</li>
<li>细节：</li>
</ul>
</li>
<li><p>乐观锁</p>
<ul>
<li><p>定义：</p>
<ol>
<li>[每次对共享变量的修改过程持乐观态度，认为其他线程不会 <strong>频繁写入而只是读取</strong> 共享变量]{.pink}</li>
<li>[所以每次线程访问共享变量时是不会上锁的，<strong>多个线程可以同时访问</strong> 共享变量]{.pink}</li>
<li>[只有在多个线程同时写入共享变量时才会 <strong>检测是否发生数据冲突</strong>，如果发生冲突就会重新尝试更新数据，直到数据更新成功]{.pink}</li>
</ol>
</li>
<li><p>核心：[多线程可以同时访问共享变量，如果线程行为发生冲突，那么就会不停重试直到成功为止]{.red}</p>
</li>
<li><p>实现：[CAS]{.aqua}</p>
</li>
<li><p>优点：</p>
<ul>
<li>[线程访问共享变量的过程不需要获取锁从而减少获取锁的开销，以及避免死锁问题]{.red}</li>
<li>[底层借助硬件实现（指令集）而不是软件实现的，执行的效率也非常高]{.red}</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><p>[乐观锁会造成 ABA 问题]{.green}</p>
</li>
<li><p>[线程冲突情况特别多时，每个线程重试的次数增多就会大幅增加开销，甚至超过上下文切换带来的开销]{.green}</p>
<p>  :::warning</p>
<p>  乐观锁的 ABA 问题带来的影响远不悲观锁带来的死锁问题影响大，不过确实是个缺点就是了</p>
<p>  :::</p>
</li>
</ul>
</li>
<li><p>细节：乐观锁机制是不会共享变量添加排他锁的，无论线程是读取还是写入变量，而是采用自旋的概念替代排他锁</p>
</li>
</ul>
</li>
</ul>
<p>:::info</p>
<p>① 悲观锁一定是独占锁吗？乐观锁是共享锁吗？</p>
<p>② 乐观锁会对共享变量上锁吗？</p>
<p>:::</p>

        <h2 id="公平锁和非公平锁"   >
          <a href="#公平锁和非公平锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2>
      <ul>
<li><p>前提：公平或者非公平锁都是基于悲观锁而言的，乐观锁根本不存在锁机制也就无从谈起公不公平了</p>
</li>
<li><p>公平锁：</p>
<ul>
<li><p>定义：</p>
<ol>
<li>[想要获取的锁的线程会先检查共享变量的锁是否被其他线程占用]{.pink}</li>
<li>[如果锁没有被其他线程占用，那么线程获取该锁，如果锁已经被占用，那么直接进入阻塞队列等待]{.pink}</li>
</ol>
</li>
<li><p>优点：[避免线程出现饥饿的现象：每个线程都能够在有限的时间内获取到锁的所有权]{.red}</p>
</li>
<li><p>缺点：[正在运行的线程释放锁之后，每次都需要从阻塞队列中唤醒线程，也就是执行上下文切换，增大开销]{.green}</p>
</li>
<li><p>图示</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/公平锁.4305ski22y00.png" alt="公平锁" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>非公平锁</p>
<ul>
<li><p>定义：</p>
<ol>
<li>[想要获取锁的线程会和 <strong>阻塞队列</strong> 中的队首线程竞争获取共享变量的锁]{.pink}</li>
<li>[如果竞争锁成功，那么该线程就会直接获得锁，如果竞争失败，那么该线程就会进入阻塞队列等待]{.pink}</li>
</ol>
</li>
<li><p>实现：synchronized 是非公平锁，ReentrantLock 默认是非公平锁，可以设置为非公平锁</p>
</li>
<li><p>优点：[非公平锁避免频繁唤醒阻塞的线程，减少线程上下文切换造成的开销，增大系统的吞吐量]{.red}</p>
</li>
<li><p>缺点：[容易造成 <strong>饥饿</strong> 现象：阻塞队列中的线程长时间获取不到锁的所有权]{.green}</p>
</li>
<li><p>图示</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/非公平锁.434laznbfc80.png" alt="非公平锁" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li>[无论是公平锁还是非公平锁，阻塞队列中线程都是遵循先进先出的规则来获取锁的]{.red}</li>
<li>[如果没有特别的要求，通常都会采用非公平锁以提升系统整体的性能]{.red}</li>
</ul>
</li>
</ul>

        <h2 id="独占锁和共享锁"   >
          <a href="#独占锁和共享锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#独占锁和共享锁" class="headerlink" title="独占锁和共享锁"></a>独占锁和共享锁</h2>
      <ul>
<li>独占锁：<ul>
<li>定义：[共享变量的锁每次只能够由一个线程获取，其余线程只能够阻塞等待]{.pink}</li>
<li>实现：synchronized、ReetrantLock、ReentrantReadWriteLock.WriteLock</li>
</ul>
</li>
<li>共享锁：<ul>
<li>定义：[共享变量的锁每次可以由多个线程获取，但是多个线程只能够同时进行读操作]{.pink}</li>
<li>实现：ReentrantReadWriteLock.ReadLock</li>
</ul>
</li>
</ul>

        <h2 id="重入锁和不可重入锁"   >
          <a href="#重入锁和不可重入锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#重入锁和不可重入锁" class="headerlink" title="重入锁和不可重入锁"></a>重入锁和不可重入锁</h2>
      <ul>
<li><p>不可重入锁</p>
<ul>
<li>定义：<ol>
<li>[如果线程已经获取到特定共享变量的锁后，想要再次获取该共享变量的锁]{.pink}</li>
<li>[那么该线程将会因为自己持有锁而被阻塞，这样的锁就是不可重入的]{.pink}</li>
</ol>
</li>
<li>细节：Java 默认提供的锁都是可重入的锁，可以采用 AQS 编写不可重入的锁</li>
</ul>
</li>
<li><p>可重入锁：</p>
<ul>
<li><p>定义：</p>
<ol>
<li>[如果线程已经获取到特定共享变量的锁后，想要再次获取该共享变量的锁]{.pink}</li>
<li>[该线程可以继续获取该共享变量的锁而不是被自己阻塞，这样的锁称为可重入的]{.pink}</li>
</ol>
</li>
<li><p>实现：synchronized、ReentrantLock</p>
</li>
<li><p>测试代码</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    log.debug(<span class="string">&quot;第一次获取锁...&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用方法第二次获取锁</span></span><br><span class="line">    method2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二次获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    log.debug(<span class="string">&quot;第二次获取锁...&quot;</span>);</span><br><span class="line">    method3();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第三次获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    log.debug(<span class="string">&quot;第三次获取锁...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

</li>
</ul>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/28/juc/juc-concurrent/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-%E6%A6%82%E8%BF%B0/">线程同步-概述</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-28</span></span></div></header><div class="post-body"><div class="post-excerpt"></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/23/design/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/">模板方法</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-23</span></span></div></header><div class="post-body"><div class="post-excerpt"></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/23/design/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">策略模式</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-11-03</span></span></div></header><div class="post-body"><div class="post-excerpt"></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/23/design/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/">享元模式</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-23</span></span></div></header><div class="post-body"><div class="post-excerpt"></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/21/os/process/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/">进程通信</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-21</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-21</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="进程间通信"   >
          <a href="#进程间通信" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1>
      
        <h2 id="基本概念"   >
          <a href="#基本概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2>
      
        <h2 id="通信方式"   >
          <a href="#通信方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2>
      
        <h3 id="本地进程通信"   >
          <a href="#本地进程通信" class="heading-link"><i class="fas fa-link"></i></a><a href="#本地进程通信" class="headerlink" title="本地进程通信"></a>本地进程通信</h3>
      
        <h4 id="管道"   >
          <a href="#管道" class="heading-link"><i class="fas fa-link"></i></a><a href="#管道" class="headerlink" title="管道"></a>管道</h4>
      
        <h5 id="匿名管道"   >
          <a href="#匿名管道" class="heading-link"><i class="fas fa-link"></i></a><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h5>
      
        <h5 id="命名管道"   >
          <a href="#命名管道" class="heading-link"><i class="fas fa-link"></i></a><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h5>
      
        <h4 id="共享内存"   >
          <a href="#共享内存" class="heading-link"><i class="fas fa-link"></i></a><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4>
      
        <h3 id="分布式进程通信"   >
          <a href="#分布式进程通信" class="heading-link"><i class="fas fa-link"></i></a><a href="#分布式进程通信" class="headerlink" title="分布式进程通信"></a>分布式进程通信</h3>
      
        <h4 id="Socket"   >
          <a href="#Socket" class="heading-link"><i class="fas fa-link"></i></a><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4>
      
        <h4 id="RPC"   >
          <a href="#RPC" class="heading-link"><i class="fas fa-link"></i></a><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4>
      
        <h4 id="MQ"   >
          <a href="#MQ" class="heading-link"><i class="fas fa-link"></i></a><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h4>
      
        <h4 id="Stream"   >
          <a href="#Stream" class="heading-link"><i class="fas fa-link"></i></a><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4>
      
        <h3 id="信号"   >
          <a href="#信号" class="heading-link"><i class="fas fa-link"></i></a><a href="#信号" class="headerlink" title="信号"></a>信号</h3>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/20/tomcat/%E6%89%8B%E5%86%99%20Tomcat%EF%BC%88%E4%BA%8C%EF%BC%89/">手写 Tomcat（二）</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-20</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-20</span></span></div></header><div class="post-body"><div class="post-excerpt"></div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/2/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/4/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/随机图库/1641882498931.3kditdl6ds40.webp" alt="avatar"></div><p class="sidebar-ov-author__text">什么都不会的废物</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/fuyusakaiori" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://weibo.com/Sakiless/home?topnav=1&amp;wvr=6" target="_blank" rel="noopener" data-popover="微博" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weibo"></i></span></a><a class="sidebar-ov-social-item" href="670232228" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">107</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">31</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-nd.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020~2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>小忍的甜甜圈</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1.0.1/dist/canvas-nest.min.js" color="0,0,0" opacity="0.6" count="99" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>