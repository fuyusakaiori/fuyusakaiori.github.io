<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="啥也不会的大三狗">
<meta property="og:type" content="website">
<meta property="og:title" content="天鹅绒房间">
<meta property="og:url" content="http://example.com/page/10/index.html">
<meta property="og:site_name" content="天鹅绒房间">
<meta property="og:description" content="啥也不会的大三狗">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Fuyusakaiori">
<meta name="twitter:card" content="summary"><title>天鹅绒房间</title><link ref="canonical" href="http://example.com/page/10/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">天鹅绒房间</div><div class="header-banner-info__subtitle">Velvet Room</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/09/network/%E4%BC%A0%E8%BE%93%E5%B1%82/">传输层</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-11</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="传输层"   >
          <a href="#传输层" class="heading-link"><i class="fas fa-link"></i></a><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1>
      
        <h2 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h2>
      <ul>
<li><p>概念：为运行在不同端系统上的 <strong>进程</strong> 提供了逻辑通信 (Logic Communication) (进程的概念详见操作系统)</p>
<p>  注：网络层是为不同的 <strong>端系统</strong> 之间提供逻辑通信</p>
</li>
<li><p>单位：==报文段== (Segement)</p>
<p>  <a style="color:red;">注：UDP 协议是不对应用层交付的报文做任何处理的</a>：所以也可以认为单位是报文</p>
</li>
<li><p>协议：</p>
<ul>
<li>UDP 协议：用户数据报协议</li>
<li>TCP 协议：传输控制协议</li>
</ul>
<div class="table-container"><table>
<thead>
<tr>
<th>应用层协议</th>
<th>传输层协议</th>
</tr>
</thead>
<tbody><tr>
<td>SMTP</td>
<td>TCP</td>
</tr>
<tr>
<td>HTTP</td>
<td>TCP</td>
</tr>
<tr>
<td>Telnet</td>
<td>TCP</td>
</tr>
<tr>
<td>FTP</td>
<td>TCP</td>
</tr>
<tr>
<td>DNS</td>
<td>UDP</td>
</tr>
<tr>
<td>SMNP</td>
<td>UDP</td>
</tr>
<tr>
<td>DHCP</td>
<td>UDP</td>
</tr>
<tr>
<td>RIP</td>
<td>UDP</td>
</tr>
<tr>
<td>BGP</td>
<td>TCP</td>
</tr>
</tbody></table></div>
</li>
<li><p>功能</p>
<ul>
<li><a href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8&%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3">多路复用</a>(Mutiplexing) &amp; <a href="#%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3">多路分解</a> (Demutiplexing)：<a style="color:red;">TCP &amp; UDP 协议都提供多路复用与分解功能</a></li>
<li><a href="#%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86">连接管理</a>：<a style="color:red;">TCP 协议是 <strong>面向连接</strong> 的协议需要建立连接 &amp; UDP 协议是 <strong>无连接</strong> 的协议不需要建立连接</a></li>
<li><a href="#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93">可靠传输</a>：<a style="color:red;">TCP 协议需要 <strong>保证可靠传输</strong> &amp; UDP 协议 <strong>不保证可靠传输</strong></a> </li>
<li><a href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">流量控制</a>：<a style="color:red;">TCP 协议提供 <strong>流量控制</strong> 机制 &amp; UDP 协议不提供 <strong>流量控制</strong> 机制</a></li>
<li><a href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">拥塞控制</a>：<a style="color:red;">TCP 协议提供 <strong>拥塞控制</strong> 机制 &amp; UDP 协议不提供 <strong>拥塞控制</strong> 机制</a></li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li><p>==端对端传输==</p>
</li>
<li><p>路由器 <strong>不会检查数据报的数据部分(传输层报文段)</strong> 仅检查数据报首部 </p>
<p>  解释：(1) 路由器仅实现到网络层是无法检测传输层的数据的 (2) 问题：传输层的数据出现问题 <strong>网络层是无法检测到</strong> 的</p>
</li>
</ul>
</li>
</ul>

        <h2 id="多路复用-amp-多路分解"   >
          <a href="#多路复用-amp-多路分解" class="heading-link"><i class="fas fa-link"></i></a><a href="#多路复用-amp-多路分解" class="headerlink" title="多路复用&amp;多路分解"></a>多路复用&amp;多路分解</h2>
      <ul>
<li><p>端口号：</p>
<ul>
<li><p>定义：进程在网络通信时用于标识自己的编号</p>
</li>
<li><p>长度：16位比特 (最大端口数量 2^16^)</p>
</li>
<li><p>分类：</p>
<ul>
<li>服务端：(1) 周知端口号 0~1023 (2) 登记端口号 1024 ~ 49151</li>
<li>客户端：客户端程序参与网络通信使用的编号 49152 ~ 65536</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li><p><a style="color:red;">端口号不是进程号，多个进程可以同时使用一个端口号</a>：使得多个进程的数据可以封装在同一个报文段中</p>
<p>  解释：不同的操作系统分配进程标识符格式是不同的，为了保证统一性设计了端口号</p>
</li>
<li><p><a style="color:red;">一个进程可以占用多个端口号</a></p>
</li>
</ul>
</li>
</ul>
<div class="table-container"><table>
<thead>
<tr>
<th>应用层协议</th>
<th>FTP</th>
<th>TELNET</th>
<th>SMTP</th>
<th>DNS</th>
<th>HTTP</th>
<th>SNMP</th>
<th>RIP</th>
</tr>
</thead>
<tbody><tr>
<td>端口号</td>
<td>21</td>
<td>23</td>
<td>25</td>
<td>53</td>
<td>80</td>
<td>161</td>
<td>520</td>
</tr>
</tbody></table></div>
</li>
<li><p>套接字(Socket)：用于标识端系统上具体某个进程</p>
<ul>
<li><p>UDP 套接字：&lt;目的<code>IP</code> 地址 , 目的端口号&gt;</p>
<p>  <a style="color:red;">不同的源主机发送的报文段将会因为 <strong>相同的目的IP地址和端口号</strong> 被定向到同一主机的同一进程</a></p>
</li>
<li><p>TCP 套接字：&lt;源<code>IP</code> 地址，源端口号，目的<code>IP</code> 地址 , 目的端口号&gt;</p>
<p>  <a style="color:red;">不同源主机发送的报文段不会因为 <strong>相同的目的IP地址和端口号</strong> 被定向到同一主机的同一进程</a>：因为源主机 IP 地址和端口号不同，建立的连接也不同</p>
</li>
</ul>
</li>
<li><p>多路复用：传输层从不同的套接字中接收 <strong>报文</strong> 并为其添加首部形成 <strong>报文段</strong> (不同的应用程序可以采用相同的传输层协议传输数据)</p>
</li>
<li><p>多路分解：(1) 传输层从网络层中接收 <strong>数据报</strong> 并拆封将 <strong>报文段</strong> 交付给正确的套接字 (2) 套接字最后把数据分发给相应的集成</p>
</li>
</ul>
<p><img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210402201243799.png" alt="image-20210402201243799"></p>

        <h2 id="传输层协议"   >
          <a href="#传输层协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h2>
      
        <h3 id="UDP-协议"   >
          <a href="#UDP-协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h3>
      <ul>
<li><p>功能：(提供的是传输层 <strong>最低限度</strong> 的功能)</p>
<ul>
<li><p>多路复用&amp;多路分解</p>
</li>
<li><p>差错检测：<strong>校验和</strong> (<a style="color:red;">首部校验和不具有差错纠正的功能</a>)</p>
<p>  注：<a style="color:red;">UDP 协议丢弃受损的报文段并且向上层发出警告</a>：不具有差错的恢复能力</p>
</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li><p>无连接：(1) 进程之间通信不需要提前建立连接 (2) 减少传输的时延，适用于实时通信</p>
</li>
<li><p>不提供可靠传输：报文段可能 <strong>受损</strong>  + <strong>丢失</strong> + <strong>失序</strong> + <strong>重复到达</strong></p>
</li>
<li><p>面向报文：不对应用层交付的报文作任何处理直接封装后放入数据报中 </p>
<ul>
<li><p>如果报文容量过大，会导致网络层需要对其进行分片</p>
</li>
<li><p>如果报文容量过小，会导致网络层数据报的首部相对较大</p>
<p>  <a style="color:red;">注：报文大小控制不得当会导致网络层通信效率降低</a></p>
</li>
</ul>
</li>
<li><p>首部开销小：==8B==</p>
</li>
<li><p>支持==非一对一==通信</p>
</li>
</ul>
</li>
<li><p>报文段格式</p>
<ul>
<li><p>源端口号：服务器返回数据时可以直接从发送的报文段中提取源端口号作为目的端口号</p>
</li>
<li><p>目的端口号：</p>
</li>
<li><p>报文总长度：<strong>首部长度 + 数据长度</strong></p>
</li>
<li><p>校验和</p>
<ul>
<li><p>计算过程</p>
<p>  (1) 源端口号 + 目的端口号 + 总长度 + 数据部分 + ==伪首部==（不包括校验和字段)</p>
<p>  (2) 二进制求和后 <strong>取反码</strong> 得到校验和</p>
<p>  (3) 如果求和过程出现 <strong>溢出</strong>，需要采用 ==回卷== 操作</p>
</li>
<li><p>伪首部：==源 IP 地址 + 目的 IP 地址 + 0 + 协议字段（ UDP 协议是 17）+ UDP 报文长度== (<a style="color:red;">伪首部只在计算校验和的时候出现，不会被封装进数据报中</a>)</p>
</li>
<li><p>回卷：最高位溢出的结果 <strong>加到</strong> 最低位去</p>
</li>
<li><p>问题：</p>
<ol>
<li><p>数据链路层采用 CRC 校验了，网络层采用首部校验和校验了，为什么传输层还要采用校验和校验？</p>
<p> (1) 数据链路层和网络层的校验不能够保证发现所有的错误 (2) 网络层向传输层交付数据时仍然可能发生错误</p>
</li>
<li><p>为什么传输层的校验和要使用伪首部</p>
<ul>
<li><p>==伪首部检验 IP 地址== -&gt; 网络层在拆卸 IP 数据报的过程中 IP 地址仍然是可能发生变化的，传输层需要防止网络层交付错误的 IP 地址</p>
</li>
<li><p>==伪首部检验网络层数据报是否交付错误== -&gt; TCP/UDP 协议和 IP 协议完全可能不在同一个协议栈上，IP 数据报不一定是交付给 TCP/UDP 的</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>  <a style="color:red;">1. 网络层和传输层的首部校验和都是选择性使用的</a></p>
<p>  <a style="color:red;">2. 网络层和传输层都会对 IP 地址做校验，确实有一定的重复，所以在 IPv6 协议中取消了校验和字段，保证速率</a></p>
</li>
<li><p>细节：</p>
<ul>
<li><a style="color:red;">UDP 不提供可靠传输就意味着需要应用程序自己保证可靠传输</a></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210402204459854.png" alt="image-20210402204459854"></p>

        <h3 id="TCP-协议"   >
          <a href="#TCP-协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3>
      
        <h4 id="基本概念"   >
          <a href="#基本概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4>
      <ul>
<li><p>概念：面向连接（虚连接）的传输层协议</p>
</li>
<li><p>功能：</p>
<ul>
<li><a href="#%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86">连接管理</a></li>
<li><a href="#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93">可靠传输</a></li>
<li><a href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">流量控制</a></li>
<li><a href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">拥塞控制</a></li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li><p>面向连接</p>
<ul>
<li>连接仅建立在两个进程之间，是 <strong>点对点</strong> 的情况 (<a style="color:red;">多播协议是不可能在 TCP 下实现的</a>)</li>
<li>进程双方在通信时需要 <strong>提前建立连接</strong> 才能够发送数据</li>
<li>请求建立连接的进程称为 <strong>客户端</strong> ，响应连接建立的进程称为 <strong>服务端</strong></li>
<li>TCP 连接是 <strong>虚连接</strong>：网络层之下都是不会感受到 TCP 连接的存在</li>
</ul>
</li>
<li><p>可靠传输：保证报文段能够正确到达</p>
</li>
<li><p>全双工通信：进程双方可以同时发送数据和接收数据，接收和发送双方==都具有接收窗口和发送窗口==</p>
</li>
<li><p>面向字节流：<a style="color:red;">将应用层的交付的数据 <strong>按照字节隐式地编号</strong></a>，每次将一定数量的字节封装成报文段发送</p>
<p>  <a style="color:red;">注：每个报文段的字节数量取决于 MSS (最大报文段长度)</a></p>
</li>
</ul>
</li>
<li><p>报文格式：</p>
<ul>
<li><p>源端口号 目的端口号（2B）</p>
</li>
<li><p>序号（4B）：每次发送的报文段中 ==第一个字节的编号== 就是序号</p>
<p>  注：初始序号通常随机：(1) <a style="color:red;">避免分组重排序</a>：防止滞留在网络中的分组在某个时刻到达导致传递不必要的信息 (2) 保证网络安全</p>
</li>
<li><p>确认号（4B）：每次确认报文段中希望得到的 ==下一个字节的编号== (<a style="color:red;">序号 + 数据长度 = 确认号</a>)</p>
</li>
<li><p>首部长度（4bit）：单位 ==4B==</p>
</li>
<li><p>窗口大小（2B）：接收方将当前 <strong>缓存空间</strong> 中的 <strong>窗口大小</strong> 值放入 <strong>确认报文</strong> 中返回给发送方</p>
<p>  <a style="color:red;">注：发送方收到的窗口大小的值 = min{接收窗口大小，拥塞窗口大小}</a></p>
</li>
<li><p>控制位：</p>
<ul>
<li><code>URG</code>：(1) <code>URG</code> = 1 传输的数据是紧急数据时 (2) 紧急传输的数据不需要在 <strong>缓存空间</strong> 中排队</li>
<li><code>ACK</code>：(1) <code>ACK</code> = 1 连接建立过程中服务端回复确认报文段时 (2) <a style="color:red;">连接建立后所有报文段的 ACK 必须被置为 1</a> (无论报文段时确认报文段还是发送报文段)</li>
<li><code>PSH</code>：不需要在接收窗口中等待应用层的处理，直接交付给应用层处理</li>
<li><code>RST</code>：连接出现严重错误，需要重新建立连接</li>
<li><code>SYN</code>：(1) <code>SYN</code> = 1 客户端请求建立连接 &amp; 服务器端同意建立连接</li>
<li><code>FIN</code>：(1) <code>FIN</code> = 1 客户端请求结束连接 &amp; 服务器端同意结束连接</li>
</ul>
</li>
</ul>
</li>
<li><p>图示</p>
</li>
</ul>
<p><img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210403150832072.png" alt="image-20210403150832072"></p>

        <h4 id="功能"   >
          <a href="#功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#功能" class="headerlink" title="功能"></a>功能</h4>
      
        <h5 id="连接管理"   >
          <a href="#连接管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h5>
      <ul>
<li><p>概念：连接建立 + 连接维护 + 连接释放</p>
</li>
<li><p>前提：TCP 是全双工通信 -&gt; ==有两条通信信道==</p>
</li>
<li><p>过程：</p>
<ul>
<li><p>连接建立：服务器长期处于监听状态</p>
<ol>
<li><p>客户端发送 SYN = 1</p>
<ul>
<li>客户端进入 ==SYN_SENT 状态==</li>
<li>等待服务器响应；如果超时则利用重传机制，重传 SYN = 1</li>
<li>不携带任何数据，但是消耗序号</li>
</ul>
</li>
<li><p>服务端响应 ACK = 1和 SYN = 1</p>
<ul>
<li><p>服务器端进入 ==SYN_RCVD 状态==</p>
</li>
<li><p>等待客户端响应；如果超时则利用重传机制，重传 SYN = 1，ACK = 1</p>
<p>  <a style="color:red;">其实本质上 SYN 和 ACK 应该分开发送的，但是这里可以整合在一起发送</a></p>
</li>
<li><p>不携带任何数据，但是消耗序号</p>
</li>
<li><p>开始分配 ==TCP 缓存== 和 ==变量==</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<ol start="3">
<li>客户端响应 ACK = 1 <ul>
<li>客户端进入 ==ESTABLISHED 状态==</li>
<li>可以携带数据发送</li>
<li>开始分配 ==TCP 缓存== 和 ==变量==    4. 服务器端接收到响应进入 ==ESTABLISHED 状态==</li>
</ul>
</li>
</ol>
</li>
</ul>
<pre><code>* 细节问题

    1. seq = x：x 的值是随机分配的

    2. 为什么是三次握手，不是两次，四次或者更多次

        * 非本质回答：资源浪费

            客户端发送的连接建立请求可能在网络中滞留，导致延时到达服务器；

            客户端选择重传连接建立请求，然后传输数据，最后关闭连接；

            但是，之前延时到达的服务器的连接请求在关闭连接后到达了；

            这时，服务器端就会认为客户端又开始请求建立连接了，就会发送响应 SYN = 1 ACK = 1；

            如果是两次握手，导致连接建立，但是客户端并不想要建立连接，所以就不会回复，导致服务器端会长时间的等待直到超时，浪费资源

            如果是三次握手，那么服务器端就会因为客户端不回复知道他不想建立连接，就不会一直等待

        * 本质回答：==三次握手是理论保证可靠传输的最小值==

            一次握手：客户端发送请求，显然他根本不知道服务器到底接收到没有，所以需要等待服务器的回复 -&gt; 一次握手显然不可靠

            两次握手：服务器端回复了客户端，那么服务器端也不清楚客户端到底接收到没有，所以需要再次等待客户端的回复-&gt; 两次握手显然也不太可靠

            三次握手：客户端回复了服务器，已经基本确认两端都是可以连通的，可靠连接可以基本建立了

            四次握手：客户端也不清楚服务器端是否接收到自己的再次回复，所以再次等待服务器端的回复 -&gt; 显然相对于三次可靠性更高了

            ....

            实际上，我们可以设计非常多次的握手来保证可靠传输，但是三次就是理论上保证可靠传输的最小值

* 连接断开：客户端数据发送完毕

    1. 客户端发送 FIN = 1 

        * 客户端进入 ==FIN-WAIT1状态==
        * 客户端等待服务器的响应；超时则利用重传机制
        * 不携带任何数据，消耗序号

    2. 服务端响应客户端 ACK = 1

        * 服务器端进入 ==CLOSE-WAIT 状态==
        * 服务器允许客户端释放连接 -&gt; &lt;a style=&quot;color:red;&quot;&gt;释放客户端到服务器端的单向连接&lt;/a&gt;
        * 客户端连接释放之后不可以再发送数据；服务器端仍然可以发送数据
        * 不携带任何数据，消耗序号

        &lt;a style=&quot;color:red;&quot;&gt;上述两次握手经过后 TCP 连接处于半关闭状态，这期间服务器端仍然可能向客户端发送数据&lt;/a&gt;

    3. 服务端发送 FIN = 1

        * 服务器端进入 ==LAST-ACK状态==

        * 服务器不再向客户端发送数据后准备关闭连接
        * 服务器端等待客户端响应；超时则利用重传机制

    4. 客户端响应 ACK = 1

        * 服务器端进入 ==CLOSED状态==，客户端进入 ==TIME-WAIT状态==
        * 服务器端到客户端的连接还没有释放

    5. 客户端等待时间结束（2MSL）

        * 客户端进入 ==CLOSED状态==
        * 服务器端到客户端的连接彻底释放

    6. TCP 连接关闭完成

* 细节问题

    1. 为什么是四次挥手不是三次挥手？
        * 连接建立实际上也可以看做四次握手，而是三次握手的原因，是因为 ACK + SYN 一起发送简化了过程
        * 连接关闭时两者不可以一起发送，因为确认客户端到服务器端的连接关闭后，服务器端到客户端的连接并不会立刻关闭 -&gt; 造成四次挥手
    2. 为什么最后客户端需要等待一段时间之后才能关闭呢？
        * 因为客户端响应的 ACK 很有可能产生丢失，导致服务器端到客户端连接并没有关闭，如果此时客户端先行关闭，会导致服务器挂起
        * 所以客户端需要等待服务器先行关闭，自己再关闭，最后服务器端到客户端的连接才算彻底释放 -&gt; TCP 关闭完成
    3. 为什么一定要等待 2MSL 长度的时间呢？
        * 报文段最长存活时间是 MSL
        * ？
    4. 如果服务器第一次响应客户端的报文段丢失，会出现什么情况呢？
</code></pre>
<ul>
<li><p>图示：</p>
<ul>
<li>连接建立</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210419171811788.png" alt="image-20210419171811788"></p>
<ul>
<li>连接断开</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210419193439634.png" alt="image-20210419193439634"></p>
</li>
<li><p>SYN 洪泛攻击</p>
<ul>
<li>概念：ddos 攻击的一种</li>
<li>过程：<ul>
<li>攻击者发送 SYN = 1 的第一个报文段</li>
<li>服务端接收第一个报文段后回复给攻击者相应的确认报文段</li>
<li>攻击者此时不再回复服务器</li>
<li>服务器没有接收到回复会不断地发送确认报文段，希望得到攻击者的响应</li>
<li>服务器由于得不到攻击者的响应，连接挂起，最后因为超时而断开连接</li>
</ul>
</li>
<li>后果：消耗 CPU 和 内存，导致服务器宕机</li>
</ul>
</li>
</ul>

        <h5 id="可靠传输"   >
          <a href="#可靠传输" class="heading-link"><i class="fas fa-link"></i></a><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h5>
      <p><img src="https://i1.xpic.jp/file/xpicjp/2021/06/19/4b3c32a16c1b3d029aa3199f0ca1413b.png" alt="4b3c32a16c1b3d029aa3199f0ca1413b.png"></p>

        <h6 id="基本机制"   >
          <a href="#基本机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本机制" class="headerlink" title="基本机制"></a>基本机制</h6>
      <ul>
<li><p>前提：信道是不可靠的：导致分组在传输过程中可能 <strong>受损</strong> + <strong>丢失</strong> + <strong>失序</strong> + <strong>延迟</strong></p>
</li>
<li><p>引入：所以我们需要一种机制来确保即使在传输过程中出现了这些问题最终仍然能够将分组正确交付给接收方</p>
</li>
<li><p>核心：<a style="color:red;">自动请求重传协议 </a> (Automatic Repeat reQuest)</p>
</li>
<li><p>确认机制</p>
<ul>
<li><p>正面确认(<code>ACK</code>) &amp; 负面确认(<code>NAK</code>)</p>
<ul>
<li><p>正面确认：接收方正确收到发送方发送的分组之后反馈给接收方的分组</p>
</li>
<li><p>负面确认：接收方收到错误的分组后反馈给接收方的分组 (实际协议中通常不使用这种机制)</p>
<p>  <a style="color:red;">1. 如果在确认分组中携带数据就称为 <strong>捎带确认</strong> </a></p>
<p>  <a style="color:red;">2. <strong>正面确认 + 序号</strong> 机制可以代替负面确认</a>：接收方可以通过分组的序号确认当前的分组是否是自己想要的分组，如果不是则重复发送相同的确认分组</p>
</li>
</ul>
</li>
<li><p>差错检测：需要使用差错检测检查分组是否受损</p>
</li>
<li><p>序号：(1) 发送方发送的分组和接收方发送的确认分组都需要编号 (2) 接收方正确收到分组后返回的确认分组和接收分组的序号一致</p>
<p>  <a style="color:red;">1* TCP 的实际实现中是根据报文段中第一个字节编号作为整个报文段的编号</a></p>
<p>  <a style="color:red;">2* 序号是可以 <strong>复用</strong> 的</a>：序号复用可能会导致分组重排序的问题</p>
</li>
</ul>
<p>  注：上述机制已经解决了分组可能产生的失序和受损的问题，但是没有解决丢失和延迟到达的问题</p>
</li>
<li><p>重传机制</p>
<ul>
<li><p>超时重传：发送方在规定的等待时间内没有接收到确认分组就会重传分组</p>
<ul>
<li><p>定时器：(1) GBN 协议中仅使用 <strong>一个定时器</strong> (2) SR 协议中 <strong>每个分组都拥有一个定时器</strong> (3) TCP 实际实现中也 <strong>仅使用一个定时器</strong></p>
</li>
<li><p>计算方式：(指数加权移动平均)</p>
<p>  (1) TimeoutInterval = EstimatedRTT + 4DevRTT</p>
<p>  (2) EstimatedRTT = $(1-\alpha)<em>EstimatedRTT + \alpha</em>SampleRTT$ ($\alpha$ 通常取 0.125)</p>
<p>  (3) 4DevRTT= $(1- \beta)<em>DevRTT + \beta</em>|SampleRTT - EstimatedRTT|$ ($\beta$ 通常取 0.25) </p>
<p>  <a style="color:red;">1. SampleRTT 不是每发送一个分组就测量一次而是在某个时刻测量一次</a></p>
<p>  <a style="color:red;">2. 每出现一次超时重传 TimeoutInterval 直接翻倍而不是采用公式计算</a></p>
</li>
</ul>
</li>
<li><p>快速重传：发送方在重复接收到 <strong>3 个相同的 <code>ACK</code> 分组</strong> 后就会自动触发重传</p>
<p>  <a style="color:red;">注：可以在定时器倒计时结束前重传分组</a></p>
</li>
<li><p>重传时机：(1) 数据分组丢失 (2) 数据分组延时到达 (3) 数据分组乱序达到 (4) 确认分组延时到达 (5) 确认分组丢失</p>
</li>
</ul>
</li>
<li><p>停止-等待协议：</p>
<ul>
<li>内容：(1) 发送 <strong>每发送一个分组</strong> 都需要等待接收方返回确认分组 (2) 规定时间内没有接收到确认分组就会重传</li>
<li>优点：非常简单</li>
<li>缺点：<a style="color:red;">效率非常低</a>：$\frac{\frac{L}{R}}{RTT+\frac{L}{R}}$ (<a style="color:red;">注：这里的 RTT 指的是分组中的 <strong>最后一个比特</strong> 被发送到接收确认分组的 <strong>第一个比特</strong> 的时间</a>)</li>
</ul>
</li>
<li><p>流水线协议</p>
<ul>
<li><p>内容：允许发送方 <strong>同时发送多个分组</strong> 而不需要等待接收方的确认分组</p>
</li>
<li><p>优点：<a style="color:red;">效率相对停止-等待协议提高很多</a>：$\frac{\frac{nL}{R}}{RTT+\frac{L}{R}}$ (注：这个公式为什么是这样的？好好想想，否则流水线的题目是算不出来的)</p>
</li>
<li><p>缺点：(1) 需要控制发送方在每个时刻同时发送的分组的数量 -&gt; 如果不加以限制会造成网络拥塞 (2) 分组可能乱序到达 -&gt; 接收方如何接收？</p>
<p>  <a style="color:red;">注：(1) GBN 协议和 SR 协议都采用滑动窗口机制对发送的分组数量加以限制 (2) GBN 丢弃乱序到达的分组 SR 缓存乱序到达的分组</a></p>
</li>
<li><p>协议：(1) [GBN 协议](#GBN 协议) (2) [SR](#SR 协议)</p>
</li>
</ul>
</li>
</ul>

        <h6 id="GBN-协议"   >
          <a href="#GBN-协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#GBN-协议" class="headerlink" title="GBN 协议"></a>GBN 协议</h6>
      <ul>
<li><p>内容：</p>
<ul>
<li><p>发送方拥有发送窗口：(1) 已经发送但未确认的分组 (2) 即将要发送的分组 </p>
<p>  注：定义：(1) 最早已发送未确认的分组序号为 base (2) 即将要发送的第一个分组序号为 nextseqnum (3) 窗口长度为 N</p>
</li>
<li><p>发送方 <strong>已发送但未确认的分组数量</strong> 不可以超过当前滑动窗口的大小 (<a style="color:red;">nextseqnum - base ≤ N</a>)</p>
</li>
<li><p>发送方接收到 <strong>确认序号 ≥ base</strong> 的确认分组时就会将窗口向前移动 <strong>确认序号 - base + 1</strong> 个位置 (滑动窗口的含义)</p>
<p>  注：<a style="color:red;">GBN 协议采用 <strong>累积确认</strong> </a></p>
</li>
<li><p>发送方如果在规定时间没有接收到相应的确认分组就会 <strong>重传所有已发送但未确认的分组</strong> (就是后退 N 步的含义)</p>
</li>
<li><p>接收方 <strong>仅接收按序到来的分组</strong> 而对于乱序到来的分组直接抛弃并且发送 <strong>上次发送的确认分组</strong></p>
<p>  注：<a style="color:red;">接收方 <strong>丢弃所有乱序达到分组</strong> 不会进行缓存</a></p>
</li>
</ul>
</li>
<li><p>累积确认(Cumulative Acknowlegment)：</p>
<ul>
<li>内容：<ul>
<li>接收方连续按序接收到 <strong>多个分组</strong> 后 <strong>仅返回一个确认分组</strong> 用于通知发送方已正确接收到所有分组 (<a style="color:red;">确认分组的序号是最后一个按序到达的分组的序号</a>)</li>
<li>发送方接收到确认分组后就认为该 <strong>确认序号之前</strong> <strong>所有没有被确认的分组都已经被正确接收</strong> (所以滑动窗口会向前移动多个位置)</li>
</ul>
</li>
<li>累积确认的目的就是为了加速传输的过程，没有必要对每个分组都进行确认</li>
</ul>
</li>
<li><p>优点：实现简单 -&gt; 接收方不需要缓存任何乱序到的分组</p>
</li>
<li><p>缺点：后退 N 步造成很多无意义的重传：即使正确到达接收方的分组也可能因为乱序而不被接收，所以发送方只能够重发所有未被确认分组</p>
</li>
<li><p>窗口大小：$1 &lt; W_t &lt; 2^n - 1$ ($n$ 是比特的个数)</p>
</li>
<li><p>细节：</p>
<ul>
<li>发送方的应用层在要求发送数据时，发送方首先检查窗口是否已满：(是否已满就是判断当前已发送但未确认的分组是否达到滑动窗口大小)<ul>
<li><a style="color:red;">如果未满就将分组添加到即将要发送分组中</a> </li>
<li><a style="color:red;">如果已满：(1) 将分组返回给应用层暗示待会再发 (2) 发送方缓存当前的分组等到有空位置再发 (3) 采用同步机制</a></li>
</ul>
</li>
<li><a style="color:red;">所有分组共享一个定时器</a></li>
</ul>
</li>
</ul>

        <h6 id="SR-协议"   >
          <a href="#SR-协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#SR-协议" class="headerlink" title="SR 协议"></a>SR 协议</h6>
      <ul>
<li><p>内容：</p>
<ul>
<li><p>发送方：</p>
<p>  (1) 发送方拥有发送窗口：已经发送但未确认的分组 + 即将要发送的分组 (其余定义和 GBN 一致)</p>
<p>  (2) 发送方 <strong>已发送但未确认的分组数量</strong> 不可以超过当前滑动窗口的大小 (<a style="color:red;">nextseqnum - base ≤ N</a>)</p>
<p>  (3) 发送方仅在接收到 <strong>确认序号 == base</strong> 的确认分组时才会将滑动窗口向前移动 <strong>下一个仍未被确认的分组的序号 - base</strong> 个位置</p>
<p>  注：<a style="color:red;">SR 协议采用的是 <strong>选择重传</strong> 无法采用累积确认</a> </p>
<p>  (4) 发送方在规定时间内没有接收到相应分组的确认时 <strong>仅重传没有被确认的分组</strong></p>
</li>
<li><p>接收方：</p>
<p>  (1) 接收方也拥有接收窗口：<a style="color:red;">缓存所有乱序到达的分组并且对每个乱序到达的分组都会返回确认分组</a></p>
<p>  (2) 接收方仅在接收到 <strong>序号 == 最早期待的分组序号</strong> 才会将滑动窗口向前移动 <strong>下一个被期待的分组序号 - 最早期待的分组序号</strong> 个位置</p>
</li>
</ul>
</li>
<li><p>选择重传：</p>
<ul>
<li>无论是否按序到达分组接收方都会返回相应的确认分组让发送方得知哪些分组已经被正确接收哪些还没有被正确接收</li>
<li>发送方在重传分组的时候就 <strong>可选择性地重传没有被接收的分组</strong> 而不是重传所有已发送但未被确认的分组</li>
</ul>
</li>
<li><p>优点：不会造成非常多无意义的重传</p>
</li>
<li><p>缺点：在序号复用的情况下重传的分组和新发的分组可能无法别识别出来</p>
</li>
<li><p>窗口大小：</p>
<ul>
<li><a style="color:red;">接收窗口和发送窗口大小通常一致</a></li>
<li>$Ws + Wr ≤ 2^n$</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li><a style="color:red;">接收方和发送方的窗口并不总是 <strong>同步</strong> 的</a></li>
<li><a style="color:red;">所有分组都具有一个独立的定时器</a></li>
</ul>
</li>
</ul>

        <h6 id="TCP-协议-1"   >
          <a href="#TCP-协议-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP-协议-1" class="headerlink" title="TCP 协议"></a>TCP 协议</h6>
      <ul>
<li><p>核心：<a style="color:red;">GBN 协议 + SR 协议的 <strong>混合体</strong> </a>：采用 <strong>累积确认 + 选择重传</strong></p>
</li>
<li><p>累积确认 + 选择重传：接收方会缓存乱序到达的报文段但是 <strong>不会对乱序到达的报文段返回相应的确认</strong>，而是持续的返回期望接收到报文段的确认 (累积确认)</p>
</li>
<li><p>面向字节：(1) 应用层交付的每个报文中的比特都被隐式地 <strong>编号</strong> (2) 每次将一定数量的字节封装成报文段发送</p>
<ul>
<li>报文段序号(seq)：报文段中第一个字节的编号</li>
<li>确认报文段确认号(ack)：期望收到的下一个字节的序号 seq + data.length</li>
</ul>
</li>
<li><p>发送缓存：发送窗口(已发送未被确认字节 + 即将发送的字节) + 应用层交付的但还不可以被发送的字节</p>
</li>
<li><p>接收缓存：接收窗口(已收到的字节 + 仍未收到的字节) + 已经确认但未被应用层使用的字节</p>
</li>
<li><p>通信过程：</p>
</li>
</ul>

        <h5 id="流量控制"   >
          <a href="#流量控制" class="heading-link"><i class="fas fa-link"></i></a><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h5>
      <ul>
<li><p>原因：发送方发送的速率太快导致 <strong>接收方来不及接收处理</strong> (局部性造成的)</p>
</li>
<li><p>核心：<a style="color:red;">滑动窗口机制</a></p>
</li>
<li><p>内容：</p>
<ul>
<li>接收窗口大小 rwnd：接收缓存 - 应用层尚未处理的字节数量</li>
<li><a style="color:red;">接收方通过在确认报文段中 <strong>填写窗口大小字段</strong> </a> 通知发送方当前还可以接收的字节数量</li>
<li>从而达到控制发送方的发送速率的目的</li>
</ul>
</li>
<li><p>问题：$rwnd = 0$ 时发送方就会停止发送数据，但是接收方处理完数据之后并不会通知发送方，那么发送方怎么才能够得知接收方已经处理完数据了呢？</p>
<ul>
<li><p>核心：<a style="color:red;">设置定时器</a></p>
</li>
<li><p>方式：定时器倒计时结束后发送方发送 <strong>不带数据的报文段</strong>：</p>
<p>  (1) 如果接确认报文段的窗口大小字段为 0 则接收方没有处理完 </p>
<p>  (2) 如果接确认报文段的窗口大小字段不为 0 则接收方已经处理完成：发送方可以重新开始发送数据了</p>
</li>
</ul>
</li>
<li><p>细节：<a style="color:red;">窗口大小字段取决于 <strong>接收窗口大小 和 拥塞窗口大小</strong> 两个因素</a></p>
</li>
</ul>

        <h5 id="拥塞控制"   >
          <a href="#拥塞控制" class="heading-link"><i class="fas fa-link"></i></a><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h5>
      <ul>
<li><p>概念：网络中的各个发送方的发送速率太快导致 <strong>路由器来不及接收处理</strong> (<strong>全局性</strong> 造成的)</p>
</li>
<li><p>核心：<a style="color:red;">慢开始 + 拥塞避免 + 快重传 + 快恢复</a> (慢开始和拥塞避免是 TCP 拥塞控制的 <strong>强制部分</strong>)</p>
</li>
<li><p>前提：<a style="color:red;">发送方维护拥塞窗口大小变量 cwnd</a></p>
</li>
<li><p>内容：</p>
<ul>
<li><p>慢开始：“探测”当前网络的通信状况</p>
<p>  (1) $cwnd_0 = 1$：发送方在刚开始仅发送一个 <strong>报文段</strong> (字节数量 = <code>MSS</code>) 用于试探网络当前的堵塞状况</p>
<p>  (2) 发送方成功接收到接收方返回的确认报文后更新 $cwnd$ 的值</p>
<p>  (3) $cwnd = 2^{n-1}$ ($n$ 是发送的轮次)：发送方发送的报文段数量开始成 <strong>指数级增长</strong></p>
<p>  (4) 发送方结束指数级增长的情况：1) 进入拥塞避免状态 2) 进入快重传机制 3) 出现网络拥塞</p>
<p>  (5) 出现网络拥塞之后：使 $ssthresh$ = $cwnd / 2$ 再将 $cwnd$ 的值重新置为 $1$  重新开始 <strong>慢启动</strong></p>
</li>
<li><p>拥塞避免：$cwnd = ssthresh$ 时发送方结束指数增长开始线性增长：经过每个轮次之后 $cwnd++$</p>
</li>
<li><p>快重传：发送方在接收到 $3个ACK$ 之后重传当前发送的报文段并且进入 <strong>快恢复</strong></p>
<p>  <a style="color:red;">注：快重传通常伴随快恢复</a></p>
</li>
<li><p>快恢复：(1) 使 $ssthresh$ = $cwnd / 2$ 再将 $cwnd$ 的值重新置为 $ssthresh$ (2) 每经过一个轮次 $cwnd++$</p>
</li>
</ul>
</li>
<li><p>细节：窗口字段大小 = $min(rwnd, cwnd)$</p>
</li>
</ul>
<p><img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210405193342652.png" alt="image-20210405193342652"></p>
<p><img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210405194244655.png" alt="image-20210405194244655"></p>
<p>​    </p>
<p>​    </p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/09/network/%E5%BA%94%E7%94%A8%E5%B1%82/">应用层</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-11</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="应用层"   >
          <a href="#应用层" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1>
      
        <h2 id="应用层概述"   >
          <a href="#应用层概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用层概述" class="headerlink" title="应用层概述"></a>应用层概述</h2>
      <ul>
<li>基本概念：<ul>
<li>应用层：使用下层协议为==应用软件==提供服务</li>
<li>单位：报文（HTTP协议）</li>
</ul>
</li>
<li>功能<ul>
<li>域名解析（DNS 协议）</li>
<li>文件传输（FTP 协议）</li>
<li>邮件系统（SMTP，POP3协议）</li>
<li>虚拟终端（HTTP协议）</li>
</ul>
</li>
<li>网络应用模型<ul>
<li>C/S 客户端/服务器</li>
<li>P2P</li>
</ul>
</li>
</ul>

        <h2 id="协议"   >
          <a href="#协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#协议" class="headerlink" title="协议"></a>协议</h2>
      
        <h3 id="DNS-协议（需要修改）"   >
          <a href="#DNS-协议（需要修改）" class="heading-link"><i class="fas fa-link"></i></a><a href="#DNS-协议（需要修改）" class="headerlink" title="DNS 协议（需要修改）"></a>DNS 协议（需要修改）</h3>
      <ul>
<li><p>域名（主机名）</p>
<ul>
<li><p>概念：应用层用于==标识主机==的方式</p>
<ol>
<li>传输层：采用 IP 地址标识主机；端口号标识进程</li>
<li>网络层：采用 IP 地址标识主机；</li>
<li>数据链路层：采用 MAC 地址标识主机</li>
</ol>
</li>
<li><p>格式：==三级域名 + 二级域名 + 顶级域名==</p>
<ol>
<li>根域名：<code>.</code>（默认情况下不写：域名后加上 <code>.</code> 仍然是可以访问的）</li>
<li>顶级域名<ul>
<li>国家顶级域名：cn us uk</li>
<li>通用顶级域名：com org net gov</li>
<li>基础结构域名：arpa</li>
</ul>
</li>
<li>二级域名：<ul>
<li>类别域名：com edu gov net org</li>
<li>行政域名：cq beijing shanghai</li>
<li>自定义域名：bilibili</li>
</ul>
</li>
<li>三级域名：www mail ftp</li>
<li>四级域名：域名需要进一步划分时使用</li>
</ol>
</li>
<li><p>图示：</p>
<ul>
<li>举例</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210412144024007.png" alt="image-20210412144024007"></p>
<ul>
<li><p>划分</p>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210412144113902.png" alt="image-20210412144113902"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>DNS 协议：</p>
<ul>
<li>引入：传输层和网络层使用 ==IP 地址==才能够确定主机在网络中的位置，而应用层使用 ==域名== 确定，显然需要映射关系进行转化</li>
<li>定义：将应用层的==域名==（主机名）根据==映射关系==转换到 ==IP 地址==</li>
<li>相关协议：<ul>
<li>UDP 协议 端口 53：用于传输 DNS 请求和响应报文</li>
<li>DHCP 协议：获取本地 DNS 服务器的 IP 地址</li>
</ul>
</li>
</ul>
</li>
<li><p>DNS 服务器：</p>
<ul>
<li><p>定义：==查找== 域名 和 IP 地址 ==映射关系== 的服务器（运行在 BIND 软件的 UNIX 机器）</p>
<p>  <a style="color:red;">注：DNS 服务器 和 DNS 数据库是两个东西，服务器负责在数据库中查找所需的映射关系，并不存储映射关系</a></p>
</li>
<li><p>功能：</p>
<ol>
<li><p>查找映射关系</p>
</li>
<li><p>查找主机规范名：根据主机别名查找主机规范名及其 IP 地址</p>
<ul>
<li>主机别名：简短的主机规范名；举例：bilibili.com</li>
<li>主机规范名：完整的域名格式；举例：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://www.bilibili.com/" >www.bilibili.com</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ul>
</li>
<li><p>负载分配：多个 IP 地址的==集合映射一个域名==</p>
<ul>
<li>网站过于繁忙时需要多台服务器进行分布式处理</li>
<li>每台服务器都运行在不同的端系统上，实际的 IP 地址也是不一样的</li>
<li>每次通过域名访问网站时，实际访问的可能是不同的 IP 地址</li>
</ul>
<p> <a style="color:red;">注：一个 IP 地址可以对应多个 域名；一个域名也可以对应多个 IP 地址</a></p>
</li>
</ol>
</li>
<li><p>分类：</p>
<ul>
<li><p>根域名服务器</p>
<ol>
<li>全世界共有 400 多台根域名服务器，但是只有 13 个域名（13 个 组织管理）</li>
<li>根域名服务器==只==返回==顶级域名服务器的 IP 地址==，不会返回查询的域名的 IP 地址</li>
</ol>
  <figure class="highlight html"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ipconfig/displaydns --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 13 台根服务器的 域名 和 IP 地址 --&gt;</span></span><br><span class="line">	记录名称. . . . . . . : a.gtld-servers.net</span><br><span class="line">    A (主机)记录  . . . . : 192.5.6.30</span><br><span class="line"></span><br><span class="line">    记录名称. . . . . . . : b.gtld-servers.net</span><br><span class="line">    A (主机)记录  . . . . : 192.33.14.30</span><br><span class="line"></span><br><span class="line">    记录名称. . . . . . . : c.gtld-servers.net</span><br><span class="line">    A (主机)记录  . . . . : 192.26.92.30</span><br><span class="line"></span><br><span class="line">    记录名称. . . . . . . : d.gtld-servers.net</span><br><span class="line">    A (主机)记录  . . . . : 192.31.80.30</span><br><span class="line"></span><br><span class="line">    记录名称. . . . . . . : e.gtld-servers.net</span><br><span class="line">    A (主机)记录  . . . . : 192.12.94.30</span><br><span class="line"></span><br><span class="line">    记录名称. . . . . . . : f.gtld-servers.net</span><br><span class="line">    A (主机)记录  . . . . : 192.35.51.30</span><br><span class="line"></span><br><span class="line">    记录名称. . . . . . . : g.gtld-servers.net</span><br><span class="line">    A (主机)记录  . . . . : 192.42.93.30</span><br><span class="line"></span><br><span class="line">    记录名称. . . . . . . : h.gtld-servers.net</span><br><span class="line">    A (主机)记录  . . . . : 192.54.112.30</span><br><span class="line"></span><br><span class="line">    记录名称. . . . . . . : i.gtld-servers.net</span><br><span class="line">    A (主机)记录  . . . . : 192.43.172.30</span><br><span class="line"></span><br><span class="line">    记录名称. . . . . . . : j.gtld-servers.net</span><br><span class="line">    A (主机)记录  . . . . : 192.48.79.30</span><br><span class="line"></span><br><span class="line">    记录名称. . . . . . . : k.gtld-servers.net</span><br><span class="line">    A (主机)记录  . . . . : 192.52.178.30</span><br><span class="line"></span><br><span class="line">    记录名称. . . . . . . : l.gtld-servers.net</span><br><span class="line">    A (主机)记录  . . . . : 192.41.162.30</span><br><span class="line"><span class="comment">&lt;!-- 还有一台 m.gtld-servers.net 服务器 --&gt;</span></span><br></pre></td></tr></table></div></figure></li>
<li><p>顶级域名服务器：顶级域名只会返回权威域名服务器的 IP 地址，不会返回查询的域名对应的 IP 地址</p>
</li>
<li><p>权威域名服务器：返回查询的域名对应的 IP 地址</p>
</li>
<li><p>本地域名服务器：</p>
<ol>
<li>每个 ISP 中都有一个本地域名服务器</li>
<li>每个本地域名服务器和客户端相隔很近（几个路由器） -&gt; 同一个局域网中</li>
<li>可以直接返回查询的域名对应的 IP 地址</li>
</ol>
</li>
</ul>
</li>
<li><p>高速缓存：DNS 查询得到的映射关系存储在缓存中</p>
<ul>
<li>浏览器缓存：浏览器短时间内容会缓存 DNS 映射（Chrome 大约几分钟）</li>
<li>操作系统缓存：客户端在开机后会从本地域名服务器中的缓存进行下载得到 DNS 映射（关机后缓存消失）</li>
<li>hosts 文件：文件形式存储 DNS 映射；可以在 hosts 文件中写死映射关系，如果写错很有可能打开不了网站</li>
<li>本地域名服务器缓存<ol>
<li>每次 DNS 查询后都会返回 DNS 映射，本地域名服务器都会进行缓存（大约几天）</li>
<li>存储的映射包括：==DNS 服务器的域名对应的 IP 地址==，==查询的域名的对应的 IP 地址==</li>
</ol>
</li>
</ul>
</li>
<li><p>查找过程</p>
<ol>
<li><p>浏览器==先解析 URL 地址== -&gt; 得到需要访问的域名</p>
</li>
<li><p>浏览器==检查浏览器缓存==中是否存储该域名的 IP 地址：</p>
</li>
<li><p>浏览器==检查操作系统缓存==中是否存储该域名的 IP 地址</p>
</li>
<li><p>浏览器==检查 hosts 文件==中是否存储过该域名的 IP 地址</p>
<p> 如果上述缓存查询中都没有找到 IP 地址，浏览器会==调用 DNS 程序发送 DNS 请求==</p>
</li>
<li><p>本地域名服务器接收 DNS 请求</p>
<ul>
<li>检查高速缓存中是否存储对应的 IP 地址，如果存储过那么直接返回</li>
<li>如果高速缓存中没有存储对应的 IP 地址，那么发送 DNS 请求给==根域名服务器==进行处理</li>
</ul>
<p> <a style="color:red;">注：这里使用的是递归查询</a></p>
</li>
<li><p>根域名服务器接收 DNS 请求，返回给本地域名服务器==对应的顶级域名服务器的 IP 地址==（DNS 响应）</p>
</li>
<li><p>本地域名服务器再次向顶级域名服务器发送 DNS 请求</p>
</li>
<li><p>顶级域名服务器接收 DNS 请求，返回给本地域名服务器==对应的权威域名服务器的 IP 地址==</p>
</li>
<li><p>本地域名服务器再次向权威域名服务器发送 DNS 请求</p>
</li>
<li><p>权威域名服务器返回查询的域名对应的 IP 地址</p>
</li>
</ol>
<p>  <a style="color:red;">注：整个过程采用的迭代查询；DNS 查询过程是迭代和递归混合使用的</a></p>
</li>
</ul>
</li>
</ul>

        <h3 id="FTP-协议"   >
          <a href="#FTP-协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#FTP-协议" class="headerlink" title="FTP 协议"></a>FTP 协议</h3>
      <ul>
<li><p>概念：提供不同种类主机系统之间==传输文件==的能力</p>
</li>
<li><p>分类：</p>
<ul>
<li>文件传送协议 FTP</li>
<li>简单文件传送协议 TFTP</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>基于客户端/服务器（==C/S==）的传送方式</li>
<li>基于 TCP 协议实现文件传输</li>
</ul>
</li>
<li><p>传输过程</p>
<ul>
<li><p>连接建立</p>
<ol>
<li>登陆 FTP 服务器<ul>
<li>用户名 + 密码登陆</li>
<li>匿名登录：部分公共 FTP 服务器访问的人数过大，不需要经过注册取得 FTP 服务器授权就可以直接进入 FTP 服务器下载文件</li>
</ul>
</li>
<li>FTP 服务器 ==主进程== 打开熟知端口 21，建立 TCP ==控制连接==</li>
</ol>
<p>  <a style="color:red;">注：主进程只有一个</a></p>
</li>
<li><p>文件传输</p>
<ol>
<li>控制连接建立后接收到 FTP 客户端下载文件的请求，打开==端口号==，建立 TCP ==数据连接==</li>
<li>数据连接建立后，FTP 服务器开始向 FTP 客户端传送文件</li>
<li>文件传送完毕后，==数据连接关闭==，==控制连接暂时不关闭==</li>
<li>FTP 客户端如果需要继续下载文件，那么再次打开端口号，建立 TCP 数据连接进行传送</li>
<li>FTP 客户端如果不需要再下载文件，那么关闭控制连接，即连接释放</li>
</ol>
</li>
<li><p>连接释放</p>
</li>
<li><p>数据连接端口号：根据传输模式而定，主动方式采用端口号 20；被动方式端口号 &gt; 1024，客户端和服务器协商决定</p>
</li>
</ul>
</li>
</ul>

        <h3 id="SMTP-协议"   >
          <a href="#SMTP-协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#SMTP-协议" class="headerlink" title="SMTP 协议"></a>SMTP 协议</h3>
      <ul>
<li><p>概念：为==电子邮件系统==提供服务</p>
</li>
<li><p>电子邮件系统</p>
<ul>
<li>组成：<ul>
<li>用户代理<ol>
<li>提供用户阅读，回复，编写，保存邮件的功能</li>
<li>发送方和接收方都具有用户代理</li>
</ol>
</li>
<li>邮件服务器<ol>
<li>提供==接收和发送邮件==的功能</li>
<li>发送方和接收方都具有邮件服务器</li>
<li>发送方的用户代理将邮件发送给发送方的邮件服务器</li>
<li>邮件服务器发送邮件==不成功==，向发送方用户代理==报告发送失败==</li>
<li>邮件服务器不是专属的，是多个用户==共享==的</li>
</ol>
</li>
<li>简单邮件传输协议（SMTP）<ol>
<li>SMTP 建立在 TCP 协议之上 -&gt; ==端口号 25==</li>
<li>SMTP 规定两个电子邮件系统之间如何交换信息</li>
<li>SMTP 不会借助中间邮件服务器传递邮件 -&gt; 两台邮件服务器是==直接连接==</li>
<li>SMTP 采用  ASCII 7位比特编码 -&gt; 不能够传送二进制数据文件或者音视频文件 -&gt; 需要转码才能够进行发送</li>
<li>SMTP 采用持续连接 -&gt; 同一个 TCP 连接中可以传递多份邮件</li>
<li>SMTP 细节<ul>
<li>连接建立：SMTP 客户端发送 HELLO 命令 -&gt; SMTP 服务器返回 220 准备建立连接</li>
<li>邮件传输：<ul>
<li>SMTP 客户端发送 MAIL FROM + 发送方地址 -&gt; SMTP 服务器返回 250 -&gt; 能够接收邮件；不能够接收返回 421</li>
<li>SMTP 客户端发送 RCPT TO + 接收方地址 -&gt; SMTP 服务器返回 250</li>
<li>SMTP 客户端发送 DATA （客户端准备发送数据）-&gt; SMTP 返回 354 同意发送；让客户端发送 <code>.</code> 表示数据发送完成</li>
<li>SMTP 客户端发送 Date -&gt; SMTP 服务器返回 250 接收完成  </li>
</ul>
</li>
<li>连接释放：邮件发送完成 -&gt; SMTP 客户端发送 QUIT 命令 -&gt; SMTP 服务器返回 221 -&gt; 断开连接</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>发送过程：<ol>
<li>发送方==用户代理==和发送方==邮件服务器==之间建立 TCP 连接</li>
<li>发送方采用 ==SMTP 协议==将邮件发送到发送方的邮件服务器</li>
<li>邮件到达邮件服务器后==在队列中等待==服务器发送</li>
<li>发送方邮件服务器和接收方邮件服务器之间==建立 TCP 连接==</li>
<li>发送方邮件服务器采用 ==SMTP 协议==发送邮件到接收方的邮件服务器<ul>
<li>如果发送成功，那么邮件保存在接收方的邮件服务器中，等待接收方用户代理采取 ==POP3 协议==读取邮件</li>
<li>如果发送失败，那么发送方邮件服务器会再次尝试发送，如果多次尝试后仍然发送失败，那么会报告发送方用户代理</li>
</ul>
</li>
</ol>
</li>
<li>图示：</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210413173141269.png" alt="image-20210413173141269"></p>
</li>
</ul>

        <h3 id="POP3-协议"   >
          <a href="#POP3-协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#POP3-协议" class="headerlink" title="POP3 协议"></a>POP3 协议</h3>
      <ul>
<li>概念：为用户代理获取邮件服务器中的邮件提供服务</li>
<li>内容<ul>
<li>POP3 建立在 TCP 协议之上 -&gt; ==端口号 110==</li>
<li>POP3 细节<ol>
<li>特许：用户代理登陆邮件服务器 -&gt; 邮件服务器允许其获取邮件</li>
<li>事务处理：用户代理对邮件服务器中的邮件进行处理 <ul>
<li>获取邮件后是否在邮件服务器中删除该邮件</li>
</ul>
</li>
<li>更新：用户代理结束会话后执行删除操作</li>
</ol>
</li>
</ul>
</li>
</ul>

        <h3 id="IMAP-协议"   >
          <a href="#IMAP-协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#IMAP-协议" class="headerlink" title="IMAP 协议"></a>IMAP 协议</h3>
      
        <h3 id="HTTP-协议"   >
          <a href="#HTTP-协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3>
      <p><em>详情见 JavaWeb 笔记</em></p>

        <h2 id="网络应用模型"   >
          <a href="#网络应用模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h2>
      <ul>
<li>客户端-服务器模型<ul>
<li>概念：<ul>
<li>客户端</li>
<li>服务器</li>
</ul>
</li>
<li>优点</li>
<li>缺点</li>
</ul>
</li>
<li>P2P 模型<ul>
<li>概念：</li>
<li>执行过程：</li>
<li>优点</li>
<li>缺点</li>
<li>应用：BitTorrent</li>
</ul>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/09/network/%E7%89%A9%E7%90%86%E5%B1%82/">物理层</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-11</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="物理层"   >
          <a href="#物理层" class="heading-link"><i class="fas fa-link"></i></a><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1>
      
        <h2 id="物理层基本概念"   >
          <a href="#物理层基本概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#物理层基本概念" class="headerlink" title="物理层基本概念"></a>物理层基本概念</h2>
      
        <h3 id="物理层功能"   >
          <a href="#物理层功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#物理层功能" class="headerlink" title="物理层功能"></a>物理层功能</h3>
      <ul>
<li>机械特性：<strong>规定</strong>实现物理连接的各种设备的<strong>参数大小</strong></li>
<li>电器特性：<strong>规定</strong>传输二进制比特时的<strong>电压范围</strong>等参数</li>
<li>功能特性：<strong>规定</strong>线路上不同电压的<strong>含义</strong></li>
<li>规程特性：<strong>规定</strong>各条线路<strong>工作规程和时序关系</strong></li>
</ul>

        <h3 id="物理媒体"   >
          <a href="#物理媒体" class="heading-link"><i class="fas fa-link"></i></a><a href="#物理媒体" class="headerlink" title="物理媒体"></a>物理媒体</h3>
      <p>两者的区别：</p>
<p>物理层是规定实现数据传输的线路的参数，并不涉及实际的传输过程</p>
<p>物理媒体则是真正实现了数据的传输，一般将物理媒体视为第 0 层</p>

        <h2 id="数据通信基本知识"   >
          <a href="#数据通信基本知识" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据通信基本知识" class="headerlink" title="数据通信基本知识"></a>数据通信基本知识</h2>
      
        <h3 id="基本知识"   >
          <a href="#基本知识" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3>
      <p><img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303164612112.png" alt="image-20210303164612112"></p>
<ul>
<li><p>信号</p>
<ul>
<li>数字信号：传输的是<strong>离散</strong>的参数</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303165144337.png" alt="image-20210303165144337"></p>
<ul>
<li>模拟信号：传输的是<strong>连续</strong>的参数</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303165314973.png" alt="image-20210303165314973"></p>
</li>
<li><p>信道</p>
<ul>
<li><p>概念：信号的传输媒介；一条通信路通畅包含一条<strong>发送信道</strong>和一条<strong>接收信道</strong></p>
</li>
<li><p>分类</p>
<ul>
<li>传输信号分类：数字信道；模拟信道</li>
<li>传输介质分类：无线信道；有线信道</li>
</ul>
</li>
<li><p>通信方式</p>
<ul>
<li><p>单工通信：只有一个方向的通信没有反方向的交互</p>
<p>  计算机 A 只能作为发送方；计算机 B 只能作为接收方；只需要使用<strong>一条发送信道</strong></p>
</li>
<li><p>半双工通信：通信的双方都可以作为接收或者发送方，但是不能够同时既作为接收方又作为发送方</p>
<p>  计算机 A 作为发送方，计算机 B 就只能作为接收方；两者可以对调；需要使用<strong>两条信道</strong> </p>
</li>
<li><p>双工通信：通信的双方可以同时作为接收方和发送方</p>
<p>  计算机 A 在作为发送方的同时可以接收来自计算机 B 发送的内容；需要使用<strong>两条信道</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>传输方式</p>
<ul>
<li>串行<ul>
<li>适用情况：速度慢，适合远距离传递，费用低</li>
</ul>
</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303170350034.png" alt="image-20210303170350034"></p>
<ul>
<li><p>并行</p>
<ul>
<li><p>适用情况：速度快，适合近距离传递，费用高</p>
<p>  打印机和传真机会使用这种方式传输</p>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303170516864.png" alt="image-20210303170516864"></p>
</li>
</ul>
</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303170358246.png" alt="image-20210303170358246"></p>
</li>
</ul>

        <h3 id="性能指标"   >
          <a href="#性能指标" class="heading-link"><i class="fas fa-link"></i></a><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3>
      
        <h4 id="码元"   >
          <a href="#码元" class="heading-link"><i class="fas fa-link"></i></a><a href="#码元" class="headerlink" title="码元"></a>码元</h4>
      <p><img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303171608082.png" alt="image-20210303171608082"></p>
<ul>
<li><p>概念：一个<strong>固定时长</strong>的<strong>信号</strong>波形（数字脉冲）</p>
</li>
<li><p><strong>一个码元可以携带多个比特</strong></p>
</li>
<li><p>码元的离散状态有 M 种时：每个码元携带的比特数量 = log<del>2</del> M </p>
<p>  16 进制码元：0000 表示一种码元，0001 表示另外一种码元…所以每个码元是四个比特</p>
</li>
</ul>

        <h4 id="速率"   >
          <a href="#速率" class="heading-link"><i class="fas fa-link"></i></a><a href="#速率" class="headerlink" title="速率"></a>速率</h4>
      <ul>
<li>码元传输速率<ul>
<li>单位：波特（Baud）</li>
<li>概念：单位时间内传输的码元的个数（<strong>脉冲个数或者信号变化的次数</strong>）</li>
<li>码元传输速率和进制无关</li>
</ul>
</li>
<li>信息传输速率<ul>
<li>单位：bite（bit）</li>
<li>和码元传输速率的关系：<strong>每个码元携带的比特数 * 码元的个数</strong> = 信息传输速率</li>
</ul>
</li>
</ul>

        <h2 id="编码和调制"   >
          <a href="#编码和调制" class="heading-link"><i class="fas fa-link"></i></a><a href="#编码和调制" class="headerlink" title="编码和调制"></a>编码和调制</h2>
      
        <h3 id="信道上传输的信号"   >
          <a href="#信道上传输的信号" class="heading-link"><i class="fas fa-link"></i></a><a href="#信道上传输的信号" class="headerlink" title="信道上传输的信号"></a>信道上传输的信号</h3>
      <ul>
<li>基带信号<ul>
<li>概念：信源发出的<strong>没有</strong>经过<strong>调制</strong>的信号（模拟或者数字信号）</li>
<li>传输距离较近时，计算机网络都采用基带传输方式</li>
</ul>
</li>
<li>宽带信号<ul>
<li>概念：是将<strong>基带信号</strong>进行<strong>调制</strong>后形成的<strong>频分复用模拟信号</strong></li>
<li>主要用于网络电视和有线电视的视频广播</li>
</ul>
</li>
</ul>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/zzsfqiuyigui/article/details/8986805" >基带信号和宽带信号</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h3 id="编码"   >
          <a href="#编码" class="heading-link"><i class="fas fa-link"></i></a><a href="#编码" class="headerlink" title="编码"></a>编码</h3>
      <ul>
<li><p>概念：<strong>数字数据</strong>和<strong>模拟数据</strong>转换为<strong>数字信号</strong>的过程称为编码</p>
</li>
<li><p>数字数据编码为数字信号</p>
<ul>
<li><p>非归零编码</p>
<ul>
<li><p>概念：最简单的一种编码形式；使用高电压代表 1；低电压代表 0</p>
</li>
<li><p>缺陷：收发双方难以保持同步</p>
<p>  如果二进制数据都是 1 或者 0，那么数字信号就是一条直线，接收方无法解析数字信号；需要借助辅助的信道知道每个码元的长度，用总长度除以每个码元的长度进行分段</p>
</li>
</ul>
</li>
<li><p>归零编码</p>
<ul>
<li>概念：在一个码元内电压无论是否变化，最终都要变为低电压</li>
<li>缺陷：信道中的电压长时间都处于低电压状态，利用率偏低</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303210939257.png" alt="image-20210303210939257"></p>
</li>
<li><p>反向不归零编码</p>
<ul>
<li><p>概念：二进制数据 0 代表电压翻转（翻转是指和之前的前一个电压相反），二进制数据 1 代表不翻转</p>
<p>  区别于前两种高电压不代表 1，低电压不代表 0</p>
</li>
<li><p>缺陷：二进制数据全为 1 时数字信号为一条直线</p>
</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303211420795.png" alt="image-20210303211420795"></p>
</li>
<li><p>曼切斯特编码</p>
<ul>
<li><p>概念：一个码元划分成两个相等的间隔；前半为高电压，后半为低电压，表示二进制数据 1；前半为低电压，后半为高电压，表示二进制数据 0 </p>
</li>
<li><p>特点：数据传输速率（比特传输的速率）是调制速率（码元传输速率）的 1/2</p>
<p>  码元传输速率可以按照单位时间脉冲信号的个数进行计算；曼切斯特编码中一个码元有两次脉冲信号，所以这里的码元传输速率是 2Baud，但是实际的比特只传输了 1bit</p>
</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303211613404.png" alt="image-20210303211613404"></p>
</li>
<li><p>差分曼切斯特编码</p>
<ul>
<li>概念：根据两个码元判断；前一个码元的后半部分和当前码元的前半部分相同，表示二进制数据 1；相反则表示0</li>
<li>特点：抗干扰性强于曼切斯特编码编码</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303212442509.png" alt="image-20210303212442509"></p>
</li>
</ul>
</li>
<li><p>数字数据编码为模拟信号</p>
<ul>
<li><p>调幅（2ASK）</p>
<ul>
<li>概念：对于二进制数据 0 和 1 设计不同的振幅大小；频率和相位不发生改变</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303212818673.png" alt="image-20210303212818673"></p>
</li>
<li><p>调频（2FSK）</p>
<ul>
<li>概念：对于二进制数据 0 和 1设计不同的振动频率；振幅和相位不发生变化</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303213144115.png" alt="image-20210303213144115"></p>
</li>
<li><p>调相（2PSK）</p>
<ul>
<li>概念：对于二进制数据 0 和 1 设计不同的相位；振幅和频率不发生变化</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303213153308.png" alt="image-20210303213153308"></p>
</li>
<li><p>QAM(调相 + 调幅)</p>
<ul>
<li><p>例子：4 个相位，每个相位 4 个振幅</p>
<p>  每个相位 可以 匹配 4 种不同的振幅，那么就会出现 4 种不同的码元，所以最后是 16 种码元</p>
</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li><p>这里只涉及到每个码元携带一个比特的情况，所以是2XSK；如果携带的比特数更多，那么设计的不同振幅，不同频率，不同相位也会更多</p>
</li>
<li><p>相位：对于二进制而言，0对应的是余弦波，1对应的是正弦波，所以每个波的起始点的斜率是相反的</p>
<p>  如果是携带的比特数越多，那么相位越多，超出 3 个相位基本是不可能在图上画出来的</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>模拟数据编码为数字信号</p>
<ul>
<li><p>抽样：将连续的模拟信号转为离散的信号；遵循的采样规则：f<del>采样频率</del> ≥ 2f<del>信号最高频率</del></p>
<p>  确定一个信号波，至少进行<strong>两次采样</strong>就可以得到信号波形状，如果对信号频率比较小的波进行两次采样，很有可能导致<strong>信号频率高的信号波无法被识</strong>别出来</p>
</li>
<li><p>量化：将每个离散的信号按照分级标度转化的<strong>整数数字</strong></p>
</li>
<li><p>编码：将整数数字进行<strong>二进制编码</strong></p>
</li>
</ul>
</li>
<li><p>模拟数据编码为模拟信号</p>
<ul>
<li>目的：防止模拟信号因为衰减过多导致最后无法识别，所以通过放大增强模拟信号</li>
</ul>
</li>
</ul>

        <h3 id="调制"   >
          <a href="#调制" class="heading-link"><i class="fas fa-link"></i></a><a href="#调制" class="headerlink" title="调制"></a>调制</h3>
      
        <h2 id="奈氏准则和香农定理"   >
          <a href="#奈氏准则和香农定理" class="heading-link"><i class="fas fa-link"></i></a><a href="#奈氏准则和香农定理" class="headerlink" title="奈氏准则和香农定理"></a>奈氏准则和香农定理</h2>
      
        <h3 id="码间串扰"   >
          <a href="#码间串扰" class="heading-link"><i class="fas fa-link"></i></a><a href="#码间串扰" class="headerlink" title="码间串扰"></a>码间串扰</h3>
      <ul>
<li>失真：发送的信号在信道中的传播受到噪声的干扰，导致最后无法被解析的现象<ul>
<li>影响因素：码元传输速率；信号传输的距离；噪声干扰；传输媒体的质量</li>
</ul>
</li>
<li>码间串扰：（失真的一种现象）接收端收到的信号波形<strong>每个码元之间没有清晰的界限</strong></li>
<li>信道带宽：信道能够通过的信号的最高频率与信号的最低频率之差</li>
</ul>

        <h3 id="奈氏准则"   >
          <a href="#奈氏准则" class="heading-link"><i class="fas fa-link"></i></a><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h3>
      <ul>
<li>适用情况：宽带受限，不受噪声影响的情况</li>
<li>公式：2Wlog<del>2</del>V<ul>
<li>W 指的是宽带的 Hz 大小</li>
<li>V 指的是码元的种数</li>
</ul>
</li>
<li>特点<ul>
<li>奈氏准则给出了<strong>码元传输速率</strong>的极限，没有给出信息传输速率的极限</li>
<li>码元的传输速率是有极限的，所以提高的信息传输速率的方式就是让每个码元携带更多的比特</li>
</ul>
</li>
</ul>

        <h3 id="香农定理"   >
          <a href="#香农定理" class="heading-link"><i class="fas fa-link"></i></a><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h3>
      <ul>
<li>适用情况：宽带受限，受到噪声影响的情况</li>
<li>公式：Wlog<del>2</del>（1 + S/N）<ul>
<li>W 指的是宽带的 Hz 大小</li>
<li>S/N 是信噪比<ul>
<li>10*log<del>10</del>S/N = dB </li>
</ul>
</li>
</ul>
</li>
<li>特点<ul>
<li>只要信息的传输速率小于极限的信息传输速率，那么一定能够找到一种<strong>无差错的传输</strong></li>
</ul>
</li>
</ul>

        <h3 id="对比"   >
          <a href="#对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#对比" class="headerlink" title="对比"></a>对比</h3>
      <p>如果在非理想低通的情况下，两个公式都可以采用，选择两者中极限信息传输速率较小的那个</p>

        <h2 id="设备"   >
          <a href="#设备" class="heading-link"><i class="fas fa-link"></i></a><a href="#设备" class="headerlink" title="设备"></a>设备</h2>
      
        <h3 id="中继器"   >
          <a href="#中继器" class="heading-link"><i class="fas fa-link"></i></a><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h3>
      
        <h3 id="集线器"   >
          <a href="#集线器" class="heading-link"><i class="fas fa-link"></i></a><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/09/network/%E6%A6%82%E8%BF%B0/">概述</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-09</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h1>
      
        <h2 id="概念"   >
          <a href="#概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#概念" class="headerlink" title="概念"></a>概念</h2>
      
        <h3 id="定义"   >
          <a href="#定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#定义" class="headerlink" title="定义"></a>定义</h3>
      <ul>
<li><p>定义：计算机网络是将多个 [分散独立]{.red} 的计算机系统，通过 [通信设备]{.red} 和 [通信链路]{.red} 连接起来，并且利用软件实现 [资源共享]{.red} 和 [数据传递]{.red} 的系统</p>
<p>  [互联网是 <strong>互联自治</strong> 的计算机集合]{.red}</p>
</li>
<li><p>通信设备</p>
<ul>
<li><p><a href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA">链路层交换机</a> (Link-Layer Switch)  链路层交换机通常称为交换机</p>
</li>
<li><p><a href="#%E8%B7%AF%E7%94%B1%E5%99%A8">路由器</a> (Router)</p>
<p>  注：(1) 链路层交换机和路由器被统称为交换机 (2) 链路层交换机位于 <a href="#%E6%8E%A5%E5%85%A5%E7%BD%91">接入网</a> 而路由器位于 <a href="#%E7%BD%91%E7%BB%9C%E6%A0%B8%E5%BF%83">网络核心</a></p>
</li>
</ul>
</li>
<li><p>通信链路：又称为 <a href="#%E6%8E%A5%E5%85%A5%E7%BD%91">物理媒介</a> 或者 <a href="#%E6%8E%A5%E5%85%A5%E7%BD%91">接入网</a></p>
<ul>
<li>双绞线：(1) 屏蔽双绞线 (2) 非屏蔽双绞线</li>
<li>同轴电缆</li>
<li>光纤</li>
</ul>
</li>
<li><p>数据传递：互联网中的所有数据都可以称为 [分组]{.red} ；每层也有自己具体的数据单位</p>
<ul>
<li><a href="#%E7%AC%AC%E5%85%AD%E7%AB%A0">应用层</a>：报文</li>
<li><a href="#%E7%AC%AC%E4%BA%94%E7%AB%A0">传输层</a>：报文段</li>
<li><a href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0">网络层</a>：数据报</li>
<li><a href="#%E7%AC%AC%E4%B8%89%E7%AB%A0">数据链路层</a>：帧</li>
<li>物理层：比特</li>
</ul>
</li>
</ul>

        <h3 id="功能"   >
          <a href="#功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#功能" class="headerlink" title="功能"></a>功能</h3>
      <ul>
<li><p>[数据通信]{.red}：借助计算机网络的 [连通性]{.red}，将数据从当前计算机系统 [传递]{.red} 到其他的计算机系统</p>
</li>
<li><p>[资源共享]{.red}：硬件 + 软件 + 数据</p>
<p>  注：资源共享并不只是共享数据；借助计算机网络硬件和软件同样可以共享</p>
</li>
<li><p>分布式处理：各台计算机承担同一工作的不同部分</p>
</li>
<li><p>提高可靠性：当前计算机系统宕机后，使用代替机继续完成当前工作</p>
</li>
<li><p>负载均衡：调整不同计算机系统之间的工作</p>
</li>
</ul>

        <h3 id="组成"   >
          <a href="#组成" class="heading-link"><i class="fas fa-link"></i></a><a href="#组成" class="headerlink" title="组成"></a>组成</h3>
      <ul>
<li><p>前提：计算机网络的组成可以按照三种方式看：(1) 从实际的内容看(组成部分) (2) <a href="#%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F">从实际运行方式来看</a> (3) 从实际的功能来看(功能组成)</p>
</li>
<li><p>组成部分：</p>
<ul>
<li><p>软件：运行在端系统上的各种软件</p>
</li>
<li><p>硬件：端系统 + 适配器 + 通信链路 + 通信设备</p>
<p>  注：端系统又称为主机；端系统可以分为两类：(1) 客户端(个人电脑) (2) 服务器(大型机)</p>
</li>
<li><p>协议：[规定了两个或者多个通信实体之间交换报文的格式和顺序，以及发送报文和接收报文等其他事件需要采取的动作]{.red}</p>
<p>  注：协议是计算机网络的核心；协议仅仅只是规定，真正的实现是由各种各样的硬件实现的，这些硬件需要遵循协议规定的内容</p>
</li>
</ul>
</li>
<li><p>功能组成：<a href="#%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84">分层结构</a></p>
</li>
</ul>

        <h4 id="工作方式"   >
          <a href="#工作方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4>
      <img src="https://i1.xpic.jp/file/xpicjp/2021/06/09/17a785f65128b91281140180321346ed.png" alt="17a785f65128b91281140180321346ed.png" style="zoom:80%;" />


        <h5 id="网络边缘"   >
          <a href="#网络边缘" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h5>
      <ul>
<li>定义：位于网络边缘的通常都是端系统：各式各样的个人电脑，移动端设备，以及大型数据中心</li>
<li>通信方式：P2P C/S</li>
<li>细节：网络边缘的设备从网络核心中获取相应的的网络服务</li>
</ul>

        <h5 id="接入网"   >
          <a href="#接入网" class="heading-link"><i class="fas fa-link"></i></a><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h5>
      <ul>
<li><p>定义：将端系统 [物理连接]{.red} 到网络核心中的边缘路由器的网络</p>
<ul>
<li>物理连接：说白了就是装网线的</li>
<li><a href="%E7%AC%AC%E5%9B%9B%E7%AB%A0">边缘路由器</a></li>
</ul>
</li>
<li><p>接入方式</p>
<ul>
<li><p>家庭接入：</p>
<ul>
<li><p>DSL (全称：Digital Subscribe Line 俗称：宽带)：</p>
<ul>
<li>接入：每个用户将自己的 [DSL 调制解调器]{.red} 使用 [双绞线]{.red} 连接到本地电话公司的 [复用器]{.red} (DSLAM) 中</li>
<li>调制解调器（俗称：猫(Modem)）：[用于数字信号和模拟信号的相互转换]{.red}</li>
<li>双绞线：传统的电话线，[只能够传输模拟信号]{.red}</li>
<li>复用器：就是可以接入多个用户的调制解调器</li>
<li>[DSL 接入的上行速率和下行速率不相等，这种接入被称为不对称的接入（ADSL 接入）]{.red}</li>
<li>DSL 使用 <a href="#%E9%93%BE%E8%B7%AF%E7%AE%A1%E7%90%86">FDM</a>(频分复用技术)：用户的多个设备可以共享同一通信链路</li>
</ul>
</li>
<li><p>拨号上网：(1) 可以看做没有使用频分复用技术的 DSL 接入 (2) 速率非常慢</p>
</li>
<li><p>电缆接入：</p>
<ul>
<li>接入：每个用户将自己的 [电缆调制解调器]{.red} 使用 [同轴电缆]{.red} 连接到本地有线电视公司的 [电缆调制解调器]{.red} (CMTS)  中</li>
<li>[电缆接入通常采用的也是不对称的接入]{.red}</li>
<li>电缆接入最重要的特征：[共享广播媒体]{.red}（需要使用 <a href="#%E9%93%BE%E8%B7%AF%E7%AE%A1%E7%90%86">信道访问控制</a> 来解决，否则实际下行速率会远低于理想的下行速率）</li>
</ul>
</li>
<li><p>光纤接入(FTTH)：</p>
<p>  (1) ISP 直接将光纤接入到每个用户的位置（每个用户独占一根光纤） (2) ISP 直到接近每个用户时才将光纤分开接入到每个用户 (多个用户共享一个光纤)</p>
</li>
</ul>
</li>
<li><p>企业接入</p>
<ul>
<li><a href="#%E4%BB%A5%E5%A4%AA%E7%BD%91">以太网接入</a></li>
<li>WiFi 接入：使用非导向性质的媒介：无线电波接入</li>
</ul>
</li>
<li><p>广域无线接入：4G 5G 都属于广域无线接入</p>
</li>
</ul>
</li>
<li><p>物理媒介</p>
<ul>
<li><p>导向性质媒介</p>
<ul>
<li><p>双绞线(Twisted Pair)：(1) 非屏蔽双绞线(UTP) (2) 屏蔽双绞线(STP)</p>
<p>  注：10Mbps 传统电话线([3类双绞线]{.blue}) ； 100Mbps 以太网 ([5类双绞线]{.blue}) ；1Gbps 吉比特以太网（[6类双绞线]{.blue}）</p>
</li>
<li><p>同轴电缆(Coaxial cable)：(1) 2类同轴电缆(10BASE-2) (2) 5类同轴电缆(10BASE-5)</p>
</li>
<li><p>光纤：(1) 单模光纤 (2) 多模光纤</p>
</li>
</ul>
</li>
<li><p>非导向性质媒介：无线电波，微波，红外线</p>
</li>
</ul>
</li>
</ul>

        <h5 id="网络核心"   >
          <a href="#网络核心" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h5>
      <ul>
<li><p>定义：网络边缘的端系统发送分组到网络核心的交换设备中，经过多个交换设备 [交换]{.red} 送到目的端系统上</p>
</li>
<li><p>交换设备：(1) 链路层交换机 (2) 路由器</p>
</li>
<li><p>交换方式</p>
<ul>
<li><p>电路交换（Circuit Switching）：两个主机之间建立一条由多个交换设备和多条通信链路组成的 [专用线路]{.red}，报文通过专用线路传输到另一个主机上</p>
<ul>
<li><p><a href="#%E9%93%BE%E8%B7%AF%E7%AE%A1%E7%90%86">复用</a>：(1) 频分复用(FDM) (2) 时分复用(TDM) (3) 码分多址复用(CDM)</p>
<p>  注：每个频带或者每个时隙都相当于一条线路，相当于将一条完整的线路在逻辑划分成多条，可以供多个用户使用</p>
</li>
<li><p>优点：(1) 报文传输 [延时小实时性强]{.red} (2) [可靠性高]{.red} (3) [没有冲突]{.red} 产生 (4) 适用范围广</p>
</li>
<li><p>缺点：(1) 线路独占导致资源利用率低（存在静默期(Silent Period)） (2) 连接建立时间长 (3) 每个用户获得的带宽仅为总带宽的 $\frac{1}{N}$</p>
</li>
<li><p>[电路交换时 <strong>面向连接服务</strong> 的：保证了可靠传输]{.red}</p>
</li>
<li><p>电路交换发送报文采取的是直通方式不是存储转发的方式</p>
</li>
</ul>
</li>
<li><p><a href="#%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2">分组交换</a></p>
</li>
</ul>
</li>
</ul>

        <h3 id="分类"   >
          <a href="#分类" class="heading-link"><i class="fas fa-link"></i></a><a href="#分类" class="headerlink" title="分类"></a>分类</h3>
      <ul>
<li><p>按分布范围分类</p>
<ul>
<li>[广域网（WAN）]{.red}：使用 [交换技术]{.red}；连接各结点交换机的链路一般是高速电路，具有较大的通信容量；互联网是广域网的一种</li>
<li>城域网（MAN）</li>
<li>[局域网（LAN）]{.red}：使用 [广播技术]{.red}；配置的主机数量没有限制（可以达到上百台）；[工作到数据链路层，不涉及网络层]{.red}</li>
<li>个人网（PAN）：个人范围内（通常范围只有数米）的计算机设备组成的网络</li>
</ul>
</li>
<li><p>按使用者分类</p>
<ul>
<li>公网（Extranet）：中国电信 中国移动 中国联通；大众都可以付费使用的网络</li>
<li>专网（Intranet）：政府 银行 军队；只有特定的人员才能够使用的网络</li>
</ul>
</li>
<li><p>按交换技术分类</p>
<ul>
<li>电路交换</li>
<li>报文交换</li>
<li><a href="#%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2">分组交换</a></li>
</ul>
</li>
<li><p>按拓扑结构分类(逻辑拓扑 + 物理拓扑)：</p>
<ul>
<li><p>定义：描述各个端系统和通信链路的连接方式和布局，以及数据传输的路径</p>
</li>
<li><p>总线型网络：</p>
<ul>
<li>优点：(1) 建立网络容易 (2) 增删结点方便 (3) 减少成本</li>
<li>缺点：(1) 重负载时通信效率不高 (2) 总线对故障敏感</li>
</ul>
</li>
<li><p>星型网络</p>
<ul>
<li>优点：(1) 便于集中控制管理 (2) 提高流量的利用率</li>
<li>缺点：(1) 成本高 (2)单点故障</li>
</ul>
</li>
<li><p>环状型网络：(1) 单向环型：环中信号单向传输 (2) 双向环型：允许环中信号双向传输</p>
</li>
</ul>
</li>
</ul>
<pre><code>* 网状型（常用于广域网）

    * 优点：可靠性高
    * 缺点：(1) 控制复杂 (2) 线路成本高
</code></pre>
<ul>
<li><p>按传输技术分类</p>
<ul>
<li><p>广播式网络</p>
<ul>
<li>共享的公共通信信道</li>
<li>广域网中的 [卫星通信网络]{.blue} 和 [无线通信网络]{.blue} 也是采用的广播式网络</li>
</ul>
</li>
<li><p>点对点网络：</p>
<ul>
<li><p>每条物理线路都连接一对主机</p>
</li>
<li><p>使用 <a href="%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91">分组存储转发</a> 和 <a href="#%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE%E5%8F%8A%E7%AE%97%E6%B3%95">路由选择机制</a></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h2 id="互联网提供商"   >
          <a href="#互联网提供商" class="heading-link"><i class="fas fa-link"></i></a><a href="#互联网提供商" class="headerlink" title="互联网提供商"></a>互联网提供商</h2>
      
        <h2 id="性能指标"   >
          <a href="#性能指标" class="heading-link"><i class="fas fa-link"></i></a><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2>
      <ul>
<li><p>速率：单位时间内从一端传送到另一端的 [数据量]{.red}</p>
<ul>
<li>单位：bps Kbps Mbps Gbps &lt;-&gt; Bps KBps MBps GBps </li>
<li>换算：<ul>
<li>[上述单位都是以 <strong>比特</strong> 为单位的不是 <strong>字节</strong>]{.red}：需要将上述单位再除以 8 才是以字节为单位的</li>
<li>相邻两个单位之间的使用 [10^3^]{.red} 换算（也有可能是 1024）</li>
</ul>
</li>
</ul>
</li>
<li><p>带宽：</p>
<ul>
<li>定义 1：指信道具有的频度宽度：就是最高频率和最低频率之差，单位赫兹</li>
<li>定义 2：单位时间从一端传输到另一端的 [最大数据量]{.red} ([通常都是理想速率，难以达到]{.blue})</li>
</ul>
</li>
<li><p>吞吐量：单位时间内 [成功传输的数据量]{.red}（传输过程中会出现丢包等现象，实际接收的数据量可能并不是发送的数据量）</p>
<ul>
<li>[每段链路的吞吐量可能不一致]{.red}：吞吐量 = $min(R_0,R_1,R_2···R_n)$ 取最小的那个吞吐量</li>
<li>[多个用户共享信道]{.red}：每个用户的吞吐量是信道总的吞吐量的 $\frac{1}{N}$</li>
<li>[吞吐量受制于接入网或者用户的数量]{.red}</li>
</ul>
</li>
<li><p>时延：</p>
<ul>
<li><p>传输时延(propagation delay)：[分组大小 ÷ 带宽]{.red}</p>
<ul>
<li>前提：仅考虑传输时延的情况下<ul>
<li>一个分组经过 $N$ 个路由器转发到达目的地所花的时间 $d = N*\frac{L}{R}$</li>
<li>$P$ 个分组经过 $N$ 个路由器转发到达目的地所花的时间 $d= (N + P - 1)*\frac{L}{R}$ (无论 $N$ 和 $P$ 的关系如何这个公式都是成立的)</li>
</ul>
</li>
</ul>
</li>
<li><p>传播时延(transmission delay)：[信道长度 ÷ 介质传输速率]{.red}</p>
</li>
<li><p>排队时延(queuing delay)：分组在路由器队列中等待处理的时间</p>
</li>
<li><p>处理时延(processing delay)：路由器查询路由表转发的消耗时间</p>
<p>  注：通常只考虑传输时延</p>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/image-20210301143343776.4gg7k2y80ui0.png" alt="image-20210301143343776" style="zoom:80%;" />



<ul>
<li><p>时延带宽积()</p>
<ul>
<li>定义：[当前的数字信道中所存在的比特数量]{.red}；即某链路现在又多少比特</li>
<li>公式：[带宽 x 时延 = 时延带宽积]{.red}</li>
</ul>
</li>
<li><p>流量强度：</p>
<ul>
<li>定义：$\frac{L\alpha}{R}$ （$L$ 是每个分组的比特数 $\alpha$ 是到达路由的分组数量 $R$ 是带宽或者传输速率）</li>
<li>[流量强度增加会导致平均时延增加]{.red}</li>
</ul>
</li>
<li><p>往返时延概念：</p>
<ul>
<li>定义：从 [发送方发送数据开始]{.red} 到 [发送方收到接收方的确认]{.red} 为止</li>
<li>公式：[传播时延 * 2]{.red} + 末端处理时间</li>
<li>特点：往返时延越大，发送方能够传输的数据就越多，等待越久</li>
</ul>
</li>
<li><p>利用率</p>
<ul>
<li><p>信道利用率：[有数据通过的时间 ÷ 有 + 无数据通过的时间]{.red}</p>
</li>
<li><p>网络利用率：信道利用率的加权平均值</p>
</li>
</ul>
</li>
</ul>

        <h2 id="分层结构"   >
          <a href="#分层结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h2>
      
        <h3 id="概念-1"   >
          <a href="#概念-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3>
      <ul>
<li><p>目的：</p>
<ul>
<li>提高功能的独立性</li>
<li>促进标准化工作</li>
<li>灵活性高的同时降低了各层协议设计的复杂性</li>
</ul>
</li>
<li><p>实体：(1) 每层中的活动元素称为实体（数据）(2) 同一层中的实体称为 [对等实体]{.red}</p>
</li>
<li><p>协议：</p>
<ul>
<li>定义：规定两个通信实体之间交换报文的格式和顺序，以及接受报文和发送报文等其他事件需要执行的动作</li>
<li>组成：<ul>
<li>(1) [语法]{.red}(Syntax)：规定当前数据如何进行解析 </li>
<li>(2) [语义]{.red}(Semantic)：解析当前的数据所执行的功能 </li>
<li>(3) [同步]{.red}(Synchronization)：规定各个数据包解析的先后次序</li>
</ul>
</li>
</ul>
</li>
<li><p>数据单位：PCI + SDU = PDU</p>
<ul>
<li>协议控制信息(PCI)</li>
<li>服务数据单元(SDU)</li>
<li>协议数据单元(PDU)</li>
</ul>
</li>
<li><p>服务</p>
<ul>
<li>概念<ul>
<li>下层实体<strong>提供</strong>给上层实体的可以<strong>调用的功能</strong></li>
<li>上层实体可以调用<strong>所有下层</strong>实体提供的功能</li>
<li>下层实体提供的服务的实现细节对于上层是<strong>不可见的</strong></li>
<li>实现本层的协议需要下一层提供的服务</li>
</ul>
</li>
<li>服务原语<ul>
<li>请求；指示；响应；证实</li>
<li>有应答服务包含 4 中服务原语；无应答服务只包含 <strong>请求</strong> 和 <strong>指示</strong></li>
</ul>
</li>
<li>服务分类<ul>
<li>面向连接服务（TCP） 和 无连接服务（UDP / IP）</li>
<li>可靠服务（TCP） 和 不可靠服务（UDP）</li>
<li>有应答服务 和 无应答服务（HTTP）</li>
</ul>
</li>
</ul>
</li>
<li><p>接口：上层实体 <strong>调用</strong> 下层实体提供的 <strong>服务</strong> 的入口</p>
</li>
</ul>

        <h3 id="分层"   >
          <a href="#分层" class="heading-link"><i class="fas fa-link"></i></a><a href="#分层" class="headerlink" title="分层"></a>分层</h3>
      <ul>
<li>TCP/IP 协议栈：<a href="#%E7%AC%AC%E5%85%AD%E7%AB%A0">应用层</a> + <a href="#%E7%AC%AC%E4%BA%94%E7%AB%A0">传输层</a> + <a href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0">网络层</a> + <a href="#%E7%AC%AC%E4%B8%89%E7%AB%A0">数据链路层</a> + <a href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0">物理层</a></li>
<li>OSI 协议栈：应用层 + 表示层 + 会话层 + 传输层 + 网络层 + 数据链路层 + 物理层</li>
</ul>
<img src="https://i1.xpic.jp/file/xpicjp/2021/06/09/2e913893eec8bf48149e56305a5315e4.png" alt="2e913893eec8bf48149e56305a5315e4.png" style="zoom:80%;" /></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/09/java/io/AIO/">AIO</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-10</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="AIO"   >
          <a href="#AIO" class="heading-link"><i class="fas fa-link"></i></a><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h1>
      
        <h2 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h2>
      <blockquote>
<p><strong>什么是 AIO？</strong></p>
</blockquote>
<ul>
<li><p>历史：JDK 1.7 推出真正的 [异步非阻塞式的调用（AIO）]{.red}</p>
</li>
<li><p>名称：</p>
<ul>
<li><p>AIO 全称为 Asynchronous IO </p>
</li>
<li><p>AIO 实际上并不是官方定义的名称，而是根据新增加的核心类命名的，通常也可以称为 NIO2</p>
<blockquote>
<p>AIO 所有的核心类仍然是属于 java.nio 包下的，本质上是对 NIO 架构的完善</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>什么是异步非阻塞式调用？</strong></p>
</blockquote>
<p>:::info</p>
<p>此前的 IO 概述中已经提到过了，这里再简单的描述下</p>
<p>:::</p>
<ul>
<li><p>异步非阻塞式调用</p>
<ul>
<li><p>定义：</p>
<ul>
<li><p>进程向操作系统注册，[编写回调函数后将 IO 操作完全交付给操作系统实现]{.blue}，进程继续执行自己其他的任务</p>
<blockquote>
<p>回调函数：名字听起来很高端，实际就是进程告诉操作系统在 IO 事件发生后该如何处理，毕竟进程自己不再管了</p>
</blockquote>
</li>
<li><p>操作系统在 IO 事件发生后，选择 [线程池中的某个线程执行进程提供的回调函数]{.blue} 处理发生的 IO 事件</p>
</li>
<li><p>回调函数处理 IO 事件完成后，向进程发出信号通知 IO 事件已经完成，[进程不需要再使用任何系统调用来完成 IO 事件]{.blue}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/AIO.i95xm33f7co.png" alt="AIO" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>区别：</p>
<ul>
<li>不同于同步非阻塞式中的 [Selector 采用轮询机制处理事件]{.red}，异步非阻塞式采用 [订阅-通知]{.red} 模式</li>
<li>[无论是 NIO 的哪个版本最终都需要进程自己调用方法处理事件，AIO 则是将编写好的方法完全交给操作系统去执行，自己则不再关心]{.blue}</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>为什么要使用 AIO？</strong></p>
</blockquote>
<ul>
<li><p>异步非阻塞式 IO 是多路复用式 IO 的一种 [替代方案]{.blue}</p>
<p>  +++ 两种方案并没有本质上的优劣之分，实际开发就是 NIO + AIO 两者的结合</p>
<ul>
<li><p>[NIO 是 Java 自己实现的方法，所以在不同的操作系统都是没有区别的]{.red}</p>
</li>
<li><p>[AIO 是涉及到操作系统的实现，所以在不同的操作系统下效率可能是不同的]{.red}</p>
<blockquote>
<p>Windows 平台采用 IOCP 技术真正实现异步操作，Linux 平台仅能够利用 epoll 模拟异步操作</p>
</blockquote>
</li>
</ul>
<p>  +++</p>
</li>
</ul>

        <h2 id="核心类"   >
          <a href="#核心类" class="heading-link"><i class="fas fa-link"></i></a><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2>
      <blockquote>
<p><strong>AIO 的核心类有哪些？</strong></p>
</blockquote>
<ul>
<li>[AsynchronousSocketChannel]{.red}</li>
<li>[AsynchronousServerSocketChannel]{.red}</li>
<li>AsynchronousFileChannel：文件操作并不常用，所以不会编写案例</li>
<li>[AsynchronousChannelGroup]{.blue}</li>
<li>[CompletionHandler&lt;V,A&gt;]{.red}</li>
<li>Future&lt;V.&gt;：[Future 类并不是 NIO 包下的类，而是 JUC 包中提供的类]{.green}</li>
</ul>
<blockquote>
<p><strong>AIO 核心类如何使用？</strong></p>
</blockquote>
<ul>
<li>概述中提到了 AIO 本质是对 NIO 的完善，所以新增的核心类在使用方法上和 NIO 没有太大的区别</li>
<li>主要区别在于新增的 CompletionHandler 类，该类是用于编写回调函数处理 IO 事件的，其余类没有太大区别</li>
</ul>
<blockquote>
<p><strong>AsynchronousServerSocketChannel：创建服务器端</strong></p>
</blockquote>
<ul>
<li><p>[创建线程池（推荐使用）]{.red}</p>
<ul>
<li><p>问题：IO 事件发生时，进程在执行其他的任务，显然主线程是肯定不可能执行回调函数了，那么操作系统应该如何执行回调函数呢？</p>
</li>
<li><p>解决方式：[操作系统调用线程池中存在的线程去执行回调函数]{.red}</p>
<blockquote>
<p>操作系统调用 AsynchronousChannelGroup 中的线程池，线程在 IO 事件发生时执行回调函数</p>
</blockquote>
</li>
<li><p>创建方式：</p>
<ul>
<li>利用工具类 Excutors 创建线程池：[newFixedThreadPool、newCachedThreadPool、newScheduledThreadPool、newSingleThreadExecutor]{.blue}</li>
<li>利用类 ThreadPoolExecutor 创建自定义线程池：[阿里开发手册推荐使用的方式]{.red}</li>
</ul>
</li>
</ul>
</li>
<li><p>创建服务器端：[bind]{.blue} 方法绑定端口号</p>
</li>
<li><p>服务器端接收客户端请求：调用 [accept]{.blue} 方法接收请求 </p>
</li>
<li><p>使用循环和阻塞函数：</p>
<ul>
<li><p>问题一：[accept]{.blue} 方法是异步非阻塞式的，也就意味着服务器端在执行完这个方法之后，会立刻执行之后的代码，如果没有，那么服务器就会直接结束，这显然是不合理的，因为客户端都还没有连接上，服务器就结束了，那么应该怎么解决？</p>
</li>
<li><p>解决方式：[while(true)]{.blue} 循环显然可以避免这个问题</p>
</li>
<li><p>问题二：[while(true)]{.blue} 循环会导致服务器不停的空转，也就是此前轮询模型的问题，这也是我们不想看到的，那么应该怎么解决？</p>
</li>
<li><p>解决方式：此前的 [多路复用模型]{.red} 的解决方式就是使用 [select]{.blue} 阻塞方法来避免这个问题，那么我们也可以采用阻塞方法来解决</p>
<blockquote>
<p>此前学习过程中使用的方法是 System.in.read，虽然确实能够达到效果，但是感觉不是最终的解决方案</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器端主方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建自定义线程池</span></span><br><span class="line">        ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>,<span class="comment">// 核心线程数量</span></span><br><span class="line">            <span class="number">3</span>,<span class="comment">// 最大线程数量</span></span><br><span class="line">            <span class="number">5</span>,<span class="comment">// 空闲线程的存活时间</span></span><br><span class="line">            TimeUnit.SECONDS,<span class="comment">// 存活时间单位</span></span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(),<span class="comment">// 阻塞队列：超过最大线程时还能够容纳的客户端</span></span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()<span class="comment">// 拒绝策略：超过阻塞队列容量后的处理方式</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 创建 AsynchronousChannelGroup</span></span><br><span class="line">        AsynchronousChannelGroup acg = AsynchronousChannelGroup.withThreadPool(threadPool);</span><br><span class="line">        <span class="comment">// 创建服务器端实例（assc 是我定义的成员变量）：如果没有传入 AsynchronousChannelGroup，则会使用默认的</span></span><br><span class="line">        assc = AsynchronousServerSocketChannel.open(acg);</span><br><span class="line">        <span class="comment">// 服务器端绑定端口号</span></span><br><span class="line">        assc.bind(<span class="keyword">new</span> InetSocketAddress(DEFAULT_PORT));</span><br><span class="line">        System.out.printf(<span class="string">&quot;服务器[%d]:%s\n&quot;</span>, DEFAULT_PORT, <span class="string">&quot;启动成功&quot;</span>);</span><br><span class="line">        <span class="comment">// accept 方法参数介绍</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 第一个参数是 Attachment：(1) 可以传入任意的类型 (2) 用于辅助回调函数处理 IO 事件的</span></span><br><span class="line">            <span class="comment">// 诸如缓冲区等辅助信息都是可以传入的</span></span><br><span class="line">            <span class="comment">// 第二个参数是 CompletionHandler（回调函数）：用于处理 IO 事件的类</span></span><br><span class="line">            <span class="comment">// 这里有两种写法：(1) 直接使用匿名内部类的写法（不推荐）(2) 编写实现 CompletionHandler 接口的内部类</span></span><br><span class="line">            <span class="comment">// 不推荐第一种写法的原因是会导致代码看起来非常乱，虽然简洁，读者可以自己试试编写一下</span></span><br><span class="line">            assc.accept(<span class="keyword">null</span>, <span class="keyword">new</span> AcceptHandler());</span><br><span class="line">            assc.accept(<span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;()&#123;</span><br><span class="line">                <span class="comment">// 回调函数</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 阻塞服务器：防止服务器空转</span></span><br><span class="line">            System.in.read();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p><strong>CompletionHandler&lt;V,A&gt;：编写回调函数处理 IO 事件</strong></p>
</blockquote>
<ul>
<li><p>前提：服务器创建完成后，显然需要向操作系统交代 IO 事件如何处理，即回调函数的编写</p>
</li>
<li><p>[处理客户端连接请求的回调函数]{.red}</p>
<ul>
<li><p>实现 [CompletionHandler]{.blue} 接口，传入两个类型</p>
<blockquote>
<p>第一个类型只能够是 AsynchronousSocketChannel、第二个类型根据自己的 Attachment而定，不过通常都是 Object</p>
</blockquote>
</li>
<li><p>重写 [completed]{.blue} 和 [failed]{.blue} 方法</p>
<blockquote>
<p>completed 方法在正确接收到客户端请求后触发，failed 方法在客户端异常断开后触发</p>
</blockquote>
</li>
</ul>
</li>
<li><p>[处理读取客户端发送的数据和向客户端写入数据的回调函数]{.red}</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部类: 用于处理客户端发出的连接请求</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptHandler</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">AsynchronousSocketChannel</span>, <span class="title">Object</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 第一个参数是客户端，第二个参数是附件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel asc, Object attachment)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 注：对客户端进行操作前需要确保客户端是仍然是正常连接的</span></span><br><span class="line">        <span class="keyword">if</span> (asc != <span class="keyword">null</span> &amp;&amp; asc.isOpen())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 打印客户端信息：getRemoteAddress 可以得到客户端的进程号</span></span><br><span class="line">            <span class="comment">// 注：getRemoteAddress 是会抛出异常的，这里我省略掉了，节省篇幅</span></span><br><span class="line">            System.out.println(<span class="string">&quot;客户端&quot;</span> + asc.getRemoteAddress() + <span class="string">&quot;:连接成功&quot;</span>);</span><br><span class="line">            <span class="comment">// 对客户端执行操作</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            Map&lt;String, Object&gt; info = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="comment">// 回调函数不仅要处理写还要处理，所以提供辅助信息用以判断</span></span><br><span class="line">            info.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="comment">// 读取数据需要从缓冲区中读取，所以也应该作为辅助信息传入</span></span><br><span class="line">            info.put(<span class="string">&quot;buffer&quot;</span>, buffer);</span><br><span class="line">            <span class="comment">// 读取客户端的发送的数据： read 方法也是异步非阻塞式的方法，所以也需要相应的回调函数进行处理</span></span><br><span class="line">            asc.read(buffer, info, <span class="keyword">new</span> ReadAndWriteHandler(asc));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务器必须再次向操作系统注册，才能够继续连接客户端，否则服务器端就不会继续连接客户端了</span></span><br><span class="line">        <span class="keyword">if</span> (assc.isOpen())</span><br><span class="line">        &#123;</span><br><span class="line">            assc.accept(<span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出现异常执行的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部类: 用于处理读取客户端的数据的请求和向客户端写入数据的请求</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadAndWriteHandler</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>, <span class="title">Object</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 记录当前处理的客户端</span></span><br><span class="line">    <span class="keyword">private</span> AsynchronousSocketChannel asc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadAndWriteHandler</span><span class="params">(AsynchronousSocketChannel asc)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.asc = asc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个参数是每次读取或者写入的字节数量，第二个参数依然是附件信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, Object attachment)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 强制转换获取辅助信息</span></span><br><span class="line">        Map&lt;String, Object&gt; info = (Map&lt;String, Object&gt;) attachment;</span><br><span class="line">        <span class="comment">// 获取缓冲区</span></span><br><span class="line">        ByteBuffer buffer = (ByteBuffer) info.get(<span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取当前处理的是读取还是写入</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;read&quot;</span>.equals(info.get(<span class="string">&quot;type&quot;</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 读取客户端发送的数据并且显示在服务器端</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            String msg = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">            <span class="comment">// 依然省略捕获异常的过程</span></span><br><span class="line">            System.out.println(asc.getRemoteAddress() + <span class="string">&quot;:\t&quot;</span> + msg + <span class="string">&quot;\t字节数量[&quot;</span> + result +<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            <span class="comment">// 清空缓冲区</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="comment">// 更新辅助信息</span></span><br><span class="line">            info.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="comment">// 向客户端发送信息，原封不动的发送回去，当然你也可以发送其他内容，修改缓冲区就行</span></span><br><span class="line">            <span class="comment">// 向客户端发送信息后，服务器端显然需要继续读取客户端发送的信息，所以不可以将回调函数置为 null，那样后续就接收不到信息了</span></span><br><span class="line">            asc.write(buffer, info, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;write&quot;</span>.equals(info.get(<span class="string">&quot;type&quot;</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            asc.read(buffer, info, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p><strong>AsynchronousSocketChannel：创建客户端</strong></p>
</blockquote>
<ul>
<li>前提：客户端的创建比较简单，所以采用未来时 Future 来处理</li>
<li>创建线程池（推荐）：客户端依然有对应的 AsynchronousChannelGroup 来处理回调函数，只不过我这里就不再演示了</li>
<li>创建客户端：[connect]{.blue} 连接服务器端</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建客户端</span></span><br><span class="line">        asc = AsynchronousSocketChannel.open();</span><br><span class="line">        <span class="comment">// 向服务器端发出连接请求</span></span><br><span class="line">        asc.connect(<span class="keyword">new</span> InetSocketAddress(DEFAULT_LOCALHOST, DEFAULT_PORT));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException | InterruptedException | ExecutionException e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p><strong>Future：利用未来时处理 IO 事件</strong></p>
</blockquote>
<ul>
<li>异步非阻塞式的方法都具有 Future 类型的返回值</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建客户端</span></span><br><span class="line">        asc = AsynchronousSocketChannel.open();</span><br><span class="line">        <span class="comment">// 获取返回值</span></span><br><span class="line">        Future&lt;Void&gt; connect = asc.connect(<span class="keyword">new</span> InetSocketAddress(DEFAULT_LOCALHOST, DEFAULT_PORT));</span><br><span class="line">        <span class="comment">// 客户端将会等待连接建立完成: 如果连接没有建立完成，就会阻塞，如果建立完成，将继续执行</span></span><br><span class="line">        connect.get();</span><br><span class="line">        <span class="comment">// 从控制台中读取信息</span></span><br><span class="line">        String msg;</span><br><span class="line">        <span class="keyword">while</span> ((msg = reader.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 向服务端发送信息</span></span><br><span class="line">            ByteBuffer buffer = StandardCharsets.UTF_8.encode(msg);</span><br><span class="line">            Future&lt;Integer&gt; write = asc.write(buffer);</span><br><span class="line">            <span class="comment">// 数据发送完毕后才会继续执行</span></span><br><span class="line">            write.get();</span><br><span class="line">            <span class="comment">// 读取服务器端返回的消息</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            Future&lt;Integer&gt; read = asc.read(buffer);</span><br><span class="line">            <span class="comment">// 接收数据完成后才会继续执行</span></span><br><span class="line">            read.get();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException | InterruptedException | ExecutionException e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="实战：多人聊天室"   >
          <a href="#实战：多人聊天室" class="heading-link"><i class="fas fa-link"></i></a><a href="#实战：多人聊天室" class="headerlink" title="实战：多人聊天室"></a>实战：多人聊天室</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.v4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousChannelGroup;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多人聊天室服务器端: 采用异步非阻塞式 IO 实现</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 服务器端口号: 默认使用的端口号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">8888</span>;</span><br><span class="line">    <span class="comment">// 缓冲区固定分配的空间大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">// 退出消息标识符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXIT = <span class="string">&quot;退出&quot;</span>;</span><br><span class="line">    <span class="comment">// 调用者可以根据需要使用其他的端口号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="comment">// 保存客户端的集合: 因为采用的是订阅-通知的模式, 所以没有方法可以直接获取到所有的客户端</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;AsynchronousSocketChannel&gt; clients;</span><br><span class="line">    <span class="comment">// 服务器端通道: 调用者可以根据需要传入自定义的通道</span></span><br><span class="line">    <span class="keyword">private</span> AsynchronousServerSocketChannel server;</span><br><span class="line">    <span class="comment">// 线程池</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService threadPool;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousChannelGroup acg;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理客户端连接请求的回调函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">AsynchronousSocketChannel</span>, <span class="title">Object</span>&gt;</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel client, Object attachment)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 服务器端继续接收其他的客户端连接请求</span></span><br><span class="line">            <span class="keyword">if</span> (server.isOpen())</span><br><span class="line">            &#123;</span><br><span class="line">                server.accept(attachment, <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 提示客户端连接成功</span></span><br><span class="line">            System.out.println(getClientName(client) + <span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">            <span class="comment">// 客户端加入集合中</span></span><br><span class="line">            addClient(client);</span><br><span class="line">            <span class="comment">// 服务器端主要功能: 接收客户端发送的消息并且转发给其他客户端</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE);</span><br><span class="line">            buffer.put(getClientName(client).getBytes());</span><br><span class="line">            <span class="comment">// 客户端通道实际只有读事件才需要使用回调函数, 写事件是不需要的</span></span><br><span class="line">            client.read(buffer, buffer, <span class="keyword">new</span> ReadHandler(client));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 异常处理</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理客户端读写请求的回调函数: 泛型中传入的是整型, 所以为了知道客户端的信息, 我们需要将其作为辅助信息传入</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>, <span class="title">Object</span>&gt;</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> AsynchronousSocketChannel client;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReadHandler</span><span class="params">(AsynchronousSocketChannel client)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.client = client;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, Object attachment)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            ByteBuffer buffer = (ByteBuffer) attachment;</span><br><span class="line">            <span class="comment">// 从写模式切换成读模式</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">// 判断客户端是否想要退出</span></span><br><span class="line">            <span class="keyword">if</span> (isExit(buffer))</span><br><span class="line">            &#123;</span><br><span class="line">                removeClient(client);</span><br><span class="line">                <span class="comment">// 关闭该客户端, 不需要再继续读取该客户端的信息, 所以没必要传递回调函数</span></span><br><span class="line">                client.write(StandardCharsets.UTF_8.encode(EXIT));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 服务器端显示客户端发送的消息</span></span><br><span class="line">            String msg = String.valueOf(StandardCharsets.UTF_8.decode(buffer));</span><br><span class="line">            System.out.println(msg + <span class="string">&quot;(&quot;</span> + result + <span class="string">&quot;字节)&quot;</span>);</span><br><span class="line">            <span class="comment">// 转发消息</span></span><br><span class="line">            forward(client, msg);</span><br><span class="line">            <span class="comment">// 读模式切换成写模式</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="comment">// 更新辅助信息</span></span><br><span class="line">            buffer.put(getClientName(client).getBytes());</span><br><span class="line">            <span class="comment">// 服务器端继续读取当前客户端发送的其他消息</span></span><br><span class="line">            client.read(buffer, buffer, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 异常处理</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatServer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_PORT, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatServer</span><span class="params">(<span class="keyword">int</span> port, AsynchronousServerSocketChannel server)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.server = server;</span><br><span class="line">        clients = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认使用的服务器端通道</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AsynchronousServerSocketChannel <span class="title">getAsynchronousServerSocketChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 默认使用的线程池</span></span><br><span class="line">        threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">8</span>,</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">        );</span><br><span class="line">        acg = AsynchronousChannelGroup.withThreadPool(threadPool);</span><br><span class="line">        <span class="keyword">return</span> AsynchronousServerSocketChannel.open(acg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转发消息: 最为关键的修改</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">forward</span><span class="params">(AsynchronousSocketChannel client, String msg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (AsynchronousSocketChannel other : clients)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (client != other)</span><br><span class="line">                <span class="comment">// 每个客户端都应该拥有属于自己的缓冲区, 否则在多线程环境下共用一个, 真的不好检测会出现什么问题</span></span><br><span class="line">                <span class="comment">// (其实主要问题还是他妈的 IDEA 调试异步函数进不去, 就离谱)</span></span><br><span class="line">                other.write(StandardCharsets.UTF_8.encode(msg));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断客户端是否想要退出</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isExit</span><span class="params">(ByteBuffer buffer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> EXIT.equals(<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端加入服务器端</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addClient</span><span class="params">(AsynchronousSocketChannel client)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        clients.add(client);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端退出服务器端</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeClient</span><span class="params">(AsynchronousSocketChannel client)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        close(client);</span><br><span class="line">        clients.remove(client);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取客户端标识符</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getClientName</span><span class="params">(AsynchronousSocketChannel client)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            InetSocketAddress address = (InetSocketAddress) client.getRemoteAddress();</span><br><span class="line">            port = address.getPort();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;客户端[&quot;</span> + port + <span class="string">&quot;]:&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭各种通道或者流</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable closeable)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (closeable != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                closeable.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器端主方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 服务器端初始化</span></span><br><span class="line">            <span class="keyword">if</span> (server == <span class="keyword">null</span>)</span><br><span class="line">                server = getAsynchronousServerSocketChannel();</span><br><span class="line">            <span class="comment">// 绑定端口号</span></span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            <span class="comment">// 提示服务器启动成功</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;服务器[%d]:%s\n&quot;</span>, port, <span class="string">&quot;启动成功&quot;</span>);</span><br><span class="line">            <span class="comment">// 接收客户端的连接请求:</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                server.accept(<span class="keyword">null</span>, <span class="keyword">new</span> AcceptHandler());</span><br><span class="line">                <span class="comment">// 阻塞服务器</span></span><br><span class="line">                System.in.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            close(server);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 启动服务器</span></span><br><span class="line">        <span class="keyword">new</span> ChatServer().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>





<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.v4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousChannelGroup;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多人聊天室: 客户端</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_LOCALHOST = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">8888</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXIT = <span class="string">&quot;退出&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousSocketChannel client;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousChannelGroup acg;</span><br><span class="line">    <span class="keyword">private</span> ExecutorService threadPool;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClient</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_PORT, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClient</span><span class="params">(<span class="keyword">int</span> port, AsynchronousSocketChannel client)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AsynchronousSocketChannel <span class="title">getAsynchronousSocketChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 默认使用的线程池</span></span><br><span class="line">        threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">15</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">        );</span><br><span class="line">        acg = AsynchronousChannelGroup.withThreadPool(threadPool);</span><br><span class="line">        <span class="keyword">return</span> AsynchronousSocketChannel.open(acg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取客户端标识符</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getClientName</span><span class="params">(AsynchronousSocketChannel client)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            InetSocketAddress address = (InetSocketAddress) client.getRemoteAddress();</span><br><span class="line">            port = address.getPort();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;客户端[&quot;</span> + port + <span class="string">&quot;]:&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable closeable)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (closeable != <span class="keyword">null</span>)</span><br><span class="line">                closeable.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (client == <span class="keyword">null</span>)</span><br><span class="line">                client = getAsynchronousSocketChannel();</span><br><span class="line">            Future&lt;Void&gt; connect = client.connect(<span class="keyword">new</span> InetSocketAddress(DEFAULT_LOCALHOST, port));</span><br><span class="line">            <span class="comment">// 阻塞客户端</span></span><br><span class="line">            connect.get();</span><br><span class="line">            System.out.println(getClientName(client) + <span class="string">&quot;启动成功&quot;</span>);</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE);</span><br><span class="line">            <span class="comment">// 控制台输入必然阻塞: 只能够新开线程处理</span></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ChatClientInputThread(client)).start();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Future&lt;Integer&gt; read = client.read(buffer);</span><br><span class="line">                <span class="keyword">int</span> res = read.get();</span><br><span class="line">                <span class="keyword">if</span> (res &lt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    close(client);</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    System.out.println(StandardCharsets.UTF_8.decode(buffer));</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException | InterruptedException | ExecutionException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ChatClient().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>





<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.v4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClientInputThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXIT = <span class="string">&quot;退出&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BufferedReader READER = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">        <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">            System.in));</span><br><span class="line">    <span class="keyword">private</span> AsynchronousSocketChannel client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClientInputThread</span><span class="params">(AsynchronousSocketChannel client)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">while</span> ((msg = READER.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Future&lt;Integer&gt; write = client.write(StandardCharsets.UTF_8.encode(msg));</span><br><span class="line">                write.get();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException | InterruptedException | ExecutionException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/07/java/interface/Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/">Lambda 表达式</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-07</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-09</span></span></div></header><div class="post-body"><div class="post-excerpt"></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/07/java/interface/%E5%86%85%E9%83%A8%E7%B1%BB/">内部类</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-07</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-09</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="内部类"   >
          <a href="#内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1>
      <img src="https://i1.xpic.jp/file/xpicjp/2021/08/06/a0d492c62fb589175f32dd41b3ec0c07.png" alt="a0d492c62fb589175f32dd41b3ec0c07.png" style="zoom:80%;" />

<ul>
<li><p>定义：可以将一个类的定义置于另一个类的定义内部</p>
</li>
<li><p>特点：（这些特点是所有类型的内部类都具有的）</p>
<ul>
<li>[非静态内部类可以直接访问外部类的所有成员变量和方法]{.red}</li>
<li>[外部类不能够直接访问内部类成员变量和方法]{.red}</li>
<li>[内部类在外部创建对象必须依附外部类创建]{.red}</li>
<li>[所有类型的内部类都具有构造器（包括匿名内部类）]{.red}</li>
</ul>
</li>
<li><p>类型：① <a href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB">成员内部类</a> ② <a href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB">静态内部类</a> ③ <a href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB">局部内部类</a> ④ <a href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB">匿名内部类</a></p>
<p>  注：按照这个顺序分类是有原因的，<code>Lambda</code> 表达式就是这样通过内部类地不断演化得来的</p>
</li>
<li><p>问题：</p>
<ul>
<li><p>为什么需要提供内部类机制？</p>
<ul>
<li><p>[内部类使得多重继承的解决方案变得更加完善]{.red}：接口多重继承解决了部分多重继承的问题，内部类完善了多重继承方案</p>
</li>
<li><p>内部类可以非常方便地隐藏实现细节，方便实现定义回调</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这种类型的代码可以在 HashMap 中看到类似的 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span></span>&#123;</span><br><span class="line">    <span class="comment">/*外部类只需要在内部创建内部类相应的引用就可以使用内部类的方法，从而也就可以使用内部类继承的父类的方法，实现多继承*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassA</span> <span class="keyword">extends</span> <span class="title">HashMap</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassB</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> InnerClassA getInnerClassAInstance&#123;<span class="keyword">return</span> <span class="keyword">new</span> InnerClassA()&#125;;</span><br><span class="line">    <span class="keyword">private</span> InnerClassB getInnerClassBInstance&#123;<span class="keyword">return</span> <span class="keyword">new</span> InnerClassB()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>为什么非静态内部类可以直接访问外部类的所有属性？</p>
<ul>
<li><p>编译器编译时 [平等对待]{.red} 外部类和内部类：为内部类和外部类都会生成相应的字节码文件，内部类字节码的文件名称为 <code>OuterClassName$InnerClassName</code></p>
</li>
<li><p>反编译字节码文件就可以看到内部类究竟是如何被初始化的：局部变量表中存在两个引用，一个是内部类自身的引用，另一个是外部类对象的引用</p>
</li>
<li><p>编译器在编译时会在 [构造器]{.red} 中添加对于外部类对象的引用：[静态内部类访问不了的原因显然是因为本身不是对象了]{.red}</p>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/06/f7584cb7b6d63810f7a0cc5cb0ed00ad.png" alt="f7584cb7b6d63810f7a0cc5cb0ed00ad.png" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li><p>如果内部类存在和外部类名称相同的成员变量或者方法，[内部类的成员变量会 <strong>覆盖</strong> 外部类的成员变量]{.red}</p>
<p>  外部类属性被覆盖之后，显然内部类无法直接访问到外部类的属性，有两种方式可以提供访问</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OuterClass.<span class="keyword">this</span>.number; <span class="comment">/* 外部类.this.成员变量 或者 外部类.this.方法：可以访问到外部类对象 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> OuterClass <span class="title">getOuterClassInstance</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> OuterClass()&#125;; <span class="comment">/*直接创建外部类对象后去引用成员变量或者方法*/</span></span><br></pre></td></tr></table></div></figure></li>
<li><p>内部类可以采用任何访问权限进行修饰：（方法内部类和匿名内部类除外）</p>
<ul>
<li>通常内部类不会是公开的，因为需要隐藏实现细节</li>
<li>无论内部类是何种访问权限、普通方法和构造方法的访问权限如何，外部类都可以在 ++自身内部++ 创建内部类的对象并且对其进行访问</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h2 id="成员内部类"   >
          <a href="#成员内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2>
      <ul>
<li><p>定义：最普通的内部类</p>
</li>
<li><p>特点：[成员内部类不可以拥有静态属性（静态变量、静态方法、静态代码块）]{.red}：可以拥有静态常量和普通常量、不可以变方法</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="comment">// 静态常量</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> innerNumber = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 不可变变量（常量）</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String innerString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// 成员变量</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> publicNumber;					   </span><br><span class="line">        <span class="comment">// 不可以存在静态变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>创建方式</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">	</span><br></pre></td></tr></table></div></figure></li>
</ul>
<blockquote>
<p>《<code>Java</code> 核心技术卷一：》：成员内部类中不能够存在静态属性，但是 <code>Java</code> 语言规范没有对该限制做出任何解释</p>
</blockquote>

        <h2 id="静态内部类"   >
          <a href="#静态内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2>
      <ul>
<li><p>定义：采用 <code>static</code> 关键字修饰的内部类</p>
</li>
<li><p>特点：</p>
<ul>
<li>[静态内部类仅能够访问外部类的所有静态属性]{.red}：静态内部类抹去了对于外部类对象的引用，所以是不可能访问到外部类的成员变量的</li>
<li>[静态内部类可以拥有静态属性和普通属性]{.red}</li>
<li>[接口中所有内部类都默认是静态内部类]{.red}</li>
</ul>
</li>
<li><p>创建方式：[内部类不能够是私有的]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">			</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">creatInnerClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 外部类中创建内部类对象</span></span><br><span class="line">        InnerClass innerClass = <span class="keyword">new</span> InnerClass();					</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 其他类类中创建内部类对象</span></span><br><span class="line">    OuterClass.InnerClass innerClass = <span class="keyword">new</span> OuterClass.InnerClass(); </span><br><span class="line">&#125;	</span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h2 id="局部内部类"   >
          <a href="#局部内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2>
      <ul>
<li><p>定义：位于 [方法作用域]{.red} 中的内部类</p>
</li>
<li><p>特点：</p>
<ul>
<li>[局部内部类本身不可以采用任何访问权限进行修饰]{.red}</li>
<li>[局部内部类仅可以在该方法中被访问，其他任何位置均不可以访问局部内部类]{.red}</li>
<li>局部内部类可以访问方法提供的形参和方法内部定义的局部变量：[方法的形式参数和局部变量必须是不可变的]{.red}（<code>Java 8</code> 之后 [默认形参和局部变量]{.red} 就是不可变的）</li>
</ul>
</li>
<li><p>细节：局部内部类对应的字节码文件名称：<code>OuterClassName$XInnerClassName</code></p>
</li>
<li><p>创建方式：[仅可以在方法内部创建对象]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认形式参数是不可变的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodInnerClass</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 默认局部变量是不可变的</span></span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 局部内部类不可以采用任何关键字进行修饰</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MethodInnerClass</span></span>&#123;						</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">// 调用方法中的形式参数</span></span><br><span class="line">			System.out.println(count);			</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建局部内部类对象并且调用方法</span></span><br><span class="line">    <span class="keyword">new</span> MethodInnerClass().method();			</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure></li>
<li><p>问题：为什么方法的参数或者局部变量必须是不可变的呢？</p>
<ul>
<li><p>普通方法和类的声明周期并不一致：类在加载阶段开始直到虚拟机关闭才销毁，方法在调用完成后就会被销毁</p>
</li>
<li><p>形式参数和局部变量会随着方法被虚拟机销毁而跟着销毁，局部内部类/匿名内部类也就无法再次访问形式参数、局部变量</p>
</li>
<li><p>为了避免生命周期不一致引发的数据访问问题：<code>Java</code> 采用 [复制]{.red} 来避免</p>
<p>  (1) [如果局部内部类访问的是局部变量，那么就将这个局部变量的值复制运行时常量池中，确保局部内部类能够访问]{.red}</p>
<p>  (2) [如果局部内部类访问的是形式参数，那么复制这个形式参数到局部内部类的构造器中进行初始化，确保局部内部类始终能够访问]{.red}</p>
</li>
<li><p>实际上两种方式访问的局部变量、形式参数都不是原本的局部变量和形式参数，仅仅只是复制过来的内容，所以如果不增加 <code>final</code> 关键字加以修饰，就会导致 [数据不一致的问题]{.red}</p>
</li>
</ul>
</li>
</ul>

        <h2 id="匿名内部类"   >
          <a href="#匿名内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2>
      <ul>
<li><p>定义：[没有名字的局部内部类]{.red}</p>
</li>
<li><p>特点：</p>
<ul>
<li>[匿名内部类需要实现相应的接口或者继承抽象类]{.red}</li>
<li>[匿名内部类不需要显式的声明]{.red}：</li>
<li>[匿名内部类可以借助代码块“迫使”编译器生成构造器]{.red}</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li>匿名内部类只可以继承一个类或者实现一个接口</li>
<li>匿名内部类对应的字节码文件名称：<code>OuterClassName$X</code>（<code>X</code> 代表数字：通常根据数量来生成）</li>
</ul>
</li>
<li><p>创建方式：[仅可以在方法内部创建对象]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AnonymousInnerClass</span></span>&#123;					<span class="comment">// 匿名内部类实现的接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anonymousInnerClass</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 匿名内部类隐式的声明 */</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    class AnonymousClass implements AnonymousInnerClass&#123;</span></span><br><span class="line"><span class="comment">    	public void method()&#123;</span></span><br><span class="line"><span class="comment">    	</span></span><br><span class="line"><span class="comment">    	&#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 实现接口创建匿名内部类对象</span></span><br><span class="line">    <span class="keyword">new</span> AnonymousInnerClass()&#123;					</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">// 匿名内部类和局部内部类相同依然可以使用外部类的属性和不可变的形式参数</span></span><br><span class="line">            System.out.println(count);			</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 继承类创建匿名内部类对象</span></span><br><span class="line">    <span class="keyword">new</span> ArrayList()&#123;							</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
<div class="table-container"><table>
<thead>
<tr>
<th></th>
<th>成员内部类</th>
<th>静态内部类</th>
<th>局部内部类</th>
<th>匿名内部类</th>
</tr>
</thead>
<tbody><tr>
<td>属性</td>
<td>[不可以拥有任何静态属性（静态常量除外）]{.red}</td>
<td>可以拥有任何属性</td>
<td>可以拥有任何属性</td>
<td>可以拥有任何属性</td>
</tr>
<tr>
<td>继承&amp;实现</td>
<td>继承一个实现多个</td>
<td>继承一个实现多个</td>
<td>继承一个实现多个</td>
<td>[继承一个或者实现一个]{.red}</td>
</tr>
<tr>
<td>外部类</td>
<td>直接访问外部类属性</td>
<td>[仅能访问外部类静态属性]{.red}</td>
<td>直接访问外部类属性</td>
<td>直接访问外部类属性</td>
</tr>
<tr>
<td>构造器</td>
<td>有</td>
<td>有</td>
<td>有</td>
<td>[有]{.red}</td>
</tr>
<tr>
<td>作用域</td>
<td>外部类内部</td>
<td>任意位置</td>
<td>仅能在方法中被访问</td>
<td>仅能在访问中被访问</td>
</tr>
<tr>
<td>访问权限</td>
<td>任意访问权限</td>
<td>任意访问权限</td>
<td>[不可以修饰]{.red}</td>
<td>[不可以修饰]{.red}</td>
</tr>
</tbody></table></div>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/07/java/interface/%E6%8E%A5%E5%8F%A3/">接口概述</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-07</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-09</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="抽象类"   >
          <a href="#抽象类" class="heading-link"><i class="fas fa-link"></i></a><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1>
      <blockquote>
<p><strong>什么是抽象类？</strong></p>
</blockquote>
<ul>
<li><p>定义：[拥有抽象方法的类或者说采用 abstract 关键字修饰的类]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义的抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义的抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>特点：</p>
<ul>
<li><p>[抽象类中并非所有方法都是抽象的]{.red}：</p>
<ul>
<li>[每个抽象类可以同时拥有具体实现方法和抽象方法]{.blue}</li>
<li>[每个继承抽象类的子类必须实现所有的抽象方法]{.blue}</li>
</ul>
</li>
<li><p>[抽象方法的访问权限不可以是私有的、也不可以是静态或者不可变的]{.red}：这几种情况都会导致子类无法重写或者说实现抽象方法</p>
</li>
<li><p>[抽象类中可以存在任意访问权限的成员变量]{.red}：拥有成员变量也就意味着拥有构造方法</p>
</li>
<li><p>[不可以利用 new 关键字直接创建抽象类实例]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种创建方式是错误的</span></span><br><span class="line">AbstractClass object = <span class="keyword">new</span> AbstractClass();</span><br><span class="line"><span class="comment">// 只能够将抽象类的引用指向具体的实现类来创建：SubClass 继承实现了抽象类</span></span><br><span class="line">AbstractClass object = <span class="keyword">new</span> SubClass();</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>为什么需要提供抽象类？为什么不直接提供一个实现了方法的父类呢？</strong></p>
</blockquote>
<ul>
<li><p>可以将不同的类中拥有相同的变量和方法抽取出来成为抽象类的属性，任何类需要拥有这些属性时只需要继承抽象类就行，[便于代码的继续进行扩展]{.blue}</p>
</li>
<li><p>设计系统架构时很难得知最终如何去实现这些功能，抽象类就能很好地帮助系统的架构设计，不需要提供任何实现，仅考虑需要提供什么，有利于程序架构设计以及之后的重构</p>
</li>
<li><p>普通父类中的所有方法都必须实现，之前提到的在设计系统架构时是很难得知最终如何实现这个方法</p>
</li>
</ul>
<p>:::info</p>
<p>总结：抽象类除了拥有抽象方法之外，其余和普通的类没有什么区别</p>
<p>:::</p>

        <h1 id="接口"   >
          <a href="#接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#接口" class="headerlink" title="接口"></a>接口</h1>
      
        <h2 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h2>
      <ul>
<li><p>定义：[没有具体实现和成员变量，而只是描述类应该完成的需求，没有具体的实现]{.red}</p>
</li>
<li><p>特点：</p>
<ul>
<li><p>[接口中所有方法都没有具体实现，都是公共的抽象方法]{.red}：实现类必须实现所有抽象方法</p>
<blockquote>
<p><code>Java 8</code> 新特性中接口也可以拥有实现的方法</p>
</blockquote>
</li>
<li><p>[接口和接口之间可以继承，类可以实现多个接口]{.red}</p>
<blockquote>
<p>接口继承接口采用的实现 <code>extends</code> 关键字而不是 <code>implements</code></p>
</blockquote>
</li>
<li><p>[接口中默认所有变量都是公共的静态常量]{.red}</p>
<blockquote>
<p>不能有成员变量，也不能有非公共的变量（<code>protected</code>、<code>private</code> 都不可以修饰接口中的变量）</p>
</blockquote>
</li>
<li><p>接口不能采用 <code>new</code> 创建对象仅可以创建接口引用，指向各个实现接口的类</p>
</li>
<li><p>[接口中可以嵌套定义接口，类中也可以嵌套定义接口，接口中也可以嵌套定义内部类（默认为静态内部类）]{.blue}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Walk</span></span>&#123;												<span class="comment">// 接口的定义</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Run</span> <span class="keyword">extends</span> <span class="title">Walk</span></span>&#123;									<span class="comment">// 接口继承接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Run</span>, <span class="title">Comparator</span>&lt;<span class="title">Animal</span>&gt;</span>&#123;			<span class="comment">// 类实现接口，多接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*初始化接口*/</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>新特性：（<code>Java 8</code>后新增加的特性）</p>
<ul>
<li><p>[接口中可以存在静态方法]{.red}</p>
<blockquote>
<p>通常仍然将这些方法放入伴生的工具类中（<code>Collection &amp; Collections</code>前者仍然只是提供抽象方法，后者提供具体方法）</p>
</blockquote>
</li>
<li><p><a style="color:red;">接口中可以存在默认的实现方法</a>：采用 <code>default</code> 关键字修饰；实现类可以重写默认方法可以不重写</p>
<p>  注：这两个新特性实际上是有违接口的设计初衷</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">defaultMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>细节：</p>
<p>  +++ 接口中定义一个默认实现方法，抽象类中也定义一个具有相同名称的实现方法，那么实现接口同时继承抽象类的类会选择哪个方法呢？</p>
<p>  [解决方式：抽象类中的方法将会覆盖其余接口中所有的同名方法，父类优先级最高]{.red}</p>
<p>  +++</p>
<p>  +++ 两个接口同时定义一个具有相同名称的默认实现方法，那么同时实现两个接口的实现类会选择哪个方法呢？</p>
<p>  [解决方式：编译器无法识别实现类到底继承哪个方法，需要实现类 <strong>重写该方法</strong> 从而覆盖两个接口的默认实现]{.red}</p>
<p>  +++</p>
<p>  +++ 一个接口中定义了一个默认的实现方法，另一个接口定义了一个同名的抽象方法，那么同时实现两个接口的类会继承默认的实现方法吗？</p>
<p>  [解决方式：编译器依然直接报错，仍然需要重写，<code>Java</code> 强调一致性，这种二义性依然需要程序员处理]{.red}</p>
<p>  +++</p>
<p>  +++ 两个接口同时定义了一个具有相同名称的抽象方法，那么同时实现两个接口的实现类不会有任何问题，只需要实现就行了</p>
<p>  +++</p>
<p>  +++ 抽象类实现接口，子类继承抽象类</p>
<ul>
<li>抽象类可以选择实现接口中的方法，也可以选择不实现交给继承的子类实现</li>
<li>子类必须实现没有被抽象类实现的方法，也可以选择覆写抽象类实现的方法</li>
</ul>
<p>  +++</p>
</li>
</ul>

        <h2 id="常用接口"   >
          <a href="#常用接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h2>
      
        <h3 id="比较接口"   >
          <a href="#比较接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#比较接口" class="headerlink" title="比较接口"></a>比较接口</h3>
      <ul>
<li><p><code>Comparable&lt;T&gt;</code>：该接口仅提供一个方法</p>
<ul>
<li><p>定义：[实现该接口的类的实例对象是可以相互进行比较的]{.blue}</p>
</li>
<li><p>规则：[泛型接口中传入的类必须是实现该接口的类]{.red}</p>
</li>
<li><p>细节：(1)<code>java.util</code> 包下的方法 (2) 函数式接口</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*接口定义*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*例子*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    ... <span class="comment">// 提供构造方法初始化成员变量</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">		<span class="comment">// 根据对象的年龄进行比较</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age &gt; person.age ? <span class="number">1</span> : (<span class="keyword">this</span>.age == person.age ? <span class="number">0</span> : -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    List&lt;MyClass&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Collections.addAll(list, <span class="keyword">new</span> MyClass(<span class="number">23</span>),</span><br><span class="line">                       <span class="keyword">new</span> MyClass(<span class="number">12</span>),</span><br><span class="line">                       <span class="keyword">new</span> MyClass(<span class="number">98</span>),</span><br><span class="line">                       <span class="keyword">new</span> MyClass(<span class="number">20</span>));</span><br><span class="line">    <span class="comment">// Collections 工具类就可以直接对这种可比较的对象进行排序</span></span><br><span class="line">    Collections.sort(list);															</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Collections sort 方法源码*/</span></span><br><span class="line"><span class="comment">// 如果链表中存放的对象本身就是可比较的那么就不需要传入比较器来比较对象了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">    list.sort(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p><code>Comparator&lt;T&gt;</code>：[该接口仅需要重写一个方法]{.red}，其余方法都是静态的或者默认实现的</p>
<ul>
<li><p>定义：[实现该接口的类是可以去比较其他类的]{.blue}，也就是说实现了该接口的类就是 [比较器]{.red}</p>
</li>
<li><p>要求：[泛型接口中传入的类可以不是实现该接口的类，可以是任何需要比较的类]{.red}</p>
</li>
<li><p>细节：(1) <code>java.lang</code> 包下的方法 (2) 函数式接口</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*接口定义*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*例子*/</span></span><br><span class="line"><span class="comment">// 被比较的类不需要实现任何接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;																			</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    ... <span class="comment">// 提供构造方法初始化成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*比较器：传入的类型就是需要比较的类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonComaprator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person person1, Person person2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person1.age &gt; person2.age ? <span class="number">1</span> : (person1.age == person2.age ? <span class="number">0</span> : -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    List&lt;MyClass&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Collections.addAll(list, <span class="keyword">new</span> MyClass(<span class="number">23</span>),</span><br><span class="line">                       <span class="keyword">new</span> MyClass(<span class="number">12</span>),</span><br><span class="line">                       <span class="keyword">new</span> MyClass(<span class="number">98</span>),</span><br><span class="line">                       <span class="keyword">new</span> MyClass(<span class="number">20</span>));</span><br><span class="line">    <span class="comment">// Collections 工具类就可以直接对这种可比较的对象进行排序</span></span><br><span class="line">    Collections.sort(list， <span class="keyword">new</span> PersonComparator());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Collections sort 方法源码*/</span></span><br><span class="line"><span class="comment">// 如果链表中存放的对象本身是不可比较的，那么就需要传入实现了 Comparator 接口的比较器来对链表元素进行比较</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    list.sort(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>

        <h3 id="克隆接口"   >
          <a href="#克隆接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#克隆接口" class="headerlink" title="克隆接口"></a>克隆接口</h3>
      <p>:::info</p>
<p>参考博客：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Qian123/p/5710533.html"><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/Qian123/p/5710533.html" >Java提高篇——对象克隆（复制）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></a></p>
<p>:::</p>
<blockquote>
<p><strong>什么是克隆？</strong></p>
</blockquote>
<ul>
<li><p>定义：简单来说就是 [复制]{.blue}，将一个变量的值赋给另一个变量</p>
</li>
<li><p>基本数据类型的克隆：[原变量发生变化不会影响到克隆变量的值，两者在栈中具有独立的空间]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 基本数据类型的克隆</span></span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> cloneNumber = number;</span><br><span class="line">    <span class="comment">// 修改原变量的值</span></span><br><span class="line">    number = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 查看两个的变量的值是否相同</span></span><br><span class="line">    System.out.println(number + <span class="string">&quot;\t&quot;</span> + cloneNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>引用类型的克隆：</p>
<ul>
<li><p>思考：引用对象是怎么进行克隆的呢？和基本数据类型相同吗？</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 引用类型的克隆</span></span><br><span class="line">    Student student1 = <span class="keyword">new</span> Student(<span class="number">12</span>, <span class="string">&quot;冬坂五百里&quot;</span>);</span><br><span class="line">    <span class="comment">// 尝试用基本数据类型的克隆方法来完成引用类型的克隆</span></span><br><span class="line">    Student student2 = student1;</span><br><span class="line">    <span class="comment">// 修改第二个对象的年龄</span></span><br><span class="line">    student2.age = <span class="number">24</span>;</span><br><span class="line">    <span class="comment">// 查看两个对象的年龄是否相同</span></span><br><span class="line">    System.out.println(student1.age);</span><br><span class="line">    System.out.println(student2.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>结果：[在我们修改了第二个对象的年龄之后发现两者的年龄居然相同，两者并没有在堆空间独立存在]{.green}</p>
</li>
<li><p>分析：这种方式只是将栈空间中的两个引用指向了堆空间中的同一个对象而已，并没有为克隆变量开辟新的堆空间</p>
<blockquote>
<p>利用 System.identityHashCode(); 方法可以计算对象在堆内存中的地址，结果一定是一样的</p>
</blockquote>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/引用类型.11b5vy5sxfr4.png" alt="引用类型" style="zoom:80%;" /></li>
<li><p>结论：显然这种克隆并不是我们真正想要的克隆方式，我们想要的显然是两个对象是完全独立的，相互不受影响的</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>如何实现克隆？</strong></p>
</blockquote>
<ul>
<li><p>前提：[经过前面的分析可以明确的是，克隆这种技术主要针对的是引用类型的对象，毕竟基础数据类型完全可以直接复制]{.red}</p>
</li>
<li><p>核心：</p>
<ul>
<li><p>[实现 Cloneable 接口，覆写 Object 类提供的 clone 方法后调用即可]{.red}</p>
<blockquote>
<p>Cloneable 接口是 [标志性]{.red} 接口，没有定义任何方法，实现该接口仅仅是标志当前对象可以被克隆</p>
</blockquote>
</li>
<li><p>源码</p>
<ul>
<li><p>[克隆的对象和原对象在堆中具有相互独立的空间，两者不会相互影响]{.red}</p>
</li>
<li><p>克隆的对象类型和原对象的类型相同，并不强制</p>
<blockquote>
<p>clone 方法返回的类型是 Object，可以根据自己的需要强制转换，所以可能出现和原对象类型不相同的情况</p>
</blockquote>
</li>
<li><p>克隆对象和原对象内容是相同的，前提是必须重写 <code>equals</code> 方法</p>
</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 源码中提到的注意事项</span></span><br><span class="line"><span class="comment">* x.clone() != x will be true</span></span><br><span class="line"><span class="comment">* x.clone().getClass() == x.getClass() will be true, but these are not absolute requirements.</span></span><br><span class="line"><span class="comment">* x.clone().equals(x) will be true, this is not an absolute requirement.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>浅克隆与深克隆：</p>
<ul>
<li><p>场景：类中不仅包含基本数据类型的成员变量，同时包含引用类型的成员变量</p>
</li>
<li><p>浅克隆：对象被复制时，仅复制基本数据类型的成员变量和引用类型的引用，[并不会复制引用类型拥有的成员变量]{.red}</p>
<blockquote>
<p>注：意味着只要修改引用类型拥有的成员变量就会导致克隆对象和原对象一起发生改变</p>
</blockquote>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/浅克隆.44pp8d02w0c0.png" alt="浅克隆" style="zoom:80%;" /></li>
<li><p>深克隆：对象被复制时，不仅复制基本数据类型的成员变量，[并且将引用类型拥有的成员变量一起复制]{.red}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/深克隆.6cph705nbow0.png" alt="深克隆" style="zoom:80%;" /></li>
</ul>
<p>  :::info</p>
<p>  简单了解区别之后，再来看这两者具体是怎么实现的，具体的演示也在后面</p>
<p>  :::</p>
</li>
<li><p>浅克隆</p>
<ul>
<li><p>特点：</p>
<ul>
<li>[Object 类默认提供的克隆方式就是浅克隆]{.red}</li>
<li>[不会复制引用类型拥有的成员变量，仅会复制引用类型的引用]{.red}</li>
</ul>
</li>
<li><p>实现：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 克隆的对象必须实现 Cloneable 接口并且重写 clone 方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 为了方便赋值就设为公共的属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age, String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Object 类中默认的克隆方式就是浅拷贝：不需要重写任何代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">    <span class="comment">// 浅克隆: 本质是创建新的对象并且将旧对象的值赋给新对象</span></span><br><span class="line">    Student old_student = <span class="keyword">new</span> Student(<span class="number">12</span>, <span class="string">&quot;冬坂五百里&quot;</span>);</span><br><span class="line">    Student new_student = (Student) old_student.clone();</span><br><span class="line">    <span class="comment">// 修改克隆对象的年龄</span></span><br><span class="line">    new_student.age = <span class="number">24</span>;</span><br><span class="line">    <span class="comment">// 测试两者的年龄是否相同：结果是显然不相同的</span></span><br><span class="line">    System.out.println(old_student.age);</span><br><span class="line">    System.out.println(new_student.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>深克隆</p>
<ul>
<li><p>手动实现：</p>
<ul>
<li><p>特点：</p>
<ul>
<li>[会将引用类型拥有的成员变量一起复制]{.red}</li>
<li>引用类型的成员变量也必须实现 Cloneable 接口并且重写 clone 方法</li>
</ul>
</li>
<li><p>实现：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">(String address)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 克隆的对象必须实现 Cloneable 接口并且重写 clone 方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age, String name, Address address)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Student student = (Student) <span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="comment">// 调用引用类型的成员变量后调用其相应的克隆方法: 手动克隆</span></span><br><span class="line">        student.address = (Address) address.clone();</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">错误测试：更改的是引用类型拥有成员变量而不是引用类型本身</span></span><br><span class="line"><span class="comment">new_student.address = new Address(&quot;中国&quot;)</span></span><br><span class="line"><span class="comment">这样修改就相当于修改了成员变量的引用，无论你是浅克隆还是深克隆，两个对象的地址肯定都是不一样的</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">    <span class="comment">// 手动实现深克隆：在克隆方法中继续调用引用类型的克隆方法就是手动实现</span></span><br><span class="line">    Student old_student = <span class="keyword">new</span> Student(<span class="number">12</span>, <span class="string">&quot;冬坂五百里&quot;</span>);</span><br><span class="line">    Address address = <span class="keyword">new</span> Address(<span class="string">&quot;日本&quot;</span>);</span><br><span class="line">    old_student.address = address;</span><br><span class="line">    Student new_student = (Student) old_student.clone();</span><br><span class="line">    <span class="comment">// 更改克隆对象的引用类型成员变量拥有的成员变量的值</span></span><br><span class="line">    address.address = <span class="string">&quot;中国&quot;</span>;</span><br><span class="line">    <span class="comment">// 测试两个对象的地址是否相同：结果肯定是不同的</span></span><br><span class="line">    System.out.println(old_student.address);</span><br><span class="line">    System.out.println(new_student.address);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>序列化实现</p>
<ul>
<li><p>场景：</p>
<ul>
<li>如果类中的引用类型的成员变量也拥有引用类型的成员变量，或者类中存在多个引用类型的成员变量</li>
<li>前者就需要在克隆方法中不断地嵌套调用克隆方法，后者则是需要同时调用多个克隆方法</li>
<li>这种情况被称作 [多层克隆]{.red}，显然手动实现克隆是非常麻烦的</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>[序列化实现深克隆就可以解决多层克隆这种情况]{.red}</li>
<li>[每个引用类型或者说类都需要实现序列化接口]{.red}</li>
</ul>
</li>
<li><p>实现</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span>  <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; students;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="comment">// 省略不重要的代码</span></span><br><span class="line">	... </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 序列化流</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 反序列化流</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 克隆对象</span></span><br><span class="line">        Teacher teacher = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            ByteArrayOutputStream bao = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="comment">// 将对象写入字节数组输出流中</span></span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(bao);</span><br><span class="line">            oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 从哪里读入数据: 从字节数组输出流中读取数据</span></span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bao.toByteArray()));</span><br><span class="line">            teacher = (Teacher) ois.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException | ClassNotFoundException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> teacher;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 序列化实现深克隆</span></span><br><span class="line">    List&lt;Student&gt; students = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Collections.addAll(students,<span class="keyword">new</span> Student(<span class="number">12</span>, <span class="string">&quot;学生1号&quot;</span>),</span><br><span class="line">                       <span class="keyword">new</span> Student(<span class="number">13</span>, <span class="string">&quot;学生2号&quot;</span>),</span><br><span class="line">                       <span class="keyword">new</span> Student(<span class="number">14</span>, <span class="string">&quot;学生2号&quot;</span>));</span><br><span class="line">    Teacher teacher = <span class="keyword">new</span> Teacher(<span class="number">24</span>, <span class="string">&quot;冬坂五百里&quot;</span>, students,<span class="keyword">new</span> Address(<span class="string">&quot;日本&quot;</span>));</span><br><span class="line">    Teacher clone_teacher = (Teacher) teacher.clone();</span><br><span class="line">    <span class="comment">// 修改克隆对象</span></span><br><span class="line">    clone_teacher.getAddress().setAddress(<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">    clone_teacher.getStudents().remove(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 测试两个对象的集合内容是否相同、以及地址是否相同</span></span><br><span class="line">    teacher.getStudents().forEach(System.out::println);</span><br><span class="line">    clone_teacher.getStudents().forEach(System.out::println);</span><br><span class="line">    System.out.println(teacher.getAddress());</span><br><span class="line">    System.out.println(clone_teacher.getAddress());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>为什么要使用克隆？为什么不直接创建新对象后挨个赋值呢？</strong></p>
</blockquote>
<ul>
<li>理由①：某些情况我们需要暂时保存当前对象的状态，确保我们在修改当前对象后依然能够得知其原有的状态</li>
<li>理由②：<ul>
<li><code>clone</code> 方法的默认实现是本地的，[效率显然会优于循环赋值]{.red}</li>
<li><code>clone</code> 能够简化循环赋值的过程，[代码更加简洁]{.red}</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>细节</strong></p>
</blockquote>
<ul>
<li>字符串对象实际上也是引用类型的对象，但是由于字符串对象具有 [不可变的特性]{.red}，</li>
<li>修改字符串内容实际上修改的是引用指向的内容，而不是在原有的基础上进行修改</li>
<li>所以在浅克隆中修改字符串对象不会导致克隆对象和原对象一起发生，原对象的引用依然指向原来的字符串内容，克隆对象的引用已经指向新的字符串内容了</li>
</ul>

        <h2 id="接口-vs-抽象类"   >
          <a href="#接口-vs-抽象类" class="heading-link"><i class="fas fa-link"></i></a><a href="#接口-vs-抽象类" class="headerlink" title="接口 vs 抽象类"></a>接口 vs 抽象类</h2>
      <div class="table-container"><table>
<thead>
<tr>
<th></th>
<th>接口</th>
<th>抽象类</th>
</tr>
</thead>
<tbody><tr>
<td>继承 &amp; 实现</td>
<td>可以实现多个接口</td>
<td>仅可以继承一个抽象类</td>
</tr>
<tr>
<td>方法</td>
<td>所有方法都是公共的抽象方法</td>
<td>既有抽象方法也有普通方法（[抽象方法默认包可见性]{.red}）</td>
</tr>
<tr>
<td>成员变量</td>
<td>仅拥有静态常量</td>
<td>任意类型成员变量</td>
</tr>
<tr>
<td>耦合度</td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table></div>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/08/20/design/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/">装饰器模式</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-08-20</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-08-20</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="装饰器模式"   >
          <a href="#装饰器模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1>
      <blockquote>
<p><strong>为什么设计装饰器模式</strong></p>
</blockquote>
<ul>
<li><p>核心：[装饰器模式是继承关系的一种替代方案：可以动态地扩展实现类的功能]{.red}</p>
</li>
<li><p>情景：</p>
<ul>
<li><p>经常游玩 <code>FPS</code> 类型游戏的玩家都知道枪械是会有各种配件的</p>
</li>
<li><p>如果不为枪械安装任何配件那么就只是一把最普通的枪，如果需要具有更多功能的枪械显然就需要安装更多的配件</p>
</li>
<li><p>现在将枪械和配件的关系抽象出来，<strong>最直接的解决方案就是继承</strong>：每个具有不同配件的枪械都是普通枪的子类，对普通枪进行扩展</p>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/06/6a1b1256badfadcf7b03d4ae0cb5fc29.png" alt="6a1b1256badfadcf7b03d4ae0cb5fc29.png" style="zoom: 67%;" /></li>
<li><p>继承关系可以在枪械和配件之间建立联系，同时也带来了相应的问题：</p>
<p>  (1) [子类数量会随着需求大量增长]{.red}：存在非常多的配件那么子类的数量就会爆炸</p>
<p>  (2) [难以满足复合的需求]{.red}：有些枪械既需要瞄准镜又需要垂直握把，显然继承关系就难以满足这种复合的需求</p>
</li>
<li><p>重新将枪械和配件的关系抽象出来，<strong>采用装饰器模式</strong>：将枪械的各个配件和普通的枪进行分离，需要什么配件就对普通的枪械进行装饰</p>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/06/1452502dbb05482503a68f7f1bb49d52.png" alt="1452502dbb05482503a68f7f1bb49d52.png" style="zoom:67%;" /></li>
<li><p>装饰器模式显然可以避免继承关系带来的子类数量爆炸的问题并且满足复合需求：[只需要利用组合关系就可以完成装饰器模式]{.red}</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>什么是装饰器模式</strong></p>
</blockquote>
<ul>
<li><p>定义：[<strong>动态地将责任分配到附加到对象上</strong>，如果需要扩展基类的功能，只需要利用组合就可以完成扩展]{.red}</p>
</li>
<li><p>细节：[每个基本类被多个装饰类修饰之后仍然是抽象类的实例]{.red}</p>
</li>
<li><p>优先 &amp; 缺点</p>
<ul>
<li>优点：[<strong>利用组合关系</strong>替代了继承关系显著降低了类与类之间的耦合度]{.red}：每个基本类和装饰类都是相互独立的，只在有需要的时候存在联系</li>
<li>缺点：[装饰类过多时容易造成代码阅读困难和排错困难]{.red}：装饰器模式创建对象通常采用嵌套的方式创建，所以看着会比较迷惑</li>
</ul>
</li>
<li><p>类图：</p>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/06/74690f6c1f6157a138932a9907105d79.png" alt="74690f6c1f6157a138932a9907105d79.png" style="zoom:67%;" /></li>
<li><p>实现：</p>
<ul>
<li><p><code>Component</code> 抽象类：提供该类型的类需要满足的最基本功能</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对应枪械例子中的枪模*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span></span>;    <span class="comment">// 枪械开火</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span></span>;  <span class="comment">// 枪械装弹</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p><code>ConcreteComponent</code>：具有基本功能的实现类（[可以提供多个不同实现的基本类]{.red}）</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对应枪械例子中的普通枪械*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开火...&quot;</span>);				<span class="comment">// 实现枪械最基本的功能：开火</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span></span>&#123;							<span class="comment">//  实现枪械最基本的功能：装弹</span></span><br><span class="line">        System.out.println(<span class="string">&quot;装弹...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p><code>Decorator</code>：装饰类通常 <strong>只是调用基本类</strong> 的方法并不会做进一步的扩展</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对应枪械例子中的配件类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decoration</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component = <span class="keyword">null</span>;			</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decoration</span><span class="params">(Component component)</span></span>&#123;			<span class="comment">// 利用组合获取到基本类</span></span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span></span>&#123;								<span class="comment">// 实现枪械最基本的功能但是不做任何扩展，只是调用基本类的方法</span></span><br><span class="line">        component.fire();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span></span>&#123;</span><br><span class="line">        component.reload();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p><code>ConcreteDecoretor</code>：可以拓展功能的具体装饰类</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorationB</span> <span class="keyword">extends</span> <span class="title">Decoration</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorationB</span><span class="params">(Component component)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;装备垂直握把...&quot;</span>);				<span class="comment">// 拓展的逻辑功能</span></span><br><span class="line">        <span class="keyword">super</span>.fire();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;装备垂直握把...&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.reload();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>创建具有装饰器的基本类</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*装饰器模式创建类通常都采用这种嵌套的写法：根据每个装饰器类的构造方法可以看出，每个装饰器类可以接着嵌套装饰器*/</span></span><br><span class="line">    Component component = <span class="keyword">new</span> ConcreteDecorationA(			<span class="comment">// 装备瞄准镜</span></span><br><span class="line">        				  <span class="keyword">new</span> ConcreteDecorationB(			<span class="comment">// 装备垂直握把</span></span><br><span class="line">                          <span class="keyword">new</span> ConcreteDecorationC(			<span class="comment">// 装备消音器</span></span><br><span class="line">                          <span class="keyword">new</span> ConcreteComponent())));		<span class="comment">// 最基本的类在最里面</span></span><br><span class="line">    component.fire();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>应用装饰器模式</strong></p>
</blockquote>
<ul>
<li><p>核心应用：[Java I/O 框架完全采用装饰器模式设计]{.red}</p>
</li>
<li><p>情景：</p>
<ul>
<li>每个输入源存放的数据类型可能各不相同：有些输入源提供的是字节流（<code>ByteArrayInputStream</code>），有些输入源提供的是文件（<code>FileInputStream</code>），这些都是<strong>基本类</strong></li>
<li>每个输入源在传输数据的过程中的要求也不尽相同：有些输入源可能要求提供缓冲区（<code>BufferedInputStream</code>），有些输入源可能要求提供类型转换的功能（<code>DataInputStream</code>），显然这些类就是 <strong>装饰类</strong></li>
<li>只需要将基本类和装饰类进行组合就可以得到满足要求的输入环境</li>
</ul>
</li>
<li><p>常用基本类：<code>ByteArrayInputStream</code>、<code>FileInputStream</code>、<code>PipeInputStream</code>、<code>SequenceInputStream</code></p>
</li>
<li><p>常用装饰类：<code>DataInputStream</code>、<code>BufferedInputStream</code>、<code>PushBackInputStream</code></p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* FilteInputStream 父装饰类具有成员变量 */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line"><span class="comment">/*构造方法：只需要传入进程了该抽象类的基本类或者装饰类即可*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">FilterInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.in = in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* FilteInputStream 装饰类没有对原有读取进行任何扩展*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> read(b, <span class="number">0</span>, b.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* BufferedStream 装饰类扩展：具有缓冲区*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &gt;= count) &#123;</span><br><span class="line">        fill();</span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= count)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getBufIfOpen()[pos++] &amp; <span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>创建被装饰器修饰的基本类对象</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建被装饰的基本类对象：被装饰的文件传输类就具有了缓冲区和转换数据类型的功能*/</span></span><br><span class="line">InputStream in = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">    <span class="keyword">new</span> DataInputStream(</span><br><span class="line">        <span class="keyword">new</span> FileInputStream(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></div></figure>

</li>
</ul>
<blockquote>
<p>参考博客：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/volcano-liu/p/10897897.html" >什么是装饰器模式？</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/08/20/java/io/%E5%BA%8F%E5%88%97%E5%8C%96/">序列化</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-08-20</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-08-20</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="序列化"   >
          <a href="#序列化" class="heading-link"><i class="fas fa-link"></i></a><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1>
      <blockquote>
<p><strong>什么是序列化和反序列化?</strong></p>
</blockquote>
<ul>
<li>序列化：[将类的实例对象转换成二进制字节序列的过程]{.red}</li>
<li>反序列化：根据二进制字节序列信息重新构建类的实例对象的过程</li>
</ul>
<blockquote>
<p><strong>为什么要使用序列化?</strong></p>
</blockquote>
<ul>
<li><p>核心：[不同的 Java 虚拟机之间共享实例对象的解决方案]{.red}</p>
</li>
<li><p>[持久化]{.pink}：对象的实例变量可以通过序列化成二进制字节序列长期保存在磁盘中，脱离进程独立存在</p>
</li>
<li><p>[网络传输]{.pink}：不同进程之间进行通信需要传输数据，只有二进制数据能够在网络中传输，对象想要在网络中传输必须被序列化</p>
<ul>
<li><code>Socket</code>：客户端和服务器之间进行通信</li>
<li><code>RMI</code> ：采用分布式架构的各个计算机之间进行通信</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li>通常建议所有类都实现序列化接口从而方便对象能够进行网络传输或者持久化存储</li>
<li>序列化核心目的是为了共享实例对象而不是为了持久化存储，毕竟持久化存储已经交给了数据库完成，所以如果你的程序不涉及网络那么序列化也就没什么用了</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>如何实现序列化?</strong></p>
</blockquote>
<ul>
<li><p>Serializable（[标志性接口]{.red}）</p>
<ul>
<li><p>持久化</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*实现接口*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="comment">/*序列化编号：后文将会提到它的作用*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">114514L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, String age, String gender)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*成员变量初始化...*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</span><br><span class="line">    <span class="comment">/*序列化目的：文件、网络、分布传输*/</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;files/person&quot;</span>);</span><br><span class="line">    <span class="comment">/*创建序列化输出流*/</span></span><br><span class="line">    ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">        <span class="keyword">new</span> FileOutputStream(</span><br><span class="line">            file));</span><br><span class="line">    <span class="comment">/*等待被序列化的对象*/</span></span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;24&quot;</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="comment">/*如果文件不存在就创建文件*/</span></span><br><span class="line">    <span class="keyword">if</span> (!file.exists())&#123;</span><br><span class="line">        file.createNewFile();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*调用序列化输出流将对象写入文件进行持久化保存*/</span></span><br><span class="line">    os.writeObject(person);</span><br><span class="line">    <span class="comment">/*关闭序列化输出流*/</span></span><br><span class="line">    os.close();</span><br><span class="line">	<span class="comment">/*创建序列化输入流*/</span></span><br><span class="line">    ObjectInputStream is = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">        <span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">    <span class="comment">/*需要进行强制类型转换才可以得到原对象*/</span></span><br><span class="line">    Person newPerson = (Person) is.readObject();</span><br><span class="line">    System.out.println(newPerson);</span><br><span class="line">    is.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>网络传输</p>
<blockquote>
<p>吐槽一句，明明序列化技术主要就是用于网络传输，但是为什么那么多讲序列化的博客都没有将网络传输作为例子讲呢？</p>
</blockquote>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*服务器和客户端进行交互的例子*/</span></span><br><span class="line"><span class="comment">/*需要发送的消息*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">114514L</span>;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> String date;</span><br><span class="line">    <span class="comment">/*类的其余方法不在此列出，不重要*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*服务器*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span></span>&#123;</span><br><span class="line">    <span class="comment">/*服务器端口号*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_SERVER_PORT = <span class="number">4396</span>;</span><br><span class="line">    <span class="comment">/*服务器端*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</span><br><span class="line">        <span class="comment">// 创建服务器处理请求的端口 Socket</span></span><br><span class="line">        ServerSocket server = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 服务器读取客户端传递的数据</span></span><br><span class="line">        ObjectInputStream reader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 服务器返回给客户端的数据</span></span><br><span class="line">        ObjectOutputStream writer = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        server = <span class="keyword">new</span> ServerSocket(DEFAULT_SERVER_PORT);</span><br><span class="line">        System.out.printf(<span class="string">&quot;服务器[%d]:%s\n&quot;</span>, DEFAULT_SERVER_PORT, <span class="string">&quot;启动完成...&quot;</span>);</span><br><span class="line">        <span class="comment">/*服务器始终运行*/</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            Socket client = server.accept();</span><br><span class="line">            System.out.printf(<span class="string">&quot;客户端[%d]:%s\n&quot;</span>, client.getPort(), <span class="string">&quot;建立连接&quot;</span>);</span><br><span class="line">            <span class="comment">/*传递的消息对象*/</span></span><br><span class="line">            Message message = <span class="keyword">null</span>;</span><br><span class="line">            reader = <span class="keyword">new</span> ObjectInputStream(client.getInputStream());</span><br><span class="line">            writer = <span class="keyword">new</span> ObjectOutputStream(client.getOutputStream());</span><br><span class="line">            <span class="comment">/*读出对象*/</span></span><br><span class="line">            <span class="keyword">while</span> ((message = (Message) reader.readObject()) != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 格式化输出客户端发送的消息</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;客户端[%d]:%s\n&quot;</span>, client.getPort(), message.getMessage() + <span class="string">&quot;\t&quot;</span> + message.getDate());</span><br><span class="line">                <span class="comment">// 向客户端写入对象</span></span><br><span class="line">                writer.writeObject(<span class="keyword">new</span> Message(<span class="string">&quot;服务器[&quot;</span> + DEFAULT_SERVER_PORT + <span class="string">&quot;]:处理完毕&quot;</span>));</span><br><span class="line">                <span class="comment">// 确保缓冲区中所有的内容都被推出: writer 关闭后会自动推出缓冲区中剩余的内容</span></span><br><span class="line">                writer.flush();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.printf(<span class="string">&quot;客户端[%d]:%s&quot;</span>, client.getPort(), <span class="string">&quot;退出连接&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*客户端*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SERVER_HOSTNAME = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_SERVER_PORT = <span class="number">4396</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXIT = <span class="string">&quot;退出&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 客户端访问服务器端口: 客户端的端口是操作系统随机分配的，不需要程序员决定，只需要指定访问哪个服务器端口</span></span><br><span class="line">        Socket server = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 客户端向服务器发送数据</span></span><br><span class="line">        ObjectOutputStream writer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 客户端接收服务器返回的数据</span></span><br><span class="line">        ObjectInputStream reader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 客户端输入需要发送的数据</span></span><br><span class="line">        BufferedReader consoleReader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">            <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                System.in));</span><br><span class="line"></span><br><span class="line">        server = <span class="keyword">new</span> Socket(DEFAULT_SERVER_HOSTNAME, DEFAULT_SERVER_PORT);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端启动成功...&quot;</span>);</span><br><span class="line">        Message message;</span><br><span class="line">        String string;</span><br><span class="line">        writer = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">            		<span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                		server.getOutputStream()));</span><br><span class="line">        <span class="keyword">while</span> (!EXIT.equals(string = consoleReader.readLine()))&#123;</span><br><span class="line">            <span class="comment">/*将控制台输入的字符串封装成对象发送给服务器*/</span></span><br><span class="line">            writer.writeObject(<span class="keyword">new</span> Message(string));</span><br><span class="line">            writer.flush();</span><br><span class="line">            <span class="comment">/*输入流只能够创建在循环内：原因不明*/</span></span><br><span class="line">            reader = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                    server.getInputStream()));</span><br><span class="line">            <span class="comment">/*读出服务器返回的消息对象*/</span></span><br><span class="line">            message = (Message)reader.readObject();</span><br><span class="line">            System.out.println(message.getMessage() + <span class="string">&quot;\t&quot;</span> + message.getDate());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>Externalizable（[需要实现两个方法]{.red}）</p>
<blockquote>
<p>(1) [Externalizable 序列化必须要提供 <strong>空参构造器</strong>]{.red}：否则抛出 java.io.InvalidClassException 异常</p>
<p>(2) Externalizable 序列化强制要求提供空参构造器是因为虚拟机在创建对象的时候采用 [反射机制]{.red} 会调用空参构造器创建对象，然后调用相应的 <code>readObject</code> 方法初始化成员变量</p>
</blockquote>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这里仅列举文件传输的例子不再使用网络传输列子*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Externalizable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">114514L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">	<span class="comment">/*空参构造器必须提供*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, String gender)</span></span>&#123;</span><br><span class="line">			...</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*必须实现以下两个方法*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">/*可以自行选择需要序列化的成员变量*/</span></span><br><span class="line">        out.writeObject(name);</span><br><span class="line">        out.writeObject(age);</span><br><span class="line">        out.writeObject(gender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</span><br><span class="line">        <span class="comment">/*需要按照序列化的顺序进行反序列化*/</span></span><br><span class="line">        <span class="keyword">this</span>.name = (String) in.readObject();</span><br><span class="line">        <span class="keyword">this</span>.age = (<span class="keyword">int</span>)in.readObject();</span><br><span class="line">        <span class="keyword">this</span>.gender = (String)in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;files/person.ser&quot;</span>);</span><br><span class="line">    ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">        <span class="keyword">new</span> FileOutputStream(</span><br><span class="line">            file));</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">24</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!file.exists())&#123;</span><br><span class="line">        file.createNewFile();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*Externalizable 序列化有两种方式使用：这两种方式都可以将对象序列化*/</span></span><br><span class="line">    <span class="comment">/*第一种方式：区别于 Serializable 接口：Externalizable 是对象调用自己的方法来进行序列化*/</span></span><br><span class="line">    person.writeExternal(os);</span><br><span class="line">    <span class="comment">/*第二种方式：采用和 Serializable 接口 一样的方式 */</span></span><br><span class="line">    os.writeObject(person);</span><br><span class="line">    os.close();</span><br><span class="line">	</span><br><span class="line">    ObjectInputStream is = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">        <span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">    <span class="comment">/*Externalizable 反序列化对应也有两种方式使用：这两种方式都可以将对象反序列化*/</span></span><br><span class="line">    <span class="comment">/*第一种方式：采用和 Serializable 接口一样的方式 */</span></span><br><span class="line">    os.readObject(person);</span><br><span class="line">    <span class="comment">/*第二种方式：需要先创建对象后再调用反序列化方法*/</span></span><br><span class="line">    Person newPerson = <span class="keyword">new</span> Person();</span><br><span class="line">    <span class="comment">/*区别于 Serializable 接口：Externalizable 是对象调用自己的方法来进行反序列化*/</span></span><br><span class="line">    newPerson.readExternal(is);</span><br><span class="line">    System.out.println(newPerson);</span><br><span class="line">    is.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>细节：</p>
<ul>
<li><p>[序列化技术仅会将 <strong>对象的成员变量</strong> 转换成字节序列，也就意味着 <strong>静态变量和方法</strong> 都是不会被序列化的]{.red}</p>
<p>  从定义中也可以看出，毕竟序列化的是实例对象，显然静态属性不属于对象</p>
</li>
<li><p>[如果同时实现 Externalizable 和 Serializable 接口会导致 Serializable 接口直接失效]{.red}</p>
</li>
</ul>
</li>
<li><p>区别：[通常仍然采用 Serializable 接口进行序列化]{.red}</p>
<ul>
<li>Externalizable 性能相对较好；Serializable 性能相对较差</li>
<li>Externalizable 可以 [选择性序列化成员变量]{.red} 并且可以 [定制序列化方式]{.red}；Serializable [默认序列化所有成员变量]{.red}</li>
<li>Externalizable 必须实现两个方法（[实现繁琐]{.red}）；Serializable 是标志性接口不需要实现任何方法（[实现简单]{.red}）</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>序列化如何实现的?</strong></p>
</blockquote>
<img src="https://i1.xpic.jp/file/xpicjp/2021/08/15/1af32568725763ed6be092c20fe49bfc.png" alt="1af32568725763ed6be092c20fe49bfc.png" style="zoom:80%;" />

<ul>
<li><p>ObjectStreamClass 类：保存对象对应的 <strong>Class 对象</strong> 以及对象所有 <strong>成员变量的数据信息</strong></p>
<blockquote>
<p>官方文档描述：用于描述类的描述符，主要包含类的名称和类的版本号（serialVersionUID），可以调用自身的 <code>lookup</code> 方法并且利用自身的信息构建对象 </p>
</blockquote>
</li>
<li><p>序列化原理</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject0</span><span class="params">(Object obj, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 构建相关对象之前需要完成的相关检查事项</span></span><br><span class="line">            <span class="keyword">int</span> h;</span><br><span class="line">            <span class="keyword">if</span> ((obj = subs.lookup(obj)) == <span class="keyword">null</span>) &#123;								<span class="comment">// 检查当前对象是否为：调用 writeNull 方法后返回</span></span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;			<span class="comment">// 检查当前对象是否已经被序列化过：调用 writeHandle 方法后返回</span></span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;									<span class="comment">// 检查当前对象是否为 Class 对象：调用 writeClass 方法后返回</span></span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;						<span class="comment">// 检查当前对象是否为 ObjectStreamClass 对象 writeClassDesc 方法后返回</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Object orig = obj;</span><br><span class="line">            Class&lt;?&gt; cl = obj.getClass();										<span class="comment">// 获取当前对象的 Class 对象信息</span></span><br><span class="line">            ObjectStreamClass desc;					</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Class&lt;?&gt; repCl;</span><br><span class="line">                desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);						<span class="comment">// 利用当前对象的 Class 对象构建 ObjectStreamClass 对象</span></span><br><span class="line">                <span class="keyword">if</span> (!desc.hasWriteReplaceMethod() ||							<span class="comment">// 利用 ObjectStreamClass 对象判断该对象是否可以序列化</span></span><br><span class="line">                    (obj = desc.invokeWriteReplace(obj)) == <span class="keyword">null</span> ||				<span class="comment">// 接着判断 ObjectStreamClass 对象是否和具体的对象关联</span></span><br><span class="line">                    (repCl = obj.getClass()) == cl)								<span class="comment">// 最后判断 ObjectStreamClass 对象关联的对象是否和我们传入的对象为同一个</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cl = repCl;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;										<span class="comment">// 字符串类型有相应的序列化方法可以直接被序列化</span></span><br><span class="line">                    writeString((String) obj, unshared);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;											<span class="comment">// 数组类型有相应的序列化方法可以直接被序列化</span></span><br><span class="line">                    writeArray(obj, desc, unshared);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;									<span class="comment">// 枚举类型有相应的序列化方法可以直接被序列化</span></span><br><span class="line">                    writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;							<span class="comment">// 实现了 Serializable 接口的自定义类</span></span><br><span class="line">                    writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeOrdinaryObject</span><span class="params">(Object obj, ObjectStreamClass desc, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            desc.checkSerialize();</span><br><span class="line">            bout.writeByte(TC_OBJECT);													<span class="comment">// 先向文件中写入提示信息：表示这是一个新的对象</span></span><br><span class="line">            writeClassDesc(desc, <span class="keyword">false</span>);												<span class="comment">// 写入所有成员变量的类型信息</span></span><br><span class="line">            handles.assign(unshared ? <span class="keyword">null</span> : obj);</span><br><span class="line">            <span class="keyword">if</span> (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123;</span><br><span class="line">                writeExternalData((Externalizable) obj);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;																	<span class="comment">// 写入所有成员变量对应的实际数据信息</span></span><br><span class="line">                writeSerialData(obj, desc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeClassDesc</span><span class="params">(ObjectStreamClass desc, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> handle;</span><br><span class="line">    <span class="keyword">if</span> (desc == <span class="keyword">null</span>) &#123;																	<span class="comment">// 检查 ObjectStreamClass 对象是否为空</span></span><br><span class="line">        writeNull();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (handle = handles.lookup(desc)) != -<span class="number">1</span>) &#123;					<span class="comment">// 检查 ObjectStreamClass 对象是否已经存在</span></span><br><span class="line">        writeHandle(handle);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (desc.isProxy()) &#123;														<span class="comment">// ObjectStreamClass 对象是否为动态代理类</span></span><br><span class="line">        writeProxyDesc(desc, unshared);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;																			<span class="comment">// 通常会走这个方法</span></span><br><span class="line">        writeNonProxyDesc(desc, unshared);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeNonProxyDesc</span><span class="params">(ObjectStreamClass desc, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bout.writeByte(TC_CLASSDESC);</span><br><span class="line">    handles.assign(unshared ? <span class="keyword">null</span> : desc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (protocol == PROTOCOL_VERSION_1) &#123;</span><br><span class="line">        desc.writeNonProxy(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        writeClassDescriptor(desc);													<span class="comment">// 进入这个方法</span></span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">    writeClassDesc(desc.getSuperDesc(), <span class="keyword">false</span>);										<span class="comment">// 子类序列化结束之后就会序列化父类：前提是父类可以序列化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeNonProxy</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    out.writeUTF(name);																	<span class="comment">// 写入类的名称</span></span><br><span class="line">    out.writeLong(getSerialVersionUID());												<span class="comment">// 写入序列化版本号：虽然序列化版本号是静态的，但是依然可以写入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span> flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (externalizable) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serializable) &#123;</span><br><span class="line">        flags |= ObjectStreamConstants.SC_SERIALIZABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">        out.writeByte(flags);																<span class="comment">// 写入相关信息</span></span><br><span class="line"></span><br><span class="line">    out.writeShort(fields.length);														<span class="comment">// 写入成员变量的数量											</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;											<span class="comment">// 循环写入成员变量的类型信息</span></span><br><span class="line">        ObjectStreamField f = fields[i];</span><br><span class="line">        out.writeByte(f.getTypeCode());</span><br><span class="line">        out.writeUTF(f.getName());</span><br><span class="line">        <span class="keyword">if</span> (!f.isPrimitive()) &#123;</span><br><span class="line">            out.writeTypeString(f.getTypeString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>反序列化原理</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">	</span><br></pre></td></tr></table></div></figure>

</li>
</ul>
<blockquote>
<p><strong>序列化细节</strong></p>
</blockquote>
<ul>
<li><p>transient（瞬时的）</p>
<ul>
<li>定义：[transient 关键字修饰的成员变量不会被序列化]{.red}：反序列化创建对象时该属性就会为默认值</li>
<li>目的：① 某些数据传输过程是不安全的所以避免序列化 ② 某些对象就是没有序列化的必要（Socket、Thread之类的）</li>
</ul>
</li>
<li><p>serialVersionUID（版本号）：</p>
<ul>
<li><p>定义：每个类、Class 对象、ObjectStreamClass 对象、序列化文件都具有的版本号</p>
</li>
<li><p>目的：[保证虚拟机的反序列化过程能够成功]{.red}</p>
</li>
<li><p>生成方式</p>
<ul>
<li><p>虚拟机默认生成：[虚拟机根据对象的实际信息计算出相应的版本号]{.red}，也就意味着只要对象发生“变化”版本号就很有可能一起变化，最终导致反序列化失败</p>
<blockquote>
<p>解释：也就意味着可能你修改了类中的信息，但是别人没有修改，导致你传输过去的版本号和别人的版本号不一致，最终是不可能反序列化成功的</p>
</blockquote>
</li>
<li><p>显示指定：[版本号必须为私有静态常量]{.red}（推荐使用这种方法）</p>
</li>
</ul>
</li>
<li><p>检验过程：</p>
<ul>
<li>从序列化文件中获取类的名字</li>
<li>调用 <code>Class.forname(name)</code> 后获取到类对应的 Class 对象</li>
<li>利用 Class 对象生成 ObjectStreamClass 对象</li>
<li>利用 ObjectStreamClass 对象创建类的对象</li>
</ul>
</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*源码：检查是否一致*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initNonProxy</span><span class="params">(ObjectStreamClass model, Class&lt;?&gt; cl, ClassNotFoundException resolveEx, ObjectStreamClass superDesc)</span> <span class="keyword">throws</span> InvalidClassException</span>&#123;</span><br><span class="line">    <span class="keyword">long</span> suid = Long.valueOf(model.getSerialVersionUID());</span><br><span class="line">    ObjectStreamClass osc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 利用 Class 对象获取到相应的 ObjectStreamClass 对象</span></span><br><span class="line">        osc = lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (model.serializable == osc.serializable &amp;&amp;</span><br><span class="line">            !cl.isArray() &amp;&amp;</span><br><span class="line">            <span class="comment">// 检查从序列化文件中读出的版本号是否和当前查询到的版本号一致：如果不一致将会抛出异常</span></span><br><span class="line">            suid != osc.getSerialVersionUID()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>多次序列化同一个对象：</p>
<ul>
<li><p>核心：</p>
<ul>
<li>[序列化过程中会检查该对象是否已经被序列化过]{.red}</li>
<li>如果对象已经被序列化过，那么只会向流中写入一些提示信息，<strong>序列化文件不会做任何改变</strong></li>
</ul>
</li>
<li><p>细节：对象被序列化和对象内容被修改是两件事情，如果此前已经序列化过该对象，后来修改对象内容后再次序列化是不会成功的，序列化文件保存的仍然是之前的信息</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*例子*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;files/person.ser&quot;</span>);</span><br><span class="line">    ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">        <span class="keyword">new</span> FileOutputStream(</span><br><span class="line">            file));</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">24</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!file.exists())&#123;</span><br><span class="line">        file.createNewFile();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*第一次序列化对象*/</span></span><br><span class="line">    os.writeObject(getPerson(person));</span><br><span class="line">    <span class="comment">/*修改对象后第二次序列化对象*/</span></span><br><span class="line">    person.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    os.writeObject(getPerson(person));</span><br><span class="line">    os.close();</span><br><span class="line"></span><br><span class="line">    ObjectInputStream is = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">        <span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">    <span class="comment">/*最后反序列化对象时会发现内容没有任何改变*/</span></span><br><span class="line">    Person newPerson = getPerson((Person) is.readObject());</span><br><span class="line">    System.out.println(newPerson);</span><br><span class="line">    is.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*源码*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject0</span><span class="params">(Object obj, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// handle previously written and non-replaceable objects</span></span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">if</span> ((obj = subs.lookup(obj)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">                <span class="comment">/*注意这个分支就是判断当前对象是否序列化过*/</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/*lookup 方法就是查找当前对象被序列化：如果已经被序列化就会进入分支，如果没有就会继续执行后续方法*/</span></span><br><span class="line">            writeHandle(h);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*向流中写入提示信息*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeHandle</span><span class="params">(<span class="keyword">int</span> handle)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 第一个信息是该对象已经存在的信息，第二个信息不知道是什么</span></span><br><span class="line">    bout.writeByte(TC_REFERENCE);</span><br><span class="line">    bout.writeInt(baseWireHandle + handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>组合和继承中的序列化</p>
<ul>
<li><p>组合中的序列化：可序列化的类中拥有 [引用类型]{.red} 的成员变量，[该引用类型必须实现序列化接口，否则会导致整个对象都无法被序列化]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*例子*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="comment">/*该类没有实现序列化的任何接口*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="comment">/*作为成员变量在其他可序列化的类中出现*/</span></span><br><span class="line">    <span class="comment">/*该类最终无法被实例化*/</span></span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*源码*/</span></span><br></pre></td></tr></table></div></figure></li>
<li><p>继承中的序列化</p>
<ul>
<li>[如果父类已经实现序列化接口，那么子类同样可以被序列化]{.red}</li>
<li>如果子类实现序列化接口，那么父类是不可以被序列化的</li>
</ul>
</li>
</ul>
</li>
<li><p>反序列化构造对象</p>
<ul>
<li>不存在继承关系时：利用 Class 对象 + ObjectStreamClass 对象（[反射机制]{.red}）构造的对象而 <strong>不会调用构造方法创建的对象</strong></li>
<li>存在继承关系时：<ul>
<li>子类和父类都可以被序列化时：根据之前序列化的原理，显然子类和父类的信息都会被存储在序列化文件中，所有反序列化构造对象时两者都不会走构造方法</li>
<li>子类可以序列化但是父类不能序列化时：反射构建子类的过程中同样需要初始化父类，所以显然会调用构造方法</li>
</ul>
</li>
</ul>
</li>
<li><p>自定义序列化：</p>
<ul>
<li><p>方式：重写 <code>writeObject &amp; readObject</code> 方法</p>
</li>
<li><p>目的：[可能需要对该成员变量进行加密或者其他处理后再序列化]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">114514L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="comment">/*ArrayList 源码中就采用这种设计方式*/</span></span><br><span class="line">    <span class="comment">/*我们不想要序列化整个数组，因为数组中的空间并不会被全部使用，我们只希望序列化数组中的有效元素*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] elements;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, String gender, <span class="keyword">int</span>[] elements)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*自定义序列化必须重写两个方法：writeObject、readObject*/</span></span><br><span class="line">    <span class="comment">/*自定义序列化如果采用了某种规则那么反序列化时也需要采用相反的那种规则*/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/*反转字符串*/</span></span><br><span class="line">        out.writeObject(<span class="keyword">new</span> StringBuffer(<span class="keyword">this</span>.name).reverse().toString());</span><br><span class="line">        out.writeObject(age);</span><br><span class="line">        out.writeObject(gender);</span><br><span class="line">        <span class="comment">/*我们只想序列化不为 0 的元素*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;elements.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(elements[i]!=<span class="number">0</span>)</span><br><span class="line">            out.writeObject(elements[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/*需要再次反转回来*/</span></span><br><span class="line">        <span class="keyword">this</span>.name = <span class="keyword">new</span> StringBuffer((String) in.readObject()).reverse().toString();</span><br><span class="line">        <span class="keyword">this</span>.age = (<span class="keyword">int</span>) in.readObject();</span><br><span class="line">        <span class="keyword">this</span>.gender = (String) in.readObject();</span><br><span class="line">        <span class="comment">/*只需要填充就行了*/</span></span><br><span class="line">        <span class="keyword">this</span>.elements = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>)in.readOnject()]			<span class="comment">// 通常数组的长度也需要被序列化进去否则反序列化会不知道数组有多少元素，导致抛出异常</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">            <span class="keyword">this</span>.elements[i] = (<span class="keyword">int</span>[]) in.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/9/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/11/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/随机图库/1641882498931.3kditdl6ds40.webp" alt="avatar"></div><p class="sidebar-ov-author__text">什么都不会的废物</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/fuyusakaiori" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://weibo.com/Sakiless/home?topnav=1&amp;wvr=6" target="_blank" rel="noopener" data-popover="微博" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weibo"></i></span></a><a class="sidebar-ov-social-item" href="670232228" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">106</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">32</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-nd.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020~2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>小忍的甜甜圈</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1.0.1/dist/canvas-nest.min.js" color="0,0,0" opacity="0.6" count="99" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>