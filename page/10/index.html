<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="啥也不会的大三狗">
<meta property="og:type" content="website">
<meta property="og:title" content="天鹅绒房间">
<meta property="og:url" content="http://example.com/page/10/index.html">
<meta property="og:site_name" content="天鹅绒房间">
<meta property="og:description" content="啥也不会的大三狗">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Fuyusakaiori">
<meta name="twitter:card" content="summary"><title>天鹅绒房间</title><link ref="canonical" href="http://example.com/page/10/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">天鹅绒房间</div><div class="header-banner-info__subtitle">Velvet Room</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/09/network/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">数据链路层</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-11</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="数据链路层"   >
          <a href="#数据链路层" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1>
      
        <h2 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h2>
      <ul>
<li><p>概念：[数据链路层解决的是两个节点之间如何传输数据的问题]{.red}</p>
</li>
<li><p>术语</p>
<ul>
<li>节点：主机，路由器，交换机</li>
<li>通信链路：网络中两个节点之间的通信的通道</li>
<li>协议数据单位：[帧]{.red} (通过封装网络层传递的数据包得到)</li>
</ul>
</li>
<li><p>功能</p>
<ul>
<li><p><a href="#%E6%88%90%E5%B8%A7">成帧</a>：(1) 封装成帧的方式 (2) 帧格式</p>
</li>
<li><p><a href="#%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6">差错控制</a>：(1) 奇偶校验(包括二维的奇偶校验) (2) CRC 循环冗余校验 (3) 海明码校验</p>
<p>  [注：(1) 差错控制并 <strong>不保证可靠传输</strong> (2) 差错控制采用 <strong>硬件</strong> 实现]{.red}</p>
</li>
<li><p><a href="#%E9%93%BE%E8%B7%AF%E7%AE%A1%E7%90%86">链路管理</a>：(1) 纯 ALOHA 协议 (2) 时隙 ALOHA 协议 (3) CSMA 协议 (4) CSMA/CD 协议 (5) CSMA/CA 协议</p>
</li>
<li><p>流量控制：<a style="color:red;">流量控制问题起源于数据链路层</a>，但是通常在实践中也不在数据链路层实现流量控制，<a style="color:red;">同样在传输层实现流量控制</a></p>
</li>
<li><p>可靠传输：<a style="color:red;">数据链路层可以使用超时重传保证可靠传输</a>，但是通常在实践中并不采用这种方式，<a style="color:red;">仅在传输层实现可靠传输</a></p>
</li>
</ul>
</li>
<li><p><a href="#%E5%B1%80%E5%9F%9F%E7%BD%91">局域网</a>：(1) 以太网 (2) 无线局域网</p>
</li>
<li><p>协议：(1) PPP 协议 (2) HDLC 协议</p>
</li>
<li><p><a href="#%E8%AE%BE%E5%A4%87">设备</a>：交换机</p>
</li>
</ul>

        <h2 id="实现"   >
          <a href="#实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#实现" class="headerlink" title="实现"></a>实现</h2>
      <ul>
<li><p>硬件：<a style="color:red;">网络适配器</a> (NetWork Adapter)</p>
<p>  注：网络适配器又称为 <strong>网络接口卡</strong>(俗称网卡 NIC)</p>
</li>
<li><p>核心：链路层控制器：就是实现了 成帧 + 差错控制 + 链路管理 + 以太网协议 的物理 <strong>芯片</strong></p>
</li>
<li><p>功能：(1) 执行串并行的转换 (2) 对数据进行缓存 (3) 安装网卡驱动程序 (4) 实现以太网协议等功能</p>
</li>
<li><p>通信过程：</p>
<ul>
<li>发送方网卡获取从高层传递的 <strong>网络数据报</strong> (网络层交付的) 并进行封装 <strong>成帧</strong></li>
<li>发送方网卡根据数据链路层规定的 <strong>协议</strong> 将帧送入 <strong>通信链路</strong></li>
<li>接收方网卡接收帧 (网卡驱动程序会响应中断) 并进行拆封执行 <strong>差错检测</strong> 等工作</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li><p><a style="color:red;">网卡通常直接集成在主板上而不使用外接的方式</a> ( <code>MAC</code> 地址烧录在网卡的 <code>ROM</code> 中)</p>
</li>
<li><p><a style="color:red;">数据链路层基本采用硬件实现，少量内容采用软件实现</a></p>
<p>  注：每当数据帧到达时需要相应的 <strong>数据链路层软件</strong> 去响应中断告知网卡开始处理数据帧</p>
</li>
</ul>
</li>
<li><p><code>MAC</code> 地址：</p>
<ul>
<li><p>概念：<a style="color:red;">全球唯一</a> 的 $12$ 位十六进制地址 (前 $6$ 位地址由 IEEE 分配后 $6$ 位由生产厂商自行决定)</p>
<p>  注：<code>MAC</code> 地址又被称为 <code>LAN</code> 地址或者物理地址</p>
</li>
<li><p>细节：</p>
<ul>
<li><a style="color:red;">链路层交换机是 <strong>不具有</strong> MAC 地址的</a>：端系统和路由器实际上都是内部的网卡才具有 <code>MAC</code> 地址、</li>
<li><a style="color:red;">MAC 地址在帧的传输过程中是会不断发生变化的</a> (<code>ARP</code> 协议可以看出)</li>
<li><code>MAC</code> 本质上是永久性的但是现在也可以利用一些软件进行修改</li>
</ul>
</li>
<li><p>问题：为什么要同时使用 <code>IP</code> 地址和 <code>MAC</code> 地址 （这个问题其实应该拆成两个问题）</p>
<p>  <a style="color:red;">核心：屏蔽网络异构性</a> </p>
<p>  (1) 为什么存在 <code>MAC</code> 地址了还需要 <code>IP</code> 地址：</p>
<p>  ​      <code>MAC</code> 地址是无法进行子网划分的也就意味着每个路由器都需要记住全部的 <code>MAC</code> 地址否则就没有办法转发，但是记住所有的 <code>MAC</code> 地址显然是不可能的</p>
<p>  (2) 为什么存在 <code>IP</code> 地址了还需要 <code>MAC</code> 地址：</p>
<p>  ​     局域网应该支持各种网络层协议而 <code>IP</code> 地址仅仅能够用于 <code>IP</code> 协议</p>
<p>  ​     如果网络层采用其他协议 <code>IPX</code> 或者 <code>DECnet</code> 协议，那么不同网络层的协议在没有 <code>MAC</code> 地址的情况下就是无法通信的</p>
</li>
</ul>
</li>
<li><p>[ARP](#ARP 协议)：<a style="color:red;">ARP 协议在 《TCP/IP 详解》中归为网络层；在 《自顶向下》中认为网络层或者数据链路层都是可以的</a></p>
</li>
</ul>

        <h2 id="功能"   >
          <a href="#功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#功能" class="headerlink" title="功能"></a>功能</h2>
      
        <h3 id="成帧"   >
          <a href="#成帧" class="heading-link"><i class="fas fa-link"></i></a><a href="#成帧" class="headerlink" title="成帧"></a>成帧</h3>
      
        <h4 id="封装成帧"   >
          <a href="#封装成帧" class="heading-link"><i class="fas fa-link"></i></a><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h4>
      <ul>
<li><p>封装成帧：网络适配器将 <strong>数据报</strong> 添加 <strong>首部信息</strong> 和 <strong>尾部信息</strong> 后进行封装</p>
</li>
<li><p>首部信息( 帧开始符 SOH )：<a style="color:red;">实现帧同步</a>：通知接收方数据帧即将到来请做好接收准备</p>
</li>
<li><p>尾部信息( 帧结束符 EOT)：<a style="color:red;">接收方校验数据帧是否正确</a>（CRC 循环冗余校验码）也可以标识帧的结束</p>
<p>  <a style="color:red;">注：如果不使用尾部信息接收方是无法得知帧是否出了差错</a>：那么就只能够留给高层判断，这样显然浪费时间</p>
</li>
<li><p>细节：</p>
<ul>
<li><a style="color:red;">数据报也被称为 <strong>最大传送单元</strong> (MTU) </a> </li>
<li>首部信息和尾部信息中也有许多协议控制信息，上述仅是最重要的</li>
<li>真正的帧格式并不是图中所示，这里仅仅只是抽象地表示，每个局域网协议不同，帧的格式也不同</li>
</ul>
</li>
</ul>
<p><img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210308192406247.png" alt="image-20210308192406247"></p>

        <h4 id="透明传输"   >
          <a href="#透明传输" class="heading-link"><i class="fas fa-link"></i></a><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4>
      <ul>
<li><p>透明传输：保证无论任何组合的比特序列都能够在信道中==不受到任何阻碍==地传输</p>
<p>  解释：阻碍是指帧首部和帧尾部是多位比特组成的控制信息，数据部分的比特序列可能和控制信息一致，阻碍帧的数据部分传输</p>
</li>
<li><p>实现透明传输方式</p>
<ul>
<li><p>字符计数法</p>
<ul>
<li>概念：每帧的==首位==之前==增加一位比特==，用于标记当前帧总共的比特位数（<a style="color:red;">包含标记位</a>）</li>
<li>缺陷：<a style="color:red;">标记位发生错误</a>会导致后面所有帧的比特全部都被解析错误<img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210308193222252.png" alt="image-20210308193222252"></li>
</ul>
</li>
<li><p>字符填充法</p>
<ul>
<li><p>概念：在每个与控制信息冲突的比特序列之前增加转义信息（ESC），<a style="color:red;">如果比特序列和转义信息冲突同样增加转义信息</a></p>
</li>
<li><p>解析方式：接收方找到正确的帧开始和帧结束之后会 <strong>删去转义信息剩下传输的数据</strong></p>
</li>
<li><p>缺陷：复杂性和不兼容性<img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210308193628777.png" alt="image-20210308193628777"></p>
</li>
</ul>
</li>
<li><p>==零比特填充法==</p>
<ul>
<li>概念：比特序列中每出现 5 个连续的 “1”就在后面增加 1 个 “0”</li>
<li>解析方式：接收方找到正确的帧开始和帧结束之后==硬件==会扫描比特序列，每 5 个连续的 “1” 就会删去后面的 “0”<img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210308193906261.png" alt="image-20210308193906261"></li>
</ul>
</li>
<li><p>==违规编码==</p>
</li>
</ul>
</li>
</ul>

        <h3 id="差错控制"   >
          <a href="#差错控制" class="heading-link"><i class="fas fa-link"></i></a><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3>
      
        <h4 id="原因"   >
          <a href="#原因" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因" class="headerlink" title="原因"></a>原因</h4>
      <ul>
<li><p>根本原因：信号在信道中传输时受到噪声的影响</p>
</li>
<li><p>类型</p>
<ul>
<li><p>全局性：传输介质固有的==随机噪声==；提高信噪比减少噪声（改善传感器）</p>
</li>
<li><p>局部性：外界对信道造成的短暂性的==冲击噪声==（主要原因）；使用编码技术解决</p>
<ul>
<li><p>帧错：丢失 +重复 + 失序</p>
</li>
<li><p>位错：比特位发生跳变</p>
<p>  注：比特序列中一般来说只有一位跳变的可能性最大，两位同时跳变的可能性比较低</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li><p><a style="color:red;">传输帧发生错误后数据链路层直接抛弃并不会重传帧</a>：高层没有收到相应的分组那么会要求低层重传 <strong>丢失的帧</strong> (当然高层也可能没有实现可靠传输)</p>
<p>  注：因为通常数据链路层都是不实现可靠传输和流量控制的</p>
</li>
<li><p> <a style="color:red;">帧发生错误只能够依靠可靠传输来解决，差错控制是无法解决帧错的</a></p>
</li>
<li><p> <a style="color:red;">差错控制 <strong>不能够保证可靠传输</strong></a></p>
</li>
</ul>
</li>
<li><p>适用情况</p>
<ul>
<li>==有确认无连接== 和 ==有确认有连接的服务== 是 ==通信质量较差的无线链路==需要使用纠错检错的技术，保证数据的完整性</li>
<li>==无连接无确认== 的服务是不需要使用差错控制的技术，保证传输的效率</li>
</ul>
</li>
</ul>

        <h4 id="检错编码"   >
          <a href="#检错编码" class="heading-link"><i class="fas fa-link"></i></a><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h4>
      <ul>
<li><p>奇偶校验码</p>
<ul>
<li><p>概念：</p>
<p>  在比特序列的首位前增加一位校验位（1或者0）；</p>
<p>  如果是==奇校验==，增加校验位后需要保证当前的==比特 “1” 的数量为奇数==</p>
<p>  如果是==偶校验==，增加校验位后需要保证当前的==比特 “1” 的数量为偶数==</p>
</li>
<li><p>细节：(1) <a style="color:red;">能够检测 <strong>奇数个比特位</strong> 发生错误</a>  (2) <a style="color:red;">不具有纠错的能力</a></p>
</li>
</ul>
</li>
<li><p>CRC循环冗余校验码</p>
<ul>
<li><p>概念</p>
<p>  ==需要传输的数据 ÷ 生成多项式 = 商 … FCS帧检验序列（冗余码）==</p>
<p>  实际传输数据 = 需要传输的数据 + FCS帧检验序列</p>
<p>  接收方将得到的 ==实际传输数据== ÷ 生成多项式</p>
<p>  如果余数为 0 那么证明没有发生错误，如果余数不为 0 那么证明传输过程中发生了错误</p>
</li>
<li><p>实现</p>
<ul>
<li>根据生成多项式$(X^4 + X^1 + X^0)$得到对应的二进制编码（10011）</li>
<li><a style="color:red;">需要传输的数据增加 $r$ 个 0（r是生成多项式的最高阶）</a></li>
<li>需要传输的数据 ÷ 生成多项式的二进制编码 –&gt; FCS帧检验序列</li>
<li>最后将之前增加的 $r$ 个 0 全部换成 FCS帧检验序列</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>CRC 校验码是==具有纠错功能==；数据链路层==只使用检错功能==</li>
<li>CRC 校验码实现==无差错传输==而不是==可靠传输==</li>
<li>CRC 校验码能够检验出所有的==单比特出错==</li>
<li>CRC 校验码可以使用==硬件==完成</li>
<li><a style="color:red;">带 $r$ 个校验位的多项式编码可以检测到所有长度 **小于等于 $r$ **的突发性错误</a></li>
</ul>
</li>
<li><p><a href="#IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F">首部校验和</a></p>
</li>
</ul>
</li>
</ul>

        <h4 id="纠错编码"   >
          <a href="#纠错编码" class="heading-link"><i class="fas fa-link"></i></a><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h4>
      <ul>
<li><p>海明码</p>
<ul>
<li><p>实现</p>
<ul>
<li><p>海明不等式：==2^r^ ≥ k + r + 1==（r表示<strong>校验位的位数</strong>，k表示<strong>需要传输的数据的位数</strong>）</p>
</li>
<li><p>利用海明不等式得到 r 个校验位；每个校验位<strong>只能放在 2 的 n 次方的位置</strong>（即只能放在1,2,4,8,16…）</p>
</li>
<li><p>确认好校验位和数据的相对位置关系后；利用分组的奇校验得到每个校验位的数据（1或者0）</p>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210308201008841.png" alt="image-20210308201008841"></p>
</li>
<li><p>确定每个校验位到底<strong>负责检验哪几个数据</strong></p>
<p>  P<del>1</del> 负责检验 D<del>1</del> D<del>2</del> D<del>4</del> D<del>5</del>  (P<del>1</del> 是第一个，所以找<strong>数据的二进制的最低位</strong>和<strong>P<del>1</del>的 二进制最低位相同的</strong>；P<del>2</del> 同理，找倒数第二个)</p>
</li>
<li><p>校验位 和 负责检验的数据们 进行<strong>异或</strong>的操作</p>
<p>  P<del>1</del> ⊕ D<del>1</del>⊕ D<del>2</del>⊕ D<del>4</del>⊕ D<del>5</del> = 0 –&gt; 倒推得到 P<del>1</del> 的值；其余检验位值同理</p>
</li>
<li><p>实际传输的数据 = 冗余校验位 + 需要传输的数据</p>
<p>  如果传输的数据出现差错，那么再将<strong>每个检验位</strong>和它们<strong>分别负责的数据</strong>们进行<strong>异或</strong>的操作</p>
<p>  得到的<strong>异或结果</strong>再做<strong>异或</strong>操作，这次得到的结果就是出错比特的位置</p>
</li>
</ul>
</li>
<li><p>特点：能够检验 2 个比特位，但是只能够纠错 1 位比特</p>
</li>
</ul>
</li>
</ul>

        <h3 id="链路管理"   >
          <a href="#链路管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#链路管理" class="headerlink" title="链路管理"></a>链路管理</h3>
      
        <h4 id="多路访问链路"   >
          <a href="#多路访问链路" class="heading-link"><i class="fas fa-link"></i></a><a href="#多路访问链路" class="headerlink" title="多路访问链路"></a>多路访问链路</h4>
      
        <h5 id="传输链路"   >
          <a href="#传输链路" class="heading-link"><i class="fas fa-link"></i></a><a href="#传输链路" class="headerlink" title="传输链路"></a>传输链路</h5>
      <ul>
<li>点对点链路<ul>
<li>概念：两个相邻节点相连，没有第三者</li>
<li>应用：==PPP 协议== ==HDLC 协议==</li>
</ul>
</li>
<li>广播式链路<ul>
<li>概念：所有结点共享一个通信信道</li>
<li>应用：早期的==总线以太网，无线局域网==</li>
<li>典型拓扑结构：星型（逻辑总线型），总线型<ul>
<li>星型：单点故障；中心设备故障是会导致网络瘫痪的。</li>
<li>总线型：不存在单点故障；但是总线结点出问题同样会导致网络瘫痪</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h5 id="信号冲突"   >
          <a href="#信号冲突" class="heading-link"><i class="fas fa-link"></i></a><a href="#信号冲突" class="headerlink" title="信号冲突"></a>信号冲突</h5>
      <ul>
<li><p>基本概念：两个节点 <strong>同时</strong> 传输帧，两个节点的帧在传输的过程中发生 <strong>碰撞</strong></p>
</li>
<li><p>产生情况：<a style="color:red;">电路交换不会产生信号冲突，分组交换会产生信号冲突</a></p>
<p>  注：因为电路交换是点对点地传输数据，分组交换则是基于广播式网络很容易产生冲突</p>
</li>
<li><p>细节：<a style="color:red;">多个帧在发生碰撞之后仍然会继续传输</a>，不过接收方在利用差错控制检测到错误时是不会接收的</p>
</li>
<li><p>解决方式：介质访问控制</p>
</li>
</ul>

        <h5 id="介质访问控制"   >
          <a href="#介质访问控制" class="heading-link"><i class="fas fa-link"></i></a><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h5>
      <ul>
<li>目的：==协调==节点传输数据的过程 </li>
</ul>

        <h6 id="信道划分介质访问控制"   >
          <a href="#信道划分介质访问控制" class="heading-link"><i class="fas fa-link"></i></a><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h6>
      <ul>
<li><p>基本概念：将使用介质的每个设备利用技术进行 <strong>隔离</strong> </p>
</li>
<li><p>频分多路复用（FDM）</p>
<ul>
<li><p>内容：协议分配给用户特定频率的频带，用户在通信过程中 ==始终占用当前频带==</p>
</li>
<li><p>原理：多条频率不同的频带产生的信号的“宽度”（频率）不同，接收能够解析不同的信号</p>
</li>
<li><p>优点：(1) 可以 ==同时发送数据且不需要等待== (2) <a style='color:red;'>消除碰撞</a> (3) 实现容易且效率较高</p>
</li>
<li><p>缺点：资源利用率不高：每个节点的最大带宽只有整个系统的 $\frac{1}{N}$</p>
</li>
<li><p>细节：(1) 所有节点 ==共享信道的时间== (2)==传输模拟信号== (3) <strong>每个频带都可以看做一条链路</strong></p>
</li>
</ul>
</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210311163747321.png" alt="image-20210311163747321"></p>
<ul>
<li><p>时分多路复用（TDM）</p>
<ul>
<li><p>内容</p>
<ul>
<li><p>协议将信道划分为多个 <strong>时间帧</strong>，且每个时间帧中又划分为多个 <strong>时隙</strong></p>
</li>
<li><p>每个节点会被划分到一个 <strong>特定的时隙</strong></p>
</li>
<li><p>每个节点发送数据的时候必须在自己的 <strong>特定时隙开始</strong> 的时候发送</p>
<p>  注：(1)不能够在某个时隙的中间开始发送 (2) 时隙就是 <strong>非常短</strong> 的一段时间</p>
</li>
</ul>
</li>
<li><p>原理：每个时隙只用于一个节点的传输数据，不会有其他节点的干扰</p>
</li>
<li><p>条件：<a style="color:red;">时隙的时长应该保证数据帧能够被传输完成</a></p>
</li>
<li><p>优点：(1) 可以 ==同时发送数据== (2) <a style="color:red;">消除碰撞</a></p>
<p>  解释：因为每个时隙很短，所以也可看做同时发送</p>
</li>
<li><p>缺点：(1) 每个节点需要 ==等待== 自己的时隙到来 (2) 资源利用率不高：每个节点的最大带宽只有整个系统的 $\frac{1}{N}$</p>
</li>
<li><p>细节：(1) 所有节点 ==共享信道的频率== (2)==传输数字信号== (这也是为什么更多仍然是使用时分多路复用而不是频分多路复用)</p>
</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210311165115013.png" alt="image-20210311165115013"></p>
</li>
<li><p>改进的时分复用（STDM）</p>
<ul>
<li>内容<ul>
<li>每个节点不需要等待自己的时隙到来；==直接==可以将自己需要传输的数据送入==集中器==中</li>
<li>集中器将传入的数据进行打包==封装成 STDM 帧==在信道上传输</li>
</ul>
</li>
<li>细节：<a style="color:red;">STDM 帧中的时隙数小于节点数</a></li>
<li>优点：==全速传输==（整个系统的带宽完全被利用起来）</li>
</ul>
</li>
</ul>
<p><img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210311165529935.png" alt="image-20210311165529935"></p>
<ul>
<li><p>波分多路复用（WDM）</p>
<ul>
<li>内容：光的频分多路复用</li>
</ul>
</li>
<li><p>码分多路复用（CDM / CDMA）</p>
<ul>
<li><p>内容：</p>
<p>  信道将多个结点需要发送的数据根据==特定的编码方式==封装在一起</p>
<p>  信道将封装好后的数据进行传输</p>
<p>  信道在数据传输到目的节点时根据之前设定的编码方式将多个数据拆分开</p>
</li>
<li><p>实现方式：</p>
<ul>
<li><p>每个站点被指定唯一的 m 位==芯片序列==</p>
</li>
<li><p>使用芯片序列对传输的比特进行==编码==；</p>
<p>  1 被编码为 （+1 -1 +1 -1 +1 -1 +1 -1）；0 就被编码为 1 的反码（-1 +1 -1 +1 -1 +1 -1 +1）</p>
<p>  芯片序列中使用 -1 代表 0</p>
</li>
<li><p>多个站点同时发送数据的时，要求每个站点发送的数据的==每个比特实现正交==</p>
<p>  ==A 站点发送的数据 1 的芯片序列 x B 站点发送的数据 0 的芯片序列 = 0==</p>
<p>  如果不满足正交的条件是不允许发送的</p>
</li>
<li><p>多个站点满足正交的条件下发送的数据采用 ==线性==合并的方式</p>
<p>  ==A 站点发送的数据 1 的芯片序列 + B 站点发送的数据 0 的芯片序列 = 传输的数据的芯片序列==</p>
</li>
<li><p>将合并后的数据分离使各个站点能够正常接收</p>
<p>  ==传输的数据芯片序列 x A 站点的发送的数据的芯片序列 ÷ 8 = A 站点发送的数据==</p>
</li>
</ul>
</li>
<li><p>总结：既共享时间又共享空间</p>
</li>
<li><p>优点</p>
<ul>
<li>消除碰撞</li>
<li>信道利用率高</li>
<li>抗干扰能力强，保密性强，语音质量好</li>
</ul>
</li>
<li><p>适用于无线通信系统</p>
</li>
</ul>
</li>
<li><p>对比</p>
<p>  注：只要采用这种静态划分信道的方式，可以说就是将分组交换变成了电路交换 （以太网中都不采用这种方式来划分信道）</p>
<div class="table-container"><table>
<thead>
<tr>
<th></th>
<th>FDM</th>
<th>TDM</th>
<th>CDM</th>
</tr>
</thead>
<tbody><tr>
<td>共享</td>
<td>共享时间</td>
<td>共享空间</td>
<td>共享时间和空间</td>
</tr>
<tr>
<td>特点</td>
<td><a style="color:red;">广播式变为点对点</a></td>
<td><a style="color:red;">广播式变为点对点</a></td>
<td><a style="color:red;">广播式变为点对点</a></td>
</tr>
<tr>
<td>优点</td>
<td>1.消除碰撞 2.同时发送数据</td>
<td>1.消除碰撞</td>
<td>1.消除碰撞 2.信道利用率高</td>
</tr>
<tr>
<td>适用性</td>
<td>模拟信号传输</td>
<td>数字信号传输</td>
<td>无线通信</td>
</tr>
<tr>
<td>缺点</td>
<td>每个频带带宽较低</td>
<td>1.每个频带带宽较低 2.不能同时发送</td>
<td>无</td>
</tr>
</tbody></table></div>
</li>
</ul>

        <h6 id="随机访问介质访问控制"   >
          <a href="#随机访问介质访问控制" class="heading-link"><i class="fas fa-link"></i></a><a href="#随机访问介质访问控制" class="headerlink" title="随机访问介质访问控制"></a>随机访问介质访问控制</h6>
      <ul>
<li><p>纯 ALOHA 协议</p>
<ul>
<li><p>内容：多个站点==可以同时发送数据==，产生信号冲突后，每个站点有 ==概率 p== 立即重传该帧；==1-p的概率选择其他时间== 重传该帧</p>
<p>  解释：这里的检测冲突并不是 CSMA/CD 协议的检测冲突，而是利用差错控制发现数据帧损坏而得知可能造成冲突，最后由高层要求重传</p>
</li>
<li><p>缺点：</p>
<p>  (1) 多个站点同时发送数据造成的冲突会非常多，产生非常多的超时重发，浪费信道带宽</p>
<p>  (2) <a style="color:red;">无法避免信号冲突</a></p>
</li>
</ul>
</li>
<li><p>信道效率的近似计算：$Np(1 - p)^2(N-1)$  取极限最大效率为 1 / 2e ≈ <strong>0.18</strong></p>
<p>  注：==实际带宽 = 理想带宽 * 信道效率==</p>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210311171636295.png" alt="image-20210311171636295"></p>
</li>
<li><p>时隙 ALOHA 协议</p>
<ul>
<li><p>内容：</p>
<ul>
<li>协议将时间划分为 <strong>多个时隙</strong></li>
<li>每个节点需要发送数据时都会 <strong>占用一个时隙</strong> （<a style="color:red;">这个时隙不专属于任何一个节点</a>）</li>
<li>每个节点只可以在 <strong>时隙开始</strong> 的时候发送数据 （<a style="color:red;">每个节点知道时隙什么时候开始</a>）</li>
<li>如果多个站点同时需要发送数据，产生信号冲突后，仍然以 $p$ 的概率 <strong>立即重传</strong> 或者 $1-p$ 的概率选择 <strong>其他时间重传</strong> </li>
</ul>
</li>
<li><p>缺点：(1) 效率仍然偏低 信道效率的近似计算：$Np(1 - p)^(N-1)$ ；最大效率为 1 / e ≈ <strong>0.37</strong> (2) <a style="color:red;">无法避免冲突</a></p>
</li>
<li><p>图示</p>
</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210311172237359.png" alt="image-20210311172237359"></p>
</li>
<li><p>CSMA 协议</p>
<ul>
<li><p>基本概念：每个节点在发送帧之前对信道上的其他节点进行 <strong>监听</strong>，检测其他节点是否正在发送数据</p>
</li>
<li><p>分类（信道忙的不同决策）</p>
<ul>
<li><p>1-坚持 CSMA</p>
<ul>
<li>内容：如果信道空闲下==直接传输==帧；如果信道忙则==一直监听==到信道空闲，然后立刻传输帧</li>
<li>优点：减少了信道利用率的损失</li>
<li>缺点：仍然不能够很好的避免信号冲突</li>
</ul>
</li>
<li><p>非坚持 CSMA</p>
<ul>
<li>内容：如果信道空闲下==直接传输==帧；如果信道忙则==选择其他时间监听==，如果信道空闲则立刻传输帧</li>
<li>优点：较好避免冲突的产生</li>
<li>缺点：增加网络数据在网络中延迟，信道利用率是提升的</li>
</ul>
</li>
<li><p>p-坚持 CSMA</p>
<ul>
<li><p>内容：</p>
<p>  如果信道空闲下==概率p立即传输帧，概率1-p选择其他时间==传输帧；</p>
<p>  如果信道忙则==一直监听==到信道空闲，然后立刻传输帧</p>
</li>
<li><p>缺点：产生冲突后依旧会把当前帧发送完，依然会造成带宽的浪费（之前的所有协议都有这个问题）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li><p><a style="color:red;">CSMA 协议同样是不具有物理检测冲突的能力的</a></p>
</li>
<li><p><a style="color:red;">信道空闲并不代表当前传输数据不会发生冲突</a></p>
<p>  解释：传输的数据可能刚好==没有进入==其他站点的==监听范围==，导致其他站点认为信道空闲，开始传输数据，产生冲突</p>
<p>  争用期：信号在最远的两个端点之间往返传输的时间</p>
<p>  发送方接收到碰撞信号的时间分析：</p>
</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210311175715866.png" alt="image-20210311175715866"></p>
</li>
</ul>
</li>
<li><p>CSMA/CD 协议</p>
<ul>
<li><p>基本概念：碰撞检测(Collision Detection)：网络适配器在发送数据的同时依然会对信道电压进行检测</p>
</li>
<li><p>内容：</p>
<ul>
<li>监听信道：(1) 如果信道当前正忙就会持续监听直到信道空闲 (1-坚持 CSMA) (2) 如果信道空闲就直接发送帧</li>
<li>帧在传输过程中只要检测到冲突的产生就会 <strong>立刻终止帧的传输</strong></li>
<li>终止传输后选择另一个时间（ <strong>二进制退避算法</strong> ）进行重传</li>
<li>并发送拥塞信号，通知整个网络中的节点</li>
</ul>
</li>
<li><p>信道效率：$\frac{1}{1+5d_prop/d_trans}$ （<a style="color:red;">传输帧所花费的时延越高越容易导致冲突无法检测</a>：导致效率降低）</p>
</li>
<li><p>二进制退避算法：</p>
<ul>
<li><p>目的：CSMA / CD 协议会在冲突之后终止信号的传输，选择时间重传，二进制退避算法就是用于计算这个时间</p>
</li>
<li><p>步骤</p>
<p>  ①确定==基本退避时间 2τ==</p>
<p>  ②从==离散==（只有整数）集合[0 ~ 2^k^ - 1] 中==任取一个==作为基本退避时间的==倍数==</p>
<p>  ③ ==k = min{10，重传次数}==；如果重传次数超过 10 次，那么 k 一直为 10；如果小于 10 次，那么就 k 就为重传次数</p>
<p>  ④退避时间 = 倍数 x 基本退避时间 –&gt; t = r x 2τ</p>
<p>  ⑤如果重传次数==超过 16 次==，数据链路层会向高层报告错误，帧传输失败</p>
</li>
</ul>
</li>
<li><p>最小帧长问题</p>
<ul>
<li><p>原因：如果==帧长过短==，那么发送方会直接将帧完全发送出去，此时即使发生了碰撞，发送方也无法终止</p>
</li>
<li><p>解决方式：保证在检测到碰撞的时候，帧仍然没有发送结束，剩下的部分帧就可以被终止发送</p>
</li>
<li><p>公式：==帧的传输时延 ≥ 2 * 信号传播时延（RTT）==（帧长 ÷ 数据<strong>发送速率</strong> ≥ RTT）</p>
<p>  解释：接收方检测到碰撞的==最大时延==是 2τ；只要保证在 2τ 时间之内帧仍然没有发送结束就可以</p>
</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li>适用于 <strong>总线型网络</strong> 或者 <strong>半双工网络</strong></li>
<li><a style="color:red;">应用于有线连接的局域网，不适用于无线局域网</a>：(1) ==实现冲突检测硬件花费过大== (2) 存在隐蔽站问题</li>
</ul>
</li>
</ul>
</li>
<li><p>CSMA/CA 协议</p>
<ul>
<li><p>基本概念</p>
<ul>
<li><p>基本思想：节点发送数据之前提前告知其他将要发送数据的节点，使其他节点暂时停止发送，避免出现碰撞</p>
</li>
<li><p>帧间间隔</p>
<ul>
<li><p>概念：每个结点在发送过程中每发送一帧都需要等待一段时间</p>
</li>
<li><p>目的：避免碰撞</p>
</li>
<li><p>分类</p>
<ul>
<li>SIFS：最短；分隔每一次对话的各帧</li>
<li>PIFS：中等</li>
<li>DIFS：最长；节点开始发送数据前</li>
</ul>
</li>
<li><p>情况：</p>
<p>  ①节点开始发送之前需要等待 DIFS </p>
<p>  ②节点在发送过程中每发送一帧需要等待 SIFS</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>内容</p>
<ul>
<li>根据需要采用 RTS/CTS 预约方式（一般来说是会采用的）</li>
<li>如果信道空闲，节点发送数据之前需要经过帧间间隔（DIFS），才能够发送数据</li>
<li>如果信道忙，采用二进制退避算法选择其他时间再发送数据</li>
<li>数据帧发送后等待接收节点的确认（ARQ）：如果未收到确认帧，就会重发</li>
</ul>
</li>
<li><p>隐蔽站问题</p>
<ul>
<li><p>问题描述</p>
<p>  两个节点同时向一个节点发送数据；</p>
<p>  两个节点因为之间的距离过远导致相互==无法通过冲突检测==到对方（两者可能同时发送数据）</p>
</li>
<li><p>解决方式：“预约”</p>
<p>  发送方需要发送数据之前向接收方发送 RTS 帧（包含源地址，目的地址，发送数据持续时间）</p>
<p>  接收方接收到 RTS 帧后返回 CTS 帧（只包括通信时间）</p>
<p>  接收方利用 CTS 帧向范围内的其他节点广播暂时不要发送数据</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>对比：数据链路层所有帧的重复都是交由高层决定，因为数据链路层本身并不实现可靠传输没有确认重传机制</p>
</li>
</ul>
<div class="table-container"><table>
<thead>
<tr>
<th></th>
<th>纯ALOHA</th>
<th>时隙ALOHA</th>
<th>CSMA</th>
<th>CSMA/CD</th>
<th>CSMA/CA</th>
</tr>
</thead>
<tbody><tr>
<td>冲突检测</td>
<td>差错控制检测</td>
<td>差错控制检测</td>
<td>差错控制检测</td>
<td>硬件物理检测</td>
<td>不检测</td>
</tr>
<tr>
<td>监听方式</td>
<td>不采用</td>
<td>不采用</td>
<td>电缆电压</td>
<td>电缆电压</td>
<td>能量检测，载波检测，能量载波混合检测</td>
</tr>
<tr>
<td>缺点</td>
<td>效率低</td>
<td>效率低</td>
<td>浪费信道带宽</td>
<td>无线网难中以实现</td>
<td>无法完全避免冲突</td>
</tr>
<tr>
<td>避免冲突</td>
<td>不能</td>
<td>不能</td>
<td>不能</td>
<td>不能</td>
<td>尽量避免</td>
</tr>
</tbody></table></div>

        <h6 id="轮询访问介质访问控制"   >
          <a href="#轮询访问介质访问控制" class="heading-link"><i class="fas fa-link"></i></a><a href="#轮询访问介质访问控制" class="headerlink" title="轮询访问介质访问控制"></a>轮询访问介质访问控制</h6>
      <ul>
<li><p>轮询协议</p>
<ul>
<li><p>内容：</p>
<p>  (1) 主节点依次询问从节点是否需要发送数据（发送信号询问）</p>
<p>  (2) 如果需要发送数据，从节点立刻发送就行；如果不需要发送数据，主节点依次询问下一个节点是否发送数据</p>
</li>
<li><p>优点：(1) <a style="color:red;">消除碰撞</a>  (2) <a style="color:red;">发送时可以占用所有带宽</a></p>
</li>
<li><p>缺点：(1) 询问信号产生开销 (2) 每个节点需要依次等待 (3) 单点故障</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>令牌传递协议</p>
<ul>
<li><p>内容：</p>
<p>  所有节点在==逻辑结构==上组成==环形== （令牌实际上是 MAC 控制帧）</p>
<p>  如果信道空闲，令牌就会在信道上按照一定的方向移动（顺时针或者逆时针）</p>
<p>  如果节点需要发送数据，那么该节点获得令牌，==修改其标志位==，将其和==数据帧结合==，发送到信道上</p>
<p>  令牌 + 数据帧继续在信道上移动，非接收方的节点不会对令牌做任何修改</p>
<p>  相应的接收方会对令牌 + 数据帧==进行复制==，再次==修改其标志位==</p>
<p>  令牌 + 数据帧到达接收方并被复制一份后==再次回到发送方处==</p>
<p>  发送方==检查是否出错==，如果出错就会重发；如果没有出错令牌将会和数据帧分离，继续在信道上移动</p>
</li>
<li><p>优点：适用于==网络负载重，通信量==较大的网络</p>
</li>
<li><p>缺点：(1) ==令牌开销== (2) 每个节点需要依次等待 (3) 单点故障</p>
</li>
<li><p>注意点：每个节点只能在一定的时间内持有令牌，如果超过这个时间数据没有发送成功，令牌将被移交到另一个节点</p>
</li>
<li><p>图示</p>
</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210312154721673.png" alt="image-20210312154721673"></p>
</li>
</ul>

        <h6 id="三种介质访问控制方式对比"   >
          <a href="#三种介质访问控制方式对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#三种介质访问控制方式对比" class="headerlink" title="三种介质访问控制方式对比"></a>三种介质访问控制方式对比</h6>
      <ul>
<li>信道划分介质访问控制<ul>
<li>优点：适用于网络负载重的情况<ul>
<li>共享信道效率较高，非常公平</li>
<li>不会产生任何冲突</li>
</ul>
</li>
<li>缺点：不适合网络负载轻的情况<ul>
<li>共享信道长时间处于空闲，信道利用率低</li>
<li>节点的传输速率在空闲状态依然受到限制</li>
</ul>
</li>
</ul>
</li>
<li>随机访问介质访问控制<ul>
<li>优点：适用于网络负载轻的情况<ul>
<li>节点可以全速传输数据</li>
<li>信道利用率高</li>
</ul>
</li>
<li>缺点：不适用于网络负载重的情况<ul>
<li>多个节点同时发送数据会造成大量的冲突，解决冲突会消耗资源</li>
</ul>
</li>
</ul>
</li>
<li>轮询访问介质访问控制<ul>
<li>优点<ul>
<li>不会产生冲突</li>
<li>节点可以全速传输数据</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h4 id="点对点链路"   >
          <a href="#点对点链路" class="heading-link"><i class="fas fa-link"></i></a><a href="#点对点链路" class="headerlink" title="点对点链路"></a>点对点链路</h4>
      <ul>
<li><p>广域网</p>
<ul>
<li>概念：国际性网络（Internet）</li>
<li>特点<ul>
<li>通信子网使用<strong>分组交换</strong>技术</li>
<li>实现资源共享的目的</li>
</ul>
</li>
<li>对比<ul>
<li>局域网：强调数据<strong>传输的速率</strong></li>
<li>广域网：强调<strong>资源共享</strong>的能力</li>
</ul>
</li>
</ul>
</li>
<li><p>PPP协议</p>
<ul>
<li><p>概念：点对点网络协议；<strong>不支持多点线路</strong></p>
<p>  点对点：每个站点只能够对应一个站点</p>
</li>
<li><p>特点</p>
<ul>
<li><p>使用最为广泛的链路层协议</p>
<p>  用户拨号上网时一般都会采用 PPP 协议</p>
</li>
<li><p><strong>只支持全双工通信</strong>链路</p>
</li>
</ul>
</li>
<li><p>功能</p>
<ul>
<li><p>简单迅速：链路层传输帧不需要<strong>纠错</strong>，<strong>序号</strong>，<strong>流量控制</strong>等功能</p>
</li>
<li><p>封装成帧</p>
</li>
<li><p>透明传输</p>
<p>  ①<strong>异步线路</strong>实现透明传输的方式：字节填充</p>
<p>  ②<strong>同步线路</strong>实现透明传输的方式：比特填充</p>
</li>
<li><p>多种网络层协议：网络层可以采用多种<strong>不同的协议</strong></p>
</li>
<li><p>多种类型链路：数据链路层可以采用多种<strong>不同的数据链路</strong>传输</p>
</li>
<li><p>差错检测：帧出错直接丢弃</p>
</li>
<li><p>检测连接状态</p>
</li>
<li><p>设定最大传送数据单元（MTU）：1500 B</p>
</li>
<li><p>网络层地址协商：知道通信双方的<strong>网络层地址</strong></p>
</li>
<li><p>数据压缩协商</p>
</li>
</ul>
</li>
<li><p>协议流程</p>
<ul>
<li><p>IP 数据报根据采用<strong>透明传输的方式</strong>（同步/异步）封装成帧</p>
</li>
<li><p>链路层控制协议 LCP：建立并维护连接</p>
</li>
<li><p>网络层控制协议 NCP：建立并配置逻辑连接</p>
<p>  网络层每个不同的协议，PPP协议都会提供对应的 NCP 协议</p>
</li>
</ul>
</li>
<li><p>帧格式</p>
</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210314151304864.png" alt="image-20210314151304864"></p>
</li>
<li><p>HDLC协议</p>
<ul>
<li>概念：同步网上传输数据，面向比特的数据链路层协议</li>
<li>特点&amp;功能<ul>
<li>只支持全双工通信</li>
<li>透明传输：采用 0 比特填充法</li>
<li>采用 CRC 检验</li>
<li>会对信息帧进行编号</li>
<li>传输可靠性高</li>
</ul>
</li>
<li>HDLC 站的概念<ul>
<li>主站：发送<strong>命令帧</strong>；接收从站的<strong>响应帧</strong>；控制整个链路的启动，差错检验，流量控制</li>
<li>从站：接收<strong>命令帧</strong>；接收主站的<strong>命令帧</strong>；配合主站工作</li>
<li>复合站：既能发送命令帧也能发送响应帧；控制整个链路</li>
</ul>
</li>
<li>数据操作方式<ul>
<li>正常响应方式：从站只能够在主站允许的情况下发送数据</li>
<li>异步响应方式：从站可以任意发送数据；不需要得到主站的允许</li>
<li>异步平衡方式：每个站点都可以同时发送接收数据</li>
</ul>
</li>
<li>帧格式</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210314152232517.png" alt="image-20210314152232517"></p>
<ul>
<li>帧种类<ul>
<li>信息帧</li>
<li>监督帧</li>
<li>无编号帧</li>
</ul>
</li>
</ul>
</li>
<li><p>对比</p>
</li>
</ul>

        <h2 id="局域网"   >
          <a href="#局域网" class="heading-link"><i class="fas fa-link"></i></a><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2>
      
        <h3 id="基本概念"   >
          <a href="#基本概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3>
      <ul>
<li><p>概念：<strong>某一较小区域内</strong>，多台计算机设备共同组成的计算机组，使用<strong>广播信道</strong></p>
</li>
<li><p>组成</p>
<ul>
<li><strong>网络拓扑结构</strong>：描述局域网的整体结构</li>
<li><strong>传输介质</strong>：局域网中各个计算机传输数据依赖的物理媒体</li>
<li><strong>介质访问控制方法</strong>：计算机传输数据时需要遵循的规定（协议）</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>覆盖范围小</li>
<li>数据传输速率高（<strong>双绞线（主流介质），同轴电缆，光纤</strong>）</li>
<li>通信时延低，误码率低，可靠性高</li>
<li>多采用分布式控制和广播通信；能够进行广播和组播</li>
</ul>
</li>
<li><p>网络拓扑结构</p>
<p>  <a style=color:red;>网络的物理拓扑结构和逻辑拓扑结构可以不一样</a></p>
<ul>
<li>星型拓扑<ul>
<li>优点：传输速度快；建网容易且便于控制管理</li>
<li>缺点：可靠性低；共享能力差；单点故障</li>
</ul>
</li>
<li>总线型拓扑<ul>
<li>优点：可靠性高；共享能力强；传输速度快；成本低</li>
<li>缺点：单点故障（指的是总线不是节点）</li>
</ul>
</li>
<li>环形拓扑<ul>
<li>优点：成本低</li>
<li>缺点：单点故障；响应效率低；传输速度低；不便于扩充</li>
</ul>
</li>
<li>树形拓扑<ul>
<li>优点：易于拓展；易于排除故障</li>
<li>缺点：单点故障</li>
</ul>
</li>
</ul>
</li>
<li><p>介质访问控制方法</p>
<ul>
<li><p>CSMA / CD 协议：常用于<strong>总线型局域网和树形局域网</strong></p>
</li>
<li><p>令牌传递协议：常用于<strong>环形局域网</strong></p>
</li>
<li><p>令牌总线协议（？）：常用于<strong>总线型局域网和树形局域网</strong></p>
<p>  该协议在<strong>逻辑上</strong>将总线型或者树形的每个节点按照接口地址大小排列成环</p>
</li>
</ul>
</li>
<li><p>局域网分类</p>
<ul>
<li><p>有线局域网</p>
<ul>
<li><p>以太网</p>
<p>  应用最为广泛；标准以太网，快速以太网，千兆以太网</p>
<p>  <strong>逻辑拓扑总线型，物理拓扑星型</strong></p>
<p>  <strong>CSMA / CD 协议</strong>实现介质访问控制</p>
<p>  <strong>IEEE 802.3协议</strong>制定以太网的标准</p>
</li>
<li><p>令牌环网</p>
<p>  <strong>逻辑拓扑环形，物理拓扑星型</strong></p>
</li>
<li><p>FDDI 网</p>
<p>  <strong>逻辑拓扑环形，物理拓扑双环</strong></p>
</li>
<li><p>ATM 网</p>
<p>  使用 53 固定字节长度的单元进行交换</p>
</li>
</ul>
</li>
<li><p>无线局域网</p>
<p>  WIiFi 是无线局域网的一种应用，范围较无线局域网小</p>
<p>  <strong>IEEE 802.11 协议</strong>制定无线局局域网的标准</p>
</li>
</ul>
</li>
<li><p>局域网 和 OSI 模型</p>
<ul>
<li><p>局域网对应 OSI 模型中的<strong>数据链路层和物理层</strong></p>
</li>
<li><p>IEEE 802.3 协议将数据链路层细分为<strong>LLC层和MAC层</strong></p>
<ul>
<li><p>LLC 层</p>
<p>  ①为网络层提供服务（接口）</p>
<p>  ②维护数据链路层链接</p>
<p>  ③差错控制</p>
<p>  ④给帧添加序号</p>
<p>  注意：现在许多网卡并没有 LLC 协议</p>
</li>
<li><p>MAC 层</p>
<p>  ①负责帧的封装和拆卸（组帧和拆帧）</p>
<p>  ②负责帧的寻址和识别（寻址）</p>
<p>  ③帧的接收和发送</p>
<p>  ④帧的差错控制（比特差错控制）</p>
<p>  ⑤链路管理（竞争处理）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h3 id="以太网"   >
          <a href="#以太网" class="heading-link"><i class="fas fa-link"></i></a><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3>
      <ul>
<li><p>定义：</p>
<ul>
<li>以太网是局域网的一种：所以可以认为以太网是互联自治的计算机集合</li>
<li>以太网是一种 <strong>技术规范</strong>：只规定 ==数据链路层== 和 ==物理层== 的规范<ul>
<li>数据链路层：(1) 规定数据链路层采用何种帧的格式 (2) 规定如何解决多路访问问题</li>
<li>物理层规范：规定采用何种物理媒介去接入网络核心</li>
</ul>
</li>
</ul>
</li>
<li><p>基本特性：造价低廉；应用广泛；速率快</p>
</li>
<li><p>标准</p>
<ul>
<li>DIX Ethernet V2：第一个以太网规约</li>
<li>IEEE 802.3：第一IEEE以太网规约</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li><p>无连接</p>
</li>
<li><p>不可靠服务</p>
<p>  只实现<strong>无差错传输</strong>，不实现<strong>可靠传输</strong>；即以太网并不负责对产生差错的帧进行处理，而是交由高层负责</p>
</li>
<li><p>采用曼切斯特编码</p>
</li>
</ul>
</li>
<li><p>V2 标准（常用）</p>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210312170154293.png" alt="image-20210312170154293"></p>
</li>
<li><p>高速以太网</p>
<ul>
<li>100 BASE-T 以太网<ul>
<li>概念：传送<strong>基带信号</strong>（数字信号）的无屏蔽双绞线以太网，传输速率 100Mb/s</li>
<li>采用<strong>半双工或者全双工</strong>的通信方式</li>
<li>全双工通信方式下不使用 CSMA/CD协议</li>
</ul>
</li>
<li>吉比特以太网<ul>
<li>又称千兆以太网</li>
<li>采用<strong>半双工或者全双工</strong>的通信方式</li>
</ul>
</li>
<li>10 吉比特以太网<ul>
<li>不使用铜线<strong>只使用光纤</strong>作为传输媒体</li>
<li><strong>只采用全双工</strong>通信方式</li>
</ul>
</li>
</ul>
</li>
<li><p>常见传输介质对比</p>
</li>
</ul>
<div class="table-container"><table>
<thead>
<tr>
<th>参数</th>
<th>10BASE5</th>
<th>10BASE2</th>
<th>10BASE-T</th>
<th>10BASE-FL</th>
</tr>
</thead>
<tbody><tr>
<td>传输媒体</td>
<td>同轴电缆（粗）</td>
<td>同轴电缆（细）</td>
<td>非屏蔽双绞线（UTP）</td>
<td>光纤对</td>
</tr>
<tr>
<td>编码方式</td>
<td>曼切斯特编码</td>
<td>曼切斯特编码</td>
<td>曼切斯特编码</td>
<td>曼切斯特编码</td>
</tr>
<tr>
<td>拓扑结构</td>
<td>总线型</td>
<td>总线型</td>
<td>星型</td>
<td>点对点</td>
</tr>
<tr>
<td>最大段长</td>
<td>500m</td>
<td>185m</td>
<td>100m</td>
<td>2000m</td>
</tr>
<tr>
<td>最多结点数目</td>
<td>100</td>
<td>30</td>
<td>2</td>
<td>2</td>
</tr>
</tbody></table></div>

        <h3 id="无线局域网"   >
          <a href="#无线局域网" class="heading-link"><i class="fas fa-link"></i></a><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h3>
      <ul>
<li><p>标准：<strong>IEEE 802.11</strong></p>
</li>
<li><p>IEEE 802.11 标准</p>
<ul>
<li>WDS 帧头格式</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210314143614745.png" alt="image-20210314143614745"></p>
<ul>
<li><p>概念解释</p>
<ul>
<li><p>基本服务集（BSS：Basic Service Set） = 基站（AP：Access Point） + 移动站（移动设备）</p>
<p>  ①所有的移动站都可以在基本服务集的范围内任意通信</p>
<p>  ②移动站经过基站可以和基本服务集之外的移动站通信</p>
</li>
<li><p>基站：需要为每一个基站分配一个不超过 32B 的服务集标识符（SSID：Service Set IDentifier）</p>
</li>
<li><p>基本服务区：一个基本服务集覆盖的地理范围称为一个基本服务区（BSA：Basic Service Area）</p>
</li>
<li><p>分配系统（DS：Distribution System）：连接两个基本服务集</p>
</li>
</ul>
</li>
<li><p>四种不同格式表格</p>
<ul>
<li>SA：Source Address</li>
<li>RA：Receiver Address</li>
<li>DA：Destination Address</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210314143833560.png" alt="image-20210314143833560"></p>
<ul>
<li>分类<ul>
<li>有固定基础设施无线局域网</li>
<li>无固定基础设施的无线局域网的自组织网络</li>
</ul>
</li>
</ul>

        <h3 id="虚拟局域网"   >
          <a href="#虚拟局域网" class="heading-link"><i class="fas fa-link"></i></a><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3>
      
        <h2 id="设备"   >
          <a href="#设备" class="heading-link"><i class="fas fa-link"></i></a><a href="#设备" class="headerlink" title="设备"></a>设备</h2>
      
        <h3 id="扩展以太网"   >
          <a href="#扩展以太网" class="heading-link"><i class="fas fa-link"></i></a><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h3>
      <p>扩展以太网的原因：</p>
<ul>
<li><p>主机需要和其他距离更远的主机进行通信</p>
</li>
<li><p>集线器限制传输距离只能为 100 米</p>
<p>  超出这个距离之后信道中的信号受损之后是无法恢复的</p>
</li>
</ul>

        <h4 id="物理层扩展以太网"   >
          <a href="#物理层扩展以太网" class="heading-link"><i class="fas fa-link"></i></a><a href="#物理层扩展以太网" class="headerlink" title="物理层扩展以太网"></a>物理层扩展以太网</h4>
      <ul>
<li><p>光纤</p>
<ul>
<li>采用光纤作为传输介质连接主机和集线器</li>
</ul>
</li>
<li><p>集线器</p>
<ul>
<li>采用<strong>多层集线器</strong>相连的方式</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210315145441669.png" alt="image-20210315145441669"></p>
</li>
</ul>

        <h4 id="链路层扩展以太网"   >
          <a href="#链路层扩展以太网" class="heading-link"><i class="fas fa-link"></i></a><a href="#链路层扩展以太网" class="headerlink" title="链路层扩展以太网"></a>链路层扩展以太网</h4>
      <ul>
<li><p>网桥</p>
<ul>
<li><p>基本概念</p>
<ul>
<li>网桥根据 <strong>MAC 帧的目的地址</strong>对帧进行<strong>过滤</strong>和<strong>转发</strong></li>
<li>过滤：网桥抛弃当前帧，<strong>不会</strong>将当前帧<strong>转发</strong>到任何一个<strong>接口</strong></li>
<li>转发：网桥将当前帧发送到其他接口去</li>
<li>网段：指一个计算机网络中使用<strong>同一物理设备</strong>，不借助链路层设备就能够直接通信的那一部分</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li><p>透明网桥</p>
<ul>
<li><p>透明：站点之间相互通信，并不会关心需要经过哪些网桥</p>
</li>
<li><p>原理：采用<strong>自学习</strong>算法</p>
<p>  ① 站点 A 向站点 B 发送帧；网桥判断<strong>目的地址</strong>是否在<strong>转发表</strong>中存在</p>
<p>  ②不存在：网桥将会将帧进行<strong>广播式</strong>地转发，<strong>所有的站点</strong>都能够收到帧，但只有目的站点会接收当前帧；并将</p>
<p>  ​                        目的地址记录在转发表中</p>
<p>  ③存在：网桥判断<strong>两个站点</strong>是否处于<strong>同一网段</strong></p>
<ul>
<li>同一网段：网桥<strong>过滤</strong>当前帧，<strong>不会</strong>将当前帧<strong>通过其他网桥转发</strong>到其他站点</li>
<li>不同网盾：网桥<strong>通过其他网桥</strong>转发当前帧，使目的站点能够接收到当前帧</li>
</ul>
<p>  ④网桥会<strong>定时刷新</strong>转发表中的信息</p>
</li>
</ul>
</li>
<li><p>源路由网桥</p>
<ul>
<li><p>原理：寻找最佳的转发路径</p>
<p>  源站通过发送<strong>发现帧</strong>找到用时最少的路径</p>
<p>  发送数据帧时将<strong>最佳路由信息</strong>放在帧的<strong>首部</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>每个网桥只有一个接口</li>
<li>采用全双工通信，每个端口的主机可以在任意时刻通信</li>
<li>隔离冲突域，不能隔离广播域</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>过滤通信量，增大吞吐量</li>
<li>扩大物理范围</li>
<li>提高可靠性</li>
<li>消除冲突</li>
</ul>
</li>
</ul>
</li>
<li><p>交换机</p>
<ul>
<li><p>基本概念：每个交换机相当于多个网桥；具有多个端口</p>
</li>
<li><p>分类</p>
<ul>
<li><p>直通式交换机</p>
<ul>
<li>特点：检查完目的地址立刻转发；延迟小，可靠性低，不支持具有不同速率的端口的交换</li>
</ul>
</li>
<li><p>存储转发式交换机</p>
<ul>
<li><p>特点：帧被放入高速缓存中，并检查是否正确，如果错误直接丢弃；延迟大，可靠性高，支持不同速率的端口</p>
<p>  交换</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>特点：独占传输媒体带宽</p>
<p>  交换机如果具有 30 Mb/s 带宽；每个端口上的主机同样会有 30Mb/s 带宽；</p>
<p>  集线器如果具有 30 Mb/s 带宽；每个端口上的主机只会有 30 / N Mb/s 带宽；</p>
</li>
</ul>
</li>
<li><p>冲突域：网络中同一时间只能够有一台设备发送帧</p>
</li>
<li><p>广播域：网络中能够<strong>接收</strong>任一设备发送的<strong>广播帧</strong>的所有设备集合</p>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/09/network/%E7%BD%91%E7%BB%9C%E5%B1%82/">网络层</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-11</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="网络层"   >
          <a href="#网络层" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1>
      
        <h2 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h2>
      <ul>
<li>概念：<ul>
<li><a style="color:red;">负责转发数据报</a>：并不是针对两个节点之间的</li>
<li><a style="color:red;">确定数据报的转发路径</a></li>
</ul>
</li>
<li>核心：<a style="color:red;">网络层 <strong>不提供可靠传输</strong>服务 和 <strong>流量控制</strong> 服务</a>：尽力而为</li>
<li>单位：==数据报==</li>
<li>功能<ul>
<li>异构网络互连：将物理层和数据链路层不同的网络用统一的协议互联起来<ul>
<li>[IP 协议](# IP 协议)：[IPv4](# IPv4) [IPv6](# IPv6)</li>
<li>[ARP 协议](# ARP 协议)：映射 <code>IP</code> 地址到 <code>MAC</code> 地址</li>
<li>[DHCP 协议](# DHCP 协议)：主机能够自动获取 <code>IP</code> 地址</li>
</ul>
</li>
<li>路由选择：选择开销最小的路径转发分组<ul>
<li>[路由选择协议](# 路由选择协议)：(1) RIP 协议  (2) OSPF 协议 (3) BGP 协议 (<a style="color:red;">前两个协议是 <strong>自治系统内</strong> 协议，最后一个协议是 <strong>自治系统间</strong> 协议</a>) </li>
</ul>
</li>
<li>分组检测：反馈给源路由器分组的相关信息（分组是否到达目的地，分组是否丢失）<ul>
<li>[ICMP 协议](# ICMP 协议)</li>
</ul>
</li>
<li>分组转发：[路由器](# 路由器)：将分组从一个路由器转发到另一个路由器去</li>
</ul>
</li>
<li>细节：<a style="color:red;">网络层以下都是 <strong>点对点</strong> 传输 &lt;-&gt; 传输层以上都是 <strong>端对端</strong> 传输</a></li>
</ul>

        <h2 id="数据交换"   >
          <a href="#数据交换" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据交换" class="headerlink" title="数据交换"></a>数据交换</h2>
      
        <h3 id="数据交换的原因"   >
          <a href="#数据交换的原因" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据交换的原因" class="headerlink" title="数据交换的原因"></a>数据交换的原因</h3>
      <ul>
<li><p>网络中计算机间需要实现数据通信和资源共享</p>
</li>
<li><p>如何实现数据通信和资源共享：</p>
<ul>
<li><p>每台主机之间需要进行通信</p>
</li>
<li><p>主机两两之间建立链路<strong>直接数据交换</strong>导致链路数量太多</p>
</li>
<li><p>主机都接在一个交换设备上进行数据交换，会导致吞吐量过大时<strong>交换设备无法</strong>很好地进行数据交换</p>
</li>
<li><p>主机和多个交换设备组合在一起构成交换网络</p>
<p>  <em>因此交换网络中需要<strong>按照一定的交换方式</strong>进行数据的交换，不能够在随意地进行数据的交换了</em></p>
</li>
<li><p>图示</p>
</li>
</ul>
</li>
</ul>
<p><img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210319151932221.png" alt="image-20210319151932221"></p>

        <h3 id="数据交换方式"   >
          <a href="#数据交换方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h3>
      
        <h4 id="报文交换"   >
          <a href="#报文交换" class="heading-link"><i class="fas fa-link"></i></a><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h4>
      <ul>
<li><p>概念：<strong>动态选择线路</strong>发送<strong>报文</strong></p>
<ul>
<li>动态选择线路：根据网络状况选择最优的转发路径</li>
<li>报文 = 目的地址 + 源地址 + 数据</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li><p>无需建立连接：节省建立连接的时延</p>
</li>
<li><p>提高线路可靠性：不会因为某条路径故障导致数据的重发或者发送失败，可以选择另一条路径发送</p>
</li>
<li><p>提高线路的利用率：通信双方不会长时间占用某条线路</p>
</li>
<li><p>多目标服务：报文可以同时发送给多个目的站点</p>
<p>  <em>能够同时发送吗？</em></p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>具有存储转发的时延<ul>
<li><strong>报文大小不确定</strong>，交换设备需要预备较大的存储空间</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h4 id="分组交换"   >
          <a href="#分组交换" class="heading-link"><i class="fas fa-link"></i></a><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4>
      <ul>
<li><p>发送方式</p>
<ul>
<li><p>数据报交换</p>
<ul>
<li><p>概念：==无需建立连接==，==动态选择线路==发送==分组==</p>
<p>  ​            <em>实际上和分组交换完全是一个概念</em></p>
<ul>
<li><p>动态选择线路：采取路由算法选择最优的转发路径</p>
</li>
<li><p>分组：</p>
<ul>
<li><p>概念：报文按照规格划分成大小基本相等的切片</p>
</li>
<li><p>特点</p>
<p>  ①每个分组都需要附带必要的控制信息：==目的地址 + 源地址 + 控制信息==</p>
<p>  ②每个分组选择的路径不一定相同</p>
<p>  ③==每个分组占用全部带宽==</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>交换过程</p>
<ul>
<li>每个分组携带目的地址的分组传输到交换设备上</li>
</ul>
</li>
<li><p>交换设备查找路由表，找到分组携带的目的地址对应的转发接口</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>重复多次这个过程，直到分组传输到目的主机</p>
<ul>
<li><p>优点：</p>
<ul>
<li><p>无需建立连接</p>
</li>
<li><p>线路利用率较高</p>
</li>
<li><p>没有单点故障</p>
</li>
<li><p>交换设备不需要较大的存储空间</p>
</li>
<li><p>全双工通信</p>
</li>
<li><p>缺点</p>
<ul>
<li>==存储转发时延==</li>
<li>不保证可靠性</li>
</ul>
</li>
<li><p>额外控制信息开销</p>
<ul>
<li>分组可能丢失或者失序</li>
</ul>
</li>
<li><p>==网络拥塞==</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>虚电路交换</p>
<ul>
<li><p>概念：源主机和目的主机建立==虚电路==；==所有分组==按==次序==通过该虚电路从源主机发送到目的主机</p>
<ul>
<li>虚电路：<ul>
<li>源主机到目的主机建立的逻辑连接（物理上并不存在）</li>
<li>路径节点维护一张虚电路表，每张虚电路表记录每个虚电路号对应的转发接口</li>
</ul>
</li>
<li>分组：<ul>
<li>基本概念和数据报交换一致；携带的内容不同</li>
<li>分组携带==虚电路号==不携带目的地址</li>
<li>所有分组携带的虚电路号是一样的</li>
</ul>
</li>
</ul>
</li>
<li><p>交换过程：</p>
<ul>
<li>源主机向目的主机发送请求，目的主机应答后开始传输分组</li>
<li>每个携带虚电路号的分组传输到交换设备上</li>
<li>交换设备查找维护的虚电路表，找到分组携带的虚电路号对应的转发接口</li>
<li>重复多次这个过程，直到分组传输到目的主机</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>保证可靠性</li>
<li>没有分组失序问题</li>
<li>虚电路号相对目的地址开销小</li>
<li>全双工通信</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>单点故障</p>
</li>
<li><p>==连接的建立和拆除需要时间==（网络延迟）</p>
</li>
<li><p>特点：虚电路建立的连接并不是专用的（和电路交换区分开）</p>
<p>  物理意义上的链路在逻辑上可能是多条虚电路；即某部分物理链路可能被多个虚电路共用；所以通信是全双工</p>
</li>
</ul>
</li>
<li><p>流水线问题</p>
</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210319160134849.png" alt="image-20210319160134849"></p>
</li>
</ul>

        <h2 id="IP-协议"   >
          <a href="#IP-协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h2>
      
        <h3 id="IPv4"   >
          <a href="#IPv4" class="heading-link"><i class="fas fa-link"></i></a><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h3>
      
        <h4 id="IPv4-数据报格式"   >
          <a href="#IPv4-数据报格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#IPv4-数据报格式" class="headerlink" title="IPv4 数据报格式"></a>IPv4 数据报格式</h4>
      <ul>
<li><p>整体格式</p>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210319160626422.png" alt="image-20210319160626422"></p>
</li>
<li><p>详细格式</p>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210319162045953.png" alt="image-20210319162045953"></p>
<ul>
<li><p>版本：规定 IP数据报 采用的 IP 协议的版本；便于路由器解析数据报后面的部分</p>
</li>
<li><p>首部长度</p>
<ul>
<li><p>含义：表示 ==IP 数据报首部的长度==（ <a style="color:red;"><strong>固定部分</strong> 和 <strong>可变部分</strong> </a> ）</p>
</li>
<li><p>特点：</p>
<ul>
<li><p>使用 4 位比特 进行表示单位大小的数量</p>
</li>
<li><p>单位大小是 ==4B==</p>
</li>
<li><p>单位大小的数量最少为 5</p>
<p>  解释：数量 * 单位大小 = 首部长度 (<a style="color:red;">最短长度 20B 最长长度 60B</a>)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>区分服务</p>
<ul>
<li><p>含义：区分不同类型的数据报</p>
</li>
<li><p>特点：</p>
<ul>
<li><p>前面 3 bit 是优先权字段</p>
</li>
<li><p>中间 4 bit 用于设置数据报需要的服务：最小时延、最大吞吐量、最高可靠性和最小费用</p>
<p>  注：每个数据报只能够选择其中一项服务；如果都不选择，那么默认是一般服务</p>
</li>
<li><p>最后 1 bit 置为 0</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>总长度</p>
<ul>
<li>含义：表示 IP数据报 的长度（ <a style="color:red;">包括 <strong>首部</strong> 和 <strong>数据部分</strong></a>）</li>
<li>特点：<ul>
<li>使用 16 位比特表示单位大小的数量</li>
<li>单位大小 ==1B==</li>
</ul>
</li>
<li>注意：数据链路层的 <code>MTU</code> 不会达到 2^16^ - 1 B：通常会进行分片</li>
</ul>
</li>
<li><p>标识：<code>IP</code> 数据报分片后每个分片具有的统一标识符</p>
</li>
<li><p>标志：</p>
<ul>
<li>(1) 最高位不使用 </li>
<li>(2) <strong>中间位表示是否是最后一个分片</strong> (<a style="color:red;">0 表示最后一个分片 &amp; 1 表示还有分片</a>) </li>
<li>(3) 最低位表示是否允许分片 (<a style="color:red;">0表示允许分片 &amp; 1 表示禁止分片</a>)</li>
</ul>
</li>
<li><p>片偏移：</p>
<ul>
<li><p>表示：每个分片之间的相对位置</p>
</li>
<li><p>计算方式：</p>
<p>  (1) <code>IP</code> 数据报 - 首部大小 = 数据部分大小</p>
<p>  (2) 数据部分拆分成多个数据部分再分别加上一个首部形成分片：<a style="color:red;">每个分片 <strong>尽可能</strong> 接近 MTU 大小</a> （以太网中的 MTU = 1500B）</p>
<p>  (3) 如果最后一个分片的大小不是 8 的倍数：<a style="color:red;">前面所有分片的大小都需要重现调整</a></p>
</li>
</ul>
</li>
<li><p>生存时间：(1) 数据报每经过一个路由器生存时间就会减1 (2) <a style="color:red;">生存时间为0时，该数据报被丢弃</a></p>
</li>
<li><p>目的：防止数据报没有找到合适的路径进行转发，始终在交换网络中循环</p>
</li>
</ul>
</li>
<li><p>协议</p>
<ul>
<li><p>含义：上层协议采用协议号 (可能不是传输层的协议)</p>
</li>
<li><p>注意：<code>UDP</code>：17 <code>TCP</code>：6 <code>OSPF</code>：89 <code>ICMP</code>：1 <code>IGMP</code>：2 <code>DHCP</code>：67 <code>RIP</code>：520</p>
<p>  <a style="color:red;">注：TCP 协议首部长度也为 20B，UDP 协议首部长度为 8B</a></p>
</li>
</ul>
</li>
<li><p>首部校验和</p>
<ul>
<li><p>含义：检测数据报是否出错</p>
</li>
<li><p>计算过程：</p>
<p>  (1) 将首部所有字段相加 (<strong>首部校验和字段除外</strong>)</p>
<p>  (2) 最后的结果如果溢出就执行 <strong>回卷</strong> 操作</p>
<p>  (3) 将最后的结果取反码就作为首部校验和字段</p>
</li>
<li><p><a style="color:red;">网络层的首部校验和仅校验首部，传输层的校验和是校验整个报文段</a></p>
</li>
</ul>
</li>
<li><p>填充：用于填充首部部分，将首部部分的大小补为 4B 的整数倍</p>
</li>
<li><p>可选字段：用来支持测量，排错以及安全措施</p>
</li>
</ul>

        <h4 id="IPv4-编址"   >
          <a href="#IPv4-编址" class="heading-link"><i class="fas fa-link"></i></a><a href="#IPv4-编址" class="headerlink" title="IPv4 编址"></a>IPv4 编址</h4>
      
        <h5 id="IP-地址分类（二级IP地址）"   >
          <a href="#IP-地址分类（二级IP地址）" class="heading-link"><i class="fas fa-link"></i></a><a href="#IP-地址分类（二级IP地址）" class="headerlink" title="IP 地址分类（二级IP地址）"></a>IP 地址分类（二级IP地址）</h5>
      <ul>
<li><p>IP地址</p>
<ul>
<li><p>概念：全世界唯一的 32位 标识符；<strong>标识</strong>路由器或者主机的<strong>接口</strong></p>
<p>  <a style="color:red;">注意：标识的是接口不是主机；意味着路由器可以有多个 IP 地址</a></p>
</li>
<li><p>表示方法</p>
<ul>
<li>二进制表示</li>
<li>点分十进制(dotted-decimal notation)：将每 8bit 转换成十进制表示</li>
</ul>
</li>
</ul>
</li>
<li><p>分类 IP 地址</p>
</li>
</ul>
<p><img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210319172151300.png" alt="image-20210319172151300"></p>
<ul>
<li>特殊 IP 地址</li>
</ul>
<div class="table-container"><table>
<thead>
<tr>
<th>网络号</th>
<th>主机号</th>
<th>作为IP分组源地址</th>
<th>作为IP分组目的地址</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>全0</td>
<td>全0</td>
<td>可以</td>
<td>不可以</td>
<td>表示主机上的所有 IP 地址</td>
</tr>
<tr>
<td>特定值</td>
<td>全0</td>
<td>不可以</td>
<td>不可以</td>
<td>表示子网本身</td>
</tr>
<tr>
<td>特定值</td>
<td>全1</td>
<td>不可以</td>
<td>可以</td>
<td>直接广播地址</td>
</tr>
<tr>
<td>全1</td>
<td>全1</td>
<td>不可以</td>
<td>可以</td>
<td>受限广播地</td>
</tr>
<tr>
<td>127</td>
<td>任意</td>
<td>不可以</td>
<td>不可以</td>
<td>环回自检；用于软件测试</td>
</tr>
</tbody></table></div>
<p><a style="color:red;">(1) 127 开头的 IP 地址只能够作为环回自检地址；但是能够使用的只有 127.0.0.1</a></p>
<p><a style="color:red;">(2) 0.0.0.0 通常用于默认路由</a></p>
<ul>
<li>优点：<ul>
<li>便于 NIC 组织分配 IP 地址；只需要根据网络号进行分配就行，不需要考虑主机号；主机号由得到网络的机构自行分配</li>
<li><strong>路由器转发表中只需要保存网络号</strong>，而不需要记录主机号（全0），节省表项数量</li>
</ul>
</li>
<li>缺点：不够灵活，造成 IP 地址浪费</li>
</ul>

        <h5 id="NAT转换"   >
          <a href="#NAT转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#NAT转换" class="headerlink" title="NAT转换"></a>NAT转换</h5>
      <ul>
<li><p>公有 IP 地址：可==直接==用于互联网连接的 IP 地址 (利用 <code>python</code> 的 pystun3 可以查看 <code>NAT</code> 相关信息)</p>
  <figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8 </span></span><br><span class="line"><span class="keyword">import</span> stun </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    nat_type, external_ip, external_port = stun.get_ip_info() <span class="comment"># 东北大学校园网 NAT</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;NAT 类型: &quot;</span> + nat_type) <span class="comment"># Restric NAT</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;NAT IP: &quot;</span> + external_ip) <span class="comment"># 210.30.193.143</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;NAT 端口: &quot;</span> + <span class="built_in">str</span>(external_port)) <span class="comment"># 54320</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></div></figure></li>
<li><p>私有 IP 地址</p>
<ul>
<li><p>概念：不能直接用于互联网连接的 IP 地址，只能用于局域网连接</p>
</li>
<li><p>目的：(1) 实现网络安全 (互联网中的任何主机都是不可以直接访问私有 IP 地址的) (2) 节省 IP 地址 ( <strong>不同私网中的私有 IP 地址可以重复使用</strong> )</p>
</li>
<li><p>私有地址</p>
</li>
</ul>
<div class="table-container"><table>
<thead>
<tr>
<th>分类</th>
<th>地址范围</th>
<th>网段个数</th>
<th>IP 地址数量</th>
</tr>
</thead>
<tbody><tr>
<td>A类</td>
<td>10.0.0.0 ~ 10.255.255.255</td>
<td>1</td>
<td>256 x 256 x256</td>
</tr>
<tr>
<td>B类</td>
<td>172.16.0.0 ~ 172.31.255.255</td>
<td>16</td>
<td>16 x 256 x 256</td>
</tr>
<tr>
<td>C类</td>
<td>192.168.0.0 ~ 192.168.255.255</td>
<td>256</td>
<td>256 x 256</td>
</tr>
</tbody></table></div>
<p>  <em>思考：网段个数是怎么算的？</em></p>
<p>  注意：网段个数不是私有 IP 地址的数量</p>
</li>
<li><p>NAT转换 (Network Address Translation) </p>
<ul>
<li><p>原因：私有 IP 地址不能够被外界访问，某些情况下外界需要对私有网络进行访问</p>
<p>  <a style="color:red;">注：私有 IP 地址不可以直接访问外网，外网也不可以直接访问私有 IP 地址</a></p>
</li>
<li><p>实现：</p>
<ul>
<li><p>普通的路由器中安装 <code>NAT</code> 软件 (<a style="color:red;">没有安装 NAT 软件的路由器是无法实现 NAT 穿越的</a>)</p>
</li>
<li><p><code>NAT</code> 路由器 <a style="color:red;">至少具有一个</a> 全球唯一的 IP 地址 &amp;&amp; 维护一张 <code>NAT</code> 转换表 (包含 IP 地址 + 端口号)</p>
</li>
<li><p>私网中的主机需要访问外界时：<code>NAT</code> 路由器会查找转换表，将 ==私有IP地址 + 端口号== 转换成 ==公有IP地址 + 端口号==</p>
</li>
<li><p>外界主机需要访问私网时：<code>NAT</code> 路由器会查找转换表，将  ==公有IP地址 + 端口号== 转换成 ==私有IP地址 + 端口号==</p>
</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li><p><a style="color:red;">NAT 路由器在转发分组时一定会改变 <strong>源 IP 地址</strong></a> (正常的分组在转发过程中只会更改 <code>MAC</code> 地址不会更改 <code>IP</code> 地址)</p>
</li>
<li><p>==节省公有 IP 地址== ：每个私网中都是可以重复使用这些私有 IP 地址的；例如，局域网1使用 172.16.1.1，那么局域网2仍然可以使用 172.16.1.1</p>
</li>
<li><p><code>NAT</code> 路由器没有自学习的能力：如果接收的公网 IP 地址在转换表中并不存在，那么会直接抛弃</p>
</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li><code>NAT</code> 路由器的唯一 <code>IP</code> 地址是通过 <code>ISP</code> 的 [DHCP 协议](#DHCP 协议) 获取的</li>
<li><a style="color:red;">NAT 路由器会 <strong>运行一个 DHCP 服务器</strong> 用于给私网中的每个用户分配临时性的 IP 地址</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        <h5 id="子网划分（三级IP地址）"   >
          <a href="#子网划分（三级IP地址）" class="heading-link"><i class="fas fa-link"></i></a><a href="#子网划分（三级IP地址）" class="headerlink" title="子网划分（三级IP地址）"></a>子网划分（三级IP地址）</h5>
      <ul>
<li><p>原因：</p>
<ul>
<li><p>IP 地址空间的==利用率有时很低==</p>
<p>  申请者申请网络（A类 B类 C类..）可能<strong>实际连接的主机数量</strong>并没有达到<strong>最大容纳的主机数量</strong></p>
<p>  剩余的主机数又不能够被其他申请者使用，导致空闲浪费</p>
</li>
<li><p>两级 IP 地址不够灵活</p>
<p>  没有办法根据实际主机的数量划分网络 IP 地址</p>
</li>
</ul>
</li>
<li><p>概念：</p>
<ul>
<li><p>基本概念：使用 ==网络号 + 部分主机号== 细分一个完整的网络</p>
</li>
<li><p>特点：</p>
<ul>
<li><p>完整的网络进行划分之后，==对外仍然表现为一个网络==；即路由器是不知道这个网络进行了划分</p>
</li>
<li><p>子网号：<a style="color:red;">在分类 IP 地址的基础上划分子网：<strong>子网号是不可以全 0 全 1 的</strong> &amp; 在 CIDR 基础上是可以的</a></p>
<ol>
<li>全 0 子网号：导致该子网的网络地址和主网络的网络地址冲突</li>
<li>全 1 子网号：导致该子网的广播地址和主网络的广播地址冲突</li>
</ol>
<p>  <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34228570/article/details/80245031" >子网号不能够全0全1原因</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>主机号：和二级 IP 地址一致==不能够全0全1==</p>
<ul>
<li>全0：表示第一个子网</li>
<li>全1：表示当前子网的广播地址</li>
</ul>
</li>
</ul>
</li>
<li><p>目的：更好的利用 IP 地址</p>
</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210320185910140.png" alt="image-20210320185910140"></p>
<ul>
<li><p>定长划分子网</p>
<ul>
<li><p>概念：借用==位数一定==的主机号来细分网络</p>
</li>
<li><p>特点：</p>
<ul>
<li><a style="color:red;">每个子网的子网掩码都一样</a></li>
<li><a style="color:red;">每个子网能够容纳的主机数量一样</a></li>
</ul>
</li>
<li><p>划分方式</p>
<ul>
<li>明确需要划分的子网数量 k</li>
<li>记子网号的位数为（从主机号中借用的位数）n</li>
<li>两个变量满足不等式 <strong>k ≤ 2^n^ - 2</strong>（<a style="color:red;">分类 IP 地址的基础上是需要减去无法使用的子网 &amp; CIDR 是不需要减去无法使用的子网</a>）</li>
<li>利用该不等式计算出子网号的位数</li>
</ul>
</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210329154108192.png" alt="image-20210329154108192"></p>
</li>
<li><p>变长子网划分</p>
<ul>
<li>概念：借用的==主机号位数可变==</li>
<li>特点：<ul>
<li>每个子网的子网掩码都不一样</li>
<li>每个子网能够容纳的最大主机数量也不一样；==借用位数越多会导致最大主机数容量越小==</li>
<li>划分方式</li>
</ul>
</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210322170402977.png" alt="image-20210322170402977"></p>
<ul>
<li><p>划分后的变化</p>
<ul>
<li><p>子网掩码：每个子网的==子网掩码都是不一样的==</p>
</li>
<li><p>广播地址：==每个子网都有自己的广播地址==</p>
<p>  <em>00 111111 ；01 111111；10 111111；11 111111；都是不可以使用 的</em></p>
</li>
<li><p>点分十进制：仍然按照 8bit 划分；这样得到的子网地址结尾就可以不是 0 了</p>
</li>
</ul>
</li>
<li><p>注意：<strong>上述只是演示变长子网的划分过程，如果采用分类 IP 地址划分子网，上述非常多的子网是无效的，如果采用 CIDR 技术划分子网是没有问题的</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>子网掩码</p>
<ul>
<li><p>概念：一串 1 + 一串 0 组成（32bit）</p>
<ul>
<li><p>所有的 1 对应 网络号 + 子网号</p>
</li>
<li><p>所有的 0 对应 主机号</p>
<p>  <em>牢记子网掩码的目的就是为了提取网络号部分就能够理解</em></p>
</li>
</ul>
</li>
<li><p>目的：从 IP 地址中提取出 ==网络号 + 子网号==；获取每个子网的 IP 地址</p>
</li>
<li><p>子网 IP 地址计算方式</p>
<ul>
<li>获取==主机 IP 地址==和==子网掩码==<ul>
<li>子网如果没有进行划分：默认的子网掩码是 255.0.0.0（A类） 255.255.0.0（B类） 255.255.255.0（C类）</li>
<li>子网如果划分之后：子网掩码会发生变化</li>
</ul>
</li>
<li>主机 IP 地址 和 子网掩码进行 ==<strong>与运算</strong>==<ul>
<li>因为 1 对应 网络号 + 子网号，所以在与运算之后，这两部分都被提取出来了</li>
<li>因为 0 对应 主机号，所以在与运算之后，这部分就是 0 了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分组转发</p>
<ul>
<li>利用 ==IP 地址 + 子网掩码== 判断源主机和目的主机是否在==同一子网（网段）==内<ol>
<li>如果在同一子网内，那么源主机==直接==将分组交付给目的主机</li>
<li>如果不在同一子网内，执行==间接交付==的操作</li>
</ol>
</li>
<li>路由器接收源主机提交的分组，根据路由表将分组交付给下一个路由器（间接交付）</li>
<li>最后一个路由器将分组==直接交付==给目的主机</li>
</ul>
</li>
<li><p>直接交付和间接交付比较</p>
<ul>
<li>直接交付：<ul>
<li>形式：(1) 源主机直接将分组交付给目的主机 (2) 最后一个路由器将分组交付给目的主机</li>
<li>判断条件：两台设备==必须在同一子网==内<ol>
<li>如果是形式1，那显然两台主机在同一子网内</li>
<li>如果是形式2，那么判断地是最后一个路由器和目的主机是否在一个子网内，而不是源主机和目的主机</li>
</ol>
</li>
<li>注意：<a style="color:red;">直接交付不涉及路由器（形式2虽然有路由器参与但是仍然如此认为）</a></li>
</ul>
</li>
<li>间接交付：<ul>
<li>判断条件：至少涉及两个以上的路由器</li>
<li>注意：间接交付包含直接交付</li>
</ul>
</li>
<li>细节<ul>
<li><a style="color:red;">间接交付中源 IP 和目的 IP 都是不会发生变化的，但是源 MAC 和 目的 MAC 是会变化的（参考 ARP 协议）</a></li>
<li><a style="color:red;">链路层交换机转发分组时，源 MAC 地址不会改变</a></li>
</ul>
</li>
<li>图示</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210329150334335.png" alt="image-20210329150334335"></p>
</li>
</ul>

        <h5 id="无分类编址方法（CIDR）"   >
          <a href="#无分类编址方法（CIDR）" class="heading-link"><i class="fas fa-link"></i></a><a href="#无分类编址方法（CIDR）" class="headerlink" title="无分类编址方法（CIDR）"></a>无分类编址方法（CIDR）</h5>
      <ul>
<li><p>引入：分类 IP 地址 + 子网划分 仍然不够灵活，网络号部分始终是固定的，考虑将网络号部分变为随机的，增加灵活性</p>
</li>
<li><p>概念：(无类别域间路由选择 Classless Interdomain Routing)</p>
<ul>
<li><p>基本思想：取消按照固定的网络号对 IP 地址进行分类；使用 ==网络前缀==对 IP 地址进行“分类”</p>
</li>
<li><p>网络前缀：</p>
<ul>
<li>概念：相当与 ==任意长度== 的网络号；剩余的就是主机号</li>
<li>记法：192.168.0.0 / 20；网络前缀是 20bit </li>
</ul>
</li>
<li><p>CIDR 地址块：具有 ==相同的网络前缀== 的 IP 地址组成 CIDR 地址块</p>
<p>  相当于分类 IP 地址中的类型</p>
</li>
</ul>
</li>
<li><p>图解</p>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210322172035423.png" alt="image-20210322172035423"></p>
</li>
<li><p>超网</p>
<ul>
<li><p>概念：多个 ==CIDR 地址块== <strong>聚合</strong> 在一起形成的网络 (称为地址聚合 Address Aggregation)</p>
</li>
<li><p>目的：多个子网合并在一起形成超网，只需要在==转发表中存储一个网络前缀==和对应转发的路由器</p>
<p>  多个子网的网络前缀中可能存在大量相同的比特位，不使用聚合技术，那么转发表中就会存储每个子网的网络前缀和对应转发的路由器，增大了路由表的存储开销</p>
</li>
<li><p>聚合方式：从最高位开始直到==第一个不相同的位之前（ <strong>不包含不相同的位</strong> ）==出现为止 -&gt; 作为超网的网络前缀</p>
</li>
<li><p>图解</p>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210329154822131.png" alt="image-20210329154822131"></p>
</li>
<li><p><strong>CIDR 地址块</strong> 和 <strong>超网</strong> 的区分</p>
<ul>
<li>CIDR地址块 是相同网络前缀的==不同主机的集合==</li>
<li>超网 是不同网络前缀的==子网的集合==</li>
</ul>
</li>
<li><p>CIDR 子网划分：子网号是可以==全 0 全 1==的</p>
<ul>
<li><p>优点：使用 CIDR 划分子网能够得到==更多的子网数==相比于传统的分类地址</p>
</li>
<li><p>原因：使用==最长前缀匹配技术==能够==避免二义性==，所有和主网络冲突的信息都会被发送到对应的 CIDR 地址块</p>
</li>
<li><p>做题注意事项：如果题目中没有明确指明是否采用 CIDR 技术，我们需要根据问题进行推测，如果问的是最大子网数，那么显然采用 CIDR 划分子网显</p>
<p>  然得到的子网数更多，也就是不用 -2，还有一点就是如果用于表示网络号的比特位数不是8,16,24，那么肯定是采用的 CIDR</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>最长前缀匹配</p>
<ul>
<li>引入：<ul>
<li>每个分组都会携带目的 IP 地址</li>
<li>进入路由器转发的时候，可能会出现多个==相同的 IP 地址==（网络前缀不一样）</li>
<li>此时就需要根据最长前缀匹配选择合适的 IP 地址进行转发</li>
</ul>
</li>
<li>概念：多个相同 IP 地址出现时，选择 ==符合条件==的且 ==最具体的 IP 地址==</li>
<li>图解：132.19.237.5 如何转发</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210322174027769.png" alt="image-20210322174027769"></p>
</li>
</ul>

        <h3 id="IPv6"   >
          <a href="#IPv6" class="heading-link"><i class="fas fa-link"></i></a><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3>
      
        <h4 id="IPv6-数据报格式"   >
          <a href="#IPv6-数据报格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#IPv6-数据报格式" class="headerlink" title="IPv6 数据报格式"></a>IPv6 数据报格式</h4>
      <ul>
<li>引入：<ul>
<li>IPv4 地址已经被分配耗尽；利用 NAT 和 CIDR 技术也无法改变地址消耗殆尽的现状</li>
<li>ST-2 协议被舍弃，未能够成为 IPv5 协议</li>
</ul>
</li>
<li>基本格式：基本首部 + 有效载荷<ul>
<li>基本首部：<a style="color:red;">长度固定为40B</a> (区别于 IPv4 是不固定的，只是最小长度为 20B)</li>
<li>有效载荷：<code>IP</code> 数据报的数据部分 </li>
<li>图示</li>
</ul>
</li>
</ul>
<p><img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210326160114164.png" alt="image-20210326160114164"></p>
<ul>
<li>详细格式<ul>
<li>图示</li>
</ul>
</li>
</ul>
<p><img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210326162033661.png" alt="image-20210326162033661"></p>
<ul>
<li><p>特点：</p>
<ul>
<li><p><strong>快速</strong> 处理和转发数据报：因为许多字段从基本首部中移除，路由器不需要再对多余的内容作处理</p>
</li>
<li><p><a style="color:red;">IPv6 支持 <strong>即插即用</strong> </a>：不需要配置 DHCP 协议</p>
</li>
<li><p>支持 QoS</p>
</li>
</ul>
</li>
<li><p>对比</p>
<ul>
<li><p>新增</p>
<ul>
<li><p>地址扩大：IPv6 地址从 32 位（4B）扩大到 ==128位==（16B）</p>
</li>
<li><p>流标签：标识属于同一个流的数据报</p>
</li>
</ul>
</li>
<li><p>减少</p>
<ul>
<li><p>IPv6 地址不可以在 <strong>路由器处</strong> 进行分片仅可以在 <strong>主机处</strong> 分片：删去==标志，标识，片偏移==字段</p>
<p>  <a style="color:red;">注：超过 MTU 的分组将会被路由器 <strong>直接丢弃</strong></a></p>
</li>
<li><p>IPv6 地址删去==校验和==：保证数据报的快速处理 (数据链路层和传输层已经存在差错控制)</p>
</li>
<li><p>IPv6 地址删去==首部长度==：基本首部长度是固定的 40B</p>
</li>
</ul>
</li>
<li><p>修改</p>
<ul>
<li>IPv6 ==有效载荷长度==：<a style="color:red;"><strong>仅包括数据部分</strong>，不包括首部长度</a>(IPv4 的总长度是包含首部的)</li>
<li>IPv6 地址==优先级==字段 – IPv4 ==区分服务== 字段</li>
<li>IPv6 跳数限制字段 – IPv4 生存时间字段</li>
<li>IPv6 ==下一个首部==字段 – IPv4 ==协议==字段</li>
<li>IPv6 将==选项==字段放入==有效载荷==字段中</li>
</ul>
</li>
</ul>
</li>
<li><p>问题：为什么 IPv6 地址是 128 bit，但是数据报中字段只有 32 bit？</p>
</li>
<li><p>表示形式：冒号十六进制记法</p>
<ul>
<li>例子：2408:842e:d10:24c6:49f4:a398:e7cf:86e1</li>
<li>特点：<ul>
<li>每个单元 4 个十六进制数；共 8 个单元</li>
<li>如果单元内 4 个十六进制数全为 0，那么可以将 <strong>4 个 0 简化为 1 个 0</strong></li>
<li>如果多个连续单元内 4 个十六进制数全为 0 ，那么可以将多个单元合并成<strong>一对冒号</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>地址类型</p>
<ul>
<li>单播地址：二级分类地址中的 ABC 类地址</li>
<li>广播地址：二级分类地址中的 特殊 IP 地址</li>
<li>多播地址：二级分类地址中的 ==D 类地址==</li>
</ul>
</li>
<li><p>过渡策略</p>
<ul>
<li>双栈协议：每台主机和路由器同时配置 IPv4 和 IPv6 协议</li>
<li>隧道技术(Tunneling)：<ul>
<li>IPv6 数据报经过使用 IPv4 协议的路由器时</li>
<li>路由器 <strong>将 IPv6 数据报放入 IPv4 数据报的数据部分</strong> 然后转发</li>
<li>目的主机可以得知这是 IPv6 数据报会进行拆卸</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h4 id="IPv6-多播"   >
          <a href="#IPv6-多播" class="heading-link"><i class="fas fa-link"></i></a><a href="#IPv6-多播" class="headerlink" title="IPv6 多播"></a>IPv6 多播</h4>
      
        <h5 id="基本内容"   >
          <a href="#基本内容" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h5>
      <ul>
<li><p>概念</p>
<ul>
<li>内容：<ul>
<li>源主机发送给==多个特定==用户数据</li>
<li>数据报在传输过程中==仅存在一份==</li>
<li>数据报在到达离特定用户最近的路由器时==复制一份==发送给用户</li>
<li>重复上述过程，直到所有特定用户都收到数据</li>
</ul>
</li>
<li>区别<ul>
<li>广播技术：对网络（子网）中所有主机发送数据报，多播只对网络中的多个特定用户发送数据（相当于一个组内的用户）</li>
<li>单播技术：点对点的传输，需要在源主机处复制多份需要发送的数据，然后再进行传输，多播在源主机处只需要一份数据 </li>
</ul>
</li>
<li>特点<ul>
<li>减少主干网络出现堵塞的情况，提高传输数据的效率</li>
<li>==组内的主机==可以分散在不同的局域网内，只需要提供==多播路由器==就可以实现</li>
</ul>
</li>
</ul>
</li>
<li><p>多播地址</p>
<ul>
<li><p>引入：</p>
<ul>
<li>源主机需要向组内多个特定用户发送数据，显然需要 IP 地址才能够确定组内用户所在的位置</li>
<li>显然不可能使用组内用户自己的唯一 IP 地址，那样就变成了单播传输</li>
<li>显然需要组内用户需要一个共同的多播地址才能将数据发送给组内用户</li>
</ul>
</li>
<li><p>概念：组内所有主机被分配一个==相同的多播地址==，标记为同一个组</p>
</li>
<li><p>特点：</p>
<ul>
<li>多播地址是二级分类地址中的 ==D 类地址==；但是并非所有 D 类地址 都可以作多播地址</li>
<li>多播地址只能够==作目的地址==，不能够是源地址</li>
<li>多播数据报==采用 UDP 协议==，尽最大努力交付（不提供差错检查和流量控制等功能）</li>
<li>多播数据报==不产生 ICMP 错误报文==</li>
</ul>
</li>
<li><p>多播方式</p>
<ul>
<li><p>因特网范围内多播：因特网范围内的多播在进入局域网之后仍然需要采用硬件多播</p>
</li>
<li><p>硬件多播</p>
<ul>
<li>引入：局域网之间相互传播数据报需要使用 MAC 地址（数据链路层），因此多播地址仍然需要对应的 MAC 地址</li>
</ul>
</li>
</ul>
</li>
<li><p>多播 MAC 地址</p>
<pre><code>  * 前 6 个十六进制数固定为 ==01-00-5E==
  * 后 6 个十六进制数根据多播地址的后 ==23== 位进行映射
* 问题：多播地址还剩下 5 位没有被使用，这意味着两个不同的多播地址可能会映射成相同的 MAC 地址，因为这 5 位可能不同
* 解决方式：组内用户在接收多播数据报时仍需要在 ==IP 层==采用==软件==进行过滤
</code></pre>
</li>
</ul>
</li>
</ul>

        <h5 id="IGMP-协议"   >
          <a href="#IGMP-协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#IGMP-协议" class="headerlink" title="IGMP 协议"></a>IGMP 协议</h5>
      <ul>
<li><p>IGMP 协议</p>
<ul>
<li>概念：多播路由器能够==明确==组内==存在的主机==</li>
<li>工作过程：<ul>
<li>想要加入组内的主机向组播地址==发送 IGMP 报文==；声明自己想要加入组内</li>
<li>组播路由器接收到 IGMP 报文后==通知其余所有的<strong>组播路由器</strong>==组内新的成员关系</li>
<li>组播路由器==周期性==测试组内的主机，查看是否还是组内成员；如果该组内没有一个成员响应，认为该组是不活跃的；</li>
<li>组播路由器认为==组不活跃==后，不会再将组内成员关系发送给其他组播路由器</li>
</ul>
</li>
<li>特点：<ul>
<li>==不能==明确组内存在的==主机数量==</li>
<li>==不能==明确各主机所在的==局域网==</li>
</ul>
</li>
</ul>
</li>
<li><p>组播路由选择协议</p>
<ul>
<li><p>概念：找到从源主机到组内各成员的路径</p>
</li>
<li><p>特点：形成==组播转发树==</p>
</li>
<li><p>组播转发树：</p>
<ul>
<li><p>避免图形结构造成数据报在路由器之间循环</p>
</li>
<li><p>不同的多播组，生成的组播转发树也不同</p>
</li>
<li><p>相同的多播组，不同的源主机，生成的组播转发树也是不同的</p>
<p>  <em>一个多播组内可以有多个源主机吗？</em></p>
</li>
</ul>
</li>
<li><p>路由选择算法</p>
<ul>
<li>链路状态选择算法</li>
<li>距离向量选择算法</li>
<li>协议无关的组播算法</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h2 id="移动IP"   >
          <a href="#移动IP" class="heading-link"><i class="fas fa-link"></i></a><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h2>
      <ul>
<li><p>引入：每台主机都具有全球唯一的 IP 地址，如果主机发生移动进入另一个局域网中，需要和其他局域网通信，显然这台主机和局域网的网络号是不同的，</p>
<p>  根本不可能和外界通信，这时就需要借助移动 IP 技术</p>
<p>  <em>MAC 地址和 IP 地址的联系和区别？</em></p>
</li>
<li><p>概念：每台主机进入其他局域网中时，都会被分配一个==转交地址==用于和外界通信</p>
</li>
<li><p>术语</p>
<ul>
<li>移动结点：具有永久 IP 地址的移动设备</li>
<li>归属代理（本地代理）：主机 IP 地址==所属的局域网==</li>
<li>外部代理（外地代理）：主机进入的==新的局域网==</li>
<li>永久地址（归属地址，主地址）：主机被分配的全球唯一的 IP 地址</li>
<li>转交地址：主机在新的局域网被分配的==临时 IP 地址==</li>
</ul>
</li>
<li><p>通信过程</p>
<ul>
<li>主机进入新的局域网，新局域网分配给主机==临时 IP 地址==（转交地址）</li>
<li>新局域网此时根据主机的永久 IP 地址找到主机的原来所在的局域网，==向其提交临时 IP 地址==</li>
<li>其他主机向本主机通信时，数据报首先发送到本主机原来所在的局域网，原局域网==根据登记的临时地址找到本主机现在所在的局域网，转发数据报==</li>
<li>主机离开当前局域网，再次进入新的局域网，获得新的临时 IP 地址，并且==覆盖之前的临时 IP 地址==，同样需要在原局域网进行登记</li>
<li>主机回到原局域网，原局域网==注销其临时 IP 地址==，也通知主机之前所在的局域网注销临时 IP 地址</li>
</ul>
</li>
</ul>

        <h2 id="网络层协议"   >
          <a href="#网络层协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h2>
      
        <h3 id="ARP-协议"   >
          <a href="#ARP-协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h3>
      <ul>
<li><p>引入：数据链路层在封装帧时，需要得到 ==目的 IP 地址对应的 MAC 地址==</p>
</li>
<li><p>概念(Address Resolution Protocol 地址解析协议)：获取目的 IP 地址的 MAC 地址</p>
</li>
<li><p>获取方式：</p>
<ul>
<li><p>ARP 高速缓存：==IP 地址 和 MAC 地址的映射==</p>
<p>  <a style=color:red;>注意：高速缓存只会存放局域网中的映射，其他网络中的映射是没有的</a> </p>
</li>
<li><p>广播 ARP 请求分组</p>
<ul>
<li><p>前提：ARP 高速缓存中没有目的 IP 地址对应的 MAC 地址</p>
</li>
<li><p>过程描述：</p>
<ul>
<li><p>判断 ==目的 IP 地址== 和 ==源 IP 地址== 是否存在 ==一个网段==</p>
<p>  ①网段相同：广播 ARP 分组（<strong>源 IP 地址，目的 IP 地址，源 MAC 地址，广播 MAC 地址（全F）</strong>）给其他主机</p>
<ul>
<li>==目的主机==接收到广播就会向源主机==返回自己的 MAC 地址==</li>
<li>源主机接收到目的主机的 MAC 地址后，就将其==封装==在数据链路层的==帧==中</li>
</ul>
<p>  ②网段不同：广播 ARP 分组（<strong>源 IP 地址，目的 IP 地址，源 MAC 地址，默认网关 MAC 地址</strong>）给路由器</p>
<ul>
<li>==路由器==接收到广播就会向源主机==返回自己的 MAC 地址==</li>
<li>源主机接收到路由器的 MAC 地址后，就将其==封装==在数据链路层的==帧==中</li>
</ul>
</li>
<li><p>路由器之间传送数据时同样需要下一个路由器的 MAC 地址：==路由器和路由器之间同样需要使用 ARP 协议==</p>
<ol>
<li>路由器拆卸 IP 数据报，==替换 源 MAC 地址==（路由器自己的 MAC 地址） 和 ==目的 MAC 地址==（使用 ARP 获得下一个路由器的 MAC 地址）</li>
<li>路由器封装 IP 数据报，==MAC 地址发生了变化，但是 IP 地址始终没变==</li>
</ol>
</li>
<li><p>数据到达目的主机所在局域网时，获取 ==目的主机的 MAC 地址==</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li>ARP 高速缓存会定时更新</li>
<li><a style="color:red;">ARP 广播分组和响应分组是封装在 <strong>帧结构</strong> 中传输的</a></li>
<li><a style="color:red;">MAC 地址在传输过程中在不断地变化但是 IP 地址始终没有发生变化</a></li>
<li><a style="color:red;">ARP 是 <strong>即插即用</strong> 的</a>：不需要人工手动配置</li>
</ul>
</li>
</ul>

        <h3 id="DHCP-协议"   >
          <a href="#DHCP-协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#DHCP-协议" class="headerlink" title="DHCP 协议"></a>DHCP 协议</h3>
      <ul>
<li><p>引入：主机连接到互联网之前需要==获取==自己在网上的 ==IP 地址==</p>
<p>  <a style="color:red;">注：路由器基本都配置了 DHCP 服务器</a> (可以手动关闭路由器的 <code>DHCP</code> 服务器)</p>
</li>
<li><p>概念：基于传输层==UDP== 协议，采用 ==客户端 / 服务器== 方式，客户端和服务端通过 ==广播== 方式进行交互</p>
</li>
<li><p>获取方式</p>
<ul>
<li><p>静态配置：网络管理员==手动配置==各台主机的 IP 地址，默认网关，子网掩码等信息</p>
</li>
<li><p>动态配置</p>
<ul>
<li><p>概念：允许主机==自动获取 IP 地址==等信息，也允许网络管理员进行配置</p>
</li>
<li><p>过程</p>
<ul>
<li><p>新进入网络的主机 <strong>广播 DHCP 发现报文</strong></p>
<p>  <a style="color:red;">注意：报文的目的地址是广播地址 <strong>255.255.255.255</strong> ；源地址是 <strong>0.0.0.0</strong></a>(主机在没有分配到 IP 地址之前都是采用默认 0.0.0.0 的 IP 地址)</p>
</li>
<li><p>DHCP 服务器收到广播后再次 <strong>广播 DHCP 提供报文</strong></p>
<ul>
<li>DHCP 提供报文 = <strong>发现报文的 ID + 推荐的 IP 地址 + 子网掩码 + IP 地址租用时间</strong></li>
<li>采用广播的原因：DHCP 服务器不知道客户端的 IP 地址是什么，因为客户端还没有采用推荐的 IP 地址（√）</li>
</ul>
</li>
<li><p>主机 <strong>回应 DHCP 请求报文</strong>（<a style="color:red;">此时主机还没配置 IP 地址</a>）</p>
</li>
<li><p>DHCP 服务器 <strong>广播 DHCP 确认报文</strong> (<a style="color:red;">主机配置 IP 地址</a>)</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li><p><a style="color:red;">DHCP 协议是 <strong>即插即用</strong> 的协议</a></p>
</li>
<li><p>网络管理员可以让用户在每次连接时 <a style="color:red;">获取相同的 IP 地址，也可是临时性的 IP 地址</a></p>
<p>  注：<code>DHCP</code> 协议不代表每次获得 <code>IP</code> 地址都是不一样的</p>
</li>
<li><p><code>DHCP</code> 协议端口号是 ==67==</p>
</li>
</ul>
</li>
</ul>
<p>​    <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210324150127326.png" alt="image-20210324150127326"></p>

        <h3 id="ICMP-协议"   >
          <a href="#ICMP-协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#ICMP-协议" class="headerlink" title="ICMP 协议"></a>ICMP 协议</h3>
      <ul>
<li>概念(控制报文协议)：路由器和主机利用该协议用于彼此沟通有关数据报的信息</li>
<li>报文格式：==类型字段 + 编码字段 + 相关 IP 数据报的前 8 个字节==(8个字节 = 版本号 + 首部长度 +区分服务 + 总长度)</li>
<li>核心：<a style="color:red;">执行差错报告</a> (<code>ICMP</code> 报文也可以执行拥塞控制，但是传输层中已经实现了，实践中就很少再用了)</li>
<li>报文类型<ul>
<li>ICMP 差错报文<ol>
<li>终点不可达：路由器无法交付数据报</li>
<li><strong>源点抑制：路由器因堵塞丢弃数据报</strong> (执行拥塞控制)</li>
<li>时间超过：路由器收到 TTL=0 的数据报</li>
<li>参数问题：路由器收到首部字段出问题的数据报</li>
<li>改变路由：路由器认为有更好的路径发送数据报</li>
</ol>
</li>
<li>ICMP 询问报文<ol>
<li>回送请求和回答报文</li>
<li>时间戳请求和回答报文</li>
<li>掩码地址请求和回答报文</li>
<li>路由器询问和回答报文</li>
</ol>
</li>
</ul>
</li>
<li>不发送差错报文<ul>
<li>差错报文如果出错，不会再发送差错报文进行提示</li>
<li>源 IP 地址如果为组播地址，不发送差错报文</li>
<li>特殊 IP 地址，不发送差错报文</li>
<li>对第一个分片的数据报片的后续所有分片都不发送差错报文</li>
</ul>
</li>
</ul>

        <h2 id="路由选择协议"   >
          <a href="#路由选择协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2>
      
        <h3 id="基本概念"   >
          <a href="#基本概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3>
      <ul>
<li><p>概念：选择 “最佳” 的路径转发分组</p>
<p>  注意：最佳路径会跟随网络状况变化，只是相对合理的选择</p>
</li>
<li><p>算法分类</p>
<ul>
<li><p>第一种分类方式</p>
<ul>
<li><p>集中式路由选择算法(Centralizied Routing Algorithm)：<a style="color:red;">集中式算法必须得知所有节点的 <strong>连通性</strong> 和所有链路的 <strong>开销</strong></a> (代表：链路状态算法 Link State)</p>
<p>  注：每个路由器都拥有整个网络信息 或者 逻辑集中式选择控制器具有整个网络信息</p>
</li>
<li><p>分散式路由选择算法(Decentralizied Routing Algorithm)：<a style="color:red;">没有节点拥有所有链路开销的信息甚至每个节点都没有最低开销</a> (代表：距离向量算法 Distance Vector)</p>
<p>  注：更加适合 <strong>每路由器控制</strong> 的计算方式</p>
</li>
</ul>
</li>
<li><p>第二种分类方式</p>
<ul>
<li>静态路由算法(Static Routing Algorithm)：<ul>
<li>概念：通常是网络管理员 <strong>手动配置</strong> 路由器中的转发表</li>
<li>优点：(1) 简便可靠 (2) 安全性较高 (3) <a style="color:red;">适用于网络拓扑变化不大的网络</a>(不会经常有节点进入或者退出网络)</li>
<li>缺点：<a style="color:red;">路由转发表更新慢</a></li>
</ul>
</li>
<li>动态路由算法(Dynamic Routing Algorithm)<ul>
<li>概念：随着 <strong>网络拓扑结构</strong> 和 <strong>流量负载变化</strong> 而改变路由选择的算法</li>
<li>优点：(1) <a style="color:red;">路由转发表更新快</a> (2) 更快适应网络拓扑变化</li>
<li>缺点：(1) 算法复杂，增加网络负担 (2) 产生路由 <strong>选择循环</strong> <strong>路由振荡</strong> 的问题</li>
</ul>
</li>
</ul>
</li>
<li><p>第三种方式</p>
<ul>
<li><p>负载迟钝(Load-Insensitive Algorithm)：现在的所有路由选择协议都是负载迟钝的</p>
</li>
<li><p>负载敏感(Load-Sensitive Alogorithm)：早期的 ARPAnet 协议是负载敏感的</p>
<p>  <a style="color:red;">注：链路的开销不能够反映链路的拥塞状态</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>自治系统(Autonomous System)</p>
<ul>
<li>概念：处于同一个 <code>ISP</code> 中的 <strong>路由器</strong> 和相连的 <strong>链路</strong> 构成</li>
<li>特点：<a style="color:red;">每个自治系统都拥有全局唯一的 AS 号</a>：由 <code>ICANN</code> 区域注册机构唯一分配</li>
<li>细节：<ul>
<li><a style="color:red;">每个 ISP 中会划分多个自治系统不止一个</a></li>
<li><a style="color:red;">每个自治系统内部可以运行不同的自治系统 <strong>域内路由选择算法</strong> &amp; 自治系统相连必须采用相同的 <strong>域间路由选择算法</strong> </a></li>
</ul>
</li>
</ul>
</li>
</ul>

        <h3 id="内部网关协议"   >
          <a href="#内部网关协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#内部网关协议" class="headerlink" title="内部网关协议"></a>内部网关协议</h3>
      <ul>
<li>统称：自治系统内部域间路由 (Intra-Autonomous System Routing Protocol)</li>
</ul>

        <h4 id="RIP-协议"   >
          <a href="#RIP-协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#RIP-协议" class="headerlink" title="RIP 协议"></a>RIP 协议</h4>
      <ul>
<li><p>协议(Routing Information Protocol 路由信息协议)</p>
<ul>
<li><p>核心：<a style="color:red;">基于 <strong>距离向量选择算法</strong> 的协议</a></p>
</li>
<li><p>内容</p>
<ul>
<li><p>每个路由器都维护自己到其他 <strong>每个目的网络的距离</strong> 和 <strong>下一跳交付的路由器</strong>（距离也被称为跳数 Hop Count）</p>
<p>  <a style="color:red;">1* 路由器到自己 <strong>直接相邻</strong> 的子网的距离是 1 -&gt; 每经过一个路由器距离 +1</a></p>
<p>  <a style="color:red;">2* 由于每个路由器都需要维护到其他所有子网的距离 -&gt; 所以只适用于小型互联网</a></p>
</li>
<li><p>协议认为经过的 <strong>最优路径是经过的路由器最少</strong></p>
</li>
<li><p><a style="color:red;">每条路径最多可以包含 15 个路由器，<strong>16 个路由器</strong> 被视为这个网络是不可达的</a>：目的是为了防止数据报循环出现在环路上</p>
</li>
<li><p>协议要求路由器每 <strong>30s</strong> 和 <strong>相邻</strong> 的路由器 <strong>交换自己的转发表</strong> （自己相邻的路由器超过 <strong>180s</strong> 没有和自己交换转发表，视为该路由器从网络中断开） *</p>
</li>
<li><p>采用 <strong>距离向量算法</strong> 选择性更新自己的转发表</p>
</li>
<li><p>重复交换转发表的过程，最终每个路由器能够得到自己到其他网络的最短路径</p>
</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li><a style="color:red;">RIP 协议收敛速度 <strong>较慢</strong> </a></li>
<li>RIP 协议 ==周期性== 的交换路由信息 (网络拓扑结构发生变化也会导致交换信息？)</li>
<li>RIP协议健壮性相对较差</li>
<li><a style="color:red;">RIP 协议不支持子网掩码的广播：每个子网的 <strong>子网掩码必须相同</strong></a>  (仅支持分类地址编码的定长子网划分)</li>
<li><a style="color:red;">RIP 协议下层协议采用 <strong>UDP</strong> 报文段传输 </a></li>
<li><a style="color:red;">RIP 协议是 <strong>应用层协议</strong> </a></li>
</ul>
</li>
<li><p>问题：</p>
<ul>
<li>选择环路问题 (Routing Loop)</li>
<li>无穷计数问题 (Count-to-Infinity)：<a style="color:red;">采用毒性逆转 (Poisoned Reverse) 可以解决 <strong>特殊</strong> 的无穷计数问题 -&gt; 无法解决一般的无穷计数问题</a></li>
</ul>
</li>
</ul>
</li>
<li><p>算法</p>
<ul>
<li><p>前提：距离向量路由选择算法包含 <code>Bellman-Ford</code> 算法 (<code>Bellman-Ford</code> 算法只是距离向量选择算法中的一种而已)</p>
</li>
<li><p>计算过程</p>
<ul>
<li><p>每个路由器只向自己 <a style="color:red;">相邻</a> 的所有路由器广播自己的路由表 (<a style="color:red;">每个路由器当前拥有的路径开销不一定就是最低的</a>：可能还没有收敛)</p>
</li>
<li><p>每个路由器采用 <code>Bellman-Ford</code> 计算 <strong>当前的最短路径</strong></p>
<p>  ① 某个路由器接收其他路由器发送的 <strong>多个路由向量</strong></p>
<p>  ② 该路由器到其他路由器的距离 + 其他路由器到其他子网的距离 = 该路由器到其他子网的距离 -&gt; <strong>选择最小距离作为更新</strong></p>
<p>  贝尔曼福特方程：$d_x(y) = min_v(c(x, v_1) + d_{v1}(y), c(x, v_2) + d_{v2}, c(x, v_3) + d_{v3}…)$ (<a style="color:red;">同时可以收到多个节点发送的分组，选择开销小的那个更新</a>)</p>
<p>  ③ 更新内容：(1) 更新该路由器到其他子网的距离 (2) 更新自己下一跳路由器 </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h4 id="OSPF-协议"   >
          <a href="#OSPF-协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#OSPF-协议" class="headerlink" title="OSPF 协议"></a>OSPF 协议</h4>
      <ul>
<li><p>协议(Open Shortest Path First 开放最短路径优先)</p>
<ul>
<li><p>核心：<a style="color:red;">基于 <strong>链路状态选择算法</strong> 协议</a></p>
</li>
<li><p>内容：</p>
<ul>
<li><p>每个自治系统 <strong>内部</strong> 划分层次结构</p>
<p>  (1) 分为 <strong>主干区域</strong> 和 <strong>下层区域</strong></p>
<p>  (2) 主干区域包含 <strong>所有的边界路由器</strong> (也可以包含非边界路由器) &amp; 每个下层区域都独立运行 <code>OSPF</code> 协议</p>
<p>  (3) 下层区域中只有 <strong>边界路由器</strong> 会和其他区域进行 <strong>通信</strong>，其余内部路由器仅在内部通信</p>
<p>  (4) <a style="color:red;">下层区域之间发送数据报 <strong>一定会经过主干区域</strong> </a> </p>
</li>
<li><p>每个路由器在 <strong>初始阶段</strong> 仅维护与自己 <strong>相邻的路由器的链路信息</strong></p>
</li>
<li><p>每个路由器会向网络中 <strong>所有的路由器</strong> 发送 <strong>自己知道的链路信息</strong> (<a style="color:red;">采用 <strong>洪泛法</strong>(Flooding) 广播链路状态信息</a>)</p>
</li>
<li><p>仅有 <strong>受到信任的路由器</strong> 可以参与到自治系统内部的 <code>OSPF</code> 协议中</p>
</li>
<li><p><a style="color:red;">支持使用多条链路开销最小的路径 </a> (多路间负载均衡)</p>
<p>  <a style="color:red;">注：本区域内的路由器仅知道本区域的网络拓扑结构</a></p>
</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li><p><a style="color:red;">只有链路状态发生变化就会重新计算最低开销路径</a> (依然采用洪泛法)</p>
</li>
<li><p><a style="color:red;">OSPF 协议是 <strong>网络层协议</strong> 且不使用 UDP TCP 协议而是直接使用 IP 数据报传输</a></p>
</li>
<li><p><a style="color:red;">OSPF 协议支持 <strong>可变长子网划分</strong> 和 <strong>无类别域间路由</strong> 技术</a></p>
</li>
<li><p>OSPF 协议规定所有路由器每隔 30 分钟就刷新一次链路状态信息表，确保拥有的链路状态信息是一致的</p>
<p>  <a style="color:red;">注：如果链路状态信息不一致采用特定分组同步更新而不是使用洪泛法</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>算法</p>
<ul>
<li><p>前提：链路状态路由选择算法包含 <code>Dijkstra</code> 算法 (<code>Dijkstra</code> 算法只是众多链路状态选择算法中的一种而已)</p>
</li>
<li><p>链路状态算法计算过程：</p>
<ul>
<li><p>每个节点会向网络中 <a style="color:red;">“所有”</a> 其他节点广播 ==链路状态分组==（发送自己的路由表）</p>
<p>  解释：每个节点只是向自己的 <strong>每个邻居</strong> 发送自己的路由表，每张路由表也只包含自己相邻节点的信息，邻居路由器收到之后，会继续向他的邻居发送路由表 </p>
<p>  <a style="color:red;">邻居路由器不会再向自己发送链路状态信息：发送是单向的</a> (RIP 协议发送是双向的因此会导致选择环路和无穷计数的问题)</p>
</li>
<li><p>每个节点通过这种 ==全局性== 的广播能够获取整个网络的==完整拓扑结构和链路开销==</p>
</li>
<li><p> 每个节点采用 ==迪杰斯特拉算法== 计算自己到其他节点的最短路径</p>
</li>
<li><p>每个节点完成最短路径的计算之后，更新自己的路由表</p>
<p>  注：迪杰斯特拉算法能够得到最短路径（==倒着==推出来），每个节点只存储利用最短路径到达目的地的==下一个节点==，而不是整条路径</p>
</li>
</ul>
</li>
<li><p>问题：链路振荡：<a style="color:red;">最低开销链路 <strong>频繁</strong> 发生变化</a></p>
<p>  解决：(1) 使链路开销不依赖链路所承载的流量 (×)</p>
<p>  ​          (2) 使每台路由器发送链路信息的时间随机化</p>
</li>
</ul>
</li>
</ul>

        <h4 id="对比"   >
          <a href="#对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#对比" class="headerlink" title="对比"></a>对比</h4>
      <ul>
<li><p><code>RIP</code> 协议采用 <strong>距离向量算法</strong> &lt;-&gt; <code>OSPF</code> 协议采用 <strong>链路状态算法</strong></p>
</li>
<li><p><code>RIP</code> 协议每个路由器拥有的 <strong>不一定</strong> 是最低开销路径 (<a style="color:red;">需要等到 <strong>收敛</strong> 之后才是</a>) &lt;-&gt; <code>OSPF</code> 协议每个路由器拥有的 <strong>一定</strong> 是最低开销路径</p>
</li>
<li><p><code>RIP</code> 协议仅向 <strong>相邻</strong> 的路由器发送链路信息 &lt;-&gt; <code>OSPF</code> 协议向网络中 <strong>所有</strong> 路由器发送链路信息 (洪泛法)</p>
</li>
<li><p><code>RIP</code> 协议所有路由器 <strong>周期性</strong> 交换链路信息 &lt;-&gt; <code>OSPF</code> 协议仅在 <strong>链路状态发生变化</strong> 时交换链路信息 (洪泛法)</p>
<p>  注：<code>RIP</code> 协议在链路状态发生变化时也会交换链路信息 &lt;-&gt; <code>OSPF</code> 协议也会定期更新链路信息但是并不会采用洪泛法同步</p>
</li>
<li><p><code>RIP</code> 协议 <strong>不支持</strong> 变长子网划分和无分类域间路由技术 &lt;-&gt; <code>OSPF</code> 协议 <strong>支持</strong> 变长子网划分和无分类域间路由技术</p>
</li>
<li><p><code>RIP</code> 协议 <strong>仅可以配置一条</strong> 最低开销链路 &lt;-&gt; <code>OSPF</code> 协议 <strong>可以配置多条</strong> 最低开销链路</p>
</li>
<li><p><code>RIP</code> 协议路由器发送链路信息是 <strong>双向</strong> 的 &lt;-&gt; <code>OSPF</code> 协议发送链路信息是 <strong>单向</strong> 的</p>
</li>
<li><p><code>RIP</code> 协议是 <strong>应用层协议</strong> &amp; 使用 UDP 协议传输&lt;-&gt; <code>OSPF</code> 协议是 <strong>网络层协议</strong> &amp; 不使用 UDP/TCP 传输使用 IP 数据报传输</p>
</li>
<li><p><code>RIP</code> 协议端口号是 <strong>520</strong> &lt;-&gt; <code>OSPF</code> 协议端口号是 <strong>89</strong></p>
</li>
</ul>

        <h3 id="外部网关协议"   >
          <a href="#外部网关协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#外部网关协议" class="headerlink" title="外部网关协议"></a>外部网关协议</h3>
      <ul>
<li>统称：自治系统间路由选择协议 (Inter-Autonomous System Routing Protocol)</li>
</ul>

        <h4 id="BGP-协议"   >
          <a href="#BGP-协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#BGP-协议" class="headerlink" title="BGP 协议"></a>BGP 协议</h4>
      <ul>
<li><p>引入：</p>
<ul>
<li>每个自治系统的内部采用的协议并不相同，但是每个自治系统之间又需要相互联系</li>
<li>所以每个自治系统之间需要采用相同的协议来进行联系，也就是 BGP 协议</li>
</ul>
</li>
<li><p>概念(边界网关协议 Broder Gateway Protocol)：用于连接每个不同的自治系统的协议</p>
<p>  注：<code>BGP</code> 协议也是 <strong>分布式</strong> 和 <strong>异步</strong> 的</p>
</li>
<li><p>核心：<a style="color:red;">基于 <strong>路径向量选择</strong> 的协议</a></p>
</li>
<li><p>术语：</p>
<ul>
<li><p>边界网关路由器 (Gateway Router)：能够连接本自治系统中的路由器 &amp; 也可以连接其余自治系统中的路由器</p>
<p>  <a style="color:red;">注：每个边界网关路由器之间通过 <strong>TCP</strong> 建立连接后通信 </a> (该 TCP 是半永久连接使用端口号 179)</p>
</li>
<li><p>内部路由器 (Internal Router)：仅能够连接本自治系统中的路由器</p>
</li>
<li><p>BGP 连接：路由器之间用于通信的连接</p>
<ul>
<li>外部 BGP (eBGP)：跨越两个自治系统的 BGP 连接</li>
<li>内部 BGP (iBGP)：自治系统内部的 BGP 连接</li>
</ul>
</li>
<li><p>分组信息：</p>
<ul>
<li><p>AS-PATH：记录该分组 <strong>已经经过的所有自治系统</strong> (<a style="color:red;">用于检测在发送的过程中是否出现 <strong>环路</strong> </a>)</p>
</li>
<li><p>NEXT-HOP：记录分组经过的 <strong>最后一个自治系统边界网关路由器的 <code>IP</code> 地址</strong> </p>
<p>  注：两个属性用于寻找相对较好的路径</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>通信过程：(路径向量选择)</p>
</li>
<li><p>细节：</p>
<ul>
<li><a style="color:red;">每个边界网关路由器必须运行 BGP 协议以及 OSPF 协议 RIP 协议中的一种</a></li>
<li><a style="color:red;">BGP 支持 <strong>无类别域间路由</strong> 技术</a></li>
<li><a style="color:red;"> BGP 协议是 <strong>应用层协议</strong> </a></li>
</ul>
</li>
<li><p>最优路由：</p>
<ul>
<li><p>热土豆选择算法：<a style="color:red;">源路由器找到 <strong>距离 NEXT-HOP</strong> 最小的开销</a>，然后依次递推，到达最后的目的路由器</p>
<p>  注：这样得到的路径很有可能不是最短的，因为仅仅是确认距离自己最近的，从全局角度来说可能不是最近的</p>
</li>
<li><p>路由器选择算法</p>
<ul>
<li>选择偏好：网路管理员指定偏好值：偏好值高的路径就会被选择 (人为选择)</li>
<li>距离向量：如果选择偏好相同，使用距离向量计算最短开销 (计算的是经过的 AS 的跳数)</li>
<li>热土豆：如果前两者相同，使用热土豆计算</li>
<li>标识：如果前三者相同，使用标识来区分</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h2 id="路由器"   >
          <a href="#路由器" class="heading-link"><i class="fas fa-link"></i></a><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2>
      <ul>
<li><p>概念(Router)：具有 <strong>多个输入端口</strong> 和 <strong>多个输出端口</strong> 的专用 <strong>计算机</strong> (每个路由器有相应的缓存和处理器)</p>
<p>  <a style="color:red;">(1) 每个路由器拥有多个接口即拥有多个 IP 地址和 MAC 地址</a></p>
<p>  <a style="color:red;">(2) 每个链路层交换机不具有 IP 地址和 MAC 地址</a></p>
<p>  <a style="color:red;">(3) 每台路由器基本都具有 DHCP 服务器</a></p>
</li>
<li><p>功能：</p>
<ul>
<li>转发(Forwarding)：将数据报从 <strong>输入端口</strong> 经过 <strong>交换结构</strong> 转移到 <strong>输出端口</strong><ul>
<li><a style="color:red;">转发功能采用硬件实现</a> </li>
<li>转发过程中查询 <strong>转发表</strong>：(1) 如果查询到相应条目就进行转发 (2) 如果没有查询到就转发到默认路由去 (3) 输入和输出端口缓存已满可能会抛弃这个数据报</li>
</ul>
</li>
<li>路由选择(Routing)：决定转发表中的内容<ul>
<li><a style="color:red;">路由选择功能采用软件实现</a></li>
<li>采取路由选择算法 ==构造路由表== 并且定期维护更新路由表 （(1)链路状态路由选择算法 LS  (2) 距离向量路由选择算法 DV）</li>
</ul>
</li>
</ul>
</li>
<li><p>转发表(Forwarding Table)：如果没有找到对应的转发端口，通过默认路由（0.0.0.0）转发给其他的路由器</p>
</li>
</ul>
<div class="table-container"><table>
<thead>
<tr>
<th>目的网络 IP 地址</th>
<th>子网掩码</th>
<th>下一跳 IP 地址</th>
<th>转发端口</th>
</tr>
</thead>
<tbody><tr>
<td>1.1.1.0</td>
<td>255.255.255.0</td>
<td>2.2.2.0</td>
<td>1</td>
</tr>
<tr>
<td>0.0.0.0</td>
<td>0.0.0.0</td>
<td></td>
<td>11451</td>
</tr>
</tbody></table></div>
<ul>
<li><p>路由表和转发表</p>
<ul>
<li><p>路由表：仅包含目的==子网号(网络前缀) + 子网掩码 + 下一跳 IP 地址 + 输出端口== (不包含数据链路层的 <code>MAC</code> 信息)</p>
<p>  <a style="color:red;">注：所以每次都需要使用 ARP 协议去查询 IP 地址对应的 MAC 地址</a></p>
</li>
<li><p>转发表：==优化==的路由表；不仅包含路由表中的所有信息，还包含转发所必须的 ==MAC 地址和必要的封装信息==；采用==硬件实现==</p>
</li>
</ul>
</li>
<li><p>内部结构</p>
<ul>
<li><p>输入端口：(1) 内部第一个端口用于执行 <strong>物理层</strong> 的功能 (2) 内部第二个端口用于执行 <strong>数据链路层</strong> 的功能 (3) 内部第三个端口用于 <strong>查询转发表</strong></p>
<ul>
<li><p>线路前部阻塞(Head-Of-the-Line)：输入队列缓存中的分组必须等待前面分组被转发后才可以转发，即使该分组转发的端口是空闲的</p>
<p>  <img src="https://i1.xpic.jp/file/xpicjp/2021/06/14/c74a81fa8817bf954cbc11cae00f4cb3.png" alt="c74a81fa8817bf954cbc11cae00f4cb3.png"></p>
</li>
</ul>
</li>
<li><p>输出端口：(1) 内部第一个端口用于执行 <strong>网络层</strong> 功能</p>
<p>  <a style="color:red;">注：(1) 输入和输出端口都可能造成队列拥塞 (2) 输入和输出端口都拥有缓存</a></p>
</li>
<li><p>交换结构：负责将输入端口等待的数据报转移到输出端口</p>
<ul>
<li><p>内存交换：</p>
<p>  (1) 数据报到达端口时通过 <strong>中断</strong> 通知 <strong>路由选择处理器</strong> (CPU) </p>
<p>  (2) 数据报通过 <strong>总线</strong> 被复制到 <strong>内存</strong> 中</p>
<p>  (2) 路由选择处理器从内存中取出并开始处理（查找应该转发到哪个端口）</p>
<p>  <a style="color:red;">1* 每次仅能转发一个数据报</a>：处理器每次仅能执行一个进程 (对于单处理器而言) / 经过内存总线每次仅能够执行一次读写</p>
<p>  <a style="color:red;">2* 处理器的执行速率限制了带宽的传输速率</a></p>
</li>
<li><p>总线交换</p>
<p>  (1) 输入端口制定 <strong>内部标签</strong> 经过 <strong>总线</strong> 将数据报交付给输出端口 (<a style="color:red;">不需要路由选择处理器的干预</a>)</p>
<p>  (2) 所有输出端口都可以 <strong>接收</strong> 到该数据报，但是只有 <strong>内部标签匹配</strong> 的输出端口才可以 <strong>保存</strong></p>
<p>  <a style="color:red;">1* 每次仅能转发一个数据报</a>：每次仅能够有一个数据报跨越总线</p>
<p>  <a style="color:red;">2* 总线的传输速率限制了带宽的传输速率</a></p>
</li>
<li><p>网络交换</p>
<p>  <a style="color:red;">1* 每次可以 <strong>并行转发</strong> 多个数据报</a></p>
<p>  <a style="color:red;">2* 虽然可以并行转发但是如果输出端口的缓存已满，仍然需要在输入端口中等待</a></p>
</li>
</ul>
<p>  <img src="https://i1.xpic.jp/file/xpicjp/2021/06/14/422ef10781813b1d57e4450b97df2b53.png" alt="422ef10781813b1d57e4450b97df2b53.png"></p>
</li>
<li><p>转发表：</p>
<ul>
<li>采用 CIDR 的==网络前缀去对应端口==，而不是每个 IP 地址都对应一个端口，这会导致转发表过于庞大</li>
<li>端口 3 每次查找转发表中网络前缀对应的转发端口时采用的是==最长前缀匹配原则==</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210327164149171.png" alt="image-20210327164149171"></p>
<ul>
<li><p>转发过程</p>
<ul>
<li><p>机制：==存储转发==</p>
</li>
<li><p>端口：如果分组进入队列中的速率==快于==端口处理分组的速度，就会导致==队列堵塞== (<a style="color:red;">输入输出队列都会早成堵塞</a>)</p>
</li>
<li><p>队列堵塞：路由器不会接收溢出的分组；==分组溢出是造成路由器舍弃分组的重要原因==</p>
</li>
</ul>
</li>
<li><p>弃尾策略(Drop-Tail)：输入或者输出队列没有足够的缓存存放数据报时：丢弃一个或者多个数据报为新到来的数据报 <strong>腾出空间</strong> 并且提示 <strong>发送方缓存已满</strong></p>
<p>  <a style="color:red;">注：丢弃的三种策略 (1) 丢弃到来的数据报 (2) 基于数据报的优先权丢弃 (3) 随机丢弃</a></p>
<p>  注：统称为 主动队列管理 Active Queue Management</p>
</li>
<li><p>分组调度：制定策略选择输出/输入队列中的哪个数据报进行传输 (<a style="color:red;">分组调度并不能够解决队列堵塞问题</a>)</p>
<ul>
<li><p>先进先出(FIFO)：先来的数据报先进入端口进行处理，后来的数据报只能够在分组队列中的等待</p>
</li>
<li><p>优先权排队(Priority Queue)：</p>
<p>  (1) 分为 <strong>优先权队列</strong> 和 <strong>普通队列</strong>：优先权队列中的数据报优先处理，普通队列中的数据报稍后处理</p>
<p>  <a style="color:red;">1* 只有优先权队列中没有数据报时才会轮到普通队列</a></p>
<p>  <a style="color:red;">2* 同一个优先权队列中的数据报按照先进先出的方式传输</a></p>
<p>  (2) 抢占式优先权排队 &amp; 非抢占式优先权排队 (Non-Preemptive Priority Queuing)</p>
<ul>
<li>非抢占式：端口正在处理普通队列中的分组，高优先级的分组 <strong>不允许</strong> 抢占执行</li>
<li>抢占式：端口正在处理普通队列中的分组，高优先级的分组 <strong>可以</strong> 抢占执行</li>
</ul>
</li>
<li><p>循环排队 (Round Robin Queue)</p>
<p>  (1) 根据分组的类型划分 <strong>多个不同类型的队列</strong></p>
<p>  (2) <a style="color:red;">每传输完某个类型队列中的一个分组后立刻传输下一个类型队列中的一个分组</a> (循环)</p>
<p>  注：<strong>并不会</strong> 传输完某个类型中的所有分组再传输下一个类型队列中的分组，除非其他队列没有分组了</p>
</li>
<li><p>加权公平排队 (Weighted Fair Queuing)</p>
<p>  (1) 基于循环排队调度：为每个不同类型的队列 <strong>分配一个权重</strong></p>
<p>  (2) 每次传输一个类型队列中的分组数量 = 该队列的权重在所有队列权重中的占比</p>
</li>
</ul>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/09/network/%E4%BC%A0%E8%BE%93%E5%B1%82/">传输层</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-11</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="传输层"   >
          <a href="#传输层" class="heading-link"><i class="fas fa-link"></i></a><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1>
      
        <h2 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h2>
      <ul>
<li><p>概念：为运行在不同端系统上的 <strong>进程</strong> 提供了逻辑通信 (Logic Communication) (进程的概念详见操作系统)</p>
<p>  注：网络层是为不同的 <strong>端系统</strong> 之间提供逻辑通信</p>
</li>
<li><p>单位：==报文段== (Segement)</p>
<p>  <a style="color:red;">注：UDP 协议是不对应用层交付的报文做任何处理的</a>：所以也可以认为单位是报文</p>
</li>
<li><p>协议：</p>
<ul>
<li>UDP 协议：用户数据报协议</li>
<li>TCP 协议：传输控制协议</li>
</ul>
<div class="table-container"><table>
<thead>
<tr>
<th>应用层协议</th>
<th>传输层协议</th>
</tr>
</thead>
<tbody><tr>
<td>SMTP</td>
<td>TCP</td>
</tr>
<tr>
<td>HTTP</td>
<td>TCP</td>
</tr>
<tr>
<td>Telnet</td>
<td>TCP</td>
</tr>
<tr>
<td>FTP</td>
<td>TCP</td>
</tr>
<tr>
<td>DNS</td>
<td>UDP</td>
</tr>
<tr>
<td>SMNP</td>
<td>UDP</td>
</tr>
<tr>
<td>DHCP</td>
<td>UDP</td>
</tr>
<tr>
<td>RIP</td>
<td>UDP</td>
</tr>
<tr>
<td>BGP</td>
<td>TCP</td>
</tr>
</tbody></table></div>
</li>
<li><p>功能</p>
<ul>
<li><a href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8&%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3">多路复用</a>(Mutiplexing) &amp; <a href="#%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3">多路分解</a> (Demutiplexing)：<a style="color:red;">TCP &amp; UDP 协议都提供多路复用与分解功能</a></li>
<li><a href="#%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86">连接管理</a>：<a style="color:red;">TCP 协议是 <strong>面向连接</strong> 的协议需要建立连接 &amp; UDP 协议是 <strong>无连接</strong> 的协议不需要建立连接</a></li>
<li><a href="#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93">可靠传输</a>：<a style="color:red;">TCP 协议需要 <strong>保证可靠传输</strong> &amp; UDP 协议 <strong>不保证可靠传输</strong></a> </li>
<li><a href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">流量控制</a>：<a style="color:red;">TCP 协议提供 <strong>流量控制</strong> 机制 &amp; UDP 协议不提供 <strong>流量控制</strong> 机制</a></li>
<li><a href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">拥塞控制</a>：<a style="color:red;">TCP 协议提供 <strong>拥塞控制</strong> 机制 &amp; UDP 协议不提供 <strong>拥塞控制</strong> 机制</a></li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li><p>==端对端传输==</p>
</li>
<li><p>路由器 <strong>不会检查数据报的数据部分(传输层报文段)</strong> 仅检查数据报首部 </p>
<p>  解释：(1) 路由器仅实现到网络层是无法检测传输层的数据的 (2) 问题：传输层的数据出现问题 <strong>网络层是无法检测到</strong> 的</p>
</li>
</ul>
</li>
</ul>

        <h2 id="多路复用-amp-多路分解"   >
          <a href="#多路复用-amp-多路分解" class="heading-link"><i class="fas fa-link"></i></a><a href="#多路复用-amp-多路分解" class="headerlink" title="多路复用&amp;多路分解"></a>多路复用&amp;多路分解</h2>
      <ul>
<li><p>端口号：</p>
<ul>
<li><p>定义：进程在网络通信时用于标识自己的编号</p>
</li>
<li><p>长度：16位比特 (最大端口数量 2^16^)</p>
</li>
<li><p>分类：</p>
<ul>
<li>服务端：(1) 周知端口号 0~1023 (2) 登记端口号 1024 ~ 49151</li>
<li>客户端：客户端程序参与网络通信使用的编号 49152 ~ 65536</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li><p><a style="color:red;">端口号不是进程号，多个进程可以同时使用一个端口号</a>：使得多个进程的数据可以封装在同一个报文段中</p>
<p>  解释：不同的操作系统分配进程标识符格式是不同的，为了保证统一性设计了端口号</p>
</li>
<li><p><a style="color:red;">一个进程可以占用多个端口号</a></p>
</li>
</ul>
</li>
</ul>
<div class="table-container"><table>
<thead>
<tr>
<th>应用层协议</th>
<th>FTP</th>
<th>TELNET</th>
<th>SMTP</th>
<th>DNS</th>
<th>HTTP</th>
<th>SNMP</th>
<th>RIP</th>
</tr>
</thead>
<tbody><tr>
<td>端口号</td>
<td>21</td>
<td>23</td>
<td>25</td>
<td>53</td>
<td>80</td>
<td>161</td>
<td>520</td>
</tr>
</tbody></table></div>
</li>
<li><p>套接字(Socket)：用于标识端系统上具体某个进程</p>
<ul>
<li><p>UDP 套接字：&lt;目的<code>IP</code> 地址 , 目的端口号&gt;</p>
<p>  <a style="color:red;">不同的源主机发送的报文段将会因为 <strong>相同的目的IP地址和端口号</strong> 被定向到同一主机的同一进程</a></p>
</li>
<li><p>TCP 套接字：&lt;源<code>IP</code> 地址，源端口号，目的<code>IP</code> 地址 , 目的端口号&gt;</p>
<p>  <a style="color:red;">不同源主机发送的报文段不会因为 <strong>相同的目的IP地址和端口号</strong> 被定向到同一主机的同一进程</a>：因为源主机 IP 地址和端口号不同，建立的连接也不同</p>
</li>
</ul>
</li>
<li><p>多路复用：传输层从不同的套接字中接收 <strong>报文</strong> 并为其添加首部形成 <strong>报文段</strong> (不同的应用程序可以采用相同的传输层协议传输数据)</p>
</li>
<li><p>多路分解：(1) 传输层从网络层中接收 <strong>数据报</strong> 并拆封将 <strong>报文段</strong> 交付给正确的套接字 (2) 套接字最后把数据分发给相应的集成</p>
</li>
</ul>
<p><img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210402201243799.png" alt="image-20210402201243799"></p>

        <h2 id="传输层协议"   >
          <a href="#传输层协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h2>
      
        <h3 id="UDP-协议"   >
          <a href="#UDP-协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h3>
      <ul>
<li><p>功能：(提供的是传输层 <strong>最低限度</strong> 的功能)</p>
<ul>
<li><p>多路复用&amp;多路分解</p>
</li>
<li><p>差错检测：<strong>校验和</strong> (<a style="color:red;">首部校验和不具有差错纠正的功能</a>)</p>
<p>  注：<a style="color:red;">UDP 协议丢弃受损的报文段并且向上层发出警告</a>：不具有差错的恢复能力</p>
</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li><p>无连接：(1) 进程之间通信不需要提前建立连接 (2) 减少传输的时延，适用于实时通信</p>
</li>
<li><p>不提供可靠传输：报文段可能 <strong>受损</strong>  + <strong>丢失</strong> + <strong>失序</strong> + <strong>重复到达</strong></p>
</li>
<li><p>面向报文：不对应用层交付的报文作任何处理直接封装后放入数据报中 </p>
<ul>
<li><p>如果报文容量过大，会导致网络层需要对其进行分片</p>
</li>
<li><p>如果报文容量过小，会导致网络层数据报的首部相对较大</p>
<p>  <a style="color:red;">注：报文大小控制不得当会导致网络层通信效率降低</a></p>
</li>
</ul>
</li>
<li><p>首部开销小：==8B==</p>
</li>
<li><p>支持==非一对一==通信</p>
</li>
</ul>
</li>
<li><p>报文段格式</p>
<ul>
<li><p>源端口号：服务器返回数据时可以直接从发送的报文段中提取源端口号作为目的端口号</p>
</li>
<li><p>目的端口号：</p>
</li>
<li><p>报文总长度：<strong>首部长度 + 数据长度</strong></p>
</li>
<li><p>校验和</p>
<ul>
<li><p>计算过程</p>
<p>  (1) 源端口号 + 目的端口号 + 总长度 + 数据部分 + ==伪首部==（不包括校验和字段)</p>
<p>  (2) 二进制求和后 <strong>取反码</strong> 得到校验和</p>
<p>  (3) 如果求和过程出现 <strong>溢出</strong>，需要采用 ==回卷== 操作</p>
</li>
<li><p>伪首部：==源 IP 地址 + 目的 IP 地址 + 0 + 协议字段（ UDP 协议是 17）+ UDP 报文长度== (<a style="color:red;">伪首部只在计算校验和的时候出现，不会被封装进数据报中</a>)</p>
</li>
<li><p>回卷：最高位溢出的结果 <strong>加到</strong> 最低位去</p>
</li>
<li><p>问题：</p>
<ol>
<li><p>数据链路层采用 CRC 校验了，网络层采用首部校验和校验了，为什么传输层还要采用校验和校验？</p>
<p> (1) 数据链路层和网络层的校验不能够保证发现所有的错误 (2) 网络层向传输层交付数据时仍然可能发生错误</p>
</li>
<li><p>为什么传输层的校验和要使用伪首部</p>
<ul>
<li><p>==伪首部检验 IP 地址== -&gt; 网络层在拆卸 IP 数据报的过程中 IP 地址仍然是可能发生变化的，传输层需要防止网络层交付错误的 IP 地址</p>
</li>
<li><p>==伪首部检验网络层数据报是否交付错误== -&gt; TCP/UDP 协议和 IP 协议完全可能不在同一个协议栈上，IP 数据报不一定是交付给 TCP/UDP 的</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>  <a style="color:red;">1. 网络层和传输层的首部校验和都是选择性使用的</a></p>
<p>  <a style="color:red;">2. 网络层和传输层都会对 IP 地址做校验，确实有一定的重复，所以在 IPv6 协议中取消了校验和字段，保证速率</a></p>
</li>
<li><p>细节：</p>
<ul>
<li><a style="color:red;">UDP 不提供可靠传输就意味着需要应用程序自己保证可靠传输</a></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210402204459854.png" alt="image-20210402204459854"></p>

        <h3 id="TCP-协议"   >
          <a href="#TCP-协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3>
      
        <h4 id="基本概念"   >
          <a href="#基本概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4>
      <ul>
<li><p>概念：面向连接（虚连接）的传输层协议</p>
</li>
<li><p>功能：</p>
<ul>
<li><a href="#%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86">连接管理</a></li>
<li><a href="#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93">可靠传输</a></li>
<li><a href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">流量控制</a></li>
<li><a href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">拥塞控制</a></li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li><p>面向连接</p>
<ul>
<li>连接仅建立在两个进程之间，是 <strong>点对点</strong> 的情况 (<a style="color:red;">多播协议是不可能在 TCP 下实现的</a>)</li>
<li>进程双方在通信时需要 <strong>提前建立连接</strong> 才能够发送数据</li>
<li>请求建立连接的进程称为 <strong>客户端</strong> ，响应连接建立的进程称为 <strong>服务端</strong></li>
<li>TCP 连接是 <strong>虚连接</strong>：网络层之下都是不会感受到 TCP 连接的存在</li>
</ul>
</li>
<li><p>可靠传输：保证报文段能够正确到达</p>
</li>
<li><p>全双工通信：进程双方可以同时发送数据和接收数据，接收和发送双方==都具有接收窗口和发送窗口==</p>
</li>
<li><p>面向字节流：<a style="color:red;">将应用层的交付的数据 <strong>按照字节隐式地编号</strong></a>，每次将一定数量的字节封装成报文段发送</p>
<p>  <a style="color:red;">注：每个报文段的字节数量取决于 MSS (最大报文段长度)</a></p>
</li>
</ul>
</li>
<li><p>报文格式：</p>
<ul>
<li><p>源端口号 目的端口号（2B）</p>
</li>
<li><p>序号（4B）：每次发送的报文段中 ==第一个字节的编号== 就是序号</p>
<p>  注：初始序号通常随机：(1) <a style="color:red;">避免分组重排序</a>：防止滞留在网络中的分组在某个时刻到达导致传递不必要的信息 (2) 保证网络安全</p>
</li>
<li><p>确认号（4B）：每次确认报文段中希望得到的 ==下一个字节的编号== (<a style="color:red;">序号 + 数据长度 = 确认号</a>)</p>
</li>
<li><p>首部长度（4bit）：单位 ==4B==</p>
</li>
<li><p>窗口大小（2B）：接收方将当前 <strong>缓存空间</strong> 中的 <strong>窗口大小</strong> 值放入 <strong>确认报文</strong> 中返回给发送方</p>
<p>  <a style="color:red;">注：发送方收到的窗口大小的值 = min{接收窗口大小，拥塞窗口大小}</a></p>
</li>
<li><p>控制位：</p>
<ul>
<li><code>URG</code>：(1) <code>URG</code> = 1 传输的数据是紧急数据时 (2) 紧急传输的数据不需要在 <strong>缓存空间</strong> 中排队</li>
<li><code>ACK</code>：(1) <code>ACK</code> = 1 连接建立过程中服务端回复确认报文段时 (2) <a style="color:red;">连接建立后所有报文段的 ACK 必须被置为 1</a> (无论报文段时确认报文段还是发送报文段)</li>
<li><code>PSH</code>：不需要在接收窗口中等待应用层的处理，直接交付给应用层处理</li>
<li><code>RST</code>：连接出现严重错误，需要重新建立连接</li>
<li><code>SYN</code>：(1) <code>SYN</code> = 1 客户端请求建立连接 &amp; 服务器端同意建立连接</li>
<li><code>FIN</code>：(1) <code>FIN</code> = 1 客户端请求结束连接 &amp; 服务器端同意结束连接</li>
</ul>
</li>
</ul>
</li>
<li><p>图示</p>
</li>
</ul>
<p><img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210403150832072.png" alt="image-20210403150832072"></p>

        <h4 id="功能"   >
          <a href="#功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#功能" class="headerlink" title="功能"></a>功能</h4>
      
        <h5 id="连接管理"   >
          <a href="#连接管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h5>
      <ul>
<li><p>概念：连接建立 + 连接维护 + 连接释放</p>
</li>
<li><p>前提：TCP 是全双工通信 -&gt; ==有两条通信信道==</p>
</li>
<li><p>过程：</p>
<ul>
<li><p>连接建立：服务器长期处于监听状态</p>
<ol>
<li><p>客户端发送 SYN = 1</p>
<ul>
<li>客户端进入 ==SYN_SENT 状态==</li>
<li>等待服务器响应；如果超时则利用重传机制，重传 SYN = 1</li>
<li>不携带任何数据，但是消耗序号</li>
</ul>
</li>
<li><p>服务端响应 ACK = 1和 SYN = 1</p>
<ul>
<li><p>服务器端进入 ==SYN_RCVD 状态==</p>
</li>
<li><p>等待客户端响应；如果超时则利用重传机制，重传 SYN = 1，ACK = 1</p>
<p>  <a style="color:red;">其实本质上 SYN 和 ACK 应该分开发送的，但是这里可以整合在一起发送</a></p>
</li>
<li><p>不携带任何数据，但是消耗序号</p>
</li>
<li><p>开始分配 ==TCP 缓存== 和 ==变量==</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<ol start="3">
<li>客户端响应 ACK = 1 <ul>
<li>客户端进入 ==ESTABLISHED 状态==</li>
<li>可以携带数据发送</li>
<li>开始分配 ==TCP 缓存== 和 ==变量==    4. 服务器端接收到响应进入 ==ESTABLISHED 状态==</li>
</ul>
</li>
</ol>
</li>
</ul>
<pre><code>* 细节问题

    1. seq = x：x 的值是随机分配的

    2. 为什么是三次握手，不是两次，四次或者更多次

        * 非本质回答：资源浪费

            客户端发送的连接建立请求可能在网络中滞留，导致延时到达服务器；

            客户端选择重传连接建立请求，然后传输数据，最后关闭连接；

            但是，之前延时到达的服务器的连接请求在关闭连接后到达了；

            这时，服务器端就会认为客户端又开始请求建立连接了，就会发送响应 SYN = 1 ACK = 1；

            如果是两次握手，导致连接建立，但是客户端并不想要建立连接，所以就不会回复，导致服务器端会长时间的等待直到超时，浪费资源

            如果是三次握手，那么服务器端就会因为客户端不回复知道他不想建立连接，就不会一直等待

        * 本质回答：==三次握手是理论保证可靠传输的最小值==

            一次握手：客户端发送请求，显然他根本不知道服务器到底接收到没有，所以需要等待服务器的回复 -&gt; 一次握手显然不可靠

            两次握手：服务器端回复了客户端，那么服务器端也不清楚客户端到底接收到没有，所以需要再次等待客户端的回复-&gt; 两次握手显然也不太可靠

            三次握手：客户端回复了服务器，已经基本确认两端都是可以连通的，可靠连接可以基本建立了

            四次握手：客户端也不清楚服务器端是否接收到自己的再次回复，所以再次等待服务器端的回复 -&gt; 显然相对于三次可靠性更高了

            ....

            实际上，我们可以设计非常多次的握手来保证可靠传输，但是三次就是理论上保证可靠传输的最小值

* 连接断开：客户端数据发送完毕

    1. 客户端发送 FIN = 1 

        * 客户端进入 ==FIN-WAIT1状态==
        * 客户端等待服务器的响应；超时则利用重传机制
        * 不携带任何数据，消耗序号

    2. 服务端响应客户端 ACK = 1

        * 服务器端进入 ==CLOSE-WAIT 状态==
        * 服务器允许客户端释放连接 -&gt; &lt;a style=&quot;color:red;&quot;&gt;释放客户端到服务器端的单向连接&lt;/a&gt;
        * 客户端连接释放之后不可以再发送数据；服务器端仍然可以发送数据
        * 不携带任何数据，消耗序号

        &lt;a style=&quot;color:red;&quot;&gt;上述两次握手经过后 TCP 连接处于半关闭状态，这期间服务器端仍然可能向客户端发送数据&lt;/a&gt;

    3. 服务端发送 FIN = 1

        * 服务器端进入 ==LAST-ACK状态==

        * 服务器不再向客户端发送数据后准备关闭连接
        * 服务器端等待客户端响应；超时则利用重传机制

    4. 客户端响应 ACK = 1

        * 服务器端进入 ==CLOSED状态==，客户端进入 ==TIME-WAIT状态==
        * 服务器端到客户端的连接还没有释放

    5. 客户端等待时间结束（2MSL）

        * 客户端进入 ==CLOSED状态==
        * 服务器端到客户端的连接彻底释放

    6. TCP 连接关闭完成

* 细节问题

    1. 为什么是四次挥手不是三次挥手？
        * 连接建立实际上也可以看做四次握手，而是三次握手的原因，是因为 ACK + SYN 一起发送简化了过程
        * 连接关闭时两者不可以一起发送，因为确认客户端到服务器端的连接关闭后，服务器端到客户端的连接并不会立刻关闭 -&gt; 造成四次挥手
    2. 为什么最后客户端需要等待一段时间之后才能关闭呢？
        * 因为客户端响应的 ACK 很有可能产生丢失，导致服务器端到客户端连接并没有关闭，如果此时客户端先行关闭，会导致服务器挂起
        * 所以客户端需要等待服务器先行关闭，自己再关闭，最后服务器端到客户端的连接才算彻底释放 -&gt; TCP 关闭完成
    3. 为什么一定要等待 2MSL 长度的时间呢？
        * 报文段最长存活时间是 MSL
        * ？
    4. 如果服务器第一次响应客户端的报文段丢失，会出现什么情况呢？
</code></pre>
<ul>
<li><p>图示：</p>
<ul>
<li>连接建立</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210419171811788.png" alt="image-20210419171811788"></p>
<ul>
<li>连接断开</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210419193439634.png" alt="image-20210419193439634"></p>
</li>
<li><p>SYN 洪泛攻击</p>
<ul>
<li>概念：ddos 攻击的一种</li>
<li>过程：<ul>
<li>攻击者发送 SYN = 1 的第一个报文段</li>
<li>服务端接收第一个报文段后回复给攻击者相应的确认报文段</li>
<li>攻击者此时不再回复服务器</li>
<li>服务器没有接收到回复会不断地发送确认报文段，希望得到攻击者的响应</li>
<li>服务器由于得不到攻击者的响应，连接挂起，最后因为超时而断开连接</li>
</ul>
</li>
<li>后果：消耗 CPU 和 内存，导致服务器宕机</li>
</ul>
</li>
</ul>

        <h5 id="可靠传输"   >
          <a href="#可靠传输" class="heading-link"><i class="fas fa-link"></i></a><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h5>
      <p><img src="https://i1.xpic.jp/file/xpicjp/2021/06/19/4b3c32a16c1b3d029aa3199f0ca1413b.png" alt="4b3c32a16c1b3d029aa3199f0ca1413b.png"></p>

        <h6 id="基本机制"   >
          <a href="#基本机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本机制" class="headerlink" title="基本机制"></a>基本机制</h6>
      <ul>
<li><p>前提：信道是不可靠的：导致分组在传输过程中可能 <strong>受损</strong> + <strong>丢失</strong> + <strong>失序</strong> + <strong>延迟</strong></p>
</li>
<li><p>引入：所以我们需要一种机制来确保即使在传输过程中出现了这些问题最终仍然能够将分组正确交付给接收方</p>
</li>
<li><p>核心：<a style="color:red;">自动请求重传协议 </a> (Automatic Repeat reQuest)</p>
</li>
<li><p>确认机制</p>
<ul>
<li><p>正面确认(<code>ACK</code>) &amp; 负面确认(<code>NAK</code>)</p>
<ul>
<li><p>正面确认：接收方正确收到发送方发送的分组之后反馈给接收方的分组</p>
</li>
<li><p>负面确认：接收方收到错误的分组后反馈给接收方的分组 (实际协议中通常不使用这种机制)</p>
<p>  <a style="color:red;">1. 如果在确认分组中携带数据就称为 <strong>捎带确认</strong> </a></p>
<p>  <a style="color:red;">2. <strong>正面确认 + 序号</strong> 机制可以代替负面确认</a>：接收方可以通过分组的序号确认当前的分组是否是自己想要的分组，如果不是则重复发送相同的确认分组</p>
</li>
</ul>
</li>
<li><p>差错检测：需要使用差错检测检查分组是否受损</p>
</li>
<li><p>序号：(1) 发送方发送的分组和接收方发送的确认分组都需要编号 (2) 接收方正确收到分组后返回的确认分组和接收分组的序号一致</p>
<p>  <a style="color:red;">1* TCP 的实际实现中是根据报文段中第一个字节编号作为整个报文段的编号</a></p>
<p>  <a style="color:red;">2* 序号是可以 <strong>复用</strong> 的</a>：序号复用可能会导致分组重排序的问题</p>
</li>
</ul>
<p>  注：上述机制已经解决了分组可能产生的失序和受损的问题，但是没有解决丢失和延迟到达的问题</p>
</li>
<li><p>重传机制</p>
<ul>
<li><p>超时重传：发送方在规定的等待时间内没有接收到确认分组就会重传分组</p>
<ul>
<li><p>定时器：(1) GBN 协议中仅使用 <strong>一个定时器</strong> (2) SR 协议中 <strong>每个分组都拥有一个定时器</strong> (3) TCP 实际实现中也 <strong>仅使用一个定时器</strong></p>
</li>
<li><p>计算方式：(指数加权移动平均)</p>
<p>  (1) TimeoutInterval = EstimatedRTT + 4DevRTT</p>
<p>  (2) EstimatedRTT = $(1-\alpha)<em>EstimatedRTT + \alpha</em>SampleRTT$ ($\alpha$ 通常取 0.125)</p>
<p>  (3) 4DevRTT= $(1- \beta)<em>DevRTT + \beta</em>|SampleRTT - EstimatedRTT|$ ($\beta$ 通常取 0.25) </p>
<p>  <a style="color:red;">1. SampleRTT 不是每发送一个分组就测量一次而是在某个时刻测量一次</a></p>
<p>  <a style="color:red;">2. 每出现一次超时重传 TimeoutInterval 直接翻倍而不是采用公式计算</a></p>
</li>
</ul>
</li>
<li><p>快速重传：发送方在重复接收到 <strong>3 个相同的 <code>ACK</code> 分组</strong> 后就会自动触发重传</p>
<p>  <a style="color:red;">注：可以在定时器倒计时结束前重传分组</a></p>
</li>
<li><p>重传时机：(1) 数据分组丢失 (2) 数据分组延时到达 (3) 数据分组乱序达到 (4) 确认分组延时到达 (5) 确认分组丢失</p>
</li>
</ul>
</li>
<li><p>停止-等待协议：</p>
<ul>
<li>内容：(1) 发送 <strong>每发送一个分组</strong> 都需要等待接收方返回确认分组 (2) 规定时间内没有接收到确认分组就会重传</li>
<li>优点：非常简单</li>
<li>缺点：<a style="color:red;">效率非常低</a>：$\frac{\frac{L}{R}}{RTT+\frac{L}{R}}$ (<a style="color:red;">注：这里的 RTT 指的是分组中的 <strong>最后一个比特</strong> 被发送到接收确认分组的 <strong>第一个比特</strong> 的时间</a>)</li>
</ul>
</li>
<li><p>流水线协议</p>
<ul>
<li><p>内容：允许发送方 <strong>同时发送多个分组</strong> 而不需要等待接收方的确认分组</p>
</li>
<li><p>优点：<a style="color:red;">效率相对停止-等待协议提高很多</a>：$\frac{\frac{nL}{R}}{RTT+\frac{L}{R}}$ (注：这个公式为什么是这样的？好好想想，否则流水线的题目是算不出来的)</p>
</li>
<li><p>缺点：(1) 需要控制发送方在每个时刻同时发送的分组的数量 -&gt; 如果不加以限制会造成网络拥塞 (2) 分组可能乱序到达 -&gt; 接收方如何接收？</p>
<p>  <a style="color:red;">注：(1) GBN 协议和 SR 协议都采用滑动窗口机制对发送的分组数量加以限制 (2) GBN 丢弃乱序到达的分组 SR 缓存乱序到达的分组</a></p>
</li>
<li><p>协议：(1) [GBN 协议](#GBN 协议) (2) [SR](#SR 协议)</p>
</li>
</ul>
</li>
</ul>

        <h6 id="GBN-协议"   >
          <a href="#GBN-协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#GBN-协议" class="headerlink" title="GBN 协议"></a>GBN 协议</h6>
      <ul>
<li><p>内容：</p>
<ul>
<li><p>发送方拥有发送窗口：(1) 已经发送但未确认的分组 (2) 即将要发送的分组 </p>
<p>  注：定义：(1) 最早已发送未确认的分组序号为 base (2) 即将要发送的第一个分组序号为 nextseqnum (3) 窗口长度为 N</p>
</li>
<li><p>发送方 <strong>已发送但未确认的分组数量</strong> 不可以超过当前滑动窗口的大小 (<a style="color:red;">nextseqnum - base ≤ N</a>)</p>
</li>
<li><p>发送方接收到 <strong>确认序号 ≥ base</strong> 的确认分组时就会将窗口向前移动 <strong>确认序号 - base + 1</strong> 个位置 (滑动窗口的含义)</p>
<p>  注：<a style="color:red;">GBN 协议采用 <strong>累积确认</strong> </a></p>
</li>
<li><p>发送方如果在规定时间没有接收到相应的确认分组就会 <strong>重传所有已发送但未确认的分组</strong> (就是后退 N 步的含义)</p>
</li>
<li><p>接收方 <strong>仅接收按序到来的分组</strong> 而对于乱序到来的分组直接抛弃并且发送 <strong>上次发送的确认分组</strong></p>
<p>  注：<a style="color:red;">接收方 <strong>丢弃所有乱序达到分组</strong> 不会进行缓存</a></p>
</li>
</ul>
</li>
<li><p>累积确认(Cumulative Acknowlegment)：</p>
<ul>
<li>内容：<ul>
<li>接收方连续按序接收到 <strong>多个分组</strong> 后 <strong>仅返回一个确认分组</strong> 用于通知发送方已正确接收到所有分组 (<a style="color:red;">确认分组的序号是最后一个按序到达的分组的序号</a>)</li>
<li>发送方接收到确认分组后就认为该 <strong>确认序号之前</strong> <strong>所有没有被确认的分组都已经被正确接收</strong> (所以滑动窗口会向前移动多个位置)</li>
</ul>
</li>
<li>累积确认的目的就是为了加速传输的过程，没有必要对每个分组都进行确认</li>
</ul>
</li>
<li><p>优点：实现简单 -&gt; 接收方不需要缓存任何乱序到的分组</p>
</li>
<li><p>缺点：后退 N 步造成很多无意义的重传：即使正确到达接收方的分组也可能因为乱序而不被接收，所以发送方只能够重发所有未被确认分组</p>
</li>
<li><p>窗口大小：$1 &lt; W_t &lt; 2^n - 1$ ($n$ 是比特的个数)</p>
</li>
<li><p>细节：</p>
<ul>
<li>发送方的应用层在要求发送数据时，发送方首先检查窗口是否已满：(是否已满就是判断当前已发送但未确认的分组是否达到滑动窗口大小)<ul>
<li><a style="color:red;">如果未满就将分组添加到即将要发送分组中</a> </li>
<li><a style="color:red;">如果已满：(1) 将分组返回给应用层暗示待会再发 (2) 发送方缓存当前的分组等到有空位置再发 (3) 采用同步机制</a></li>
</ul>
</li>
<li><a style="color:red;">所有分组共享一个定时器</a></li>
</ul>
</li>
</ul>

        <h6 id="SR-协议"   >
          <a href="#SR-协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#SR-协议" class="headerlink" title="SR 协议"></a>SR 协议</h6>
      <ul>
<li><p>内容：</p>
<ul>
<li><p>发送方：</p>
<p>  (1) 发送方拥有发送窗口：已经发送但未确认的分组 + 即将要发送的分组 (其余定义和 GBN 一致)</p>
<p>  (2) 发送方 <strong>已发送但未确认的分组数量</strong> 不可以超过当前滑动窗口的大小 (<a style="color:red;">nextseqnum - base ≤ N</a>)</p>
<p>  (3) 发送方仅在接收到 <strong>确认序号 == base</strong> 的确认分组时才会将滑动窗口向前移动 <strong>下一个仍未被确认的分组的序号 - base</strong> 个位置</p>
<p>  注：<a style="color:red;">SR 协议采用的是 <strong>选择重传</strong> 无法采用累积确认</a> </p>
<p>  (4) 发送方在规定时间内没有接收到相应分组的确认时 <strong>仅重传没有被确认的分组</strong></p>
</li>
<li><p>接收方：</p>
<p>  (1) 接收方也拥有接收窗口：<a style="color:red;">缓存所有乱序到达的分组并且对每个乱序到达的分组都会返回确认分组</a></p>
<p>  (2) 接收方仅在接收到 <strong>序号 == 最早期待的分组序号</strong> 才会将滑动窗口向前移动 <strong>下一个被期待的分组序号 - 最早期待的分组序号</strong> 个位置</p>
</li>
</ul>
</li>
<li><p>选择重传：</p>
<ul>
<li>无论是否按序到达分组接收方都会返回相应的确认分组让发送方得知哪些分组已经被正确接收哪些还没有被正确接收</li>
<li>发送方在重传分组的时候就 <strong>可选择性地重传没有被接收的分组</strong> 而不是重传所有已发送但未被确认的分组</li>
</ul>
</li>
<li><p>优点：不会造成非常多无意义的重传</p>
</li>
<li><p>缺点：在序号复用的情况下重传的分组和新发的分组可能无法别识别出来</p>
</li>
<li><p>窗口大小：</p>
<ul>
<li><a style="color:red;">接收窗口和发送窗口大小通常一致</a></li>
<li>$Ws + Wr ≤ 2^n$</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li><a style="color:red;">接收方和发送方的窗口并不总是 <strong>同步</strong> 的</a></li>
<li><a style="color:red;">所有分组都具有一个独立的定时器</a></li>
</ul>
</li>
</ul>

        <h6 id="TCP-协议-1"   >
          <a href="#TCP-协议-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP-协议-1" class="headerlink" title="TCP 协议"></a>TCP 协议</h6>
      <ul>
<li><p>核心：<a style="color:red;">GBN 协议 + SR 协议的 <strong>混合体</strong> </a>：采用 <strong>累积确认 + 选择重传</strong></p>
</li>
<li><p>累积确认 + 选择重传：接收方会缓存乱序到达的报文段但是 <strong>不会对乱序到达的报文段返回相应的确认</strong>，而是持续的返回期望接收到报文段的确认 (累积确认)</p>
</li>
<li><p>面向字节：(1) 应用层交付的每个报文中的比特都被隐式地 <strong>编号</strong> (2) 每次将一定数量的字节封装成报文段发送</p>
<ul>
<li>报文段序号(seq)：报文段中第一个字节的编号</li>
<li>确认报文段确认号(ack)：期望收到的下一个字节的序号 seq + data.length</li>
</ul>
</li>
<li><p>发送缓存：发送窗口(已发送未被确认字节 + 即将发送的字节) + 应用层交付的但还不可以被发送的字节</p>
</li>
<li><p>接收缓存：接收窗口(已收到的字节 + 仍未收到的字节) + 已经确认但未被应用层使用的字节</p>
</li>
<li><p>通信过程：</p>
</li>
</ul>

        <h5 id="流量控制"   >
          <a href="#流量控制" class="heading-link"><i class="fas fa-link"></i></a><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h5>
      <ul>
<li><p>原因：发送方发送的速率太快导致 <strong>接收方来不及接收处理</strong> (局部性造成的)</p>
</li>
<li><p>核心：<a style="color:red;">滑动窗口机制</a></p>
</li>
<li><p>内容：</p>
<ul>
<li>接收窗口大小 rwnd：接收缓存 - 应用层尚未处理的字节数量</li>
<li><a style="color:red;">接收方通过在确认报文段中 <strong>填写窗口大小字段</strong> </a> 通知发送方当前还可以接收的字节数量</li>
<li>从而达到控制发送方的发送速率的目的</li>
</ul>
</li>
<li><p>问题：$rwnd = 0$ 时发送方就会停止发送数据，但是接收方处理完数据之后并不会通知发送方，那么发送方怎么才能够得知接收方已经处理完数据了呢？</p>
<ul>
<li><p>核心：<a style="color:red;">设置定时器</a></p>
</li>
<li><p>方式：定时器倒计时结束后发送方发送 <strong>不带数据的报文段</strong>：</p>
<p>  (1) 如果接确认报文段的窗口大小字段为 0 则接收方没有处理完 </p>
<p>  (2) 如果接确认报文段的窗口大小字段不为 0 则接收方已经处理完成：发送方可以重新开始发送数据了</p>
</li>
</ul>
</li>
<li><p>细节：<a style="color:red;">窗口大小字段取决于 <strong>接收窗口大小 和 拥塞窗口大小</strong> 两个因素</a></p>
</li>
</ul>

        <h5 id="拥塞控制"   >
          <a href="#拥塞控制" class="heading-link"><i class="fas fa-link"></i></a><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h5>
      <ul>
<li><p>概念：网络中的各个发送方的发送速率太快导致 <strong>路由器来不及接收处理</strong> (<strong>全局性</strong> 造成的)</p>
</li>
<li><p>核心：<a style="color:red;">慢开始 + 拥塞避免 + 快重传 + 快恢复</a> (慢开始和拥塞避免是 TCP 拥塞控制的 <strong>强制部分</strong>)</p>
</li>
<li><p>前提：<a style="color:red;">发送方维护拥塞窗口大小变量 cwnd</a></p>
</li>
<li><p>内容：</p>
<ul>
<li><p>慢开始：“探测”当前网络的通信状况</p>
<p>  (1) $cwnd_0 = 1$：发送方在刚开始仅发送一个 <strong>报文段</strong> (字节数量 = <code>MSS</code>) 用于试探网络当前的堵塞状况</p>
<p>  (2) 发送方成功接收到接收方返回的确认报文后更新 $cwnd$ 的值</p>
<p>  (3) $cwnd = 2^{n-1}$ ($n$ 是发送的轮次)：发送方发送的报文段数量开始成 <strong>指数级增长</strong></p>
<p>  (4) 发送方结束指数级增长的情况：1) 进入拥塞避免状态 2) 进入快重传机制 3) 出现网络拥塞</p>
<p>  (5) 出现网络拥塞之后：使 $ssthresh$ = $cwnd / 2$ 再将 $cwnd$ 的值重新置为 $1$  重新开始 <strong>慢启动</strong></p>
</li>
<li><p>拥塞避免：$cwnd = ssthresh$ 时发送方结束指数增长开始线性增长：经过每个轮次之后 $cwnd++$</p>
</li>
<li><p>快重传：发送方在接收到 $3个ACK$ 之后重传当前发送的报文段并且进入 <strong>快恢复</strong></p>
<p>  <a style="color:red;">注：快重传通常伴随快恢复</a></p>
</li>
<li><p>快恢复：(1) 使 $ssthresh$ = $cwnd / 2$ 再将 $cwnd$ 的值重新置为 $ssthresh$ (2) 每经过一个轮次 $cwnd++$</p>
</li>
</ul>
</li>
<li><p>细节：窗口字段大小 = $min(rwnd, cwnd)$</p>
</li>
</ul>
<p><img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210405193342652.png" alt="image-20210405193342652"></p>
<p><img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210405194244655.png" alt="image-20210405194244655"></p>
<p>​    </p>
<p>​    </p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/09/network/%E5%BA%94%E7%94%A8%E5%B1%82/">应用层</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-11</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="应用层"   >
          <a href="#应用层" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1>
      
        <h2 id="应用层概述"   >
          <a href="#应用层概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用层概述" class="headerlink" title="应用层概述"></a>应用层概述</h2>
      <ul>
<li>基本概念：<ul>
<li>应用层：使用下层协议为==应用软件==提供服务</li>
<li>单位：报文（HTTP协议）</li>
</ul>
</li>
<li>功能<ul>
<li>域名解析（DNS 协议）</li>
<li>文件传输（FTP 协议）</li>
<li>邮件系统（SMTP，POP3协议）</li>
<li>虚拟终端（HTTP协议）</li>
</ul>
</li>
<li>网络应用模型<ul>
<li>C/S 客户端/服务器</li>
<li>P2P</li>
</ul>
</li>
</ul>

        <h2 id="协议"   >
          <a href="#协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#协议" class="headerlink" title="协议"></a>协议</h2>
      
        <h3 id="DNS-协议（需要修改）"   >
          <a href="#DNS-协议（需要修改）" class="heading-link"><i class="fas fa-link"></i></a><a href="#DNS-协议（需要修改）" class="headerlink" title="DNS 协议（需要修改）"></a>DNS 协议（需要修改）</h3>
      <ul>
<li><p>域名（主机名）</p>
<ul>
<li><p>概念：应用层用于==标识主机==的方式</p>
<ol>
<li>传输层：采用 IP 地址标识主机；端口号标识进程</li>
<li>网络层：采用 IP 地址标识主机；</li>
<li>数据链路层：采用 MAC 地址标识主机</li>
</ol>
</li>
<li><p>格式：==三级域名 + 二级域名 + 顶级域名==</p>
<ol>
<li>根域名：<code>.</code>（默认情况下不写：域名后加上 <code>.</code> 仍然是可以访问的）</li>
<li>顶级域名<ul>
<li>国家顶级域名：cn us uk</li>
<li>通用顶级域名：com org net gov</li>
<li>基础结构域名：arpa</li>
</ul>
</li>
<li>二级域名：<ul>
<li>类别域名：com edu gov net org</li>
<li>行政域名：cq beijing shanghai</li>
<li>自定义域名：bilibili</li>
</ul>
</li>
<li>三级域名：www mail ftp</li>
<li>四级域名：域名需要进一步划分时使用</li>
</ol>
</li>
<li><p>图示：</p>
<ul>
<li>举例</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210412144024007.png" alt="image-20210412144024007"></p>
<ul>
<li><p>划分</p>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210412144113902.png" alt="image-20210412144113902"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>DNS 协议：</p>
<ul>
<li>引入：传输层和网络层使用 ==IP 地址==才能够确定主机在网络中的位置，而应用层使用 ==域名== 确定，显然需要映射关系进行转化</li>
<li>定义：将应用层的==域名==（主机名）根据==映射关系==转换到 ==IP 地址==</li>
<li>相关协议：<ul>
<li>UDP 协议 端口 53：用于传输 DNS 请求和响应报文</li>
<li>DHCP 协议：获取本地 DNS 服务器的 IP 地址</li>
</ul>
</li>
</ul>
</li>
<li><p>DNS 服务器：</p>
<ul>
<li><p>定义：==查找== 域名 和 IP 地址 ==映射关系== 的服务器（运行在 BIND 软件的 UNIX 机器）</p>
<p>  <a style="color:red;">注：DNS 服务器 和 DNS 数据库是两个东西，服务器负责在数据库中查找所需的映射关系，并不存储映射关系</a></p>
</li>
<li><p>功能：</p>
<ol>
<li><p>查找映射关系</p>
</li>
<li><p>查找主机规范名：根据主机别名查找主机规范名及其 IP 地址</p>
<ul>
<li>主机别名：简短的主机规范名；举例：bilibili.com</li>
<li>主机规范名：完整的域名格式；举例：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://www.bilibili.com/" >www.bilibili.com</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ul>
</li>
<li><p>负载分配：多个 IP 地址的==集合映射一个域名==</p>
<ul>
<li>网站过于繁忙时需要多台服务器进行分布式处理</li>
<li>每台服务器都运行在不同的端系统上，实际的 IP 地址也是不一样的</li>
<li>每次通过域名访问网站时，实际访问的可能是不同的 IP 地址</li>
</ul>
<p> <a style="color:red;">注：一个 IP 地址可以对应多个 域名；一个域名也可以对应多个 IP 地址</a></p>
</li>
</ol>
</li>
<li><p>分类：</p>
<ul>
<li><p>根域名服务器</p>
<ol>
<li>全世界共有 400 多台根域名服务器，但是只有 13 个域名（13 个 组织管理）</li>
<li>根域名服务器==只==返回==顶级域名服务器的 IP 地址==，不会返回查询的域名的 IP 地址</li>
</ol>
  <figure class="highlight html"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ipconfig/displaydns --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 13 台根服务器的 域名 和 IP 地址 --&gt;</span></span><br><span class="line">	记录名称. . . . . . . : a.gtld-servers.net</span><br><span class="line">    A (主机)记录  . . . . : 192.5.6.30</span><br><span class="line"></span><br><span class="line">    记录名称. . . . . . . : b.gtld-servers.net</span><br><span class="line">    A (主机)记录  . . . . : 192.33.14.30</span><br><span class="line"></span><br><span class="line">    记录名称. . . . . . . : c.gtld-servers.net</span><br><span class="line">    A (主机)记录  . . . . : 192.26.92.30</span><br><span class="line"></span><br><span class="line">    记录名称. . . . . . . : d.gtld-servers.net</span><br><span class="line">    A (主机)记录  . . . . : 192.31.80.30</span><br><span class="line"></span><br><span class="line">    记录名称. . . . . . . : e.gtld-servers.net</span><br><span class="line">    A (主机)记录  . . . . : 192.12.94.30</span><br><span class="line"></span><br><span class="line">    记录名称. . . . . . . : f.gtld-servers.net</span><br><span class="line">    A (主机)记录  . . . . : 192.35.51.30</span><br><span class="line"></span><br><span class="line">    记录名称. . . . . . . : g.gtld-servers.net</span><br><span class="line">    A (主机)记录  . . . . : 192.42.93.30</span><br><span class="line"></span><br><span class="line">    记录名称. . . . . . . : h.gtld-servers.net</span><br><span class="line">    A (主机)记录  . . . . : 192.54.112.30</span><br><span class="line"></span><br><span class="line">    记录名称. . . . . . . : i.gtld-servers.net</span><br><span class="line">    A (主机)记录  . . . . : 192.43.172.30</span><br><span class="line"></span><br><span class="line">    记录名称. . . . . . . : j.gtld-servers.net</span><br><span class="line">    A (主机)记录  . . . . : 192.48.79.30</span><br><span class="line"></span><br><span class="line">    记录名称. . . . . . . : k.gtld-servers.net</span><br><span class="line">    A (主机)记录  . . . . : 192.52.178.30</span><br><span class="line"></span><br><span class="line">    记录名称. . . . . . . : l.gtld-servers.net</span><br><span class="line">    A (主机)记录  . . . . : 192.41.162.30</span><br><span class="line"><span class="comment">&lt;!-- 还有一台 m.gtld-servers.net 服务器 --&gt;</span></span><br></pre></td></tr></table></div></figure></li>
<li><p>顶级域名服务器：顶级域名只会返回权威域名服务器的 IP 地址，不会返回查询的域名对应的 IP 地址</p>
</li>
<li><p>权威域名服务器：返回查询的域名对应的 IP 地址</p>
</li>
<li><p>本地域名服务器：</p>
<ol>
<li>每个 ISP 中都有一个本地域名服务器</li>
<li>每个本地域名服务器和客户端相隔很近（几个路由器） -&gt; 同一个局域网中</li>
<li>可以直接返回查询的域名对应的 IP 地址</li>
</ol>
</li>
</ul>
</li>
<li><p>高速缓存：DNS 查询得到的映射关系存储在缓存中</p>
<ul>
<li>浏览器缓存：浏览器短时间内容会缓存 DNS 映射（Chrome 大约几分钟）</li>
<li>操作系统缓存：客户端在开机后会从本地域名服务器中的缓存进行下载得到 DNS 映射（关机后缓存消失）</li>
<li>hosts 文件：文件形式存储 DNS 映射；可以在 hosts 文件中写死映射关系，如果写错很有可能打开不了网站</li>
<li>本地域名服务器缓存<ol>
<li>每次 DNS 查询后都会返回 DNS 映射，本地域名服务器都会进行缓存（大约几天）</li>
<li>存储的映射包括：==DNS 服务器的域名对应的 IP 地址==，==查询的域名的对应的 IP 地址==</li>
</ol>
</li>
</ul>
</li>
<li><p>查找过程</p>
<ol>
<li><p>浏览器==先解析 URL 地址== -&gt; 得到需要访问的域名</p>
</li>
<li><p>浏览器==检查浏览器缓存==中是否存储该域名的 IP 地址：</p>
</li>
<li><p>浏览器==检查操作系统缓存==中是否存储该域名的 IP 地址</p>
</li>
<li><p>浏览器==检查 hosts 文件==中是否存储过该域名的 IP 地址</p>
<p> 如果上述缓存查询中都没有找到 IP 地址，浏览器会==调用 DNS 程序发送 DNS 请求==</p>
</li>
<li><p>本地域名服务器接收 DNS 请求</p>
<ul>
<li>检查高速缓存中是否存储对应的 IP 地址，如果存储过那么直接返回</li>
<li>如果高速缓存中没有存储对应的 IP 地址，那么发送 DNS 请求给==根域名服务器==进行处理</li>
</ul>
<p> <a style="color:red;">注：这里使用的是递归查询</a></p>
</li>
<li><p>根域名服务器接收 DNS 请求，返回给本地域名服务器==对应的顶级域名服务器的 IP 地址==（DNS 响应）</p>
</li>
<li><p>本地域名服务器再次向顶级域名服务器发送 DNS 请求</p>
</li>
<li><p>顶级域名服务器接收 DNS 请求，返回给本地域名服务器==对应的权威域名服务器的 IP 地址==</p>
</li>
<li><p>本地域名服务器再次向权威域名服务器发送 DNS 请求</p>
</li>
<li><p>权威域名服务器返回查询的域名对应的 IP 地址</p>
</li>
</ol>
<p>  <a style="color:red;">注：整个过程采用的迭代查询；DNS 查询过程是迭代和递归混合使用的</a></p>
</li>
</ul>
</li>
</ul>

        <h3 id="FTP-协议"   >
          <a href="#FTP-协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#FTP-协议" class="headerlink" title="FTP 协议"></a>FTP 协议</h3>
      <ul>
<li><p>概念：提供不同种类主机系统之间==传输文件==的能力</p>
</li>
<li><p>分类：</p>
<ul>
<li>文件传送协议 FTP</li>
<li>简单文件传送协议 TFTP</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>基于客户端/服务器（==C/S==）的传送方式</li>
<li>基于 TCP 协议实现文件传输</li>
</ul>
</li>
<li><p>传输过程</p>
<ul>
<li><p>连接建立</p>
<ol>
<li>登陆 FTP 服务器<ul>
<li>用户名 + 密码登陆</li>
<li>匿名登录：部分公共 FTP 服务器访问的人数过大，不需要经过注册取得 FTP 服务器授权就可以直接进入 FTP 服务器下载文件</li>
</ul>
</li>
<li>FTP 服务器 ==主进程== 打开熟知端口 21，建立 TCP ==控制连接==</li>
</ol>
<p>  <a style="color:red;">注：主进程只有一个</a></p>
</li>
<li><p>文件传输</p>
<ol>
<li>控制连接建立后接收到 FTP 客户端下载文件的请求，打开==端口号==，建立 TCP ==数据连接==</li>
<li>数据连接建立后，FTP 服务器开始向 FTP 客户端传送文件</li>
<li>文件传送完毕后，==数据连接关闭==，==控制连接暂时不关闭==</li>
<li>FTP 客户端如果需要继续下载文件，那么再次打开端口号，建立 TCP 数据连接进行传送</li>
<li>FTP 客户端如果不需要再下载文件，那么关闭控制连接，即连接释放</li>
</ol>
</li>
<li><p>连接释放</p>
</li>
<li><p>数据连接端口号：根据传输模式而定，主动方式采用端口号 20；被动方式端口号 &gt; 1024，客户端和服务器协商决定</p>
</li>
</ul>
</li>
</ul>

        <h3 id="SMTP-协议"   >
          <a href="#SMTP-协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#SMTP-协议" class="headerlink" title="SMTP 协议"></a>SMTP 协议</h3>
      <ul>
<li><p>概念：为==电子邮件系统==提供服务</p>
</li>
<li><p>电子邮件系统</p>
<ul>
<li>组成：<ul>
<li>用户代理<ol>
<li>提供用户阅读，回复，编写，保存邮件的功能</li>
<li>发送方和接收方都具有用户代理</li>
</ol>
</li>
<li>邮件服务器<ol>
<li>提供==接收和发送邮件==的功能</li>
<li>发送方和接收方都具有邮件服务器</li>
<li>发送方的用户代理将邮件发送给发送方的邮件服务器</li>
<li>邮件服务器发送邮件==不成功==，向发送方用户代理==报告发送失败==</li>
<li>邮件服务器不是专属的，是多个用户==共享==的</li>
</ol>
</li>
<li>简单邮件传输协议（SMTP）<ol>
<li>SMTP 建立在 TCP 协议之上 -&gt; ==端口号 25==</li>
<li>SMTP 规定两个电子邮件系统之间如何交换信息</li>
<li>SMTP 不会借助中间邮件服务器传递邮件 -&gt; 两台邮件服务器是==直接连接==</li>
<li>SMTP 采用  ASCII 7位比特编码 -&gt; 不能够传送二进制数据文件或者音视频文件 -&gt; 需要转码才能够进行发送</li>
<li>SMTP 采用持续连接 -&gt; 同一个 TCP 连接中可以传递多份邮件</li>
<li>SMTP 细节<ul>
<li>连接建立：SMTP 客户端发送 HELLO 命令 -&gt; SMTP 服务器返回 220 准备建立连接</li>
<li>邮件传输：<ul>
<li>SMTP 客户端发送 MAIL FROM + 发送方地址 -&gt; SMTP 服务器返回 250 -&gt; 能够接收邮件；不能够接收返回 421</li>
<li>SMTP 客户端发送 RCPT TO + 接收方地址 -&gt; SMTP 服务器返回 250</li>
<li>SMTP 客户端发送 DATA （客户端准备发送数据）-&gt; SMTP 返回 354 同意发送；让客户端发送 <code>.</code> 表示数据发送完成</li>
<li>SMTP 客户端发送 Date -&gt; SMTP 服务器返回 250 接收完成  </li>
</ul>
</li>
<li>连接释放：邮件发送完成 -&gt; SMTP 客户端发送 QUIT 命令 -&gt; SMTP 服务器返回 221 -&gt; 断开连接</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>发送过程：<ol>
<li>发送方==用户代理==和发送方==邮件服务器==之间建立 TCP 连接</li>
<li>发送方采用 ==SMTP 协议==将邮件发送到发送方的邮件服务器</li>
<li>邮件到达邮件服务器后==在队列中等待==服务器发送</li>
<li>发送方邮件服务器和接收方邮件服务器之间==建立 TCP 连接==</li>
<li>发送方邮件服务器采用 ==SMTP 协议==发送邮件到接收方的邮件服务器<ul>
<li>如果发送成功，那么邮件保存在接收方的邮件服务器中，等待接收方用户代理采取 ==POP3 协议==读取邮件</li>
<li>如果发送失败，那么发送方邮件服务器会再次尝试发送，如果多次尝试后仍然发送失败，那么会报告发送方用户代理</li>
</ul>
</li>
</ol>
</li>
<li>图示：</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210413173141269.png" alt="image-20210413173141269"></p>
</li>
</ul>

        <h3 id="POP3-协议"   >
          <a href="#POP3-协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#POP3-协议" class="headerlink" title="POP3 协议"></a>POP3 协议</h3>
      <ul>
<li>概念：为用户代理获取邮件服务器中的邮件提供服务</li>
<li>内容<ul>
<li>POP3 建立在 TCP 协议之上 -&gt; ==端口号 110==</li>
<li>POP3 细节<ol>
<li>特许：用户代理登陆邮件服务器 -&gt; 邮件服务器允许其获取邮件</li>
<li>事务处理：用户代理对邮件服务器中的邮件进行处理 <ul>
<li>获取邮件后是否在邮件服务器中删除该邮件</li>
</ul>
</li>
<li>更新：用户代理结束会话后执行删除操作</li>
</ol>
</li>
</ul>
</li>
</ul>

        <h3 id="IMAP-协议"   >
          <a href="#IMAP-协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#IMAP-协议" class="headerlink" title="IMAP 协议"></a>IMAP 协议</h3>
      
        <h3 id="HTTP-协议"   >
          <a href="#HTTP-协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3>
      <p><em>详情见 JavaWeb 笔记</em></p>

        <h2 id="网络应用模型"   >
          <a href="#网络应用模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h2>
      <ul>
<li>客户端-服务器模型<ul>
<li>概念：<ul>
<li>客户端</li>
<li>服务器</li>
</ul>
</li>
<li>优点</li>
<li>缺点</li>
</ul>
</li>
<li>P2P 模型<ul>
<li>概念：</li>
<li>执行过程：</li>
<li>优点</li>
<li>缺点</li>
<li>应用：BitTorrent</li>
</ul>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/09/network/%E7%89%A9%E7%90%86%E5%B1%82/">物理层</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-11</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="物理层"   >
          <a href="#物理层" class="heading-link"><i class="fas fa-link"></i></a><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1>
      
        <h2 id="物理层基本概念"   >
          <a href="#物理层基本概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#物理层基本概念" class="headerlink" title="物理层基本概念"></a>物理层基本概念</h2>
      
        <h3 id="物理层功能"   >
          <a href="#物理层功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#物理层功能" class="headerlink" title="物理层功能"></a>物理层功能</h3>
      <ul>
<li>机械特性：<strong>规定</strong>实现物理连接的各种设备的<strong>参数大小</strong></li>
<li>电器特性：<strong>规定</strong>传输二进制比特时的<strong>电压范围</strong>等参数</li>
<li>功能特性：<strong>规定</strong>线路上不同电压的<strong>含义</strong></li>
<li>规程特性：<strong>规定</strong>各条线路<strong>工作规程和时序关系</strong></li>
</ul>

        <h3 id="物理媒体"   >
          <a href="#物理媒体" class="heading-link"><i class="fas fa-link"></i></a><a href="#物理媒体" class="headerlink" title="物理媒体"></a>物理媒体</h3>
      <p>两者的区别：</p>
<p>物理层是规定实现数据传输的线路的参数，并不涉及实际的传输过程</p>
<p>物理媒体则是真正实现了数据的传输，一般将物理媒体视为第 0 层</p>

        <h2 id="数据通信基本知识"   >
          <a href="#数据通信基本知识" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据通信基本知识" class="headerlink" title="数据通信基本知识"></a>数据通信基本知识</h2>
      
        <h3 id="基本知识"   >
          <a href="#基本知识" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3>
      <p><img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303164612112.png" alt="image-20210303164612112"></p>
<ul>
<li><p>信号</p>
<ul>
<li>数字信号：传输的是<strong>离散</strong>的参数</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303165144337.png" alt="image-20210303165144337"></p>
<ul>
<li>模拟信号：传输的是<strong>连续</strong>的参数</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303165314973.png" alt="image-20210303165314973"></p>
</li>
<li><p>信道</p>
<ul>
<li><p>概念：信号的传输媒介；一条通信路通畅包含一条<strong>发送信道</strong>和一条<strong>接收信道</strong></p>
</li>
<li><p>分类</p>
<ul>
<li>传输信号分类：数字信道；模拟信道</li>
<li>传输介质分类：无线信道；有线信道</li>
</ul>
</li>
<li><p>通信方式</p>
<ul>
<li><p>单工通信：只有一个方向的通信没有反方向的交互</p>
<p>  计算机 A 只能作为发送方；计算机 B 只能作为接收方；只需要使用<strong>一条发送信道</strong></p>
</li>
<li><p>半双工通信：通信的双方都可以作为接收或者发送方，但是不能够同时既作为接收方又作为发送方</p>
<p>  计算机 A 作为发送方，计算机 B 就只能作为接收方；两者可以对调；需要使用<strong>两条信道</strong> </p>
</li>
<li><p>双工通信：通信的双方可以同时作为接收方和发送方</p>
<p>  计算机 A 在作为发送方的同时可以接收来自计算机 B 发送的内容；需要使用<strong>两条信道</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>传输方式</p>
<ul>
<li>串行<ul>
<li>适用情况：速度慢，适合远距离传递，费用低</li>
</ul>
</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303170350034.png" alt="image-20210303170350034"></p>
<ul>
<li><p>并行</p>
<ul>
<li><p>适用情况：速度快，适合近距离传递，费用高</p>
<p>  打印机和传真机会使用这种方式传输</p>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303170516864.png" alt="image-20210303170516864"></p>
</li>
</ul>
</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303170358246.png" alt="image-20210303170358246"></p>
</li>
</ul>

        <h3 id="性能指标"   >
          <a href="#性能指标" class="heading-link"><i class="fas fa-link"></i></a><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3>
      
        <h4 id="码元"   >
          <a href="#码元" class="heading-link"><i class="fas fa-link"></i></a><a href="#码元" class="headerlink" title="码元"></a>码元</h4>
      <p><img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303171608082.png" alt="image-20210303171608082"></p>
<ul>
<li><p>概念：一个<strong>固定时长</strong>的<strong>信号</strong>波形（数字脉冲）</p>
</li>
<li><p><strong>一个码元可以携带多个比特</strong></p>
</li>
<li><p>码元的离散状态有 M 种时：每个码元携带的比特数量 = log<del>2</del> M </p>
<p>  16 进制码元：0000 表示一种码元，0001 表示另外一种码元…所以每个码元是四个比特</p>
</li>
</ul>

        <h4 id="速率"   >
          <a href="#速率" class="heading-link"><i class="fas fa-link"></i></a><a href="#速率" class="headerlink" title="速率"></a>速率</h4>
      <ul>
<li>码元传输速率<ul>
<li>单位：波特（Baud）</li>
<li>概念：单位时间内传输的码元的个数（<strong>脉冲个数或者信号变化的次数</strong>）</li>
<li>码元传输速率和进制无关</li>
</ul>
</li>
<li>信息传输速率<ul>
<li>单位：bite（bit）</li>
<li>和码元传输速率的关系：<strong>每个码元携带的比特数 * 码元的个数</strong> = 信息传输速率</li>
</ul>
</li>
</ul>

        <h2 id="编码和调制"   >
          <a href="#编码和调制" class="heading-link"><i class="fas fa-link"></i></a><a href="#编码和调制" class="headerlink" title="编码和调制"></a>编码和调制</h2>
      
        <h3 id="信道上传输的信号"   >
          <a href="#信道上传输的信号" class="heading-link"><i class="fas fa-link"></i></a><a href="#信道上传输的信号" class="headerlink" title="信道上传输的信号"></a>信道上传输的信号</h3>
      <ul>
<li>基带信号<ul>
<li>概念：信源发出的<strong>没有</strong>经过<strong>调制</strong>的信号（模拟或者数字信号）</li>
<li>传输距离较近时，计算机网络都采用基带传输方式</li>
</ul>
</li>
<li>宽带信号<ul>
<li>概念：是将<strong>基带信号</strong>进行<strong>调制</strong>后形成的<strong>频分复用模拟信号</strong></li>
<li>主要用于网络电视和有线电视的视频广播</li>
</ul>
</li>
</ul>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/zzsfqiuyigui/article/details/8986805" >基带信号和宽带信号</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h3 id="编码"   >
          <a href="#编码" class="heading-link"><i class="fas fa-link"></i></a><a href="#编码" class="headerlink" title="编码"></a>编码</h3>
      <ul>
<li><p>概念：<strong>数字数据</strong>和<strong>模拟数据</strong>转换为<strong>数字信号</strong>的过程称为编码</p>
</li>
<li><p>数字数据编码为数字信号</p>
<ul>
<li><p>非归零编码</p>
<ul>
<li><p>概念：最简单的一种编码形式；使用高电压代表 1；低电压代表 0</p>
</li>
<li><p>缺陷：收发双方难以保持同步</p>
<p>  如果二进制数据都是 1 或者 0，那么数字信号就是一条直线，接收方无法解析数字信号；需要借助辅助的信道知道每个码元的长度，用总长度除以每个码元的长度进行分段</p>
</li>
</ul>
</li>
<li><p>归零编码</p>
<ul>
<li>概念：在一个码元内电压无论是否变化，最终都要变为低电压</li>
<li>缺陷：信道中的电压长时间都处于低电压状态，利用率偏低</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303210939257.png" alt="image-20210303210939257"></p>
</li>
<li><p>反向不归零编码</p>
<ul>
<li><p>概念：二进制数据 0 代表电压翻转（翻转是指和之前的前一个电压相反），二进制数据 1 代表不翻转</p>
<p>  区别于前两种高电压不代表 1，低电压不代表 0</p>
</li>
<li><p>缺陷：二进制数据全为 1 时数字信号为一条直线</p>
</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303211420795.png" alt="image-20210303211420795"></p>
</li>
<li><p>曼切斯特编码</p>
<ul>
<li><p>概念：一个码元划分成两个相等的间隔；前半为高电压，后半为低电压，表示二进制数据 1；前半为低电压，后半为高电压，表示二进制数据 0 </p>
</li>
<li><p>特点：数据传输速率（比特传输的速率）是调制速率（码元传输速率）的 1/2</p>
<p>  码元传输速率可以按照单位时间脉冲信号的个数进行计算；曼切斯特编码中一个码元有两次脉冲信号，所以这里的码元传输速率是 2Baud，但是实际的比特只传输了 1bit</p>
</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303211613404.png" alt="image-20210303211613404"></p>
</li>
<li><p>差分曼切斯特编码</p>
<ul>
<li>概念：根据两个码元判断；前一个码元的后半部分和当前码元的前半部分相同，表示二进制数据 1；相反则表示0</li>
<li>特点：抗干扰性强于曼切斯特编码编码</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303212442509.png" alt="image-20210303212442509"></p>
</li>
</ul>
</li>
<li><p>数字数据编码为模拟信号</p>
<ul>
<li><p>调幅（2ASK）</p>
<ul>
<li>概念：对于二进制数据 0 和 1 设计不同的振幅大小；频率和相位不发生改变</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303212818673.png" alt="image-20210303212818673"></p>
</li>
<li><p>调频（2FSK）</p>
<ul>
<li>概念：对于二进制数据 0 和 1设计不同的振动频率；振幅和相位不发生变化</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303213144115.png" alt="image-20210303213144115"></p>
</li>
<li><p>调相（2PSK）</p>
<ul>
<li>概念：对于二进制数据 0 和 1 设计不同的相位；振幅和频率不发生变化</li>
</ul>
<p>  <img src="D:\Typora\Typora\文件\计算机网络.assets\image-20210303213153308.png" alt="image-20210303213153308"></p>
</li>
<li><p>QAM(调相 + 调幅)</p>
<ul>
<li><p>例子：4 个相位，每个相位 4 个振幅</p>
<p>  每个相位 可以 匹配 4 种不同的振幅，那么就会出现 4 种不同的码元，所以最后是 16 种码元</p>
</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li><p>这里只涉及到每个码元携带一个比特的情况，所以是2XSK；如果携带的比特数更多，那么设计的不同振幅，不同频率，不同相位也会更多</p>
</li>
<li><p>相位：对于二进制而言，0对应的是余弦波，1对应的是正弦波，所以每个波的起始点的斜率是相反的</p>
<p>  如果是携带的比特数越多，那么相位越多，超出 3 个相位基本是不可能在图上画出来的</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>模拟数据编码为数字信号</p>
<ul>
<li><p>抽样：将连续的模拟信号转为离散的信号；遵循的采样规则：f<del>采样频率</del> ≥ 2f<del>信号最高频率</del></p>
<p>  确定一个信号波，至少进行<strong>两次采样</strong>就可以得到信号波形状，如果对信号频率比较小的波进行两次采样，很有可能导致<strong>信号频率高的信号波无法被识</strong>别出来</p>
</li>
<li><p>量化：将每个离散的信号按照分级标度转化的<strong>整数数字</strong></p>
</li>
<li><p>编码：将整数数字进行<strong>二进制编码</strong></p>
</li>
</ul>
</li>
<li><p>模拟数据编码为模拟信号</p>
<ul>
<li>目的：防止模拟信号因为衰减过多导致最后无法识别，所以通过放大增强模拟信号</li>
</ul>
</li>
</ul>

        <h3 id="调制"   >
          <a href="#调制" class="heading-link"><i class="fas fa-link"></i></a><a href="#调制" class="headerlink" title="调制"></a>调制</h3>
      
        <h2 id="奈氏准则和香农定理"   >
          <a href="#奈氏准则和香农定理" class="heading-link"><i class="fas fa-link"></i></a><a href="#奈氏准则和香农定理" class="headerlink" title="奈氏准则和香农定理"></a>奈氏准则和香农定理</h2>
      
        <h3 id="码间串扰"   >
          <a href="#码间串扰" class="heading-link"><i class="fas fa-link"></i></a><a href="#码间串扰" class="headerlink" title="码间串扰"></a>码间串扰</h3>
      <ul>
<li>失真：发送的信号在信道中的传播受到噪声的干扰，导致最后无法被解析的现象<ul>
<li>影响因素：码元传输速率；信号传输的距离；噪声干扰；传输媒体的质量</li>
</ul>
</li>
<li>码间串扰：（失真的一种现象）接收端收到的信号波形<strong>每个码元之间没有清晰的界限</strong></li>
<li>信道带宽：信道能够通过的信号的最高频率与信号的最低频率之差</li>
</ul>

        <h3 id="奈氏准则"   >
          <a href="#奈氏准则" class="heading-link"><i class="fas fa-link"></i></a><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h3>
      <ul>
<li>适用情况：宽带受限，不受噪声影响的情况</li>
<li>公式：2Wlog<del>2</del>V<ul>
<li>W 指的是宽带的 Hz 大小</li>
<li>V 指的是码元的种数</li>
</ul>
</li>
<li>特点<ul>
<li>奈氏准则给出了<strong>码元传输速率</strong>的极限，没有给出信息传输速率的极限</li>
<li>码元的传输速率是有极限的，所以提高的信息传输速率的方式就是让每个码元携带更多的比特</li>
</ul>
</li>
</ul>

        <h3 id="香农定理"   >
          <a href="#香农定理" class="heading-link"><i class="fas fa-link"></i></a><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h3>
      <ul>
<li>适用情况：宽带受限，受到噪声影响的情况</li>
<li>公式：Wlog<del>2</del>（1 + S/N）<ul>
<li>W 指的是宽带的 Hz 大小</li>
<li>S/N 是信噪比<ul>
<li>10*log<del>10</del>S/N = dB </li>
</ul>
</li>
</ul>
</li>
<li>特点<ul>
<li>只要信息的传输速率小于极限的信息传输速率，那么一定能够找到一种<strong>无差错的传输</strong></li>
</ul>
</li>
</ul>

        <h3 id="对比"   >
          <a href="#对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#对比" class="headerlink" title="对比"></a>对比</h3>
      <p>如果在非理想低通的情况下，两个公式都可以采用，选择两者中极限信息传输速率较小的那个</p>

        <h2 id="设备"   >
          <a href="#设备" class="heading-link"><i class="fas fa-link"></i></a><a href="#设备" class="headerlink" title="设备"></a>设备</h2>
      
        <h3 id="中继器"   >
          <a href="#中继器" class="heading-link"><i class="fas fa-link"></i></a><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h3>
      
        <h3 id="集线器"   >
          <a href="#集线器" class="heading-link"><i class="fas fa-link"></i></a><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/09/network/%E6%A6%82%E8%BF%B0/">概述</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-09</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h1>
      
        <h2 id="概念"   >
          <a href="#概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#概念" class="headerlink" title="概念"></a>概念</h2>
      
        <h3 id="定义"   >
          <a href="#定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#定义" class="headerlink" title="定义"></a>定义</h3>
      <ul>
<li><p>定义：计算机网络是将多个 [分散独立]{.red} 的计算机系统，通过 [通信设备]{.red} 和 [通信链路]{.red} 连接起来，并且利用软件实现 [资源共享]{.red} 和 [数据传递]{.red} 的系统</p>
<p>  [互联网是 <strong>互联自治</strong> 的计算机集合]{.red}</p>
</li>
<li><p>通信设备</p>
<ul>
<li><p><a href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA">链路层交换机</a> (Link-Layer Switch)  链路层交换机通常称为交换机</p>
</li>
<li><p><a href="#%E8%B7%AF%E7%94%B1%E5%99%A8">路由器</a> (Router)</p>
<p>  注：(1) 链路层交换机和路由器被统称为交换机 (2) 链路层交换机位于 <a href="#%E6%8E%A5%E5%85%A5%E7%BD%91">接入网</a> 而路由器位于 <a href="#%E7%BD%91%E7%BB%9C%E6%A0%B8%E5%BF%83">网络核心</a></p>
</li>
</ul>
</li>
<li><p>通信链路：又称为 <a href="#%E6%8E%A5%E5%85%A5%E7%BD%91">物理媒介</a> 或者 <a href="#%E6%8E%A5%E5%85%A5%E7%BD%91">接入网</a></p>
<ul>
<li>双绞线：(1) 屏蔽双绞线 (2) 非屏蔽双绞线</li>
<li>同轴电缆</li>
<li>光纤</li>
</ul>
</li>
<li><p>数据传递：互联网中的所有数据都可以称为 [分组]{.red} ；每层也有自己具体的数据单位</p>
<ul>
<li><a href="#%E7%AC%AC%E5%85%AD%E7%AB%A0">应用层</a>：报文</li>
<li><a href="#%E7%AC%AC%E4%BA%94%E7%AB%A0">传输层</a>：报文段</li>
<li><a href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0">网络层</a>：数据报</li>
<li><a href="#%E7%AC%AC%E4%B8%89%E7%AB%A0">数据链路层</a>：帧</li>
<li>物理层：比特</li>
</ul>
</li>
</ul>

        <h3 id="功能"   >
          <a href="#功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#功能" class="headerlink" title="功能"></a>功能</h3>
      <ul>
<li><p>[数据通信]{.red}：借助计算机网络的 [连通性]{.red}，将数据从当前计算机系统 [传递]{.red} 到其他的计算机系统</p>
</li>
<li><p>[资源共享]{.red}：硬件 + 软件 + 数据</p>
<p>  注：资源共享并不只是共享数据；借助计算机网络硬件和软件同样可以共享</p>
</li>
<li><p>分布式处理：各台计算机承担同一工作的不同部分</p>
</li>
<li><p>提高可靠性：当前计算机系统宕机后，使用代替机继续完成当前工作</p>
</li>
<li><p>负载均衡：调整不同计算机系统之间的工作</p>
</li>
</ul>

        <h3 id="组成"   >
          <a href="#组成" class="heading-link"><i class="fas fa-link"></i></a><a href="#组成" class="headerlink" title="组成"></a>组成</h3>
      <ul>
<li><p>前提：计算机网络的组成可以按照三种方式看：(1) 从实际的内容看(组成部分) (2) <a href="#%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F">从实际运行方式来看</a> (3) 从实际的功能来看(功能组成)</p>
</li>
<li><p>组成部分：</p>
<ul>
<li><p>软件：运行在端系统上的各种软件</p>
</li>
<li><p>硬件：端系统 + 适配器 + 通信链路 + 通信设备</p>
<p>  注：端系统又称为主机；端系统可以分为两类：(1) 客户端(个人电脑) (2) 服务器(大型机)</p>
</li>
<li><p>协议：[规定了两个或者多个通信实体之间交换报文的格式和顺序，以及发送报文和接收报文等其他事件需要采取的动作]{.red}</p>
<p>  注：协议是计算机网络的核心；协议仅仅只是规定，真正的实现是由各种各样的硬件实现的，这些硬件需要遵循协议规定的内容</p>
</li>
</ul>
</li>
<li><p>功能组成：<a href="#%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84">分层结构</a></p>
</li>
</ul>

        <h4 id="工作方式"   >
          <a href="#工作方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4>
      <img src="https://i1.xpic.jp/file/xpicjp/2021/06/09/17a785f65128b91281140180321346ed.png" alt="17a785f65128b91281140180321346ed.png" style="zoom:80%;" />


        <h5 id="网络边缘"   >
          <a href="#网络边缘" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h5>
      <ul>
<li>定义：位于网络边缘的通常都是端系统：各式各样的个人电脑，移动端设备，以及大型数据中心</li>
<li>通信方式：P2P C/S</li>
<li>细节：网络边缘的设备从网络核心中获取相应的的网络服务</li>
</ul>

        <h5 id="接入网"   >
          <a href="#接入网" class="heading-link"><i class="fas fa-link"></i></a><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h5>
      <ul>
<li><p>定义：将端系统 [物理连接]{.red} 到网络核心中的边缘路由器的网络</p>
<ul>
<li>物理连接：说白了就是装网线的</li>
<li><a href="%E7%AC%AC%E5%9B%9B%E7%AB%A0">边缘路由器</a></li>
</ul>
</li>
<li><p>接入方式</p>
<ul>
<li><p>家庭接入：</p>
<ul>
<li><p>DSL (全称：Digital Subscribe Line 俗称：宽带)：</p>
<ul>
<li>接入：每个用户将自己的 [DSL 调制解调器]{.red} 使用 [双绞线]{.red} 连接到本地电话公司的 [复用器]{.red} (DSLAM) 中</li>
<li>调制解调器（俗称：猫(Modem)）：[用于数字信号和模拟信号的相互转换]{.red}</li>
<li>双绞线：传统的电话线，[只能够传输模拟信号]{.red}</li>
<li>复用器：就是可以接入多个用户的调制解调器</li>
<li>[DSL 接入的上行速率和下行速率不相等，这种接入被称为不对称的接入（ADSL 接入）]{.red}</li>
<li>DSL 使用 <a href="#%E9%93%BE%E8%B7%AF%E7%AE%A1%E7%90%86">FDM</a>(频分复用技术)：用户的多个设备可以共享同一通信链路</li>
</ul>
</li>
<li><p>拨号上网：(1) 可以看做没有使用频分复用技术的 DSL 接入 (2) 速率非常慢</p>
</li>
<li><p>电缆接入：</p>
<ul>
<li>接入：每个用户将自己的 [电缆调制解调器]{.red} 使用 [同轴电缆]{.red} 连接到本地有线电视公司的 [电缆调制解调器]{.red} (CMTS)  中</li>
<li>[电缆接入通常采用的也是不对称的接入]{.red}</li>
<li>电缆接入最重要的特征：[共享广播媒体]{.red}（需要使用 <a href="#%E9%93%BE%E8%B7%AF%E7%AE%A1%E7%90%86">信道访问控制</a> 来解决，否则实际下行速率会远低于理想的下行速率）</li>
</ul>
</li>
<li><p>光纤接入(FTTH)：</p>
<p>  (1) ISP 直接将光纤接入到每个用户的位置（每个用户独占一根光纤） (2) ISP 直到接近每个用户时才将光纤分开接入到每个用户 (多个用户共享一个光纤)</p>
</li>
</ul>
</li>
<li><p>企业接入</p>
<ul>
<li><a href="#%E4%BB%A5%E5%A4%AA%E7%BD%91">以太网接入</a></li>
<li>WiFi 接入：使用非导向性质的媒介：无线电波接入</li>
</ul>
</li>
<li><p>广域无线接入：4G 5G 都属于广域无线接入</p>
</li>
</ul>
</li>
<li><p>物理媒介</p>
<ul>
<li><p>导向性质媒介</p>
<ul>
<li><p>双绞线(Twisted Pair)：(1) 非屏蔽双绞线(UTP) (2) 屏蔽双绞线(STP)</p>
<p>  注：10Mbps 传统电话线([3类双绞线]{.blue}) ； 100Mbps 以太网 ([5类双绞线]{.blue}) ；1Gbps 吉比特以太网（[6类双绞线]{.blue}）</p>
</li>
<li><p>同轴电缆(Coaxial cable)：(1) 2类同轴电缆(10BASE-2) (2) 5类同轴电缆(10BASE-5)</p>
</li>
<li><p>光纤：(1) 单模光纤 (2) 多模光纤</p>
</li>
</ul>
</li>
<li><p>非导向性质媒介：无线电波，微波，红外线</p>
</li>
</ul>
</li>
</ul>

        <h5 id="网络核心"   >
          <a href="#网络核心" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h5>
      <ul>
<li><p>定义：网络边缘的端系统发送分组到网络核心的交换设备中，经过多个交换设备 [交换]{.red} 送到目的端系统上</p>
</li>
<li><p>交换设备：(1) 链路层交换机 (2) 路由器</p>
</li>
<li><p>交换方式</p>
<ul>
<li><p>电路交换（Circuit Switching）：两个主机之间建立一条由多个交换设备和多条通信链路组成的 [专用线路]{.red}，报文通过专用线路传输到另一个主机上</p>
<ul>
<li><p><a href="#%E9%93%BE%E8%B7%AF%E7%AE%A1%E7%90%86">复用</a>：(1) 频分复用(FDM) (2) 时分复用(TDM) (3) 码分多址复用(CDM)</p>
<p>  注：每个频带或者每个时隙都相当于一条线路，相当于将一条完整的线路在逻辑划分成多条，可以供多个用户使用</p>
</li>
<li><p>优点：(1) 报文传输 [延时小实时性强]{.red} (2) [可靠性高]{.red} (3) [没有冲突]{.red} 产生 (4) 适用范围广</p>
</li>
<li><p>缺点：(1) 线路独占导致资源利用率低（存在静默期(Silent Period)） (2) 连接建立时间长 (3) 每个用户获得的带宽仅为总带宽的 $\frac{1}{N}$</p>
</li>
<li><p>[电路交换时 <strong>面向连接服务</strong> 的：保证了可靠传输]{.red}</p>
</li>
<li><p>电路交换发送报文采取的是直通方式不是存储转发的方式</p>
</li>
</ul>
</li>
<li><p><a href="#%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2">分组交换</a></p>
</li>
</ul>
</li>
</ul>

        <h3 id="分类"   >
          <a href="#分类" class="heading-link"><i class="fas fa-link"></i></a><a href="#分类" class="headerlink" title="分类"></a>分类</h3>
      <ul>
<li><p>按分布范围分类</p>
<ul>
<li>[广域网（WAN）]{.red}：使用 [交换技术]{.red}；连接各结点交换机的链路一般是高速电路，具有较大的通信容量；互联网是广域网的一种</li>
<li>城域网（MAN）</li>
<li>[局域网（LAN）]{.red}：使用 [广播技术]{.red}；配置的主机数量没有限制（可以达到上百台）；[工作到数据链路层，不涉及网络层]{.red}</li>
<li>个人网（PAN）：个人范围内（通常范围只有数米）的计算机设备组成的网络</li>
</ul>
</li>
<li><p>按使用者分类</p>
<ul>
<li>公网（Extranet）：中国电信 中国移动 中国联通；大众都可以付费使用的网络</li>
<li>专网（Intranet）：政府 银行 军队；只有特定的人员才能够使用的网络</li>
</ul>
</li>
<li><p>按交换技术分类</p>
<ul>
<li>电路交换</li>
<li>报文交换</li>
<li><a href="#%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2">分组交换</a></li>
</ul>
</li>
<li><p>按拓扑结构分类(逻辑拓扑 + 物理拓扑)：</p>
<ul>
<li><p>定义：描述各个端系统和通信链路的连接方式和布局，以及数据传输的路径</p>
</li>
<li><p>总线型网络：</p>
<ul>
<li>优点：(1) 建立网络容易 (2) 增删结点方便 (3) 减少成本</li>
<li>缺点：(1) 重负载时通信效率不高 (2) 总线对故障敏感</li>
</ul>
</li>
<li><p>星型网络</p>
<ul>
<li>优点：(1) 便于集中控制管理 (2) 提高流量的利用率</li>
<li>缺点：(1) 成本高 (2)单点故障</li>
</ul>
</li>
<li><p>环状型网络：(1) 单向环型：环中信号单向传输 (2) 双向环型：允许环中信号双向传输</p>
</li>
</ul>
</li>
</ul>
<pre><code>* 网状型（常用于广域网）

    * 优点：可靠性高
    * 缺点：(1) 控制复杂 (2) 线路成本高
</code></pre>
<ul>
<li><p>按传输技术分类</p>
<ul>
<li><p>广播式网络</p>
<ul>
<li>共享的公共通信信道</li>
<li>广域网中的 [卫星通信网络]{.blue} 和 [无线通信网络]{.blue} 也是采用的广播式网络</li>
</ul>
</li>
<li><p>点对点网络：</p>
<ul>
<li><p>每条物理线路都连接一对主机</p>
</li>
<li><p>使用 <a href="%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91">分组存储转发</a> 和 <a href="#%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE%E5%8F%8A%E7%AE%97%E6%B3%95">路由选择机制</a></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h2 id="互联网提供商"   >
          <a href="#互联网提供商" class="heading-link"><i class="fas fa-link"></i></a><a href="#互联网提供商" class="headerlink" title="互联网提供商"></a>互联网提供商</h2>
      
        <h2 id="性能指标"   >
          <a href="#性能指标" class="heading-link"><i class="fas fa-link"></i></a><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2>
      <ul>
<li><p>速率：单位时间内从一端传送到另一端的 [数据量]{.red}</p>
<ul>
<li>单位：bps Kbps Mbps Gbps &lt;-&gt; Bps KBps MBps GBps </li>
<li>换算：<ul>
<li>[上述单位都是以 <strong>比特</strong> 为单位的不是 <strong>字节</strong>]{.red}：需要将上述单位再除以 8 才是以字节为单位的</li>
<li>相邻两个单位之间的使用 [10^3^]{.red} 换算（也有可能是 1024）</li>
</ul>
</li>
</ul>
</li>
<li><p>带宽：</p>
<ul>
<li>定义 1：指信道具有的频度宽度：就是最高频率和最低频率之差，单位赫兹</li>
<li>定义 2：单位时间从一端传输到另一端的 [最大数据量]{.red} ([通常都是理想速率，难以达到]{.blue})</li>
</ul>
</li>
<li><p>吞吐量：单位时间内 [成功传输的数据量]{.red}（传输过程中会出现丢包等现象，实际接收的数据量可能并不是发送的数据量）</p>
<ul>
<li>[每段链路的吞吐量可能不一致]{.red}：吞吐量 = $min(R_0,R_1,R_2···R_n)$ 取最小的那个吞吐量</li>
<li>[多个用户共享信道]{.red}：每个用户的吞吐量是信道总的吞吐量的 $\frac{1}{N}$</li>
<li>[吞吐量受制于接入网或者用户的数量]{.red}</li>
</ul>
</li>
<li><p>时延：</p>
<ul>
<li><p>传输时延(propagation delay)：[分组大小 ÷ 带宽]{.red}</p>
<ul>
<li>前提：仅考虑传输时延的情况下<ul>
<li>一个分组经过 $N$ 个路由器转发到达目的地所花的时间 $d = N*\frac{L}{R}$</li>
<li>$P$ 个分组经过 $N$ 个路由器转发到达目的地所花的时间 $d= (N + P - 1)*\frac{L}{R}$ (无论 $N$ 和 $P$ 的关系如何这个公式都是成立的)</li>
</ul>
</li>
</ul>
</li>
<li><p>传播时延(transmission delay)：[信道长度 ÷ 介质传输速率]{.red}</p>
</li>
<li><p>排队时延(queuing delay)：分组在路由器队列中等待处理的时间</p>
</li>
<li><p>处理时延(processing delay)：路由器查询路由表转发的消耗时间</p>
<p>  注：通常只考虑传输时延</p>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/image-20210301143343776.4gg7k2y80ui0.png" alt="image-20210301143343776" style="zoom:80%;" />



<ul>
<li><p>时延带宽积()</p>
<ul>
<li>定义：[当前的数字信道中所存在的比特数量]{.red}；即某链路现在又多少比特</li>
<li>公式：[带宽 x 时延 = 时延带宽积]{.red}</li>
</ul>
</li>
<li><p>流量强度：</p>
<ul>
<li>定义：$\frac{L\alpha}{R}$ （$L$ 是每个分组的比特数 $\alpha$ 是到达路由的分组数量 $R$ 是带宽或者传输速率）</li>
<li>[流量强度增加会导致平均时延增加]{.red}</li>
</ul>
</li>
<li><p>往返时延概念：</p>
<ul>
<li>定义：从 [发送方发送数据开始]{.red} 到 [发送方收到接收方的确认]{.red} 为止</li>
<li>公式：[传播时延 * 2]{.red} + 末端处理时间</li>
<li>特点：往返时延越大，发送方能够传输的数据就越多，等待越久</li>
</ul>
</li>
<li><p>利用率</p>
<ul>
<li><p>信道利用率：[有数据通过的时间 ÷ 有 + 无数据通过的时间]{.red}</p>
</li>
<li><p>网络利用率：信道利用率的加权平均值</p>
</li>
</ul>
</li>
</ul>

        <h2 id="分层结构"   >
          <a href="#分层结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h2>
      
        <h3 id="概念-1"   >
          <a href="#概念-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3>
      <ul>
<li><p>目的：</p>
<ul>
<li>提高功能的独立性</li>
<li>促进标准化工作</li>
<li>灵活性高的同时降低了各层协议设计的复杂性</li>
</ul>
</li>
<li><p>实体：(1) 每层中的活动元素称为实体（数据）(2) 同一层中的实体称为 [对等实体]{.red}</p>
</li>
<li><p>协议：</p>
<ul>
<li>定义：规定两个通信实体之间交换报文的格式和顺序，以及接受报文和发送报文等其他事件需要执行的动作</li>
<li>组成：<ul>
<li>(1) [语法]{.red}(Syntax)：规定当前数据如何进行解析 </li>
<li>(2) [语义]{.red}(Semantic)：解析当前的数据所执行的功能 </li>
<li>(3) [同步]{.red}(Synchronization)：规定各个数据包解析的先后次序</li>
</ul>
</li>
</ul>
</li>
<li><p>数据单位：PCI + SDU = PDU</p>
<ul>
<li>协议控制信息(PCI)</li>
<li>服务数据单元(SDU)</li>
<li>协议数据单元(PDU)</li>
</ul>
</li>
<li><p>服务</p>
<ul>
<li>概念<ul>
<li>下层实体<strong>提供</strong>给上层实体的可以<strong>调用的功能</strong></li>
<li>上层实体可以调用<strong>所有下层</strong>实体提供的功能</li>
<li>下层实体提供的服务的实现细节对于上层是<strong>不可见的</strong></li>
<li>实现本层的协议需要下一层提供的服务</li>
</ul>
</li>
<li>服务原语<ul>
<li>请求；指示；响应；证实</li>
<li>有应答服务包含 4 中服务原语；无应答服务只包含 <strong>请求</strong> 和 <strong>指示</strong></li>
</ul>
</li>
<li>服务分类<ul>
<li>面向连接服务（TCP） 和 无连接服务（UDP / IP）</li>
<li>可靠服务（TCP） 和 不可靠服务（UDP）</li>
<li>有应答服务 和 无应答服务（HTTP）</li>
</ul>
</li>
</ul>
</li>
<li><p>接口：上层实体 <strong>调用</strong> 下层实体提供的 <strong>服务</strong> 的入口</p>
</li>
</ul>

        <h3 id="分层"   >
          <a href="#分层" class="heading-link"><i class="fas fa-link"></i></a><a href="#分层" class="headerlink" title="分层"></a>分层</h3>
      <ul>
<li>TCP/IP 协议栈：<a href="#%E7%AC%AC%E5%85%AD%E7%AB%A0">应用层</a> + <a href="#%E7%AC%AC%E4%BA%94%E7%AB%A0">传输层</a> + <a href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0">网络层</a> + <a href="#%E7%AC%AC%E4%B8%89%E7%AB%A0">数据链路层</a> + <a href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0">物理层</a></li>
<li>OSI 协议栈：应用层 + 表示层 + 会话层 + 传输层 + 网络层 + 数据链路层 + 物理层</li>
</ul>
<img src="https://i1.xpic.jp/file/xpicjp/2021/06/09/2e913893eec8bf48149e56305a5315e4.png" alt="2e913893eec8bf48149e56305a5315e4.png" style="zoom:80%;" /></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/09/java/io/AIO/">AIO</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-10</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="AIO"   >
          <a href="#AIO" class="heading-link"><i class="fas fa-link"></i></a><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h1>
      
        <h2 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h2>
      <blockquote>
<p><strong>什么是 AIO？</strong></p>
</blockquote>
<ul>
<li><p>历史：JDK 1.7 推出真正的 [异步非阻塞式的调用（AIO）]{.red}</p>
</li>
<li><p>名称：</p>
<ul>
<li><p>AIO 全称为 Asynchronous IO </p>
</li>
<li><p>AIO 实际上并不是官方定义的名称，而是根据新增加的核心类命名的，通常也可以称为 NIO2</p>
<blockquote>
<p>AIO 所有的核心类仍然是属于 java.nio 包下的，本质上是对 NIO 架构的完善</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>什么是异步非阻塞式调用？</strong></p>
</blockquote>
<p>:::info</p>
<p>此前的 IO 概述中已经提到过了，这里再简单的描述下</p>
<p>:::</p>
<ul>
<li><p>异步非阻塞式调用</p>
<ul>
<li><p>定义：</p>
<ul>
<li><p>进程向操作系统注册，[编写回调函数后将 IO 操作完全交付给操作系统实现]{.blue}，进程继续执行自己其他的任务</p>
<blockquote>
<p>回调函数：名字听起来很高端，实际就是进程告诉操作系统在 IO 事件发生后该如何处理，毕竟进程自己不再管了</p>
</blockquote>
</li>
<li><p>操作系统在 IO 事件发生后，选择 [线程池中的某个线程执行进程提供的回调函数]{.blue} 处理发生的 IO 事件</p>
</li>
<li><p>回调函数处理 IO 事件完成后，向进程发出信号通知 IO 事件已经完成，[进程不需要再使用任何系统调用来完成 IO 事件]{.blue}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/AIO.i95xm33f7co.png" alt="AIO" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>区别：</p>
<ul>
<li>不同于同步非阻塞式中的 [Selector 采用轮询机制处理事件]{.red}，异步非阻塞式采用 [订阅-通知]{.red} 模式</li>
<li>[无论是 NIO 的哪个版本最终都需要进程自己调用方法处理事件，AIO 则是将编写好的方法完全交给操作系统去执行，自己则不再关心]{.blue}</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>为什么要使用 AIO？</strong></p>
</blockquote>
<ul>
<li><p>异步非阻塞式 IO 是多路复用式 IO 的一种 [替代方案]{.blue}</p>
<p>  +++ 两种方案并没有本质上的优劣之分，实际开发就是 NIO + AIO 两者的结合</p>
<ul>
<li><p>[NIO 是 Java 自己实现的方法，所以在不同的操作系统都是没有区别的]{.red}</p>
</li>
<li><p>[AIO 是涉及到操作系统的实现，所以在不同的操作系统下效率可能是不同的]{.red}</p>
<blockquote>
<p>Windows 平台采用 IOCP 技术真正实现异步操作，Linux 平台仅能够利用 epoll 模拟异步操作</p>
</blockquote>
</li>
</ul>
<p>  +++</p>
</li>
</ul>

        <h2 id="核心类"   >
          <a href="#核心类" class="heading-link"><i class="fas fa-link"></i></a><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2>
      <blockquote>
<p><strong>AIO 的核心类有哪些？</strong></p>
</blockquote>
<ul>
<li>[AsynchronousSocketChannel]{.red}</li>
<li>[AsynchronousServerSocketChannel]{.red}</li>
<li>AsynchronousFileChannel：文件操作并不常用，所以不会编写案例</li>
<li>[AsynchronousChannelGroup]{.blue}</li>
<li>[CompletionHandler&lt;V,A&gt;]{.red}</li>
<li>Future&lt;V.&gt;：[Future 类并不是 NIO 包下的类，而是 JUC 包中提供的类]{.green}</li>
</ul>
<blockquote>
<p><strong>AIO 核心类如何使用？</strong></p>
</blockquote>
<ul>
<li>概述中提到了 AIO 本质是对 NIO 的完善，所以新增的核心类在使用方法上和 NIO 没有太大的区别</li>
<li>主要区别在于新增的 CompletionHandler 类，该类是用于编写回调函数处理 IO 事件的，其余类没有太大区别</li>
</ul>
<blockquote>
<p><strong>AsynchronousServerSocketChannel：创建服务器端</strong></p>
</blockquote>
<ul>
<li><p>[创建线程池（推荐使用）]{.red}</p>
<ul>
<li><p>问题：IO 事件发生时，进程在执行其他的任务，显然主线程是肯定不可能执行回调函数了，那么操作系统应该如何执行回调函数呢？</p>
</li>
<li><p>解决方式：[操作系统调用线程池中存在的线程去执行回调函数]{.red}</p>
<blockquote>
<p>操作系统调用 AsynchronousChannelGroup 中的线程池，线程在 IO 事件发生时执行回调函数</p>
</blockquote>
</li>
<li><p>创建方式：</p>
<ul>
<li>利用工具类 Excutors 创建线程池：[newFixedThreadPool、newCachedThreadPool、newScheduledThreadPool、newSingleThreadExecutor]{.blue}</li>
<li>利用类 ThreadPoolExecutor 创建自定义线程池：[阿里开发手册推荐使用的方式]{.red}</li>
</ul>
</li>
</ul>
</li>
<li><p>创建服务器端：[bind]{.blue} 方法绑定端口号</p>
</li>
<li><p>服务器端接收客户端请求：调用 [accept]{.blue} 方法接收请求 </p>
</li>
<li><p>使用循环和阻塞函数：</p>
<ul>
<li><p>问题一：[accept]{.blue} 方法是异步非阻塞式的，也就意味着服务器端在执行完这个方法之后，会立刻执行之后的代码，如果没有，那么服务器就会直接结束，这显然是不合理的，因为客户端都还没有连接上，服务器就结束了，那么应该怎么解决？</p>
</li>
<li><p>解决方式：[while(true)]{.blue} 循环显然可以避免这个问题</p>
</li>
<li><p>问题二：[while(true)]{.blue} 循环会导致服务器不停的空转，也就是此前轮询模型的问题，这也是我们不想看到的，那么应该怎么解决？</p>
</li>
<li><p>解决方式：此前的 [多路复用模型]{.red} 的解决方式就是使用 [select]{.blue} 阻塞方法来避免这个问题，那么我们也可以采用阻塞方法来解决</p>
<blockquote>
<p>此前学习过程中使用的方法是 System.in.read，虽然确实能够达到效果，但是感觉不是最终的解决方案</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器端主方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建自定义线程池</span></span><br><span class="line">        ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>,<span class="comment">// 核心线程数量</span></span><br><span class="line">            <span class="number">3</span>,<span class="comment">// 最大线程数量</span></span><br><span class="line">            <span class="number">5</span>,<span class="comment">// 空闲线程的存活时间</span></span><br><span class="line">            TimeUnit.SECONDS,<span class="comment">// 存活时间单位</span></span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(),<span class="comment">// 阻塞队列：超过最大线程时还能够容纳的客户端</span></span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()<span class="comment">// 拒绝策略：超过阻塞队列容量后的处理方式</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 创建 AsynchronousChannelGroup</span></span><br><span class="line">        AsynchronousChannelGroup acg = AsynchronousChannelGroup.withThreadPool(threadPool);</span><br><span class="line">        <span class="comment">// 创建服务器端实例（assc 是我定义的成员变量）：如果没有传入 AsynchronousChannelGroup，则会使用默认的</span></span><br><span class="line">        assc = AsynchronousServerSocketChannel.open(acg);</span><br><span class="line">        <span class="comment">// 服务器端绑定端口号</span></span><br><span class="line">        assc.bind(<span class="keyword">new</span> InetSocketAddress(DEFAULT_PORT));</span><br><span class="line">        System.out.printf(<span class="string">&quot;服务器[%d]:%s\n&quot;</span>, DEFAULT_PORT, <span class="string">&quot;启动成功&quot;</span>);</span><br><span class="line">        <span class="comment">// accept 方法参数介绍</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 第一个参数是 Attachment：(1) 可以传入任意的类型 (2) 用于辅助回调函数处理 IO 事件的</span></span><br><span class="line">            <span class="comment">// 诸如缓冲区等辅助信息都是可以传入的</span></span><br><span class="line">            <span class="comment">// 第二个参数是 CompletionHandler（回调函数）：用于处理 IO 事件的类</span></span><br><span class="line">            <span class="comment">// 这里有两种写法：(1) 直接使用匿名内部类的写法（不推荐）(2) 编写实现 CompletionHandler 接口的内部类</span></span><br><span class="line">            <span class="comment">// 不推荐第一种写法的原因是会导致代码看起来非常乱，虽然简洁，读者可以自己试试编写一下</span></span><br><span class="line">            assc.accept(<span class="keyword">null</span>, <span class="keyword">new</span> AcceptHandler());</span><br><span class="line">            assc.accept(<span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;()&#123;</span><br><span class="line">                <span class="comment">// 回调函数</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 阻塞服务器：防止服务器空转</span></span><br><span class="line">            System.in.read();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p><strong>CompletionHandler&lt;V,A&gt;：编写回调函数处理 IO 事件</strong></p>
</blockquote>
<ul>
<li><p>前提：服务器创建完成后，显然需要向操作系统交代 IO 事件如何处理，即回调函数的编写</p>
</li>
<li><p>[处理客户端连接请求的回调函数]{.red}</p>
<ul>
<li><p>实现 [CompletionHandler]{.blue} 接口，传入两个类型</p>
<blockquote>
<p>第一个类型只能够是 AsynchronousSocketChannel、第二个类型根据自己的 Attachment而定，不过通常都是 Object</p>
</blockquote>
</li>
<li><p>重写 [completed]{.blue} 和 [failed]{.blue} 方法</p>
<blockquote>
<p>completed 方法在正确接收到客户端请求后触发，failed 方法在客户端异常断开后触发</p>
</blockquote>
</li>
</ul>
</li>
<li><p>[处理读取客户端发送的数据和向客户端写入数据的回调函数]{.red}</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部类: 用于处理客户端发出的连接请求</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptHandler</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">AsynchronousSocketChannel</span>, <span class="title">Object</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 第一个参数是客户端，第二个参数是附件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel asc, Object attachment)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 注：对客户端进行操作前需要确保客户端是仍然是正常连接的</span></span><br><span class="line">        <span class="keyword">if</span> (asc != <span class="keyword">null</span> &amp;&amp; asc.isOpen())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 打印客户端信息：getRemoteAddress 可以得到客户端的进程号</span></span><br><span class="line">            <span class="comment">// 注：getRemoteAddress 是会抛出异常的，这里我省略掉了，节省篇幅</span></span><br><span class="line">            System.out.println(<span class="string">&quot;客户端&quot;</span> + asc.getRemoteAddress() + <span class="string">&quot;:连接成功&quot;</span>);</span><br><span class="line">            <span class="comment">// 对客户端执行操作</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            Map&lt;String, Object&gt; info = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="comment">// 回调函数不仅要处理写还要处理，所以提供辅助信息用以判断</span></span><br><span class="line">            info.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="comment">// 读取数据需要从缓冲区中读取，所以也应该作为辅助信息传入</span></span><br><span class="line">            info.put(<span class="string">&quot;buffer&quot;</span>, buffer);</span><br><span class="line">            <span class="comment">// 读取客户端的发送的数据： read 方法也是异步非阻塞式的方法，所以也需要相应的回调函数进行处理</span></span><br><span class="line">            asc.read(buffer, info, <span class="keyword">new</span> ReadAndWriteHandler(asc));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务器必须再次向操作系统注册，才能够继续连接客户端，否则服务器端就不会继续连接客户端了</span></span><br><span class="line">        <span class="keyword">if</span> (assc.isOpen())</span><br><span class="line">        &#123;</span><br><span class="line">            assc.accept(<span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出现异常执行的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部类: 用于处理读取客户端的数据的请求和向客户端写入数据的请求</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadAndWriteHandler</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>, <span class="title">Object</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 记录当前处理的客户端</span></span><br><span class="line">    <span class="keyword">private</span> AsynchronousSocketChannel asc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadAndWriteHandler</span><span class="params">(AsynchronousSocketChannel asc)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.asc = asc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个参数是每次读取或者写入的字节数量，第二个参数依然是附件信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, Object attachment)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 强制转换获取辅助信息</span></span><br><span class="line">        Map&lt;String, Object&gt; info = (Map&lt;String, Object&gt;) attachment;</span><br><span class="line">        <span class="comment">// 获取缓冲区</span></span><br><span class="line">        ByteBuffer buffer = (ByteBuffer) info.get(<span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取当前处理的是读取还是写入</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;read&quot;</span>.equals(info.get(<span class="string">&quot;type&quot;</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 读取客户端发送的数据并且显示在服务器端</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            String msg = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">            <span class="comment">// 依然省略捕获异常的过程</span></span><br><span class="line">            System.out.println(asc.getRemoteAddress() + <span class="string">&quot;:\t&quot;</span> + msg + <span class="string">&quot;\t字节数量[&quot;</span> + result +<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            <span class="comment">// 清空缓冲区</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="comment">// 更新辅助信息</span></span><br><span class="line">            info.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="comment">// 向客户端发送信息，原封不动的发送回去，当然你也可以发送其他内容，修改缓冲区就行</span></span><br><span class="line">            <span class="comment">// 向客户端发送信息后，服务器端显然需要继续读取客户端发送的信息，所以不可以将回调函数置为 null，那样后续就接收不到信息了</span></span><br><span class="line">            asc.write(buffer, info, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;write&quot;</span>.equals(info.get(<span class="string">&quot;type&quot;</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            asc.read(buffer, info, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p><strong>AsynchronousSocketChannel：创建客户端</strong></p>
</blockquote>
<ul>
<li>前提：客户端的创建比较简单，所以采用未来时 Future 来处理</li>
<li>创建线程池（推荐）：客户端依然有对应的 AsynchronousChannelGroup 来处理回调函数，只不过我这里就不再演示了</li>
<li>创建客户端：[connect]{.blue} 连接服务器端</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建客户端</span></span><br><span class="line">        asc = AsynchronousSocketChannel.open();</span><br><span class="line">        <span class="comment">// 向服务器端发出连接请求</span></span><br><span class="line">        asc.connect(<span class="keyword">new</span> InetSocketAddress(DEFAULT_LOCALHOST, DEFAULT_PORT));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException | InterruptedException | ExecutionException e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p><strong>Future：利用未来时处理 IO 事件</strong></p>
</blockquote>
<ul>
<li>异步非阻塞式的方法都具有 Future 类型的返回值</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建客户端</span></span><br><span class="line">        asc = AsynchronousSocketChannel.open();</span><br><span class="line">        <span class="comment">// 获取返回值</span></span><br><span class="line">        Future&lt;Void&gt; connect = asc.connect(<span class="keyword">new</span> InetSocketAddress(DEFAULT_LOCALHOST, DEFAULT_PORT));</span><br><span class="line">        <span class="comment">// 客户端将会等待连接建立完成: 如果连接没有建立完成，就会阻塞，如果建立完成，将继续执行</span></span><br><span class="line">        connect.get();</span><br><span class="line">        <span class="comment">// 从控制台中读取信息</span></span><br><span class="line">        String msg;</span><br><span class="line">        <span class="keyword">while</span> ((msg = reader.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 向服务端发送信息</span></span><br><span class="line">            ByteBuffer buffer = StandardCharsets.UTF_8.encode(msg);</span><br><span class="line">            Future&lt;Integer&gt; write = asc.write(buffer);</span><br><span class="line">            <span class="comment">// 数据发送完毕后才会继续执行</span></span><br><span class="line">            write.get();</span><br><span class="line">            <span class="comment">// 读取服务器端返回的消息</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            Future&lt;Integer&gt; read = asc.read(buffer);</span><br><span class="line">            <span class="comment">// 接收数据完成后才会继续执行</span></span><br><span class="line">            read.get();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException | InterruptedException | ExecutionException e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="实战：多人聊天室"   >
          <a href="#实战：多人聊天室" class="heading-link"><i class="fas fa-link"></i></a><a href="#实战：多人聊天室" class="headerlink" title="实战：多人聊天室"></a>实战：多人聊天室</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.v4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousChannelGroup;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多人聊天室服务器端: 采用异步非阻塞式 IO 实现</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 服务器端口号: 默认使用的端口号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">8888</span>;</span><br><span class="line">    <span class="comment">// 缓冲区固定分配的空间大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">// 退出消息标识符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXIT = <span class="string">&quot;退出&quot;</span>;</span><br><span class="line">    <span class="comment">// 调用者可以根据需要使用其他的端口号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="comment">// 保存客户端的集合: 因为采用的是订阅-通知的模式, 所以没有方法可以直接获取到所有的客户端</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;AsynchronousSocketChannel&gt; clients;</span><br><span class="line">    <span class="comment">// 服务器端通道: 调用者可以根据需要传入自定义的通道</span></span><br><span class="line">    <span class="keyword">private</span> AsynchronousServerSocketChannel server;</span><br><span class="line">    <span class="comment">// 线程池</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService threadPool;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousChannelGroup acg;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理客户端连接请求的回调函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">AsynchronousSocketChannel</span>, <span class="title">Object</span>&gt;</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel client, Object attachment)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 服务器端继续接收其他的客户端连接请求</span></span><br><span class="line">            <span class="keyword">if</span> (server.isOpen())</span><br><span class="line">            &#123;</span><br><span class="line">                server.accept(attachment, <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 提示客户端连接成功</span></span><br><span class="line">            System.out.println(getClientName(client) + <span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">            <span class="comment">// 客户端加入集合中</span></span><br><span class="line">            addClient(client);</span><br><span class="line">            <span class="comment">// 服务器端主要功能: 接收客户端发送的消息并且转发给其他客户端</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE);</span><br><span class="line">            buffer.put(getClientName(client).getBytes());</span><br><span class="line">            <span class="comment">// 客户端通道实际只有读事件才需要使用回调函数, 写事件是不需要的</span></span><br><span class="line">            client.read(buffer, buffer, <span class="keyword">new</span> ReadHandler(client));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 异常处理</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理客户端读写请求的回调函数: 泛型中传入的是整型, 所以为了知道客户端的信息, 我们需要将其作为辅助信息传入</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>, <span class="title">Object</span>&gt;</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> AsynchronousSocketChannel client;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReadHandler</span><span class="params">(AsynchronousSocketChannel client)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.client = client;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, Object attachment)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            ByteBuffer buffer = (ByteBuffer) attachment;</span><br><span class="line">            <span class="comment">// 从写模式切换成读模式</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">// 判断客户端是否想要退出</span></span><br><span class="line">            <span class="keyword">if</span> (isExit(buffer))</span><br><span class="line">            &#123;</span><br><span class="line">                removeClient(client);</span><br><span class="line">                <span class="comment">// 关闭该客户端, 不需要再继续读取该客户端的信息, 所以没必要传递回调函数</span></span><br><span class="line">                client.write(StandardCharsets.UTF_8.encode(EXIT));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 服务器端显示客户端发送的消息</span></span><br><span class="line">            String msg = String.valueOf(StandardCharsets.UTF_8.decode(buffer));</span><br><span class="line">            System.out.println(msg + <span class="string">&quot;(&quot;</span> + result + <span class="string">&quot;字节)&quot;</span>);</span><br><span class="line">            <span class="comment">// 转发消息</span></span><br><span class="line">            forward(client, msg);</span><br><span class="line">            <span class="comment">// 读模式切换成写模式</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="comment">// 更新辅助信息</span></span><br><span class="line">            buffer.put(getClientName(client).getBytes());</span><br><span class="line">            <span class="comment">// 服务器端继续读取当前客户端发送的其他消息</span></span><br><span class="line">            client.read(buffer, buffer, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 异常处理</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatServer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_PORT, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatServer</span><span class="params">(<span class="keyword">int</span> port, AsynchronousServerSocketChannel server)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.server = server;</span><br><span class="line">        clients = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认使用的服务器端通道</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AsynchronousServerSocketChannel <span class="title">getAsynchronousServerSocketChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 默认使用的线程池</span></span><br><span class="line">        threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">8</span>,</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">        );</span><br><span class="line">        acg = AsynchronousChannelGroup.withThreadPool(threadPool);</span><br><span class="line">        <span class="keyword">return</span> AsynchronousServerSocketChannel.open(acg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转发消息: 最为关键的修改</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">forward</span><span class="params">(AsynchronousSocketChannel client, String msg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (AsynchronousSocketChannel other : clients)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (client != other)</span><br><span class="line">                <span class="comment">// 每个客户端都应该拥有属于自己的缓冲区, 否则在多线程环境下共用一个, 真的不好检测会出现什么问题</span></span><br><span class="line">                <span class="comment">// (其实主要问题还是他妈的 IDEA 调试异步函数进不去, 就离谱)</span></span><br><span class="line">                other.write(StandardCharsets.UTF_8.encode(msg));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断客户端是否想要退出</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isExit</span><span class="params">(ByteBuffer buffer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> EXIT.equals(<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端加入服务器端</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addClient</span><span class="params">(AsynchronousSocketChannel client)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        clients.add(client);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端退出服务器端</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeClient</span><span class="params">(AsynchronousSocketChannel client)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        close(client);</span><br><span class="line">        clients.remove(client);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取客户端标识符</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getClientName</span><span class="params">(AsynchronousSocketChannel client)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            InetSocketAddress address = (InetSocketAddress) client.getRemoteAddress();</span><br><span class="line">            port = address.getPort();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;客户端[&quot;</span> + port + <span class="string">&quot;]:&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭各种通道或者流</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable closeable)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (closeable != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                closeable.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器端主方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 服务器端初始化</span></span><br><span class="line">            <span class="keyword">if</span> (server == <span class="keyword">null</span>)</span><br><span class="line">                server = getAsynchronousServerSocketChannel();</span><br><span class="line">            <span class="comment">// 绑定端口号</span></span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            <span class="comment">// 提示服务器启动成功</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;服务器[%d]:%s\n&quot;</span>, port, <span class="string">&quot;启动成功&quot;</span>);</span><br><span class="line">            <span class="comment">// 接收客户端的连接请求:</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                server.accept(<span class="keyword">null</span>, <span class="keyword">new</span> AcceptHandler());</span><br><span class="line">                <span class="comment">// 阻塞服务器</span></span><br><span class="line">                System.in.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            close(server);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 启动服务器</span></span><br><span class="line">        <span class="keyword">new</span> ChatServer().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>





<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.v4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousChannelGroup;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多人聊天室: 客户端</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_LOCALHOST = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">8888</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXIT = <span class="string">&quot;退出&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousSocketChannel client;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousChannelGroup acg;</span><br><span class="line">    <span class="keyword">private</span> ExecutorService threadPool;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClient</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_PORT, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClient</span><span class="params">(<span class="keyword">int</span> port, AsynchronousSocketChannel client)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AsynchronousSocketChannel <span class="title">getAsynchronousSocketChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 默认使用的线程池</span></span><br><span class="line">        threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">15</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">        );</span><br><span class="line">        acg = AsynchronousChannelGroup.withThreadPool(threadPool);</span><br><span class="line">        <span class="keyword">return</span> AsynchronousSocketChannel.open(acg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取客户端标识符</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getClientName</span><span class="params">(AsynchronousSocketChannel client)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            InetSocketAddress address = (InetSocketAddress) client.getRemoteAddress();</span><br><span class="line">            port = address.getPort();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;客户端[&quot;</span> + port + <span class="string">&quot;]:&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable closeable)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (closeable != <span class="keyword">null</span>)</span><br><span class="line">                closeable.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (client == <span class="keyword">null</span>)</span><br><span class="line">                client = getAsynchronousSocketChannel();</span><br><span class="line">            Future&lt;Void&gt; connect = client.connect(<span class="keyword">new</span> InetSocketAddress(DEFAULT_LOCALHOST, port));</span><br><span class="line">            <span class="comment">// 阻塞客户端</span></span><br><span class="line">            connect.get();</span><br><span class="line">            System.out.println(getClientName(client) + <span class="string">&quot;启动成功&quot;</span>);</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE);</span><br><span class="line">            <span class="comment">// 控制台输入必然阻塞: 只能够新开线程处理</span></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ChatClientInputThread(client)).start();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Future&lt;Integer&gt; read = client.read(buffer);</span><br><span class="line">                <span class="keyword">int</span> res = read.get();</span><br><span class="line">                <span class="keyword">if</span> (res &lt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    close(client);</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    System.out.println(StandardCharsets.UTF_8.decode(buffer));</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException | InterruptedException | ExecutionException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ChatClient().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>





<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.v4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClientInputThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXIT = <span class="string">&quot;退出&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BufferedReader READER = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">        <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">            System.in));</span><br><span class="line">    <span class="keyword">private</span> AsynchronousSocketChannel client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClientInputThread</span><span class="params">(AsynchronousSocketChannel client)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">while</span> ((msg = READER.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Future&lt;Integer&gt; write = client.write(StandardCharsets.UTF_8.encode(msg));</span><br><span class="line">                write.get();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException | InterruptedException | ExecutionException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/07/java/interface/Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/">Lambda 表达式</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-07</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-09</span></span></div></header><div class="post-body"><div class="post-excerpt"></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/07/java/interface/%E5%86%85%E9%83%A8%E7%B1%BB/">内部类</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-07</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-09</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="内部类"   >
          <a href="#内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1>
      <img src="https://i1.xpic.jp/file/xpicjp/2021/08/06/a0d492c62fb589175f32dd41b3ec0c07.png" alt="a0d492c62fb589175f32dd41b3ec0c07.png" style="zoom:80%;" />

<ul>
<li><p>定义：可以将一个类的定义置于另一个类的定义内部</p>
</li>
<li><p>特点：（这些特点是所有类型的内部类都具有的）</p>
<ul>
<li>[非静态内部类可以直接访问外部类的所有成员变量和方法]{.red}</li>
<li>[外部类不能够直接访问内部类成员变量和方法]{.red}</li>
<li>[内部类在外部创建对象必须依附外部类创建]{.red}</li>
<li>[所有类型的内部类都具有构造器（包括匿名内部类）]{.red}</li>
</ul>
</li>
<li><p>类型：① <a href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB">成员内部类</a> ② <a href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB">静态内部类</a> ③ <a href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB">局部内部类</a> ④ <a href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB">匿名内部类</a></p>
<p>  注：按照这个顺序分类是有原因的，<code>Lambda</code> 表达式就是这样通过内部类地不断演化得来的</p>
</li>
<li><p>问题：</p>
<ul>
<li><p>为什么需要提供内部类机制？</p>
<ul>
<li><p>[内部类使得多重继承的解决方案变得更加完善]{.red}：接口多重继承解决了部分多重继承的问题，内部类完善了多重继承方案</p>
</li>
<li><p>内部类可以非常方便地隐藏实现细节，方便实现定义回调</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这种类型的代码可以在 HashMap 中看到类似的 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span></span>&#123;</span><br><span class="line">    <span class="comment">/*外部类只需要在内部创建内部类相应的引用就可以使用内部类的方法，从而也就可以使用内部类继承的父类的方法，实现多继承*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassA</span> <span class="keyword">extends</span> <span class="title">HashMap</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassB</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> InnerClassA getInnerClassAInstance&#123;<span class="keyword">return</span> <span class="keyword">new</span> InnerClassA()&#125;;</span><br><span class="line">    <span class="keyword">private</span> InnerClassB getInnerClassBInstance&#123;<span class="keyword">return</span> <span class="keyword">new</span> InnerClassB()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>为什么非静态内部类可以直接访问外部类的所有属性？</p>
<ul>
<li><p>编译器编译时 [平等对待]{.red} 外部类和内部类：为内部类和外部类都会生成相应的字节码文件，内部类字节码的文件名称为 <code>OuterClassName$InnerClassName</code></p>
</li>
<li><p>反编译字节码文件就可以看到内部类究竟是如何被初始化的：局部变量表中存在两个引用，一个是内部类自身的引用，另一个是外部类对象的引用</p>
</li>
<li><p>编译器在编译时会在 [构造器]{.red} 中添加对于外部类对象的引用：[静态内部类访问不了的原因显然是因为本身不是对象了]{.red}</p>
  <img src="https://i1.xpic.jp/file/xpicjp/2021/08/06/f7584cb7b6d63810f7a0cc5cb0ed00ad.png" alt="f7584cb7b6d63810f7a0cc5cb0ed00ad.png" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li><p>如果内部类存在和外部类名称相同的成员变量或者方法，[内部类的成员变量会 <strong>覆盖</strong> 外部类的成员变量]{.red}</p>
<p>  外部类属性被覆盖之后，显然内部类无法直接访问到外部类的属性，有两种方式可以提供访问</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OuterClass.<span class="keyword">this</span>.number; <span class="comment">/* 外部类.this.成员变量 或者 外部类.this.方法：可以访问到外部类对象 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> OuterClass <span class="title">getOuterClassInstance</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> OuterClass()&#125;; <span class="comment">/*直接创建外部类对象后去引用成员变量或者方法*/</span></span><br></pre></td></tr></table></div></figure></li>
<li><p>内部类可以采用任何访问权限进行修饰：（方法内部类和匿名内部类除外）</p>
<ul>
<li>通常内部类不会是公开的，因为需要隐藏实现细节</li>
<li>无论内部类是何种访问权限、普通方法和构造方法的访问权限如何，外部类都可以在 ++自身内部++ 创建内部类的对象并且对其进行访问</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h2 id="成员内部类"   >
          <a href="#成员内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2>
      <ul>
<li><p>定义：最普通的内部类</p>
</li>
<li><p>特点：[成员内部类不可以拥有静态属性（静态变量、静态方法、静态代码块）]{.red}：可以拥有静态常量和普通常量、不可以变方法</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="comment">// 静态常量</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> innerNumber = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 不可变变量（常量）</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String innerString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// 成员变量</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> publicNumber;					   </span><br><span class="line">        <span class="comment">// 不可以存在静态变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>创建方式</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">	</span><br></pre></td></tr></table></div></figure></li>
</ul>
<blockquote>
<p>《<code>Java</code> 核心技术卷一：》：成员内部类中不能够存在静态属性，但是 <code>Java</code> 语言规范没有对该限制做出任何解释</p>
</blockquote>

        <h2 id="静态内部类"   >
          <a href="#静态内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2>
      <ul>
<li><p>定义：采用 <code>static</code> 关键字修饰的内部类</p>
</li>
<li><p>特点：</p>
<ul>
<li>[静态内部类仅能够访问外部类的所有静态属性]{.red}：静态内部类抹去了对于外部类对象的引用，所以是不可能访问到外部类的成员变量的</li>
<li>[静态内部类可以拥有静态属性和普通属性]{.red}</li>
<li>[接口中所有内部类都默认是静态内部类]{.red}</li>
</ul>
</li>
<li><p>创建方式：[内部类不能够是私有的]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">			</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">creatInnerClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 外部类中创建内部类对象</span></span><br><span class="line">        InnerClass innerClass = <span class="keyword">new</span> InnerClass();					</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 其他类类中创建内部类对象</span></span><br><span class="line">    OuterClass.InnerClass innerClass = <span class="keyword">new</span> OuterClass.InnerClass(); </span><br><span class="line">&#125;	</span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h2 id="局部内部类"   >
          <a href="#局部内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2>
      <ul>
<li><p>定义：位于 [方法作用域]{.red} 中的内部类</p>
</li>
<li><p>特点：</p>
<ul>
<li>[局部内部类本身不可以采用任何访问权限进行修饰]{.red}</li>
<li>[局部内部类仅可以在该方法中被访问，其他任何位置均不可以访问局部内部类]{.red}</li>
<li>局部内部类可以访问方法提供的形参和方法内部定义的局部变量：[方法的形式参数和局部变量必须是不可变的]{.red}（<code>Java 8</code> 之后 [默认形参和局部变量]{.red} 就是不可变的）</li>
</ul>
</li>
<li><p>细节：局部内部类对应的字节码文件名称：<code>OuterClassName$XInnerClassName</code></p>
</li>
<li><p>创建方式：[仅可以在方法内部创建对象]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认形式参数是不可变的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodInnerClass</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 默认局部变量是不可变的</span></span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 局部内部类不可以采用任何关键字进行修饰</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MethodInnerClass</span></span>&#123;						</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">// 调用方法中的形式参数</span></span><br><span class="line">			System.out.println(count);			</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建局部内部类对象并且调用方法</span></span><br><span class="line">    <span class="keyword">new</span> MethodInnerClass().method();			</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure></li>
<li><p>问题：为什么方法的参数或者局部变量必须是不可变的呢？</p>
<ul>
<li><p>普通方法和类的声明周期并不一致：类在加载阶段开始直到虚拟机关闭才销毁，方法在调用完成后就会被销毁</p>
</li>
<li><p>形式参数和局部变量会随着方法被虚拟机销毁而跟着销毁，局部内部类/匿名内部类也就无法再次访问形式参数、局部变量</p>
</li>
<li><p>为了避免生命周期不一致引发的数据访问问题：<code>Java</code> 采用 [复制]{.red} 来避免</p>
<p>  (1) [如果局部内部类访问的是局部变量，那么就将这个局部变量的值复制运行时常量池中，确保局部内部类能够访问]{.red}</p>
<p>  (2) [如果局部内部类访问的是形式参数，那么复制这个形式参数到局部内部类的构造器中进行初始化，确保局部内部类始终能够访问]{.red}</p>
</li>
<li><p>实际上两种方式访问的局部变量、形式参数都不是原本的局部变量和形式参数，仅仅只是复制过来的内容，所以如果不增加 <code>final</code> 关键字加以修饰，就会导致 [数据不一致的问题]{.red}</p>
</li>
</ul>
</li>
</ul>

        <h2 id="匿名内部类"   >
          <a href="#匿名内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2>
      <ul>
<li><p>定义：[没有名字的局部内部类]{.red}</p>
</li>
<li><p>特点：</p>
<ul>
<li>[匿名内部类需要实现相应的接口或者继承抽象类]{.red}</li>
<li>[匿名内部类不需要显式的声明]{.red}：</li>
<li>[匿名内部类可以借助代码块“迫使”编译器生成构造器]{.red}</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li>匿名内部类只可以继承一个类或者实现一个接口</li>
<li>匿名内部类对应的字节码文件名称：<code>OuterClassName$X</code>（<code>X</code> 代表数字：通常根据数量来生成）</li>
</ul>
</li>
<li><p>创建方式：[仅可以在方法内部创建对象]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AnonymousInnerClass</span></span>&#123;					<span class="comment">// 匿名内部类实现的接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anonymousInnerClass</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 匿名内部类隐式的声明 */</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    class AnonymousClass implements AnonymousInnerClass&#123;</span></span><br><span class="line"><span class="comment">    	public void method()&#123;</span></span><br><span class="line"><span class="comment">    	</span></span><br><span class="line"><span class="comment">    	&#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 实现接口创建匿名内部类对象</span></span><br><span class="line">    <span class="keyword">new</span> AnonymousInnerClass()&#123;					</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">// 匿名内部类和局部内部类相同依然可以使用外部类的属性和不可变的形式参数</span></span><br><span class="line">            System.out.println(count);			</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 继承类创建匿名内部类对象</span></span><br><span class="line">    <span class="keyword">new</span> ArrayList()&#123;							</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
<div class="table-container"><table>
<thead>
<tr>
<th></th>
<th>成员内部类</th>
<th>静态内部类</th>
<th>局部内部类</th>
<th>匿名内部类</th>
</tr>
</thead>
<tbody><tr>
<td>属性</td>
<td>[不可以拥有任何静态属性（静态常量除外）]{.red}</td>
<td>可以拥有任何属性</td>
<td>可以拥有任何属性</td>
<td>可以拥有任何属性</td>
</tr>
<tr>
<td>继承&amp;实现</td>
<td>继承一个实现多个</td>
<td>继承一个实现多个</td>
<td>继承一个实现多个</td>
<td>[继承一个或者实现一个]{.red}</td>
</tr>
<tr>
<td>外部类</td>
<td>直接访问外部类属性</td>
<td>[仅能访问外部类静态属性]{.red}</td>
<td>直接访问外部类属性</td>
<td>直接访问外部类属性</td>
</tr>
<tr>
<td>构造器</td>
<td>有</td>
<td>有</td>
<td>有</td>
<td>[有]{.red}</td>
</tr>
<tr>
<td>作用域</td>
<td>外部类内部</td>
<td>任意位置</td>
<td>仅能在方法中被访问</td>
<td>仅能在访问中被访问</td>
</tr>
<tr>
<td>访问权限</td>
<td>任意访问权限</td>
<td>任意访问权限</td>
<td>[不可以修饰]{.red}</td>
<td>[不可以修饰]{.red}</td>
</tr>
</tbody></table></div>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/07/java/interface/%E6%8E%A5%E5%8F%A3/">接口概述</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-09-07</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-09-09</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="抽象类"   >
          <a href="#抽象类" class="heading-link"><i class="fas fa-link"></i></a><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1>
      <blockquote>
<p><strong>什么是抽象类？</strong></p>
</blockquote>
<ul>
<li><p>定义：[拥有抽象方法的类或者说采用 abstract 关键字修饰的类]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义的抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义的抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>特点：</p>
<ul>
<li><p>[抽象类中并非所有方法都是抽象的]{.red}：</p>
<ul>
<li>[每个抽象类可以同时拥有具体实现方法和抽象方法]{.blue}</li>
<li>[每个继承抽象类的子类必须实现所有的抽象方法]{.blue}</li>
</ul>
</li>
<li><p>[抽象方法的访问权限不可以是私有的、也不可以是静态或者不可变的]{.red}：这几种情况都会导致子类无法重写或者说实现抽象方法</p>
</li>
<li><p>[抽象类中可以存在任意访问权限的成员变量]{.red}：拥有成员变量也就意味着拥有构造方法</p>
</li>
<li><p>[不可以利用 new 关键字直接创建抽象类实例]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种创建方式是错误的</span></span><br><span class="line">AbstractClass object = <span class="keyword">new</span> AbstractClass();</span><br><span class="line"><span class="comment">// 只能够将抽象类的引用指向具体的实现类来创建：SubClass 继承实现了抽象类</span></span><br><span class="line">AbstractClass object = <span class="keyword">new</span> SubClass();</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>为什么需要提供抽象类？为什么不直接提供一个实现了方法的父类呢？</strong></p>
</blockquote>
<ul>
<li><p>可以将不同的类中拥有相同的变量和方法抽取出来成为抽象类的属性，任何类需要拥有这些属性时只需要继承抽象类就行，[便于代码的继续进行扩展]{.blue}</p>
</li>
<li><p>设计系统架构时很难得知最终如何去实现这些功能，抽象类就能很好地帮助系统的架构设计，不需要提供任何实现，仅考虑需要提供什么，有利于程序架构设计以及之后的重构</p>
</li>
<li><p>普通父类中的所有方法都必须实现，之前提到的在设计系统架构时是很难得知最终如何实现这个方法</p>
</li>
</ul>
<p>:::info</p>
<p>总结：抽象类除了拥有抽象方法之外，其余和普通的类没有什么区别</p>
<p>:::</p>

        <h1 id="接口"   >
          <a href="#接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#接口" class="headerlink" title="接口"></a>接口</h1>
      
        <h2 id="概述"   >
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h2>
      <ul>
<li><p>定义：[没有具体实现和成员变量，而只是描述类应该完成的需求，没有具体的实现]{.red}</p>
</li>
<li><p>特点：</p>
<ul>
<li><p>[接口中所有方法都没有具体实现，都是公共的抽象方法]{.red}：实现类必须实现所有抽象方法</p>
<blockquote>
<p><code>Java 8</code> 新特性中接口也可以拥有实现的方法</p>
</blockquote>
</li>
<li><p>[接口和接口之间可以继承，类可以实现多个接口]{.red}</p>
<blockquote>
<p>接口继承接口采用的实现 <code>extends</code> 关键字而不是 <code>implements</code></p>
</blockquote>
</li>
<li><p>[接口中默认所有变量都是公共的静态常量]{.red}</p>
<blockquote>
<p>不能有成员变量，也不能有非公共的变量（<code>protected</code>、<code>private</code> 都不可以修饰接口中的变量）</p>
</blockquote>
</li>
<li><p>接口不能采用 <code>new</code> 创建对象仅可以创建接口引用，指向各个实现接口的类</p>
</li>
<li><p>[接口中可以嵌套定义接口，类中也可以嵌套定义接口，接口中也可以嵌套定义内部类（默认为静态内部类）]{.blue}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Walk</span></span>&#123;												<span class="comment">// 接口的定义</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Run</span> <span class="keyword">extends</span> <span class="title">Walk</span></span>&#123;									<span class="comment">// 接口继承接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Run</span>, <span class="title">Comparator</span>&lt;<span class="title">Animal</span>&gt;</span>&#123;			<span class="comment">// 类实现接口，多接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*初始化接口*/</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>新特性：（<code>Java 8</code>后新增加的特性）</p>
<ul>
<li><p>[接口中可以存在静态方法]{.red}</p>
<blockquote>
<p>通常仍然将这些方法放入伴生的工具类中（<code>Collection &amp; Collections</code>前者仍然只是提供抽象方法，后者提供具体方法）</p>
</blockquote>
</li>
<li><p><a style="color:red;">接口中可以存在默认的实现方法</a>：采用 <code>default</code> 关键字修饰；实现类可以重写默认方法可以不重写</p>
<p>  注：这两个新特性实际上是有违接口的设计初衷</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">defaultMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>细节：</p>
<p>  +++ 接口中定义一个默认实现方法，抽象类中也定义一个具有相同名称的实现方法，那么实现接口同时继承抽象类的类会选择哪个方法呢？</p>
<p>  [解决方式：抽象类中的方法将会覆盖其余接口中所有的同名方法，父类优先级最高]{.red}</p>
<p>  +++</p>
<p>  +++ 两个接口同时定义一个具有相同名称的默认实现方法，那么同时实现两个接口的实现类会选择哪个方法呢？</p>
<p>  [解决方式：编译器无法识别实现类到底继承哪个方法，需要实现类 <strong>重写该方法</strong> 从而覆盖两个接口的默认实现]{.red}</p>
<p>  +++</p>
<p>  +++ 一个接口中定义了一个默认的实现方法，另一个接口定义了一个同名的抽象方法，那么同时实现两个接口的类会继承默认的实现方法吗？</p>
<p>  [解决方式：编译器依然直接报错，仍然需要重写，<code>Java</code> 强调一致性，这种二义性依然需要程序员处理]{.red}</p>
<p>  +++</p>
<p>  +++ 两个接口同时定义了一个具有相同名称的抽象方法，那么同时实现两个接口的实现类不会有任何问题，只需要实现就行了</p>
<p>  +++</p>
<p>  +++ 抽象类实现接口，子类继承抽象类</p>
<ul>
<li>抽象类可以选择实现接口中的方法，也可以选择不实现交给继承的子类实现</li>
<li>子类必须实现没有被抽象类实现的方法，也可以选择覆写抽象类实现的方法</li>
</ul>
<p>  +++</p>
</li>
</ul>

        <h2 id="常用接口"   >
          <a href="#常用接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h2>
      
        <h3 id="比较接口"   >
          <a href="#比较接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#比较接口" class="headerlink" title="比较接口"></a>比较接口</h3>
      <ul>
<li><p><code>Comparable&lt;T&gt;</code>：该接口仅提供一个方法</p>
<ul>
<li><p>定义：[实现该接口的类的实例对象是可以相互进行比较的]{.blue}</p>
</li>
<li><p>规则：[泛型接口中传入的类必须是实现该接口的类]{.red}</p>
</li>
<li><p>细节：(1)<code>java.util</code> 包下的方法 (2) 函数式接口</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*接口定义*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*例子*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    ... <span class="comment">// 提供构造方法初始化成员变量</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">		<span class="comment">// 根据对象的年龄进行比较</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age &gt; person.age ? <span class="number">1</span> : (<span class="keyword">this</span>.age == person.age ? <span class="number">0</span> : -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    List&lt;MyClass&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Collections.addAll(list, <span class="keyword">new</span> MyClass(<span class="number">23</span>),</span><br><span class="line">                       <span class="keyword">new</span> MyClass(<span class="number">12</span>),</span><br><span class="line">                       <span class="keyword">new</span> MyClass(<span class="number">98</span>),</span><br><span class="line">                       <span class="keyword">new</span> MyClass(<span class="number">20</span>));</span><br><span class="line">    <span class="comment">// Collections 工具类就可以直接对这种可比较的对象进行排序</span></span><br><span class="line">    Collections.sort(list);															</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Collections sort 方法源码*/</span></span><br><span class="line"><span class="comment">// 如果链表中存放的对象本身就是可比较的那么就不需要传入比较器来比较对象了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">    list.sort(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p><code>Comparator&lt;T&gt;</code>：[该接口仅需要重写一个方法]{.red}，其余方法都是静态的或者默认实现的</p>
<ul>
<li><p>定义：[实现该接口的类是可以去比较其他类的]{.blue}，也就是说实现了该接口的类就是 [比较器]{.red}</p>
</li>
<li><p>要求：[泛型接口中传入的类可以不是实现该接口的类，可以是任何需要比较的类]{.red}</p>
</li>
<li><p>细节：(1) <code>java.lang</code> 包下的方法 (2) 函数式接口</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*接口定义*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*例子*/</span></span><br><span class="line"><span class="comment">// 被比较的类不需要实现任何接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;																			</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    ... <span class="comment">// 提供构造方法初始化成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*比较器：传入的类型就是需要比较的类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonComaprator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person person1, Person person2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person1.age &gt; person2.age ? <span class="number">1</span> : (person1.age == person2.age ? <span class="number">0</span> : -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    List&lt;MyClass&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Collections.addAll(list, <span class="keyword">new</span> MyClass(<span class="number">23</span>),</span><br><span class="line">                       <span class="keyword">new</span> MyClass(<span class="number">12</span>),</span><br><span class="line">                       <span class="keyword">new</span> MyClass(<span class="number">98</span>),</span><br><span class="line">                       <span class="keyword">new</span> MyClass(<span class="number">20</span>));</span><br><span class="line">    <span class="comment">// Collections 工具类就可以直接对这种可比较的对象进行排序</span></span><br><span class="line">    Collections.sort(list， <span class="keyword">new</span> PersonComparator());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Collections sort 方法源码*/</span></span><br><span class="line"><span class="comment">// 如果链表中存放的对象本身是不可比较的，那么就需要传入实现了 Comparator 接口的比较器来对链表元素进行比较</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    list.sort(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>

        <h3 id="克隆接口"   >
          <a href="#克隆接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#克隆接口" class="headerlink" title="克隆接口"></a>克隆接口</h3>
      <p>:::info</p>
<p>参考博客：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Qian123/p/5710533.html"><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/Qian123/p/5710533.html" >Java提高篇——对象克隆（复制）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></a></p>
<p>:::</p>
<blockquote>
<p><strong>什么是克隆？</strong></p>
</blockquote>
<ul>
<li><p>定义：简单来说就是 [复制]{.blue}，将一个变量的值赋给另一个变量</p>
</li>
<li><p>基本数据类型的克隆：[原变量发生变化不会影响到克隆变量的值，两者在栈中具有独立的空间]{.red}</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 基本数据类型的克隆</span></span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> cloneNumber = number;</span><br><span class="line">    <span class="comment">// 修改原变量的值</span></span><br><span class="line">    number = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 查看两个的变量的值是否相同</span></span><br><span class="line">    System.out.println(number + <span class="string">&quot;\t&quot;</span> + cloneNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>引用类型的克隆：</p>
<ul>
<li><p>思考：引用对象是怎么进行克隆的呢？和基本数据类型相同吗？</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 引用类型的克隆</span></span><br><span class="line">    Student student1 = <span class="keyword">new</span> Student(<span class="number">12</span>, <span class="string">&quot;冬坂五百里&quot;</span>);</span><br><span class="line">    <span class="comment">// 尝试用基本数据类型的克隆方法来完成引用类型的克隆</span></span><br><span class="line">    Student student2 = student1;</span><br><span class="line">    <span class="comment">// 修改第二个对象的年龄</span></span><br><span class="line">    student2.age = <span class="number">24</span>;</span><br><span class="line">    <span class="comment">// 查看两个对象的年龄是否相同</span></span><br><span class="line">    System.out.println(student1.age);</span><br><span class="line">    System.out.println(student2.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>结果：[在我们修改了第二个对象的年龄之后发现两者的年龄居然相同，两者并没有在堆空间独立存在]{.green}</p>
</li>
<li><p>分析：这种方式只是将栈空间中的两个引用指向了堆空间中的同一个对象而已，并没有为克隆变量开辟新的堆空间</p>
<blockquote>
<p>利用 System.identityHashCode(); 方法可以计算对象在堆内存中的地址，结果一定是一样的</p>
</blockquote>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/引用类型.11b5vy5sxfr4.png" alt="引用类型" style="zoom:80%;" /></li>
<li><p>结论：显然这种克隆并不是我们真正想要的克隆方式，我们想要的显然是两个对象是完全独立的，相互不受影响的</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>如何实现克隆？</strong></p>
</blockquote>
<ul>
<li><p>前提：[经过前面的分析可以明确的是，克隆这种技术主要针对的是引用类型的对象，毕竟基础数据类型完全可以直接复制]{.red}</p>
</li>
<li><p>核心：</p>
<ul>
<li><p>[实现 Cloneable 接口，覆写 Object 类提供的 clone 方法后调用即可]{.red}</p>
<blockquote>
<p>Cloneable 接口是 [标志性]{.red} 接口，没有定义任何方法，实现该接口仅仅是标志当前对象可以被克隆</p>
</blockquote>
</li>
<li><p>源码</p>
<ul>
<li><p>[克隆的对象和原对象在堆中具有相互独立的空间，两者不会相互影响]{.red}</p>
</li>
<li><p>克隆的对象类型和原对象的类型相同，并不强制</p>
<blockquote>
<p>clone 方法返回的类型是 Object，可以根据自己的需要强制转换，所以可能出现和原对象类型不相同的情况</p>
</blockquote>
</li>
<li><p>克隆对象和原对象内容是相同的，前提是必须重写 <code>equals</code> 方法</p>
</li>
</ul>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 源码中提到的注意事项</span></span><br><span class="line"><span class="comment">* x.clone() != x will be true</span></span><br><span class="line"><span class="comment">* x.clone().getClass() == x.getClass() will be true, but these are not absolute requirements.</span></span><br><span class="line"><span class="comment">* x.clone().equals(x) will be true, this is not an absolute requirement.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>浅克隆与深克隆：</p>
<ul>
<li><p>场景：类中不仅包含基本数据类型的成员变量，同时包含引用类型的成员变量</p>
</li>
<li><p>浅克隆：对象被复制时，仅复制基本数据类型的成员变量和引用类型的引用，[并不会复制引用类型拥有的成员变量]{.red}</p>
<blockquote>
<p>注：意味着只要修改引用类型拥有的成员变量就会导致克隆对象和原对象一起发生改变</p>
</blockquote>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/浅克隆.44pp8d02w0c0.png" alt="浅克隆" style="zoom:80%;" /></li>
<li><p>深克隆：对象被复制时，不仅复制基本数据类型的成员变量，[并且将引用类型拥有的成员变量一起复制]{.red}</p>
  <img src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/学习图示/深克隆.6cph705nbow0.png" alt="深克隆" style="zoom:80%;" /></li>
</ul>
<p>  :::info</p>
<p>  简单了解区别之后，再来看这两者具体是怎么实现的，具体的演示也在后面</p>
<p>  :::</p>
</li>
<li><p>浅克隆</p>
<ul>
<li><p>特点：</p>
<ul>
<li>[Object 类默认提供的克隆方式就是浅克隆]{.red}</li>
<li>[不会复制引用类型拥有的成员变量，仅会复制引用类型的引用]{.red}</li>
</ul>
</li>
<li><p>实现：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 克隆的对象必须实现 Cloneable 接口并且重写 clone 方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 为了方便赋值就设为公共的属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age, String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Object 类中默认的克隆方式就是浅拷贝：不需要重写任何代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">    <span class="comment">// 浅克隆: 本质是创建新的对象并且将旧对象的值赋给新对象</span></span><br><span class="line">    Student old_student = <span class="keyword">new</span> Student(<span class="number">12</span>, <span class="string">&quot;冬坂五百里&quot;</span>);</span><br><span class="line">    Student new_student = (Student) old_student.clone();</span><br><span class="line">    <span class="comment">// 修改克隆对象的年龄</span></span><br><span class="line">    new_student.age = <span class="number">24</span>;</span><br><span class="line">    <span class="comment">// 测试两者的年龄是否相同：结果是显然不相同的</span></span><br><span class="line">    System.out.println(old_student.age);</span><br><span class="line">    System.out.println(new_student.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>深克隆</p>
<ul>
<li><p>手动实现：</p>
<ul>
<li><p>特点：</p>
<ul>
<li>[会将引用类型拥有的成员变量一起复制]{.red}</li>
<li>引用类型的成员变量也必须实现 Cloneable 接口并且重写 clone 方法</li>
</ul>
</li>
<li><p>实现：</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">(String address)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 克隆的对象必须实现 Cloneable 接口并且重写 clone 方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age, String name, Address address)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Student student = (Student) <span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="comment">// 调用引用类型的成员变量后调用其相应的克隆方法: 手动克隆</span></span><br><span class="line">        student.address = (Address) address.clone();</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">错误测试：更改的是引用类型拥有成员变量而不是引用类型本身</span></span><br><span class="line"><span class="comment">new_student.address = new Address(&quot;中国&quot;)</span></span><br><span class="line"><span class="comment">这样修改就相当于修改了成员变量的引用，无论你是浅克隆还是深克隆，两个对象的地址肯定都是不一样的</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">    <span class="comment">// 手动实现深克隆：在克隆方法中继续调用引用类型的克隆方法就是手动实现</span></span><br><span class="line">    Student old_student = <span class="keyword">new</span> Student(<span class="number">12</span>, <span class="string">&quot;冬坂五百里&quot;</span>);</span><br><span class="line">    Address address = <span class="keyword">new</span> Address(<span class="string">&quot;日本&quot;</span>);</span><br><span class="line">    old_student.address = address;</span><br><span class="line">    Student new_student = (Student) old_student.clone();</span><br><span class="line">    <span class="comment">// 更改克隆对象的引用类型成员变量拥有的成员变量的值</span></span><br><span class="line">    address.address = <span class="string">&quot;中国&quot;</span>;</span><br><span class="line">    <span class="comment">// 测试两个对象的地址是否相同：结果肯定是不同的</span></span><br><span class="line">    System.out.println(old_student.address);</span><br><span class="line">    System.out.println(new_student.address);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>序列化实现</p>
<ul>
<li><p>场景：</p>
<ul>
<li>如果类中的引用类型的成员变量也拥有引用类型的成员变量，或者类中存在多个引用类型的成员变量</li>
<li>前者就需要在克隆方法中不断地嵌套调用克隆方法，后者则是需要同时调用多个克隆方法</li>
<li>这种情况被称作 [多层克隆]{.red}，显然手动实现克隆是非常麻烦的</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>[序列化实现深克隆就可以解决多层克隆这种情况]{.red}</li>
<li>[每个引用类型或者说类都需要实现序列化接口]{.red}</li>
</ul>
</li>
<li><p>实现</p>
  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span>  <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; students;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="comment">// 省略不重要的代码</span></span><br><span class="line">	... </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 序列化流</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 反序列化流</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 克隆对象</span></span><br><span class="line">        Teacher teacher = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            ByteArrayOutputStream bao = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="comment">// 将对象写入字节数组输出流中</span></span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(bao);</span><br><span class="line">            oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 从哪里读入数据: 从字节数组输出流中读取数据</span></span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bao.toByteArray()));</span><br><span class="line">            teacher = (Teacher) ois.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException | ClassNotFoundException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> teacher;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 序列化实现深克隆</span></span><br><span class="line">    List&lt;Student&gt; students = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Collections.addAll(students,<span class="keyword">new</span> Student(<span class="number">12</span>, <span class="string">&quot;学生1号&quot;</span>),</span><br><span class="line">                       <span class="keyword">new</span> Student(<span class="number">13</span>, <span class="string">&quot;学生2号&quot;</span>),</span><br><span class="line">                       <span class="keyword">new</span> Student(<span class="number">14</span>, <span class="string">&quot;学生2号&quot;</span>));</span><br><span class="line">    Teacher teacher = <span class="keyword">new</span> Teacher(<span class="number">24</span>, <span class="string">&quot;冬坂五百里&quot;</span>, students,<span class="keyword">new</span> Address(<span class="string">&quot;日本&quot;</span>));</span><br><span class="line">    Teacher clone_teacher = (Teacher) teacher.clone();</span><br><span class="line">    <span class="comment">// 修改克隆对象</span></span><br><span class="line">    clone_teacher.getAddress().setAddress(<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">    clone_teacher.getStudents().remove(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 测试两个对象的集合内容是否相同、以及地址是否相同</span></span><br><span class="line">    teacher.getStudents().forEach(System.out::println);</span><br><span class="line">    clone_teacher.getStudents().forEach(System.out::println);</span><br><span class="line">    System.out.println(teacher.getAddress());</span><br><span class="line">    System.out.println(clone_teacher.getAddress());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>为什么要使用克隆？为什么不直接创建新对象后挨个赋值呢？</strong></p>
</blockquote>
<ul>
<li>理由①：某些情况我们需要暂时保存当前对象的状态，确保我们在修改当前对象后依然能够得知其原有的状态</li>
<li>理由②：<ul>
<li><code>clone</code> 方法的默认实现是本地的，[效率显然会优于循环赋值]{.red}</li>
<li><code>clone</code> 能够简化循环赋值的过程，[代码更加简洁]{.red}</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>细节</strong></p>
</blockquote>
<ul>
<li>字符串对象实际上也是引用类型的对象，但是由于字符串对象具有 [不可变的特性]{.red}，</li>
<li>修改字符串内容实际上修改的是引用指向的内容，而不是在原有的基础上进行修改</li>
<li>所以在浅克隆中修改字符串对象不会导致克隆对象和原对象一起发生，原对象的引用依然指向原来的字符串内容，克隆对象的引用已经指向新的字符串内容了</li>
</ul>

        <h2 id="接口-vs-抽象类"   >
          <a href="#接口-vs-抽象类" class="heading-link"><i class="fas fa-link"></i></a><a href="#接口-vs-抽象类" class="headerlink" title="接口 vs 抽象类"></a>接口 vs 抽象类</h2>
      <div class="table-container"><table>
<thead>
<tr>
<th></th>
<th>接口</th>
<th>抽象类</th>
</tr>
</thead>
<tbody><tr>
<td>继承 &amp; 实现</td>
<td>可以实现多个接口</td>
<td>仅可以继承一个抽象类</td>
</tr>
<tr>
<td>方法</td>
<td>所有方法都是公共的抽象方法</td>
<td>既有抽象方法也有普通方法（[抽象方法默认包可见性]{.red}）</td>
</tr>
<tr>
<td>成员变量</td>
<td>仅拥有静态常量</td>
<td>任意类型成员变量</td>
</tr>
<tr>
<td>耦合度</td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table></div>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/9/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/11/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://cdn.jsdelivr.net/gh/fuyusakaiori/image@master/随机图库/1641882498931.3kditdl6ds40.webp" alt="avatar"></div><p class="sidebar-ov-author__text">什么都不会的废物</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/fuyusakaiori" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://weibo.com/Sakiless/home?topnav=1&amp;wvr=6" target="_blank" rel="noopener" data-popover="微博" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weibo"></i></span></a><a class="sidebar-ov-social-item" href="670232228" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">107</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">31</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-nd.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020~2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>小忍的甜甜圈</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1.0.1/dist/canvas-nest.min.js" color="0,0,0" opacity="0.6" count="99" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>